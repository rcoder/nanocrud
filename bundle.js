// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/reusify/reusify.js":[function(require,module,exports) {
'use strict';

function reusify(Constructor) {
  var head = new Constructor();
  var tail = head;

  function get() {
    var current = head;

    if (current.next) {
      head = current.next;
    } else {
      head = new Constructor();
      tail = head;
    }

    current.next = null;
    return current;
  }

  function release(obj) {
    tail.next = obj;
    tail = obj;
  }

  return {
    get: get,
    release: release
  };
}

module.exports = reusify;
},{}],"node_modules/fastq/queue.js":[function(require,module,exports) {
'use strict'

var reusify = require('reusify')

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  var cache = reusify(Task)
  var queueHead = null
  var queueTail = null
  var _running = 0

  var self = {
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain
  }

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true
  }

  function length () {
    var current = queueHead
    var counter = 0

    while (current) {
      current = current.next
      counter++
    }

    return counter
  }

  function resume () {
    if (!self.paused) return
    self.paused = false
    for (var i = 0; i < self.concurrency; i++) {
      _running++
      release()
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current
        queueTail = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function unshift (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead
        queueHead = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder)
    }
    var next = queueHead
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null
        }
        queueHead = next.next
        next.next = null
        worker.call(context, next.value, next.worked)
        if (queueTail === null) {
          self.empty()
        }
      } else {
        _running--
      }
    } else if (--_running === 0) {
      self.drain()
    }
  }

  function kill () {
    queueHead = null
    queueTail = null
    self.drain = noop
  }

  function killAndDrain () {
    queueHead = null
    queueTail = null
    self.drain()
    self.drain = noop
  }
}

function noop () {}

function Task () {
  this.value = null
  this.callback = noop
  this.next = null
  this.release = noop
  this.context = null

  var self = this

  this.worked = function worked (err, result) {
    var callback = self.callback
    self.value = null
    self.callback = noop
    callback.call(self.context, err, result)
    self.release(self)
  }
}

module.exports = fastqueue

},{"reusify":"node_modules/reusify/reusify.js"}],"node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = $getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  var args = [];

  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);

  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}
},{}],"node_modules/util/support/isBufferBrowser.js":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"node_modules/util/node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"node_modules/util/util.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = undefined || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function () {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;
},{"./support/isBuffer":"node_modules/util/support/isBufferBrowser.js","inherits":"node_modules/util/node_modules/inherits/inherits_browser.js","process":"node_modules/process/browser.js"}],"node_modules/archy/index.js":[function(require,module,exports) {
module.exports = function archy (obj, prefix, opts) {
    if (prefix === undefined) prefix = '';
    if (!opts) opts = {};
    var chr = function (s) {
        var chars = {
            '│' : '|',
            '└' : '`',
            '├' : '+',
            '─' : '-',
            '┬' : '-'
        };
        return opts.unicode === false ? chars[s] : s;
    };
    
    if (typeof obj === 'string') obj = { label : obj };
    
    var nodes = obj.nodes || [];
    var lines = (obj.label || '').split('\n');
    var splitter = '\n' + prefix + (nodes.length ? chr('│') : ' ') + ' ';
    
    return prefix
        + lines.join(splitter) + '\n'
        + nodes.map(function (node, ix) {
            var last = ix === nodes.length - 1;
            var more = node.nodes && node.nodes.length;
            var prefix_ = prefix + (last ? ' ' : chr('│')) + ' ';
            
            return prefix
                + (last ? chr('└') : chr('├')) + chr('─')
                + (more ? chr('┬') : chr('─')) + ' '
                + archy(node, prefix_, opts).slice(prefix.length + 2)
            ;
        }).join('')
    ;
};

},{}],"node_modules/avvio/time-tree.js":[function(require,module,exports) {
'use strict'
const archy = require('archy')

function TimeTree () {
  this.root = null
  this.tableId = new Map()
  this.tableLabel = new Map()
}

TimeTree.prototype.trackNode = function (node) {
  this.tableId.set(node.id, node)
  if (this.tableLabel.has(node.label)) {
    this.tableLabel.get(node.label).push(node)
  } else {
    this.tableLabel.set(node.label, [node])
  }
}

TimeTree.prototype.untrackNode = function (node) {
  this.tableId.delete(node.id)

  const labelNode = this.tableLabel.get(node.label)
  if (labelNode.id) {
    this.tableLabel.delete(node.label)
    return
  }
  labelNode.pop()

  if (labelNode.length === 0) {
    this.tableLabel.delete(node.label)
  }
}

TimeTree.prototype.getParent = function (parent) {
  if (parent === null) {
    return this.root
  }

  const parentNode = this.tableLabel.get(parent)
  if (parentNode.id) {
    return parentNode
  }
  return parentNode[parentNode.length - 1]
}

TimeTree.prototype.getNode = function (nodeId) {
  return this.tableId.get(nodeId)
}

TimeTree.prototype.add = function (parent, child, start) {
  const isRoot = parent === null
  if (isRoot) {
    this.root = {
      id: 'root',
      label: child,
      start,
      nodes: []
    }
    this.trackNode(this.root)
    return this.root.id
  }

  const parentNode = this.getParent(parent)
  const nodeId = `${child}-${Math.random()}`
  const childNode = {
    id: nodeId,
    parent,
    start,
    label: child,
    nodes: []
  }
  parentNode.nodes.push(childNode)
  this.trackNode(childNode)
  return nodeId
}

TimeTree.prototype.start = function (parent, child, start) {
  return this.add(parent, child, start || Date.now())
}

TimeTree.prototype.stop = function (nodeId, stop) {
  const node = this.getNode(nodeId)
  if (node) {
    node.stop = stop || Date.now()
    node.diff = (node.stop - node.start) || 0
    this.untrackNode(node)
  }
}

TimeTree.prototype.toJSON = function () {
  return Object.assign({}, this.root)
}

TimeTree.prototype.prittyPrint = function () {
  const decorateText = (node) => {
    node.label = `${node.label} ${node.diff} ms`
    if (node.nodes.length > 0) {
      node.nodes = node.nodes.map(_ => decorateText(_))
    }
    return node
  }
  const out = decorateText(this.toJSON())
  return archy(out)
}

module.exports = TimeTree

},{"archy":"node_modules/archy/index.js"}],"node_modules/ms/index.js":[function(require,module,exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],"node_modules/debug/src/common.js":[function(require,module,exports) {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":"node_modules/ms/index.js"}],"node_modules/debug/src/browser.js":[function(require,module,exports) {
var process = require("process");
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  const c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, match => {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log(...args) {
  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return typeof console === 'object' && console.log && console.log(...args);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  let r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = undefined;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
const {
  formatters
} = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};
},{"./common":"node_modules/debug/src/common.js","process":"node_modules/process/browser.js"}],"node_modules/avvio/plugin.js":[function(require,module,exports) {
var process = require("process");
'use strict'

const fastq = require('fastq')
const EE = require('events').EventEmitter
const inherits = require('util').inherits
const debug = require('debug')('avvio')
const CODE_PLUGIN_TIMEOUT = 'ERR_AVVIO_PLUGIN_TIMEOUT'

function getName (func) {
  // let's see if this is a file, and in that case use that
  // this is common for plugins
  const cache = require.cache
  const keys = Object.keys(cache)

  for (var i = 0; i < keys.length; i++) {
    if (cache[keys[i]].exports === func) {
      return keys[i]
    }
  }

  // if not maybe it's a named function, so use that
  if (func.name) {
    return func.name
  }

  // takes the first two lines of the function if nothing else works
  return func.toString().split('\n').slice(0, 2).map(s => s.trim()).join(' -- ')
}

function Plugin (parent, func, optsOrFunc, isAfter, timeout) {
  this.func = func
  this.opts = optsOrFunc
  this.deferred = false
  this.onFinish = null
  this.parent = parent
  this.timeout = timeout === undefined ? parent._timeout : timeout
  this.name = getName(func)
  this.isAfter = isAfter

  this.q = fastq(parent, loadPlugin, 1)
  this.q.pause()
  this.loaded = false

  // always start the queue in the next tick
  // because we try to attach subsequent call to use()
  // to the right plugin. we need to defer them,
  // or they will end up at the top of _current
}

inherits(Plugin, EE)

Plugin.prototype.exec = function (server, cb) {
  const func = this.func
  var completed = false
  var name = this.name

  if (this.parent._error && !this.isAfter) {
    debug('skipping loading of plugin as parent errored and it is not an after', name)
    process.nextTick(cb)
    return
  }

  try {
    this.server = this.parent.override(server, func, this.opts)
  } catch (err) {
    debug('override errored', name)
    return cb(err)
  }

  this.opts = typeof this.opts === 'function' ? this.opts(this.server) : this.opts

  debug('exec', name)

  var timer

  if (this.timeout > 0) {
    debug('setting up timeout', name, this.timeout)
    timer = setTimeout(function () {
      debug('timed out', name)
      timer = null
      const err = new Error(`${CODE_PLUGIN_TIMEOUT}: plugin did not start in time: ${name}`)
      err.code = CODE_PLUGIN_TIMEOUT
      err.fn = func
      done(err)
    }, this.timeout)
  }

  this.emit('start', this.server ? this.server.name : null, this.name, Date.now())
  var promise = func(this.server, this.opts, done)
  if (promise && typeof promise.then === 'function') {
    debug('resolving promise', name)
    promise.then(
      () => process.nextTick(done),
      (e) => process.nextTick(done, e))
  }

  function done (err) {
    if (completed) {
      debug('loading complete', name)
      return
    }

    if (err) {
      debug('exec errored', name)
    } else {
      debug('exec completed', name)
    }

    completed = true

    if (timer) {
      clearTimeout(timer)
    }

    cb(err)
  }
}

Plugin.prototype.enqueue = function (obj, cb) {
  debug('enqueue', this.name, obj.name)
  this.emit('enqueue', this.server ? this.server.name : null, this.name, Date.now())
  this.q.push(obj, cb)
}

Plugin.prototype.finish = function (err, cb) {
  debug('finish', this.name)
  const done = () => {
    if (this.loaded) {
      return
    }

    debug('loaded', this.name)
    this.emit('loaded', this.server ? this.server.name : null, this.name, Date.now())
    this.loaded = true

    cb(err)
  }

  if (err) {
    done()
    return
  }

  const check = () => {
    debug('check', this.name, this.q.length(), this.q.running())
    if (this.q.length() === 0 && this.q.running() === 0) {
      done()
    } else {
      debug('delayed', this.name)
      // finish when the queue of nested plugins to load is empty
      this.q.drain = () => {
        debug('drain', this.name)
        this.q.drain = noop

        // we defer the check, as a safety net for things
        // that might be scheduled in the loading callback
        process.nextTick(check)
      }
    }
  }

  process.nextTick(check)

  // we start loading the dependents plugins only once
  // the current level is finished
  this.q.resume()
}

// loads a plugin
function loadPlugin (toLoad, cb) {
  const last = this._current[0]
  // place the plugin at the top of _current
  this._current.unshift(toLoad)

  toLoad.exec((last && last.server) || this._server, (err) => {
    toLoad.finish(err, (err) => {
      this._current.shift()
      cb(err)
    })
  })
}

function noop () {}

module.exports = Plugin
module.exports.loadPlugin = loadPlugin

},{"fastq":"node_modules/fastq/queue.js","events":"node_modules/events/events.js","util":"node_modules/util/util.js","debug":"node_modules/debug/src/browser.js","process":"node_modules/process/browser.js"}],"node_modules/avvio/boot.js":[function(require,module,exports) {
var process = require("process");
'use strict'

const fastq = require('fastq')
const EE = require('events').EventEmitter
const inherits = require('util').inherits
const TimeTree = require('./time-tree')
const Plugin = require('./plugin')
const debug = require('debug')('avvio')

function wrap (server, opts, instance) {
  const expose = opts.expose || {}
  const useKey = expose.use || 'use'
  const afterKey = expose.after || 'after'
  const readyKey = expose.ready || 'ready'
  const onCloseKey = expose.onClose || 'onClose'
  const closeKey = expose.close || 'close'

  if (server[useKey]) {
    throw new Error(useKey + '() is already defined, specify an expose option')
  }

  if (server[afterKey]) {
    throw new Error(afterKey + '() is already defined, specify an expose option')
  }

  if (server[readyKey]) {
    throw new Error(readyKey + '() is already defined, specify an expose option')
  }

  server[useKey] = function (a, b, c) {
    instance.use(a, b, c)
    return this
  }

  server[afterKey] = function (func) {
    if (typeof func !== 'function') {
      throw new Error('not a function')
    }
    instance.after(encapsulateThreeParam(func, this))
    return this
  }

  server[readyKey] = function (func) {
    if (func && typeof func !== 'function') {
      throw new Error('not a function')
    }
    return instance.ready(func ? encapsulateThreeParam(func, this) : undefined)
  }

  server[onCloseKey] = function (func) {
    if (typeof func !== 'function') {
      throw new Error('not a function')
    }
    instance.onClose(encapsulateTwoParam(func, this))
    return this
  }

  server[closeKey] = function (func) {
    if (func && typeof func !== 'function') {
      throw new Error('not a function')
    }

    if (func) {
      instance.close(encapsulateThreeParam(func, this))
      return this
    }

    // this is a Promise
    return instance.close()
  }
}

function Boot (server, opts, done) {
  if (typeof server === 'function' && arguments.length === 1) {
    done = server
    opts = {}
    server = null
  }

  if (typeof opts === 'function') {
    done = opts
    opts = {}
  }

  opts = opts || {}

  if (!(this instanceof Boot)) {
    const instance = new Boot(server, opts, done)

    if (server) {
      wrap(server, opts, instance)
    }

    return instance
  }

  if (opts.autostart !== false) {
    opts.autostart = true
  }

  server = server || this

  this._timeout = Number(opts.timeout) || 0
  this._server = server
  this._current = []
  this._error = null
  this._isOnCloseHandlerKey = Symbol('isOnCloseHandler')

  this.setMaxListeners(0)

  if (done) {
    this.once('start', done)
  }

  this.started = false
  this.booted = false
  this.pluginTree = new TimeTree()

  this._readyQ = fastq(this, callWithCbOrNextTick, 1)
  this._readyQ.pause()
  this._readyQ.drain = () => {
    this.emit('start')
    // nooping this, we want to emit start only once
    this._readyQ.drain = noop
  }

  this._closeQ = fastq(this, closeWithCbOrNextTick, 1)
  this._closeQ.pause()
  this._closeQ.drain = () => {
    this.emit('close')
    // nooping this, we want to emit start only once
    this._closeQ.drain = noop
  }

  this._doStart = null
  const main = new Plugin(this, root.bind(this), opts, noop, 0)

  main.once('start', (serverName, funcName, time) => {
    const nodeId = this.pluginTree.start(null, funcName, time)
    main.once('loaded', (serverName, funcName, time) => {
      this.pluginTree.stop(nodeId, time)
    })
  })

  Plugin.loadPlugin.call(this, main, (err) => {
    debug('root plugin ready')
    this.emit('preReady')
    if (err) {
      this._error = err
      if (this._readyQ.length() === 0) {
        throw err
      }
    } else {
      this.booted = true
      this._readyQ.resume()
    }
  })
}

function root (s, opts, done) {
  this._doStart = done
  if (opts.autostart) {
    this.start()
  }
}

inherits(Boot, EE)

Boot.prototype.start = function () {
  this.started = true

  // we need to wait any call to use() to happen
  process.nextTick(this._doStart)
  return this
}

// allows to override the instance of a server, given a plugin
Boot.prototype.override = function (server, func, opts) {
  return server
}

// load a plugin
Boot.prototype.use = function (plugin, opts) {
  if (typeof plugin === 'function') {
    this._addPlugin(plugin, opts, false)
  } else {
    throw new Error('plugin must be a function')
  }

  return this
}

Boot.prototype._addPlugin = function (plugin, opts, isAfter) {
  if (typeof plugin !== 'function') {
    throw new Error('plugin must be a function')
  }
  opts = opts || {}

  if (this.booted) {
    throw new Error('root plugin has already booted')
  }

  // we always add plugins to load at the current element
  const current = this._current[0]

  const obj = new Plugin(this, plugin, opts, isAfter)
  obj.once('start', (serverName, funcName, time) => {
    const nodeId = this.pluginTree.start(current.name, funcName, time)
    obj.once('loaded', (serverName, funcName, time) => {
      this.pluginTree.stop(nodeId, time)
    })
  })

  if (current.loaded) {
    throw new Error(`Impossible to load "${obj.name}" plugin because the parent "${current.name}" was already loaded`)
  }

  // we add the plugin to be loaded at the end of the current queue
  current.enqueue(obj, (err) => {
    if (err) {
      this._error = err
    }
  })
}

Boot.prototype.after = function (func) {
  this._addPlugin(_after.bind(this), {}, true)

  function _after (s, opts, done) {
    callWithCbOrNextTick.call(this, func, done)
  }

  return this
}

Boot.prototype.onClose = function (func) {
  // this is used to distinguish between onClose and close handlers
  // because they share the same queue but must be called with different signatures

  if (typeof func !== 'function') {
    throw new Error('not a function')
  }

  func[this._isOnCloseHandlerKey] = true
  this._closeQ.unshift(func, callback.bind(this))

  function callback (err) {
    if (err) this._error = err
  }

  return this
}

Boot.prototype.close = function (func) {
  var promise

  if (func) {
    if (typeof func !== 'function') {
      throw new Error('not a function')
    }
  } else {
    promise = new Promise(function (resolve, reject) {
      func = function (err) {
        if (err) {
          return reject(err)
        }
        resolve()
      }
    })
  }

  this.ready(() => {
    this._error = null
    this._closeQ.push(func)
    process.nextTick(this._closeQ.resume.bind(this._closeQ))
  })

  return promise
}

Boot.prototype.ready = function (func) {
  if (func) {
    if (typeof func !== 'function') {
      throw new Error('not a function')
    }
    this._readyQ.push(func)
    this.start()
    return
  }

  return new Promise((resolve, reject) => {
    this._readyQ.push(readyPromiseCB)
    this.start()

    function readyPromiseCB (err, context, done) {
      if (err) {
        reject(err)
      } else {
        resolve(context)
      }
      process.nextTick(done)
    }
  })
}

Boot.prototype.prettyPrint = function () {
  return this.pluginTree.prittyPrint()
}

Boot.prototype.toJSON = function () {
  return this.pluginTree.toJSON()
}

function noop () { }

function callWithCbOrNextTick (func, cb, context) {
  context = this._server
  var err = this._error
  var res

  // with this the error will appear just in the next after/ready callback
  this._error = null
  if (func.length === 0) {
    this._error = err
    res = func()
    if (res && typeof res.then === 'function') {
      res.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e))
    } else {
      process.nextTick(cb)
    }
  } else if (func.length === 1) {
    res = func(err)
    if (res && typeof res.then === 'function') {
      res.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e))
    } else {
      process.nextTick(cb)
    }
  } else if (func.length === 2) {
    func(err, cb)
  } else {
    func(err, context, cb)
  }
}

function closeWithCbOrNextTick (func, cb, context) {
  context = this._server
  var isOnCloseHandler = func[this._isOnCloseHandlerKey]
  if (func.length === 0 || func.length === 1) {
    var promise
    if (isOnCloseHandler) {
      promise = func(context)
    } else {
      promise = func(this._error)
    }
    if (promise && typeof promise.then === 'function') {
      debug('resolving close/onClose promise')
      promise.then(
        () => process.nextTick(cb),
        (e) => process.nextTick(cb, e))
    } else {
      process.nextTick(cb)
    }
  } else if (func.length === 2) {
    if (isOnCloseHandler) {
      func(context, cb)
    } else {
      func(this._error, cb)
    }
  } else {
    if (isOnCloseHandler) {
      func(context, cb)
    } else {
      func(this._error, context, cb)
    }
  }
}

function encapsulateTwoParam (func, that) {
  return _encapsulateTwoParam.bind(that)
  function _encapsulateTwoParam (context, cb) {
    if (func.length === 0) {
      func()
      process.nextTick(cb)
    } else if (func.length === 1) {
      func(cb)
    } else {
      func(this, cb)
    }
  }
}

function encapsulateThreeParam (func, that) {
  return _encapsulateThreeParam.bind(that)
  function _encapsulateThreeParam (err, cb) {
    var res
    if (!func) {
      process.nextTick(cb)
    } else if (func.length === 0) {
      res = func()
      if (res && res.then) {
        res.then(function () {
          process.nextTick(cb, err)
        }, cb)
      } else {
        process.nextTick(cb, err)
      }
    } else if (func.length === 1) {
      res = func(err)
      if (res && res.then) {
        res.then(function () {
          process.nextTick(cb)
        }, cb)
      } else {
        process.nextTick(cb)
      }
    } else if (func.length === 2) {
      func(err, cb)
    } else {
      func(err, this, cb)
    }
  }
}

module.exports = Boot
module.exports.express = function (app) {
  return Boot(app, {
    expose: {
      use: 'load'
    }
  })
}

},{"fastq":"node_modules/fastq/queue.js","events":"node_modules/events/events.js","util":"node_modules/util/util.js","./time-tree":"node_modules/avvio/time-tree.js","./plugin":"node_modules/avvio/plugin.js","debug":"node_modules/debug/src/browser.js","process":"node_modules/process/browser.js"}],"node_modules/stream-http/lib/capability.js":[function(require,module,exports) {
var global = arguments[3];
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

},{}],"node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"node_modules/process-nextick-args/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


},{"process":"node_modules/process/browser.js"}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"node_modules/events/events.js"}],"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/readable-stream/node_modules/safe-buffer/index.js":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/core-util-is/lib/util.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/readable-stream/lib/internal/streams/BufferList.js":[function(require,module,exports) {

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js"}],"node_modules/util-deprecate/browser.js":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {
var process = require("process");

var global = arguments[3];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","util-deprecate":"node_modules/util-deprecate/browser.js","./internal/streams/stream":"node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","./internal/streams/destroy":"node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_readable":"node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"node_modules/readable-stream/lib/_stream_writable.js"}],"node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js"}],"node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","isarray":"node_modules/isarray/index.js","events":"node_modules/events/events.js","./internal/streams/stream":"node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/BufferList":"node_modules/readable-stream/lib/internal/streams/BufferList.js","./internal/streams/destroy":"node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_readable.js":"node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"node_modules/readable-stream/lib/_stream_passthrough.js"}],"node_modules/stream-http/lib/response.js":[function(require,module,exports) {
var process = require("process");
var Buffer = require("buffer").Buffer;
var global = arguments[3];
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

},{"./capability":"node_modules/stream-http/lib/capability.js","inherits":"node_modules/inherits/inherits_browser.js","readable-stream":"node_modules/readable-stream/readable-browser.js","process":"node_modules/process/browser.js","buffer":"node_modules/buffer/index.js"}],"node_modules/to-arraybuffer/index.js":[function(require,module,exports) {

var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/stream-http/lib/request.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var global = arguments[3];
var process = require("process");
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

},{"./capability":"node_modules/stream-http/lib/capability.js","inherits":"node_modules/inherits/inherits_browser.js","./response":"node_modules/stream-http/lib/response.js","readable-stream":"node_modules/readable-stream/readable-browser.js","to-arraybuffer":"node_modules/to-arraybuffer/index.js","buffer":"node_modules/buffer/index.js","process":"node_modules/process/browser.js"}],"node_modules/xtend/immutable.js":[function(require,module,exports) {
module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}
},{}],"node_modules/builtin-status-codes/browser.js":[function(require,module,exports) {
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],"node_modules/node-libs-browser/node_modules/punycode/punycode.js":[function(require,module,exports) {
var global = arguments[3];
var define;
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

},{}],"node_modules/url/util.js":[function(require,module,exports) {
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],"node_modules/querystring-es3/decode.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict'; // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
},{}],"node_modules/querystring-es3/encode.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};
},{}],"node_modules/querystring-es3/index.js":[function(require,module,exports) {
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');
},{"./decode":"node_modules/querystring-es3/decode.js","./encode":"node_modules/querystring-es3/encode.js"}],"node_modules/url/url.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"punycode":"node_modules/node-libs-browser/node_modules/punycode/punycode.js","./util":"node_modules/url/util.js","querystring":"node_modules/querystring-es3/index.js"}],"node_modules/stream-http/index.js":[function(require,module,exports) {
var global = arguments[3];
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
},{"./lib/request":"node_modules/stream-http/lib/request.js","./lib/response":"node_modules/stream-http/lib/response.js","xtend":"node_modules/xtend/immutable.js","builtin-status-codes":"node_modules/builtin-status-codes/browser.js","url":"node_modules/url/url.js"}],"node_modules/fastify/lib/symbols.js":[function(require,module,exports) {
'use strict';

var keys = {
  kChildren: Symbol('fastify.children'),
  kBodyLimit: Symbol('fastify.bodyLimit'),
  kRoutePrefix: Symbol('fastify.routePrefix'),
  kLogLevel: Symbol('fastify.logLevel'),
  kHooks: Symbol('fastify.hooks'),
  kSchemas: Symbol('fastify.schemas'),
  kSchemaCompiler: Symbol('fastify.schemaCompiler'),
  kSchemaResolver: Symbol('fastify.schemaRefResolver'),
  kReplySerializerDefault: Symbol('fastify.replySerializerDefault'),
  kContentTypeParser: Symbol('fastify.contentTypeParser'),
  kReply: Symbol('fastify.Reply'),
  kRequest: Symbol('fastify.Request'),
  kMiddlewares: Symbol('fastify.middlewares'),
  kCanSetNotFoundHandler: Symbol('fastify.canSetNotFoundHandler'),
  kFourOhFour: Symbol('fastify.404'),
  kFourOhFourLevelInstance: Symbol('fastify.404LogLevelInstance'),
  kFourOhFourContext: Symbol('fastify.404ContextKey'),
  kDefaultJsonParse: Symbol('fastify.defaultJSONParse'),
  kReplySerializer: Symbol('fastify.reply.serializer'),
  kReplyIsError: Symbol('fastify.reply.isError'),
  kReplyHeaders: Symbol('fastify.reply.headers'),
  kReplyHasStatusCode: Symbol('fastify.reply.hasStatusCode'),
  kReplySent: Symbol('fastify.reply.sent'),
  kReplySentOverwritten: Symbol('fastify.reply.sentOverwritten'),
  kReplyStartTime: Symbol('fastify.reply.startTime'),
  kReplyErrorHandlerCalled: Symbol('fastify.reply.errorHandlerCalled'),
  kReplyIsRunningOnErrorHook: Symbol('fastify.reply.isRunningOnErrorHook'),
  kState: Symbol('fastify.state'),
  kOptions: Symbol('fastify.options'),
  kGlobalHooks: Symbol('fastify.globalHooks'),
  kDisableRequestLogging: Symbol('fastify.disableRequestLogging'),
  kPluginNameChain: Symbol('fastify.pluginNameChain')
};
module.exports = keys;
},{}],"node_modules/object-assign/index.js":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};
},{}],"node_modules/assert/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"node_modules/assert/node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"node_modules/assert/node_modules/util/util.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = undefined || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
},{"./support/isBuffer":"node_modules/assert/node_modules/util/support/isBufferBrowser.js","inherits":"node_modules/assert/node_modules/inherits/inherits_browser.js","process":"node_modules/process/browser.js"}],"node_modules/assert/assert.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"object-assign":"node_modules/object-assign/index.js","util/":"node_modules/assert/node_modules/util/util.js"}],"node_modules/https-browserify/index.js":[function(require,module,exports) {
var http = require('http')
var url = require('url')

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}

},{"http":"node_modules/stream-http/index.js","url":"node_modules/url/url.js"}],"node_modules/fastify/lib/errors.js":[function(require,module,exports) {
'use strict';

var {
  inherits: inherits,
  format: format
} = require('util');

var codes = {};
/**
 * Basic
 */

createError('FST_ERR_NOT_FOUND', 'Not Found', 404);
/**
 * ContentTypeParser
*/

createError('FST_ERR_CTP_ALREADY_PRESENT', "Content type parser '%s' already present.");
createError('FST_ERR_CTP_INVALID_TYPE', 'The content type should be a string', 500, TypeError);
createError('FST_ERR_CTP_EMPTY_TYPE', 'The content type cannot be an empty string', 500, TypeError);
createError('FST_ERR_CTP_INVALID_HANDLER', 'The content type handler should be a function', 500, TypeError);
createError('FST_ERR_CTP_INVALID_PARSE_TYPE', "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.", 500, TypeError);
createError('FST_ERR_CTP_BODY_TOO_LARGE', 'Request body is too large', 413, RangeError);
createError('FST_ERR_CTP_INVALID_MEDIA_TYPE', 'Unsupported Media Type: %s', 415);
createError('FST_ERR_CTP_INVALID_CONTENT_LENGTH', 'Request body size did not match Content-Length', 400, RangeError);
createError('FST_ERR_CTP_EMPTY_JSON_BODY', "Body cannot be empty when content-type is set to 'application/json'", 400);
/**
 * decorate
*/

createError('FST_ERR_DEC_ALREADY_PRESENT', "The decorator '%s' has already been added!");
createError('FST_ERR_DEC_MISSING_DEPENDENCY', "The decorator is missing dependency '%s'.");
/**
 * hooks
*/

createError('FST_ERR_HOOK_INVALID_TYPE', 'The hook name must be a string', 500, TypeError);
createError('FST_ERR_HOOK_INVALID_HANDLER', 'The hook callback must be a function', 500, TypeError);
/**
 * logger
*/

createError('FST_ERR_LOG_INVALID_DESTINATION', 'Cannot specify both logger.stream and logger.file options');
/**
 * reply
*/

createError('FST_ERR_REP_INVALID_PAYLOAD_TYPE', "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.", 500, TypeError);
createError('FST_ERR_REP_ALREADY_SENT', 'Reply was already sent.');
createError('FST_ERR_REP_SENT_VALUE', 'The only possible value for reply.sent is true.');
createError('FST_ERR_SEND_INSIDE_ONERR', 'You cannot use `send` inside the `onError` hook');
/**
 * schemas
*/

createError('FST_ERR_SCH_MISSING_ID', 'Missing schema $id property');
createError('FST_ERR_SCH_ALREADY_PRESENT', "Schema with id '%s' already declared!");
createError('FST_ERR_SCH_NOT_PRESENT', "Schema with id '%s' does not exist!");
createError('FST_ERR_SCH_DUPLICATE', "Schema with '%s' already present!");
createError('FST_ERR_SCH_BUILD', 'Failed building the schema for %s: %s, due error %s');
createError('FST_ERR_SCH_MISSING_COMPILER', 'You must provide a schemaCompiler to route %s %s to use the schemaResolver');
/**
 * wrapThenable
 */

createError('FST_ERR_PROMISE_NOT_FULLFILLED', "Promise may not be fulfilled with 'undefined' when statusCode is not 204");
/**
 * http2
 */

createError('FST_ERR_HTTP2_INVALID_VERSION', 'HTTP2 is available only from node >= 8.8.1');
/**
 * initialConfig
 */

createError('FST_ERR_INIT_OPTS_INVALID', "Invalid initialization options: '%s'");

function createError(code, message) {
  var statusCode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;
  var Base = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Error;
  if (!code) throw new Error('Fastify error code must not be empty');
  if (!message) throw new Error('Fastify error message must not be empty');
  code = code.toUpperCase();

  function FastifyError(a, b, c) {
    Error.captureStackTrace(this, FastifyError);
    this.name = "FastifyError [".concat(code, "]");
    this.code = code; // more performant than spread (...) operator

    if (a && b && c) {
      this.message = format(message, a, b, c);
    } else if (a && b) {
      this.message = format(message, a, b);
    } else if (a) {
      this.message = format(message, a);
    } else {
      this.message = message;
    }

    this.message = "".concat(this.code, ": ").concat(this.message);
    this.statusCode = statusCode || undefined;
  }

  FastifyError.prototype[Symbol.toStringTag] = 'Error';
  inherits(FastifyError, Base);
  codes[code] = FastifyError;
  return codes[code];
}

module.exports = {
  codes: codes,
  createError: createError
};
},{"util":"node_modules/util/util.js"}],"node_modules/fastify/lib/server.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var assert = require('assert');

var http = require('http');

var https = require('https');

var {
  kState: kState,
  kOptions: kOptions
} = require('./symbols');

var {
  codes: {
    FST_ERR_HTTP2_INVALID_VERSION: FST_ERR_HTTP2_INVALID_VERSION
  }
} = require('./errors');

function createServer(options, httpHandler) {
  assert(options, 'Missing options');
  assert(httpHandler, 'Missing http handler');
  var server = null;

  if (options.serverFactory) {
    server = options.serverFactory(httpHandler, options);
  } else if (options.https) {
    if (options.http2) {
      server = http2().createSecureServer(options.https, httpHandler);
    } else {
      server = https.createServer(options.https, httpHandler);
    }
  } else if (options.http2) {
    server = http2().createServer(httpHandler);
  } else {
    server = http.createServer(httpHandler);
  }

  return {
    server: server,
    listen: listen
  }; // `this` is the Fastify object

  function listen() {
    var _this = this;

    var normalizeListenArgs = function (args) {
      if (args.length === 0) {
        return {
          port: 0,
          host: 'localhost'
        };
      }

      var cb = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
      var options = {
        cb: cb
      };
      var firstArg = args[0];
      var argsLength = args.length;
      var lastArg = args[argsLength - 1];
      /* Deal with listen (options) || (handle[, backlog]) */

      if (_typeof(firstArg) === 'object' && firstArg !== null) {
        options.backlog = argsLength > 1 ? lastArg : undefined;
        Object.assign(options, firstArg);
      } else if (typeof firstArg === 'string' && isNaN(firstArg)) {
        /* Deal with listen (pipe[, backlog]) */
        options.path = firstArg;
        options.backlog = argsLength > 1 ? lastArg : undefined;
      } else {
        /* Deal with listen ([port[, host[, backlog]]]) */
        options.port = argsLength >= 1 && firstArg ? firstArg : 0; // This will listen to what localhost is.
        // It can be 127.0.0.1 or ::1, depending on the operating system.
        // Fixes https://github.com/fastify/fastify/issues/1022.

        options.host = argsLength >= 2 && args[1] ? args[1] : 'localhost';
        options.backlog = argsLength >= 3 ? args[2] : undefined;
      }

      return options;
    };

    var listenOptions = normalizeListenArgs(Array.from(arguments));
    var cb = listenOptions.cb;

    var wrap = function (err) {
      server.removeListener('error', wrap);

      if (!err) {
        var address = logServerAddress();
        cb(null, address);
      } else {
        _this[kState].listening = false;
        cb(err, null);
      }
    };

    var listenPromise = function (listenOptions) {
      if (_this[kState].listening) {
        return Promise.reject(new Error('Fastify is already listening'));
      }

      return _this.ready().then(function () {
        var errEventHandler;
        var errEvent = new Promise(function (resolve, reject) {
          errEventHandler = function (err) {
            _this[kState].listening = false;
            reject(err);
          };

          server.once('error', errEventHandler);
        });
        var listen = new Promise(function (resolve, reject) {
          server.listen(listenOptions, function () {
            server.removeListener('error', errEventHandler);
            resolve(logServerAddress());
          }); // we set it afterwards because listen can throw

          _this[kState].listening = true;
        });
        return Promise.race([errEvent, // e.g invalid port range error is always emitted before the server listening
        listen]);
      });
    };

    var logServerAddress = function () {
      var address = server.address();
      var isUnixSocket = typeof address === 'string';

      if (!isUnixSocket) {
        if (address.address.indexOf(':') === -1) {
          address = address.address + ':' + address.port;
        } else {
          address = '[' + address.address + ']:' + address.port;
        }
      }

      address = (isUnixSocket ? '' : 'http' + (_this[kOptions].https ? 's' : '') + '://') + address;

      _this.log.info('Server listening at ' + address);

      return address;
    };

    if (cb === undefined) return listenPromise(listenOptions);
    this.ready(function (err) {
      if (err != null) return cb(err);

      if (_this[kState].listening) {
        return cb(new Error('Fastify is already listening'), null);
      }

      server.once('error', wrap);
      server.listen(listenOptions, wrap);
      _this[kState].listening = true;
    });
  }
}

function http2() {
  try {
    return require('http2');
  } catch (err) {
    throw new FST_ERR_HTTP2_INVALID_VERSION();
  }
}

module.exports = {
  createServer: createServer
};
},{"assert":"node_modules/assert/assert.js","http":"node_modules/stream-http/index.js","https":"node_modules/https-browserify/index.js","./symbols":"node_modules/fastify/lib/symbols.js","./errors":"node_modules/fastify/lib/errors.js"}],"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;
},{"events":"node_modules/events/events.js"}],"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/buffer_list.js":[function(require,module,exports) {

'use strict';

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  var _proto = BufferList.prototype;

  _proto.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  _proto.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  _proto.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  _proto.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  _proto.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  _proto.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  } // Consumes a specified amount of bytes or characters from the buffered data.
  ;

  _proto.consume = function consume(n, hasStrings) {
    var ret;

    if (n < this.head.data.length) {
      // `slice` is the same for buffers and strings.
      ret = this.head.data.slice(0, n);
      this.head.data = this.head.data.slice(n);
    } else if (n === this.head.data.length) {
      // First chunk is a perfect match.
      ret = this.shift();
    } else {
      // Result spans more than one buffer.
      ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    }

    return ret;
  };

  _proto.first = function first() {
    return this.head.data;
  } // Consumes a specified amount of characters from the buffered data.
  ;

  _proto._getString = function _getString(n) {
    var p = this.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;

    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;

      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = str.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Consumes a specified amount of bytes from the buffered data.
  ;

  _proto._getBuffer = function _getBuffer(n) {
    var ret = Buffer.allocUnsafe(n);
    var p = this.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;

    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;

      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = buf.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Make sure the linked list only shows the minimal necessary information.
  ;

  _proto[custom] = function (_, options) {
    return inspect(this, _objectSpread({}, options, {
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    }));
  };

  return BufferList;
}();
},{"buffer":"node_modules/buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
var process = require("process");
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      process.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      process.nextTick(emitErrorAndCloseNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process":"node_modules/process/browser.js"}],"node_modules/fastify/node_modules/readable-stream/errors-browser.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;
},{}],"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/state.js":[function(require,module,exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":"node_modules/fastify/node_modules/readable-stream/errors-browser.js"}],"node_modules/fastify/node_modules/readable-stream/experimentalWarning.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var experimentalWarnings = new Set();

function emitExperimentalWarning(feature) {
  if (experimentalWarnings.has(feature)) return;
  var msg = feature + ' is an experimental feature. This feature could ' + 'change at any time';
  experimentalWarnings.add(feature);
  process.emitWarning(msg, 'ExperimentalWarning');
}

function noop() {}

module.exports.emitExperimentalWarning = process.emitWarning ? emitExperimentalWarning : noop;
},{"process":"node_modules/process/browser.js"}],"node_modules/fastify/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    stream.emit('error', er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
},{"util-deprecate":"node_modules/util-deprecate/browser.js","./internal/streams/stream":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/stream-browser.js","buffer":"node_modules/buffer/index.js","./internal/streams/destroy":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/state.js","../errors":"node_modules/fastify/node_modules/readable-stream/errors-browser.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_duplex":"node_modules/fastify/node_modules/readable-stream/lib/_stream_duplex.js","process":"node_modules/process/browser.js"}],"node_modules/fastify/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
},{"./_stream_readable":"node_modules/fastify/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"node_modules/fastify/node_modules/readable-stream/lib/_stream_writable.js","inherits":"node_modules/inherits/inherits_browser.js","process":"node_modules/process/browser.js"}],"node_modules/safe-buffer/index.js":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"node_modules/safe-buffer/index.js"}],"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":"node_modules/fastify/node_modules/readable-stream/errors-browser.js"}],"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/async_iterator.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
},{"./end-of-stream":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","process":"node_modules/process/browser.js"}],"node_modules/fastify/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

var _require2 = require('../experimentalWarning'),
    emitExperimentalWarning = _require2.emitExperimentalWarning; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;

require('inherits')(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc); // if setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    emitExperimentalWarning('Readable[Symbol.asyncIterator]');

    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
},{"events":"node_modules/events/events.js","./internal/streams/stream":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/stream-browser.js","buffer":"node_modules/buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/buffer_list":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/state.js","../errors":"node_modules/fastify/node_modules/readable-stream/errors-browser.js","../experimentalWarning":"node_modules/fastify/node_modules/readable-stream/experimentalWarning.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_duplex":"node_modules/fastify/node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"node_modules/string_decoder/lib/string_decoder.js","./internal/streams/async_iterator":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/async_iterator.js","process":"node_modules/process/browser.js"}],"node_modules/fastify/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":"node_modules/fastify/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"node_modules/fastify/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/fastify/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"node_modules/fastify/node_modules/readable-stream/lib/_stream_transform.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/pipeline.js":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":"node_modules/fastify/node_modules/readable-stream/errors-browser.js","./end-of-stream":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}],"node_modules/fastify/node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');
},{"./lib/_stream_readable.js":"node_modules/fastify/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"node_modules/fastify/node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"node_modules/fastify/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"node_modules/fastify/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"node_modules/fastify/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/internal/streams/end-of-stream.js":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"node_modules/fastify/node_modules/readable-stream/lib/internal/streams/pipeline.js"}],"node_modules/flatstr/index.js":[function(require,module,exports) {
'use strict'

// You may be tempted to copy and paste this, 
// but take a look at the commit history first,
// this is a moving target so relying on the module
// is the best way to make sure the optimization
// method is kept up to date and compatible with
// every Node version.

function flatstr (s) {
  s | 0
  return s
}

module.exports = flatstr
},{}],"node_modules/uri-js/dist/es5/uri.all.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.URI = global.URI || {})));
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uri.all.js.map

},{}],"node_modules/fast-deep-equal/index.js":[function(require,module,exports) {
'use strict';

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  return a!==a && b!==b;
};

},{}],"node_modules/ajv/lib/compile/ucs2length.js":[function(require,module,exports) {
'use strict';

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

},{}],"node_modules/ajv/lib/compile/util.js":[function(require,module,exports) {
'use strict';


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: require('fast-deep-equal'),
  ucs2length: require('./ucs2length'),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\s*{\s*}/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_DATA_ASYNC = 'return data;'
  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g
  , REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

function finalCleanUpCode(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2) {
    out = async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
  }

  matches = out.match(ROOTDATA_REGEXP);
  if (!matches || matches.length !== 3) return out;
  return out.replace(REMOVE_ROOTDATA, '');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

},{"fast-deep-equal":"node_modules/fast-deep-equal/index.js","./ucs2length":"node_modules/ajv/lib/compile/ucs2length.js"}],"node_modules/ajv/lib/compile/schema_obj.js":[function(require,module,exports) {
'use strict';

var util = require('./util');

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

},{"./util":"node_modules/ajv/lib/compile/util.js"}],"node_modules/json-schema-traverse/index.js":[function(require,module,exports) {
'use strict';

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

},{}],"node_modules/ajv/lib/compile/resolve.js":[function(require,module,exports) {
'use strict';

var URI = require('uri-js')
  , equal = require('fast-deep-equal')
  , util = require('./util')
  , SchemaObject = require('./schema_obj')
  , traverse = require('json-schema-traverse');

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}

},{"uri-js":"node_modules/uri-js/dist/es5/uri.all.js","fast-deep-equal":"node_modules/fast-deep-equal/index.js","./util":"node_modules/ajv/lib/compile/util.js","./schema_obj":"node_modules/ajv/lib/compile/schema_obj.js","json-schema-traverse":"node_modules/json-schema-traverse/index.js"}],"node_modules/ajv/lib/compile/error_classes.js":[function(require,module,exports) {
'use strict';

var resolve = require('./resolve');

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}

},{"./resolve":"node_modules/ajv/lib/compile/resolve.js"}],"node_modules/fast-json-stable-stringify/index.js":[function(require,module,exports) {
'use strict';

module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

},{}],"node_modules/ajv/lib/dotjs/validate.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
        }
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($i) {
              out += ' if (' + ($coerced) + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array') {
              out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
            }
            if ($type == 'string') {
              out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top) {
    out = it.util.finalCleanUpCode(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
}

},{}],"node_modules/ajv/lib/compile/index.js":[function(require,module,exports) {
'use strict';

var resolve = require('./resolve')
  , util = require('./util')
  , errorClasses = require('./error_classes')
  , stableStringify = require('fast-json-stable-stringify');

var validateGenerator = require('../dotjs/validate');

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = require('fast-deep-equal');

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}

},{"./resolve":"node_modules/ajv/lib/compile/resolve.js","./util":"node_modules/ajv/lib/compile/util.js","./error_classes":"node_modules/ajv/lib/compile/error_classes.js","fast-json-stable-stringify":"node_modules/fast-json-stable-stringify/index.js","../dotjs/validate":"node_modules/ajv/lib/dotjs/validate.js","fast-deep-equal":"node_modules/fast-deep-equal/index.js"}],"node_modules/ajv/lib/cache.js":[function(require,module,exports) {
'use strict';


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};

},{}],"node_modules/ajv/lib/compile/formats.js":[function(require,module,exports) {
'use strict';

var util = require('./util');

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: hostname,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


function hostname(str) {
  // https://tools.ietf.org/html/rfc1034#section-3.5
  // https://tools.ietf.org/html/rfc1123#section-2
  return str.length <= 255 && HOSTNAME.test(str);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}

},{"./util":"node_modules/ajv/lib/compile/util.js"}],"node_modules/ajv/lib/dotjs/ref.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/allOf.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/anyOf.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/comment.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/const.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/contains.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/dependencies.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/enum.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/format.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/if.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/items.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/_limit.js":[function(require,module,exports) {
'use strict';
module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/_limitItems.js":[function(require,module,exports) {
'use strict';
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/_limitLength.js":[function(require,module,exports) {
'use strict';
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/_limitProperties.js":[function(require,module,exports) {
'use strict';
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/multipleOf.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/not.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/oneOf.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/pattern.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/properties.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/propertyNames.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/required.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/uniqueItems.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],"node_modules/ajv/lib/dotjs/index.js":[function(require,module,exports) {
'use strict';

//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': require('./ref'),
  allOf: require('./allOf'),
  anyOf: require('./anyOf'),
  '$comment': require('./comment'),
  const: require('./const'),
  contains: require('./contains'),
  dependencies: require('./dependencies'),
  'enum': require('./enum'),
  format: require('./format'),
  'if': require('./if'),
  items: require('./items'),
  maximum: require('./_limit'),
  minimum: require('./_limit'),
  maxItems: require('./_limitItems'),
  minItems: require('./_limitItems'),
  maxLength: require('./_limitLength'),
  minLength: require('./_limitLength'),
  maxProperties: require('./_limitProperties'),
  minProperties: require('./_limitProperties'),
  multipleOf: require('./multipleOf'),
  not: require('./not'),
  oneOf: require('./oneOf'),
  pattern: require('./pattern'),
  properties: require('./properties'),
  propertyNames: require('./propertyNames'),
  required: require('./required'),
  uniqueItems: require('./uniqueItems'),
  validate: require('./validate')
};

},{"./ref":"node_modules/ajv/lib/dotjs/ref.js","./allOf":"node_modules/ajv/lib/dotjs/allOf.js","./anyOf":"node_modules/ajv/lib/dotjs/anyOf.js","./comment":"node_modules/ajv/lib/dotjs/comment.js","./const":"node_modules/ajv/lib/dotjs/const.js","./contains":"node_modules/ajv/lib/dotjs/contains.js","./dependencies":"node_modules/ajv/lib/dotjs/dependencies.js","./enum":"node_modules/ajv/lib/dotjs/enum.js","./format":"node_modules/ajv/lib/dotjs/format.js","./if":"node_modules/ajv/lib/dotjs/if.js","./items":"node_modules/ajv/lib/dotjs/items.js","./_limit":"node_modules/ajv/lib/dotjs/_limit.js","./_limitItems":"node_modules/ajv/lib/dotjs/_limitItems.js","./_limitLength":"node_modules/ajv/lib/dotjs/_limitLength.js","./_limitProperties":"node_modules/ajv/lib/dotjs/_limitProperties.js","./multipleOf":"node_modules/ajv/lib/dotjs/multipleOf.js","./not":"node_modules/ajv/lib/dotjs/not.js","./oneOf":"node_modules/ajv/lib/dotjs/oneOf.js","./pattern":"node_modules/ajv/lib/dotjs/pattern.js","./properties":"node_modules/ajv/lib/dotjs/properties.js","./propertyNames":"node_modules/ajv/lib/dotjs/propertyNames.js","./required":"node_modules/ajv/lib/dotjs/required.js","./uniqueItems":"node_modules/ajv/lib/dotjs/uniqueItems.js","./validate":"node_modules/ajv/lib/dotjs/validate.js"}],"node_modules/ajv/lib/compile/rules.js":[function(require,module,exports) {
'use strict';

var ruleModules = require('../dotjs')
  , toHash = require('./util').toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};

},{"../dotjs":"node_modules/ajv/lib/dotjs/index.js","./util":"node_modules/ajv/lib/compile/util.js"}],"node_modules/ajv/lib/data.js":[function(require,module,exports) {
'use strict';

var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};

},{}],"node_modules/ajv/lib/compile/async.js":[function(require,module,exports) {
'use strict';

var MissingRefError = require('./error_classes').MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}

},{"./error_classes":"node_modules/ajv/lib/compile/error_classes.js"}],"node_modules/ajv/lib/dotjs/custom.js":[function(require,module,exports) {
'use strict';
module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
}

},{}],"node_modules/ajv/lib/refs/json-schema-draft-07.json":[function(require,module,exports) {
module.exports = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "http://json-schema.org/draft-07/schema#",
    "title": "Core schema meta-schema",
    "definitions": {
        "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": { "$ref": "#" }
        },
        "nonNegativeInteger": {
            "type": "integer",
            "minimum": 0
        },
        "nonNegativeIntegerDefault0": {
            "allOf": [
                { "$ref": "#/definitions/nonNegativeInteger" },
                { "default": 0 }
            ]
        },
        "simpleTypes": {
            "enum": [
                "array",
                "boolean",
                "integer",
                "null",
                "number",
                "object",
                "string"
            ]
        },
        "stringArray": {
            "type": "array",
            "items": { "type": "string" },
            "uniqueItems": true,
            "default": []
        }
    },
    "type": ["object", "boolean"],
    "properties": {
        "$id": {
            "type": "string",
            "format": "uri-reference"
        },
        "$schema": {
            "type": "string",
            "format": "uri"
        },
        "$ref": {
            "type": "string",
            "format": "uri-reference"
        },
        "$comment": {
            "type": "string"
        },
        "title": {
            "type": "string"
        },
        "description": {
            "type": "string"
        },
        "default": true,
        "readOnly": {
            "type": "boolean",
            "default": false
        },
        "examples": {
            "type": "array",
            "items": true
        },
        "multipleOf": {
            "type": "number",
            "exclusiveMinimum": 0
        },
        "maximum": {
            "type": "number"
        },
        "exclusiveMaximum": {
            "type": "number"
        },
        "minimum": {
            "type": "number"
        },
        "exclusiveMinimum": {
            "type": "number"
        },
        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "pattern": {
            "type": "string",
            "format": "regex"
        },
        "additionalItems": { "$ref": "#" },
        "items": {
            "anyOf": [
                { "$ref": "#" },
                { "$ref": "#/definitions/schemaArray" }
            ],
            "default": true
        },
        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "uniqueItems": {
            "type": "boolean",
            "default": false
        },
        "contains": { "$ref": "#" },
        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": { "$ref": "#" },
        "definitions": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "patternProperties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "propertyNames": { "format": "regex" },
            "default": {}
        },
        "dependencies": {
            "type": "object",
            "additionalProperties": {
                "anyOf": [
                    { "$ref": "#" },
                    { "$ref": "#/definitions/stringArray" }
                ]
            }
        },
        "propertyNames": { "$ref": "#" },
        "const": true,
        "enum": {
            "type": "array",
            "items": true,
            "minItems": 1,
            "uniqueItems": true
        },
        "type": {
            "anyOf": [
                { "$ref": "#/definitions/simpleTypes" },
                {
                    "type": "array",
                    "items": { "$ref": "#/definitions/simpleTypes" },
                    "minItems": 1,
                    "uniqueItems": true
                }
            ]
        },
        "format": { "type": "string" },
        "contentMediaType": { "type": "string" },
        "contentEncoding": { "type": "string" },
        "if": {"$ref": "#"},
        "then": {"$ref": "#"},
        "else": {"$ref": "#"},
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
    },
    "default": true
}
;
},{}],"node_modules/ajv/lib/definition_schema.js":[function(require,module,exports) {
'use strict';

var metaSchema = require('./refs/json-schema-draft-07.json');

module.exports = {
  $id: 'https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};

},{"./refs/json-schema-draft-07.json":"node_modules/ajv/lib/refs/json-schema-draft-07.json"}],"node_modules/ajv/lib/keyword.js":[function(require,module,exports) {
'use strict';

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require('./dotjs/custom');
var definitionSchema = require('./definition_schema');

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definitionSchema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}

},{"./dotjs/custom":"node_modules/ajv/lib/dotjs/custom.js","./definition_schema":"node_modules/ajv/lib/definition_schema.js"}],"node_modules/ajv/lib/refs/data.json":[function(require,module,exports) {
module.exports = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#",
    "description": "Meta-schema for $data reference (JSON Schema extension proposal)",
    "type": "object",
    "required": [ "$data" ],
    "properties": {
        "$data": {
            "type": "string",
            "anyOf": [
                { "format": "relative-json-pointer" }, 
                { "format": "json-pointer" }
            ]
        }
    },
    "additionalProperties": false
}
;
},{}],"node_modules/ajv/lib/ajv.js":[function(require,module,exports) {
'use strict';

var compileSchema = require('./compile')
  , resolve = require('./compile/resolve')
  , Cache = require('./cache')
  , SchemaObject = require('./compile/schema_obj')
  , stableStringify = require('fast-json-stable-stringify')
  , formats = require('./compile/formats')
  , rules = require('./compile/rules')
  , $dataMetaSchema = require('./data')
  , util = require('./compile/util');

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = require('./compile/async');
var customKeyword = require('./keyword');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;

var errorClasses = require('./compile/error_classes');
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = require('./refs/data.json');
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = require('./refs/json-schema-draft-07.json');
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}

},{"./compile":"node_modules/ajv/lib/compile/index.js","./compile/resolve":"node_modules/ajv/lib/compile/resolve.js","./cache":"node_modules/ajv/lib/cache.js","./compile/schema_obj":"node_modules/ajv/lib/compile/schema_obj.js","fast-json-stable-stringify":"node_modules/fast-json-stable-stringify/index.js","./compile/formats":"node_modules/ajv/lib/compile/formats.js","./compile/rules":"node_modules/ajv/lib/compile/rules.js","./data":"node_modules/ajv/lib/data.js","./compile/util":"node_modules/ajv/lib/compile/util.js","./compile/async":"node_modules/ajv/lib/compile/async.js","./keyword":"node_modules/ajv/lib/keyword.js","./compile/error_classes":"node_modules/ajv/lib/compile/error_classes.js","./refs/data.json":"node_modules/ajv/lib/refs/data.json","./refs/json-schema-draft-07.json":"node_modules/ajv/lib/refs/json-schema-draft-07.json"}],"node_modules/deepmerge/dist/cjs.js":[function(require,module,exports) {
'use strict';

var isMergeableObject = function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value);
};

function isNonNullObject(value) {
  return !!value && typeof value === 'object';
}

function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
} // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25


var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}

function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}

function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}

function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function (element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}

function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return deepmerge;
  }

  var customMerge = options.customMerge(key);
  return typeof customMerge === 'function' ? customMerge : deepmerge;
}

function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
    return target.propertyIsEnumerable(symbol);
  }) : [];
}

function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}

function mergeObject(target, source, options) {
  var destination = {};

  if (options.isMergeableObject(target)) {
    getKeys(target).forEach(function (key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }

  getKeys(source).forEach(function (key) {
    if (!options.isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    } else {
      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    }
  });
  return destination;
}

function deepmerge(target, source, options) {
  options = Object.assign({
    arrayMerge: defaultArrayMerge,
    isMergeableObject: isMergeableObject
  }, options, {
    cloneUnlessOtherwiseSpecified: cloneUnlessOtherwiseSpecified
  });
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}

deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error('first argument should be an array');
  }

  return array.reduce(function (prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};

var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;
},{}],"node_modules/ajv/lib/compile/equal.js":[function(require,module,exports) {
'use strict';

// do NOT remove this file - it would break pre-compiled schemas
// https://github.com/epoberezkin/ajv/issues/889
module.exports = require('fast-deep-equal');

},{"fast-deep-equal":"node_modules/fast-deep-equal/index.js"}],"node_modules/fast-json-stringify/schema-validator.js":[function(require,module,exports) {
// This file is autogenerated by build-schema-validator.js, do not edit

function nop () { return true }

'use strict';
var formats = require('ajv/lib/compile/formats')();
var equal = require('ajv/lib/compile/equal');
var validate = (function() {
  var refVal = [];
  var refVal1 = {
    "type": "integer",
    "minimum": 0
  };
  refVal[1] = refVal1;
  var refVal2 = (function() {
    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {
      'use strict';
      var vErrors = null;
      var errors = 0;
      var errs_1 = errors;
      var errs_2 = errors;
      if ((typeof data !== "number" || (data % 1) || data !== data)) {
        validate.errors = [{
          keyword: 'type',
          dataPath: (dataPath || '') + "",
          schemaPath: '#/definitions/nonNegativeInteger/type',
          params: {
            type: 'integer'
          },
          message: 'should be integer'
        }];
        return false;
      }
      if (typeof data === "number") {
        if (data < 0 || data !== data) {
          validate.errors = [{
            keyword: 'minimum',
            dataPath: (dataPath || '') + "",
            schemaPath: '#/definitions/nonNegativeInteger/minimum',
            params: {
              comparison: '>=',
              limit: 0,
              exclusive: false
            },
            message: 'should be >= 0'
          }];
          return false;
        }
      }
      var valid2 = errors === errs_2;
      var valid1 = errors === errs_1;
      validate.errors = vErrors;
      return errors === 0;
    };
  })();
  refVal2.schema = {
    "allOf": [{
      "$ref": "#/definitions/nonNegativeInteger"
    }, {
      "default": 0
    }]
  };
  refVal2.errors = null;
  refVal[2] = refVal2;
  var refVal3 = (function() {
    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {
      'use strict';
      var vErrors = null;
      var errors = 0;
      if (rootData === undefined) rootData = data;
      if (Array.isArray(data)) {
        if (data.length < 1) {
          validate.errors = [{
            keyword: 'minItems',
            dataPath: (dataPath || '') + "",
            schemaPath: '#/minItems',
            params: {
              limit: 1
            },
            message: 'should NOT have fewer than 1 items'
          }];
          return false;
        } else {
          var errs__0 = errors;
          var valid0;
          for (var i0 = 0; i0 < data.length; i0++) {
            var errs_1 = errors;
            if (!nop(data[i0], (dataPath || '') + '[' + i0 + ']', data, i0, rootData)) {
              if (vErrors === null) vErrors = nop.errors;
              else vErrors = vErrors.concat(nop.errors);
              errors = vErrors.length;
            }
            var valid1 = errors === errs_1;
            if (!valid1) break;
          }
        }
      } else {
        validate.errors = [{
          keyword: 'type',
          dataPath: (dataPath || '') + "",
          schemaPath: '#/type',
          params: {
            type: 'array'
          },
          message: 'should be array'
        }];
        return false;
      }
      validate.errors = vErrors;
      return errors === 0;
    };
  })();
  refVal3.schema = {
    "type": "array",
    "minItems": 1,
    "items": {
      "$ref": "#"
    }
  };
  refVal3.errors = null;
  refVal[3] = refVal3;
  var refVal4 = {
    "type": "array",
    "items": {
      "type": "string"
    },
    "uniqueItems": true,
    "default": []
  };
  refVal[4] = refVal4;
  var refVal5 = {
    "enum": ["array", "boolean", "integer", "null", "number", "object", "string"]
  };
  refVal[5] = refVal5;
  return function validate(data, dataPath, parentData, parentDataProperty, rootData) {
    'use strict'; /*# sourceURL=http://json-schema.org/draft-07/schema# */
    var vErrors = null;
    var errors = 0;
    if (rootData === undefined) rootData = data;
    if ((!data || typeof data !== "object" || Array.isArray(data)) && typeof data !== "boolean") {
      validate.errors = [{
        keyword: 'type',
        dataPath: (dataPath || '') + "",
        schemaPath: '#/type',
        params: {
          type: 'object,boolean'
        },
        message: 'should be object,boolean'
      }];
      return false;
    }
    if ((data && typeof data === "object" && !Array.isArray(data))) {
      var errs__0 = errors;
      var valid1 = true;
      var data1 = data.$id;
      if (data1 === undefined) {
        valid1 = true;
      } else {
        var errs_1 = errors;
        if (errors === errs_1) {
          if (typeof data1 === "string") {
            if (!formats['uri-reference'].test(data1)) {
              validate.errors = [{
                keyword: 'format',
                dataPath: (dataPath || '') + '.$id',
                schemaPath: '#/properties/%24id/format',
                params: {
                  format: 'uri-reference'
                },
                message: 'should match format "uri-reference"'
              }];
              return false;
            }
          } else {
            validate.errors = [{
              keyword: 'type',
              dataPath: (dataPath || '') + '.$id',
              schemaPath: '#/properties/%24id/type',
              params: {
                type: 'string'
              },
              message: 'should be string'
            }];
            return false;
          }
        }
        var valid1 = errors === errs_1;
      }
      if (valid1) {
        var data1 = data.$schema;
        if (data1 === undefined) {
          valid1 = true;
        } else {
          var errs_1 = errors;
          if (errors === errs_1) {
            if (typeof data1 === "string") {
              if (!formats.uri.test(data1)) {
                validate.errors = [{
                  keyword: 'format',
                  dataPath: (dataPath || '') + '.$schema',
                  schemaPath: '#/properties/%24schema/format',
                  params: {
                    format: 'uri'
                  },
                  message: 'should match format "uri"'
                }];
                return false;
              }
            } else {
              validate.errors = [{
                keyword: 'type',
                dataPath: (dataPath || '') + '.$schema',
                schemaPath: '#/properties/%24schema/type',
                params: {
                  type: 'string'
                },
                message: 'should be string'
              }];
              return false;
            }
          }
          var valid1 = errors === errs_1;
        }
        if (valid1) {
          var data1 = data.$ref;
          if (data1 === undefined) {
            valid1 = true;
          } else {
            var errs_1 = errors;
            if (errors === errs_1) {
              if (typeof data1 === "string") {
                if (!formats['uri-reference'].test(data1)) {
                  validate.errors = [{
                    keyword: 'format',
                    dataPath: (dataPath || '') + '.$ref',
                    schemaPath: '#/properties/%24ref/format',
                    params: {
                      format: 'uri-reference'
                    },
                    message: 'should match format "uri-reference"'
                  }];
                  return false;
                }
              } else {
                validate.errors = [{
                  keyword: 'type',
                  dataPath: (dataPath || '') + '.$ref',
                  schemaPath: '#/properties/%24ref/type',
                  params: {
                    type: 'string'
                  },
                  message: 'should be string'
                }];
                return false;
              }
            }
            var valid1 = errors === errs_1;
          }
          if (valid1) {
            if (data.$comment === undefined) {
              valid1 = true;
            } else {
              var errs_1 = errors;
              if (typeof data.$comment !== "string") {
                validate.errors = [{
                  keyword: 'type',
                  dataPath: (dataPath || '') + '.$comment',
                  schemaPath: '#/properties/%24comment/type',
                  params: {
                    type: 'string'
                  },
                  message: 'should be string'
                }];
                return false;
              }
              var valid1 = errors === errs_1;
            }
            if (valid1) {
              if (data.title === undefined) {
                valid1 = true;
              } else {
                var errs_1 = errors;
                if (typeof data.title !== "string") {
                  validate.errors = [{
                    keyword: 'type',
                    dataPath: (dataPath || '') + '.title',
                    schemaPath: '#/properties/title/type',
                    params: {
                      type: 'string'
                    },
                    message: 'should be string'
                  }];
                  return false;
                }
                var valid1 = errors === errs_1;
              }
              if (valid1) {
                if (data.description === undefined) {
                  valid1 = true;
                } else {
                  var errs_1 = errors;
                  if (typeof data.description !== "string") {
                    validate.errors = [{
                      keyword: 'type',
                      dataPath: (dataPath || '') + '.description',
                      schemaPath: '#/properties/description/type',
                      params: {
                        type: 'string'
                      },
                      message: 'should be string'
                    }];
                    return false;
                  }
                  var valid1 = errors === errs_1;
                }
                if (valid1) {
                  if (valid1) {
                    if (data.readOnly === undefined) {
                      valid1 = true;
                    } else {
                      var errs_1 = errors;
                      if (typeof data.readOnly !== "boolean") {
                        validate.errors = [{
                          keyword: 'type',
                          dataPath: (dataPath || '') + '.readOnly',
                          schemaPath: '#/properties/readOnly/type',
                          params: {
                            type: 'boolean'
                          },
                          message: 'should be boolean'
                        }];
                        return false;
                      }
                      var valid1 = errors === errs_1;
                    }
                    if (valid1) {
                      if (data.examples === undefined) {
                        valid1 = true;
                      } else {
                        var errs_1 = errors;
                        if (Array.isArray(data.examples)) {
                          var errs__1 = errors;
                          var valid1;
                        } else {
                          validate.errors = [{
                            keyword: 'type',
                            dataPath: (dataPath || '') + '.examples',
                            schemaPath: '#/properties/examples/type',
                            params: {
                              type: 'array'
                            },
                            message: 'should be array'
                          }];
                          return false;
                        }
                        var valid1 = errors === errs_1;
                      }
                      if (valid1) {
                        var data1 = data.multipleOf;
                        if (data1 === undefined) {
                          valid1 = true;
                        } else {
                          var errs_1 = errors;
                          if (typeof data1 === "number") {
                            if (data1 <= 0 || data1 !== data1) {
                              validate.errors = [{
                                keyword: 'exclusiveMinimum',
                                dataPath: (dataPath || '') + '.multipleOf',
                                schemaPath: '#/properties/multipleOf/exclusiveMinimum',
                                params: {
                                  comparison: '>',
                                  limit: 0,
                                  exclusive: true
                                },
                                message: 'should be > 0'
                              }];
                              return false;
                            }
                          } else {
                            validate.errors = [{
                              keyword: 'type',
                              dataPath: (dataPath || '') + '.multipleOf',
                              schemaPath: '#/properties/multipleOf/type',
                              params: {
                                type: 'number'
                              },
                              message: 'should be number'
                            }];
                            return false;
                          }
                          var valid1 = errors === errs_1;
                        }
                        if (valid1) {
                          if (data.maximum === undefined) {
                            valid1 = true;
                          } else {
                            var errs_1 = errors;
                            if (typeof data.maximum !== "number") {
                              validate.errors = [{
                                keyword: 'type',
                                dataPath: (dataPath || '') + '.maximum',
                                schemaPath: '#/properties/maximum/type',
                                params: {
                                  type: 'number'
                                },
                                message: 'should be number'
                              }];
                              return false;
                            }
                            var valid1 = errors === errs_1;
                          }
                          if (valid1) {
                            if (data.exclusiveMaximum === undefined) {
                              valid1 = true;
                            } else {
                              var errs_1 = errors;
                              if (typeof data.exclusiveMaximum !== "number") {
                                validate.errors = [{
                                  keyword: 'type',
                                  dataPath: (dataPath || '') + '.exclusiveMaximum',
                                  schemaPath: '#/properties/exclusiveMaximum/type',
                                  params: {
                                    type: 'number'
                                  },
                                  message: 'should be number'
                                }];
                                return false;
                              }
                              var valid1 = errors === errs_1;
                            }
                            if (valid1) {
                              if (data.minimum === undefined) {
                                valid1 = true;
                              } else {
                                var errs_1 = errors;
                                if (typeof data.minimum !== "number") {
                                  validate.errors = [{
                                    keyword: 'type',
                                    dataPath: (dataPath || '') + '.minimum',
                                    schemaPath: '#/properties/minimum/type',
                                    params: {
                                      type: 'number'
                                    },
                                    message: 'should be number'
                                  }];
                                  return false;
                                }
                                var valid1 = errors === errs_1;
                              }
                              if (valid1) {
                                if (data.exclusiveMinimum === undefined) {
                                  valid1 = true;
                                } else {
                                  var errs_1 = errors;
                                  if (typeof data.exclusiveMinimum !== "number") {
                                    validate.errors = [{
                                      keyword: 'type',
                                      dataPath: (dataPath || '') + '.exclusiveMinimum',
                                      schemaPath: '#/properties/exclusiveMinimum/type',
                                      params: {
                                        type: 'number'
                                      },
                                      message: 'should be number'
                                    }];
                                    return false;
                                  }
                                  var valid1 = errors === errs_1;
                                }
                                if (valid1) {
                                  var data1 = data.maxLength;
                                  if (data1 === undefined) {
                                    valid1 = true;
                                  } else {
                                    var errs_1 = errors;
                                    var errs_2 = errors;
                                    if ((typeof data1 !== "number" || (data1 % 1) || data1 !== data1)) {
                                      validate.errors = [{
                                        keyword: 'type',
                                        dataPath: (dataPath || '') + '.maxLength',
                                        schemaPath: '#/definitions/nonNegativeInteger/type',
                                        params: {
                                          type: 'integer'
                                        },
                                        message: 'should be integer'
                                      }];
                                      return false;
                                    }
                                    if (typeof data1 === "number") {
                                      if (data1 < 0 || data1 !== data1) {
                                        validate.errors = [{
                                          keyword: 'minimum',
                                          dataPath: (dataPath || '') + '.maxLength',
                                          schemaPath: '#/definitions/nonNegativeInteger/minimum',
                                          params: {
                                            comparison: '>=',
                                            limit: 0,
                                            exclusive: false
                                          },
                                          message: 'should be >= 0'
                                        }];
                                        return false;
                                      }
                                    }
                                    var valid2 = errors === errs_2;
                                    var valid1 = errors === errs_1;
                                  }
                                  if (valid1) {
                                    if (data.minLength === undefined) {
                                      valid1 = true;
                                    } else {
                                      var errs_1 = errors;
                                      if (!refVal2(data.minLength, (dataPath || '') + '.minLength', data, 'minLength', rootData)) {
                                        if (vErrors === null) vErrors = refVal2.errors;
                                        else vErrors = vErrors.concat(refVal2.errors);
                                        errors = vErrors.length;
                                      }
                                      var valid1 = errors === errs_1;
                                    }
                                    if (valid1) {
                                      var data1 = data.pattern;
                                      if (data1 === undefined) {
                                        valid1 = true;
                                      } else {
                                        var errs_1 = errors;
                                        if (errors === errs_1) {
                                          if (typeof data1 === "string") {
                                            if (!formats.regex(data1)) {
                                              validate.errors = [{
                                                keyword: 'format',
                                                dataPath: (dataPath || '') + '.pattern',
                                                schemaPath: '#/properties/pattern/format',
                                                params: {
                                                  format: 'regex'
                                                },
                                                message: 'should match format "regex"'
                                              }];
                                              return false;
                                            }
                                          } else {
                                            validate.errors = [{
                                              keyword: 'type',
                                              dataPath: (dataPath || '') + '.pattern',
                                              schemaPath: '#/properties/pattern/type',
                                              params: {
                                                type: 'string'
                                              },
                                              message: 'should be string'
                                            }];
                                            return false;
                                          }
                                        }
                                        var valid1 = errors === errs_1;
                                      }
                                      if (valid1) {
                                        if (data.additionalItems === undefined) {
                                          valid1 = true;
                                        } else {
                                          var errs_1 = errors;
                                          if (!validate(data.additionalItems, (dataPath || '') + '.additionalItems', data, 'additionalItems', rootData)) {
                                            if (vErrors === null) vErrors = validate.errors;
                                            else vErrors = vErrors.concat(validate.errors);
                                            errors = vErrors.length;
                                          }
                                          var valid1 = errors === errs_1;
                                        }
                                        if (valid1) {
                                          var data1 = data.items;
                                          if (data1 === undefined) {
                                            valid1 = true;
                                          } else {
                                            var errs_1 = errors;
                                            var errs__1 = errors;
                                            var valid1 = false;
                                            var errs_2 = errors;
                                            if (!validate(data1, (dataPath || '') + '.items', data, 'items', rootData)) {
                                              if (vErrors === null) vErrors = validate.errors;
                                              else vErrors = vErrors.concat(validate.errors);
                                              errors = vErrors.length;
                                            }
                                            var valid2 = errors === errs_2;
                                            valid1 = valid1 || valid2;
                                            if (!valid1) {
                                              var errs_2 = errors;
                                              if (!refVal3(data1, (dataPath || '') + '.items', data, 'items', rootData)) {
                                                if (vErrors === null) vErrors = refVal3.errors;
                                                else vErrors = vErrors.concat(refVal3.errors);
                                                errors = vErrors.length;
                                              }
                                              var valid2 = errors === errs_2;
                                              valid1 = valid1 || valid2;
                                            }
                                            if (!valid1) {
                                              var err = {
                                                keyword: 'anyOf',
                                                dataPath: (dataPath || '') + '.items',
                                                schemaPath: '#/properties/items/anyOf',
                                                params: {},
                                                message: 'should match some schema in anyOf'
                                              };
                                              if (vErrors === null) vErrors = [err];
                                              else vErrors.push(err);
                                              errors++;
                                              validate.errors = vErrors;
                                              return false;
                                            } else {
                                              errors = errs__1;
                                              if (vErrors !== null) {
                                                if (errs__1) vErrors.length = errs__1;
                                                else vErrors = null;
                                              }
                                            }
                                            var valid1 = errors === errs_1;
                                          }
                                          if (valid1) {
                                            var data1 = data.maxItems;
                                            if (data1 === undefined) {
                                              valid1 = true;
                                            } else {
                                              var errs_1 = errors;
                                              var errs_2 = errors;
                                              if ((typeof data1 !== "number" || (data1 % 1) || data1 !== data1)) {
                                                validate.errors = [{
                                                  keyword: 'type',
                                                  dataPath: (dataPath || '') + '.maxItems',
                                                  schemaPath: '#/definitions/nonNegativeInteger/type',
                                                  params: {
                                                    type: 'integer'
                                                  },
                                                  message: 'should be integer'
                                                }];
                                                return false;
                                              }
                                              if (typeof data1 === "number") {
                                                if (data1 < 0 || data1 !== data1) {
                                                  validate.errors = [{
                                                    keyword: 'minimum',
                                                    dataPath: (dataPath || '') + '.maxItems',
                                                    schemaPath: '#/definitions/nonNegativeInteger/minimum',
                                                    params: {
                                                      comparison: '>=',
                                                      limit: 0,
                                                      exclusive: false
                                                    },
                                                    message: 'should be >= 0'
                                                  }];
                                                  return false;
                                                }
                                              }
                                              var valid2 = errors === errs_2;
                                              var valid1 = errors === errs_1;
                                            }
                                            if (valid1) {
                                              if (data.minItems === undefined) {
                                                valid1 = true;
                                              } else {
                                                var errs_1 = errors;
                                                if (!refVal[2](data.minItems, (dataPath || '') + '.minItems', data, 'minItems', rootData)) {
                                                  if (vErrors === null) vErrors = refVal[2].errors;
                                                  else vErrors = vErrors.concat(refVal[2].errors);
                                                  errors = vErrors.length;
                                                }
                                                var valid1 = errors === errs_1;
                                              }
                                              if (valid1) {
                                                if (data.uniqueItems === undefined) {
                                                  valid1 = true;
                                                } else {
                                                  var errs_1 = errors;
                                                  if (typeof data.uniqueItems !== "boolean") {
                                                    validate.errors = [{
                                                      keyword: 'type',
                                                      dataPath: (dataPath || '') + '.uniqueItems',
                                                      schemaPath: '#/properties/uniqueItems/type',
                                                      params: {
                                                        type: 'boolean'
                                                      },
                                                      message: 'should be boolean'
                                                    }];
                                                    return false;
                                                  }
                                                  var valid1 = errors === errs_1;
                                                }
                                                if (valid1) {
                                                  if (data.contains === undefined) {
                                                    valid1 = true;
                                                  } else {
                                                    var errs_1 = errors;
                                                    if (!validate(data.contains, (dataPath || '') + '.contains', data, 'contains', rootData)) {
                                                      if (vErrors === null) vErrors = validate.errors;
                                                      else vErrors = vErrors.concat(validate.errors);
                                                      errors = vErrors.length;
                                                    }
                                                    var valid1 = errors === errs_1;
                                                  }
                                                  if (valid1) {
                                                    var data1 = data.maxProperties;
                                                    if (data1 === undefined) {
                                                      valid1 = true;
                                                    } else {
                                                      var errs_1 = errors;
                                                      var errs_2 = errors;
                                                      if ((typeof data1 !== "number" || (data1 % 1) || data1 !== data1)) {
                                                        validate.errors = [{
                                                          keyword: 'type',
                                                          dataPath: (dataPath || '') + '.maxProperties',
                                                          schemaPath: '#/definitions/nonNegativeInteger/type',
                                                          params: {
                                                            type: 'integer'
                                                          },
                                                          message: 'should be integer'
                                                        }];
                                                        return false;
                                                      }
                                                      if (typeof data1 === "number") {
                                                        if (data1 < 0 || data1 !== data1) {
                                                          validate.errors = [{
                                                            keyword: 'minimum',
                                                            dataPath: (dataPath || '') + '.maxProperties',
                                                            schemaPath: '#/definitions/nonNegativeInteger/minimum',
                                                            params: {
                                                              comparison: '>=',
                                                              limit: 0,
                                                              exclusive: false
                                                            },
                                                            message: 'should be >= 0'
                                                          }];
                                                          return false;
                                                        }
                                                      }
                                                      var valid2 = errors === errs_2;
                                                      var valid1 = errors === errs_1;
                                                    }
                                                    if (valid1) {
                                                      if (data.minProperties === undefined) {
                                                        valid1 = true;
                                                      } else {
                                                        var errs_1 = errors;
                                                        if (!refVal[2](data.minProperties, (dataPath || '') + '.minProperties', data, 'minProperties', rootData)) {
                                                          if (vErrors === null) vErrors = refVal[2].errors;
                                                          else vErrors = vErrors.concat(refVal[2].errors);
                                                          errors = vErrors.length;
                                                        }
                                                        var valid1 = errors === errs_1;
                                                      }
                                                      if (valid1) {
                                                        var data1 = data.required;
                                                        if (data1 === undefined) {
                                                          valid1 = true;
                                                        } else {
                                                          var errs_1 = errors;
                                                          var errs_2 = errors;
                                                          if (Array.isArray(data1)) {
                                                            var errs__2 = errors;
                                                            var valid2;
                                                            for (var i2 = 0; i2 < data1.length; i2++) {
                                                              var errs_3 = errors;
                                                              if (typeof data1[i2] !== "string") {
                                                                validate.errors = [{
                                                                  keyword: 'type',
                                                                  dataPath: (dataPath || '') + '.required[' + i2 + ']',
                                                                  schemaPath: '#/definitions/stringArray/items/type',
                                                                  params: {
                                                                    type: 'string'
                                                                  },
                                                                  message: 'should be string'
                                                                }];
                                                                return false;
                                                              }
                                                              var valid3 = errors === errs_3;
                                                              if (!valid3) break;
                                                            }
                                                            if (errs__2 == errors) {
                                                              var i = data1.length,
                                                                valid2 = true,
                                                                j;
                                                              if (i > 1) {
                                                                var itemIndices = {},
                                                                  item;
                                                                for (; i--;) {
                                                                  var item = data1[i];
                                                                  if (typeof item !== "string") continue;
                                                                  if (typeof itemIndices[item] == 'number') {
                                                                    valid2 = false;
                                                                    j = itemIndices[item];
                                                                    break;
                                                                  }
                                                                  itemIndices[item] = i;
                                                                }
                                                              }
                                                              if (!valid2) {
                                                                validate.errors = [{
                                                                  keyword: 'uniqueItems',
                                                                  dataPath: (dataPath || '') + '.required',
                                                                  schemaPath: '#/definitions/stringArray/uniqueItems',
                                                                  params: {
                                                                    i: i,
                                                                    j: j
                                                                  },
                                                                  message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)'
                                                                }];
                                                                return false;
                                                              }
                                                            }
                                                          } else {
                                                            validate.errors = [{
                                                              keyword: 'type',
                                                              dataPath: (dataPath || '') + '.required',
                                                              schemaPath: '#/definitions/stringArray/type',
                                                              params: {
                                                                type: 'array'
                                                              },
                                                              message: 'should be array'
                                                            }];
                                                            return false;
                                                          }
                                                          var valid2 = errors === errs_2;
                                                          var valid1 = errors === errs_1;
                                                        }
                                                        if (valid1) {
                                                          if (data.additionalProperties === undefined) {
                                                            valid1 = true;
                                                          } else {
                                                            var errs_1 = errors;
                                                            if (!validate(data.additionalProperties, (dataPath || '') + '.additionalProperties', data, 'additionalProperties', rootData)) {
                                                              if (vErrors === null) vErrors = validate.errors;
                                                              else vErrors = vErrors.concat(validate.errors);
                                                              errors = vErrors.length;
                                                            }
                                                            var valid1 = errors === errs_1;
                                                          }
                                                          if (valid1) {
                                                            var data1 = data.definitions;
                                                            if (data1 === undefined) {
                                                              valid1 = true;
                                                            } else {
                                                              var errs_1 = errors;
                                                              if ((data1 && typeof data1 === "object" && !Array.isArray(data1))) {
                                                                var errs__1 = errors;
                                                                var valid2 = true;
                                                                for (var key1 in data1) {
                                                                  var errs_2 = errors;
                                                                  if (!validate(data1[key1], (dataPath || '') + '.definitions[\'' + key1 + '\']', data1, key1, rootData)) {
                                                                    if (vErrors === null) vErrors = validate.errors;
                                                                    else vErrors = vErrors.concat(validate.errors);
                                                                    errors = vErrors.length;
                                                                  }
                                                                  var valid2 = errors === errs_2;
                                                                  if (!valid2) break;
                                                                }
                                                              } else {
                                                                validate.errors = [{
                                                                  keyword: 'type',
                                                                  dataPath: (dataPath || '') + '.definitions',
                                                                  schemaPath: '#/properties/definitions/type',
                                                                  params: {
                                                                    type: 'object'
                                                                  },
                                                                  message: 'should be object'
                                                                }];
                                                                return false;
                                                              }
                                                              var valid1 = errors === errs_1;
                                                            }
                                                            if (valid1) {
                                                              var data1 = data.properties;
                                                              if (data1 === undefined) {
                                                                valid1 = true;
                                                              } else {
                                                                var errs_1 = errors;
                                                                if ((data1 && typeof data1 === "object" && !Array.isArray(data1))) {
                                                                  var errs__1 = errors;
                                                                  var valid2 = true;
                                                                  for (var key1 in data1) {
                                                                    var errs_2 = errors;
                                                                    if (!validate(data1[key1], (dataPath || '') + '.properties[\'' + key1 + '\']', data1, key1, rootData)) {
                                                                      if (vErrors === null) vErrors = validate.errors;
                                                                      else vErrors = vErrors.concat(validate.errors);
                                                                      errors = vErrors.length;
                                                                    }
                                                                    var valid2 = errors === errs_2;
                                                                    if (!valid2) break;
                                                                  }
                                                                } else {
                                                                  validate.errors = [{
                                                                    keyword: 'type',
                                                                    dataPath: (dataPath || '') + '.properties',
                                                                    schemaPath: '#/properties/properties/type',
                                                                    params: {
                                                                      type: 'object'
                                                                    },
                                                                    message: 'should be object'
                                                                  }];
                                                                  return false;
                                                                }
                                                                var valid1 = errors === errs_1;
                                                              }
                                                              if (valid1) {
                                                                var data1 = data.patternProperties;
                                                                if (data1 === undefined) {
                                                                  valid1 = true;
                                                                } else {
                                                                  var errs_1 = errors;
                                                                  if ((data1 && typeof data1 === "object" && !Array.isArray(data1))) {
                                                                    var errs__1 = errors;
                                                                    for (var key1 in data1) {
                                                                      var startErrs1 = errors;
                                                                      var data2 = key1;
                                                                      var errs_2 = errors;
                                                                      if (errors === errs_2) {
                                                                        if (typeof data2 === "string") {
                                                                          if (!formats.regex(data2)) {
                                                                            var err = {
                                                                              keyword: 'format',
                                                                              dataPath: (dataPath || '') + '.patternProperties',
                                                                              schemaPath: '#/properties/patternProperties/propertyNames/format',
                                                                              params: {
                                                                                format: 'regex'
                                                                              },
                                                                              message: 'should match format "regex"'
                                                                            };
                                                                            if (vErrors === null) vErrors = [err];
                                                                            else vErrors.push(err);
                                                                            errors++;
                                                                          }
                                                                        }
                                                                      }
                                                                      var valid2 = errors === errs_2;
                                                                      if (!valid2) {
                                                                        for (var i1 = startErrs1; i1 < errors; i1++) {
                                                                          vErrors[i1].propertyName = key1;
                                                                        }
                                                                        var err = {
                                                                          keyword: 'propertyNames',
                                                                          dataPath: (dataPath || '') + '.patternProperties',
                                                                          schemaPath: '#/properties/patternProperties/propertyNames',
                                                                          params: {
                                                                            propertyName: '' + key1 + ''
                                                                          },
                                                                          message: 'property name \'' + key1 + '\' is invalid'
                                                                        };
                                                                        if (vErrors === null) vErrors = [err];
                                                                        else vErrors.push(err);
                                                                        errors++;
                                                                        validate.errors = vErrors;
                                                                        return false;
                                                                        break;
                                                                      }
                                                                    }
                                                                    if (errs__1 == errors) {
                                                                      var errs__1 = errors;
                                                                      var valid2 = true;
                                                                      for (var key1 in data1) {
                                                                        var errs_2 = errors;
                                                                        if (!validate(data1[key1], (dataPath || '') + '.patternProperties[\'' + key1 + '\']', data1, key1, rootData)) {
                                                                          if (vErrors === null) vErrors = validate.errors;
                                                                          else vErrors = vErrors.concat(validate.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid2 = errors === errs_2;
                                                                        if (!valid2) break;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate.errors = [{
                                                                      keyword: 'type',
                                                                      dataPath: (dataPath || '') + '.patternProperties',
                                                                      schemaPath: '#/properties/patternProperties/type',
                                                                      params: {
                                                                        type: 'object'
                                                                      },
                                                                      message: 'should be object'
                                                                    }];
                                                                    return false;
                                                                  }
                                                                  var valid1 = errors === errs_1;
                                                                }
                                                                if (valid1) {
                                                                  var data1 = data.dependencies;
                                                                  if (data1 === undefined) {
                                                                    valid1 = true;
                                                                  } else {
                                                                    var errs_1 = errors;
                                                                    if ((data1 && typeof data1 === "object" && !Array.isArray(data1))) {
                                                                      var errs__1 = errors;
                                                                      var valid2 = true;
                                                                      for (var key1 in data1) {
                                                                        var data2 = data1[key1];
                                                                        var errs_2 = errors;
                                                                        var errs__2 = errors;
                                                                        var valid2 = false;
                                                                        var errs_3 = errors;
                                                                        if (!validate(data2, (dataPath || '') + '.dependencies[\'' + key1 + '\']', data1, key1, rootData)) {
                                                                          if (vErrors === null) vErrors = validate.errors;
                                                                          else vErrors = vErrors.concat(validate.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid3 = errors === errs_3;
                                                                        valid2 = valid2 || valid3;
                                                                        if (!valid2) {
                                                                          var errs_3 = errors;
                                                                          var errs_4 = errors;
                                                                          if (Array.isArray(data2)) {
                                                                            var errs__4 = errors;
                                                                            var valid4;
                                                                            for (var i4 = 0; i4 < data2.length; i4++) {
                                                                              var errs_5 = errors;
                                                                              if (typeof data2[i4] !== "string") {
                                                                                var err = {
                                                                                  keyword: 'type',
                                                                                  dataPath: (dataPath || '') + '.dependencies[\'' + key1 + '\'][' + i4 + ']',
                                                                                  schemaPath: '#/definitions/stringArray/items/type',
                                                                                  params: {
                                                                                    type: 'string'
                                                                                  },
                                                                                  message: 'should be string'
                                                                                };
                                                                                if (vErrors === null) vErrors = [err];
                                                                                else vErrors.push(err);
                                                                                errors++;
                                                                              }
                                                                              var valid5 = errors === errs_5;
                                                                              if (!valid5) break;
                                                                            }
                                                                            if (errs__4 == errors) {
                                                                              var i = data2.length,
                                                                                valid4 = true,
                                                                                j;
                                                                              if (i > 1) {
                                                                                var itemIndices = {},
                                                                                  item;
                                                                                for (; i--;) {
                                                                                  var item = data2[i];
                                                                                  if (typeof item !== "string") continue;
                                                                                  if (typeof itemIndices[item] == 'number') {
                                                                                    valid4 = false;
                                                                                    j = itemIndices[item];
                                                                                    break;
                                                                                  }
                                                                                  itemIndices[item] = i;
                                                                                }
                                                                              }
                                                                              if (!valid4) {
                                                                                var err = {
                                                                                  keyword: 'uniqueItems',
                                                                                  dataPath: (dataPath || '') + '.dependencies[\'' + key1 + '\']',
                                                                                  schemaPath: '#/definitions/stringArray/uniqueItems',
                                                                                  params: {
                                                                                    i: i,
                                                                                    j: j
                                                                                  },
                                                                                  message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)'
                                                                                };
                                                                                if (vErrors === null) vErrors = [err];
                                                                                else vErrors.push(err);
                                                                                errors++;
                                                                              }
                                                                            }
                                                                          } else {
                                                                            var err = {
                                                                              keyword: 'type',
                                                                              dataPath: (dataPath || '') + '.dependencies[\'' + key1 + '\']',
                                                                              schemaPath: '#/definitions/stringArray/type',
                                                                              params: {
                                                                                type: 'array'
                                                                              },
                                                                              message: 'should be array'
                                                                            };
                                                                            if (vErrors === null) vErrors = [err];
                                                                            else vErrors.push(err);
                                                                            errors++;
                                                                          }
                                                                          var valid4 = errors === errs_4;
                                                                          var valid3 = errors === errs_3;
                                                                          valid2 = valid2 || valid3;
                                                                        }
                                                                        if (!valid2) {
                                                                          var err = {
                                                                            keyword: 'anyOf',
                                                                            dataPath: (dataPath || '') + '.dependencies[\'' + key1 + '\']',
                                                                            schemaPath: '#/properties/dependencies/additionalProperties/anyOf',
                                                                            params: {},
                                                                            message: 'should match some schema in anyOf'
                                                                          };
                                                                          if (vErrors === null) vErrors = [err];
                                                                          else vErrors.push(err);
                                                                          errors++;
                                                                          validate.errors = vErrors;
                                                                          return false;
                                                                        } else {
                                                                          errors = errs__2;
                                                                          if (vErrors !== null) {
                                                                            if (errs__2) vErrors.length = errs__2;
                                                                            else vErrors = null;
                                                                          }
                                                                        }
                                                                        var valid2 = errors === errs_2;
                                                                        if (!valid2) break;
                                                                      }
                                                                    } else {
                                                                      validate.errors = [{
                                                                        keyword: 'type',
                                                                        dataPath: (dataPath || '') + '.dependencies',
                                                                        schemaPath: '#/properties/dependencies/type',
                                                                        params: {
                                                                          type: 'object'
                                                                        },
                                                                        message: 'should be object'
                                                                      }];
                                                                      return false;
                                                                    }
                                                                    var valid1 = errors === errs_1;
                                                                  }
                                                                  if (valid1) {
                                                                    if (data.propertyNames === undefined) {
                                                                      valid1 = true;
                                                                    } else {
                                                                      var errs_1 = errors;
                                                                      if (!validate(data.propertyNames, (dataPath || '') + '.propertyNames', data, 'propertyNames', rootData)) {
                                                                        if (vErrors === null) vErrors = validate.errors;
                                                                        else vErrors = vErrors.concat(validate.errors);
                                                                        errors = vErrors.length;
                                                                      }
                                                                      var valid1 = errors === errs_1;
                                                                    }
                                                                    if (valid1) {
                                                                      if (valid1) {
                                                                        var data1 = data.enum;
                                                                        if (data1 === undefined) {
                                                                          valid1 = true;
                                                                        } else {
                                                                          var errs_1 = errors;
                                                                          if (Array.isArray(data1)) {
                                                                            if (data1.length < 1) {
                                                                              validate.errors = [{
                                                                                keyword: 'minItems',
                                                                                dataPath: (dataPath || '') + '.enum',
                                                                                schemaPath: '#/properties/enum/minItems',
                                                                                params: {
                                                                                  limit: 1
                                                                                },
                                                                                message: 'should NOT have fewer than 1 items'
                                                                              }];
                                                                              return false;
                                                                            } else {
                                                                              var errs__1 = errors;
                                                                              var valid1;
                                                                              if (errs__1 == errors) {
                                                                                var i = data1.length,
                                                                                  valid1 = true,
                                                                                  j;
                                                                                if (i > 1) {
                                                                                  outer: for (; i--;) {
                                                                                    for (j = i; j--;) {
                                                                                      if (equal(data1[i], data1[j])) {
                                                                                        valid1 = false;
                                                                                        break outer;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                                if (!valid1) {
                                                                                  validate.errors = [{
                                                                                    keyword: 'uniqueItems',
                                                                                    dataPath: (dataPath || '') + '.enum',
                                                                                    schemaPath: '#/properties/enum/uniqueItems',
                                                                                    params: {
                                                                                      i: i,
                                                                                      j: j
                                                                                    },
                                                                                    message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)'
                                                                                  }];
                                                                                  return false;
                                                                                }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            validate.errors = [{
                                                                              keyword: 'type',
                                                                              dataPath: (dataPath || '') + '.enum',
                                                                              schemaPath: '#/properties/enum/type',
                                                                              params: {
                                                                                type: 'array'
                                                                              },
                                                                              message: 'should be array'
                                                                            }];
                                                                            return false;
                                                                          }
                                                                          var valid1 = errors === errs_1;
                                                                        }
                                                                        if (valid1) {
                                                                          var data1 = data.type;
                                                                          if (data1 === undefined) {
                                                                            valid1 = true;
                                                                          } else {
                                                                            var errs_1 = errors;
                                                                            var errs__1 = errors;
                                                                            var valid1 = false;
                                                                            var errs_2 = errors;
                                                                            var errs_3 = errors;
                                                                            var schema3 = refVal5.enum;
                                                                            var valid3;
                                                                            valid3 = false;
                                                                            for (var i3 = 0; i3 < schema3.length; i3++)
                                                                              if (equal(data1, schema3[i3])) {
                                                                                valid3 = true;
                                                                                break;
                                                                              } if (!valid3) {
                                                                              var err = {
                                                                                keyword: 'enum',
                                                                                dataPath: (dataPath || '') + '.type',
                                                                                schemaPath: '#/definitions/simpleTypes/enum',
                                                                                params: {
                                                                                  allowedValues: schema3
                                                                                },
                                                                                message: 'should be equal to one of the allowed values'
                                                                              };
                                                                              if (vErrors === null) vErrors = [err];
                                                                              else vErrors.push(err);
                                                                              errors++;
                                                                            }
                                                                            var valid3 = errors === errs_3;
                                                                            var valid2 = errors === errs_2;
                                                                            valid1 = valid1 || valid2;
                                                                            if (!valid1) {
                                                                              var errs_2 = errors;
                                                                              if (Array.isArray(data1)) {
                                                                                if (data1.length < 1) {
                                                                                  var err = {
                                                                                    keyword: 'minItems',
                                                                                    dataPath: (dataPath || '') + '.type',
                                                                                    schemaPath: '#/properties/type/anyOf/1/minItems',
                                                                                    params: {
                                                                                      limit: 1
                                                                                    },
                                                                                    message: 'should NOT have fewer than 1 items'
                                                                                  };
                                                                                  if (vErrors === null) vErrors = [err];
                                                                                  else vErrors.push(err);
                                                                                  errors++;
                                                                                } else {
                                                                                  var errs__2 = errors;
                                                                                  var valid2;
                                                                                  for (var i2 = 0; i2 < data1.length; i2++) {
                                                                                    var errs_3 = errors;
                                                                                    var errs_4 = errors;
                                                                                    var schema4 = refVal[5].enum;
                                                                                    var valid4;
                                                                                    valid4 = false;
                                                                                    for (var i4 = 0; i4 < schema4.length; i4++)
                                                                                      if (equal(data1[i2], schema4[i4])) {
                                                                                        valid4 = true;
                                                                                        break;
                                                                                      } if (!valid4) {
                                                                                      var err = {
                                                                                        keyword: 'enum',
                                                                                        dataPath: (dataPath || '') + '.type[' + i2 + ']',
                                                                                        schemaPath: '#/definitions/simpleTypes/enum',
                                                                                        params: {
                                                                                          allowedValues: schema4
                                                                                        },
                                                                                        message: 'should be equal to one of the allowed values'
                                                                                      };
                                                                                      if (vErrors === null) vErrors = [err];
                                                                                      else vErrors.push(err);
                                                                                      errors++;
                                                                                    }
                                                                                    var valid4 = errors === errs_4;
                                                                                    var valid3 = errors === errs_3;
                                                                                    if (!valid3) break;
                                                                                  }
                                                                                  if (errs__2 == errors) {
                                                                                    var i = data1.length,
                                                                                      valid2 = true,
                                                                                      j;
                                                                                    if (i > 1) {
                                                                                      outer: for (; i--;) {
                                                                                        for (j = i; j--;) {
                                                                                          if (equal(data1[i], data1[j])) {
                                                                                            valid2 = false;
                                                                                            break outer;
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    if (!valid2) {
                                                                                      var err = {
                                                                                        keyword: 'uniqueItems',
                                                                                        dataPath: (dataPath || '') + '.type',
                                                                                        schemaPath: '#/properties/type/anyOf/1/uniqueItems',
                                                                                        params: {
                                                                                          i: i,
                                                                                          j: j
                                                                                        },
                                                                                        message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)'
                                                                                      };
                                                                                      if (vErrors === null) vErrors = [err];
                                                                                      else vErrors.push(err);
                                                                                      errors++;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                var err = {
                                                                                  keyword: 'type',
                                                                                  dataPath: (dataPath || '') + '.type',
                                                                                  schemaPath: '#/properties/type/anyOf/1/type',
                                                                                  params: {
                                                                                    type: 'array'
                                                                                  },
                                                                                  message: 'should be array'
                                                                                };
                                                                                if (vErrors === null) vErrors = [err];
                                                                                else vErrors.push(err);
                                                                                errors++;
                                                                              }
                                                                              var valid2 = errors === errs_2;
                                                                              valid1 = valid1 || valid2;
                                                                            }
                                                                            if (!valid1) {
                                                                              var err = {
                                                                                keyword: 'anyOf',
                                                                                dataPath: (dataPath || '') + '.type',
                                                                                schemaPath: '#/properties/type/anyOf',
                                                                                params: {},
                                                                                message: 'should match some schema in anyOf'
                                                                              };
                                                                              if (vErrors === null) vErrors = [err];
                                                                              else vErrors.push(err);
                                                                              errors++;
                                                                              validate.errors = vErrors;
                                                                              return false;
                                                                            } else {
                                                                              errors = errs__1;
                                                                              if (vErrors !== null) {
                                                                                if (errs__1) vErrors.length = errs__1;
                                                                                else vErrors = null;
                                                                              }
                                                                            }
                                                                            var valid1 = errors === errs_1;
                                                                          }
                                                                          if (valid1) {
                                                                            if (data.format === undefined) {
                                                                              valid1 = true;
                                                                            } else {
                                                                              var errs_1 = errors;
                                                                              if (typeof data.format !== "string") {
                                                                                validate.errors = [{
                                                                                  keyword: 'type',
                                                                                  dataPath: (dataPath || '') + '.format',
                                                                                  schemaPath: '#/properties/format/type',
                                                                                  params: {
                                                                                    type: 'string'
                                                                                  },
                                                                                  message: 'should be string'
                                                                                }];
                                                                                return false;
                                                                              }
                                                                              var valid1 = errors === errs_1;
                                                                            }
                                                                            if (valid1) {
                                                                              if (data.contentMediaType === undefined) {
                                                                                valid1 = true;
                                                                              } else {
                                                                                var errs_1 = errors;
                                                                                if (typeof data.contentMediaType !== "string") {
                                                                                  validate.errors = [{
                                                                                    keyword: 'type',
                                                                                    dataPath: (dataPath || '') + '.contentMediaType',
                                                                                    schemaPath: '#/properties/contentMediaType/type',
                                                                                    params: {
                                                                                      type: 'string'
                                                                                    },
                                                                                    message: 'should be string'
                                                                                  }];
                                                                                  return false;
                                                                                }
                                                                                var valid1 = errors === errs_1;
                                                                              }
                                                                              if (valid1) {
                                                                                if (data.contentEncoding === undefined) {
                                                                                  valid1 = true;
                                                                                } else {
                                                                                  var errs_1 = errors;
                                                                                  if (typeof data.contentEncoding !== "string") {
                                                                                    validate.errors = [{
                                                                                      keyword: 'type',
                                                                                      dataPath: (dataPath || '') + '.contentEncoding',
                                                                                      schemaPath: '#/properties/contentEncoding/type',
                                                                                      params: {
                                                                                        type: 'string'
                                                                                      },
                                                                                      message: 'should be string'
                                                                                    }];
                                                                                    return false;
                                                                                  }
                                                                                  var valid1 = errors === errs_1;
                                                                                }
                                                                                if (valid1) {
                                                                                  if (data.if === undefined) {
                                                                                    valid1 = true;
                                                                                  } else {
                                                                                    var errs_1 = errors;
                                                                                    if (!validate(data.if, (dataPath || '') + '.if', data, 'if', rootData)) {
                                                                                      if (vErrors === null) vErrors = validate.errors;
                                                                                      else vErrors = vErrors.concat(validate.errors);
                                                                                      errors = vErrors.length;
                                                                                    }
                                                                                    var valid1 = errors === errs_1;
                                                                                  }
                                                                                  if (valid1) {
                                                                                    if (data.then === undefined) {
                                                                                      valid1 = true;
                                                                                    } else {
                                                                                      var errs_1 = errors;
                                                                                      if (!validate(data.then, (dataPath || '') + '.then', data, 'then', rootData)) {
                                                                                        if (vErrors === null) vErrors = validate.errors;
                                                                                        else vErrors = vErrors.concat(validate.errors);
                                                                                        errors = vErrors.length;
                                                                                      }
                                                                                      var valid1 = errors === errs_1;
                                                                                    }
                                                                                    if (valid1) {
                                                                                      if (data.else === undefined) {
                                                                                        valid1 = true;
                                                                                      } else {
                                                                                        var errs_1 = errors;
                                                                                        if (!validate(data.else, (dataPath || '') + '.else', data, 'else', rootData)) {
                                                                                          if (vErrors === null) vErrors = validate.errors;
                                                                                          else vErrors = vErrors.concat(validate.errors);
                                                                                          errors = vErrors.length;
                                                                                        }
                                                                                        var valid1 = errors === errs_1;
                                                                                      }
                                                                                      if (valid1) {
                                                                                        if (data.allOf === undefined) {
                                                                                          valid1 = true;
                                                                                        } else {
                                                                                          var errs_1 = errors;
                                                                                          if (!refVal[3](data.allOf, (dataPath || '') + '.allOf', data, 'allOf', rootData)) {
                                                                                            if (vErrors === null) vErrors = refVal[3].errors;
                                                                                            else vErrors = vErrors.concat(refVal[3].errors);
                                                                                            errors = vErrors.length;
                                                                                          }
                                                                                          var valid1 = errors === errs_1;
                                                                                        }
                                                                                        if (valid1) {
                                                                                          if (data.anyOf === undefined) {
                                                                                            valid1 = true;
                                                                                          } else {
                                                                                            var errs_1 = errors;
                                                                                            if (!refVal[3](data.anyOf, (dataPath || '') + '.anyOf', data, 'anyOf', rootData)) {
                                                                                              if (vErrors === null) vErrors = refVal[3].errors;
                                                                                              else vErrors = vErrors.concat(refVal[3].errors);
                                                                                              errors = vErrors.length;
                                                                                            }
                                                                                            var valid1 = errors === errs_1;
                                                                                          }
                                                                                          if (valid1) {
                                                                                            if (data.oneOf === undefined) {
                                                                                              valid1 = true;
                                                                                            } else {
                                                                                              var errs_1 = errors;
                                                                                              if (!refVal[3](data.oneOf, (dataPath || '') + '.oneOf', data, 'oneOf', rootData)) {
                                                                                                if (vErrors === null) vErrors = refVal[3].errors;
                                                                                                else vErrors = vErrors.concat(refVal[3].errors);
                                                                                                errors = vErrors.length;
                                                                                              }
                                                                                              var valid1 = errors === errs_1;
                                                                                            }
                                                                                            if (valid1) {
                                                                                              if (data.not === undefined) {
                                                                                                valid1 = true;
                                                                                              } else {
                                                                                                var errs_1 = errors;
                                                                                                if (!validate(data.not, (dataPath || '') + '.not', data, 'not', rootData)) {
                                                                                                  if (vErrors === null) vErrors = validate.errors;
                                                                                                  else vErrors = vErrors.concat(validate.errors);
                                                                                                  errors = vErrors.length;
                                                                                                }
                                                                                                var valid1 = errors === errs_1;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    validate.errors = vErrors;
    return errors === 0;
  };
})();
validate.schema = {
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "http://json-schema.org/draft-07/schema#",
  "title": "Core schema meta-schema",
  "definitions": {
    "schemaArray": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#"
      }
    },
    "nonNegativeInteger": {
      "type": "integer",
      "minimum": 0
    },
    "nonNegativeIntegerDefault0": {
      "allOf": [{
        "$ref": "#/definitions/nonNegativeInteger"
      }, {
        "default": 0
      }]
    },
    "simpleTypes": {
      "enum": ["array", "boolean", "integer", "null", "number", "object", "string"]
    },
    "stringArray": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true,
      "default": []
    }
  },
  "type": ["object", "boolean"],
  "properties": {
    "$id": {
      "type": "string",
      "format": "uri-reference"
    },
    "$schema": {
      "type": "string",
      "format": "uri"
    },
    "$ref": {
      "type": "string",
      "format": "uri-reference"
    },
    "$comment": {
      "type": "string"
    },
    "title": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "default": true,
    "readOnly": {
      "type": "boolean",
      "default": false
    },
    "examples": {
      "type": "array",
      "items": true
    },
    "multipleOf": {
      "type": "number",
      "exclusiveMinimum": 0
    },
    "maximum": {
      "type": "number"
    },
    "exclusiveMaximum": {
      "type": "number"
    },
    "minimum": {
      "type": "number"
    },
    "exclusiveMinimum": {
      "type": "number"
    },
    "maxLength": {
      "$ref": "#/definitions/nonNegativeInteger"
    },
    "minLength": {
      "$ref": "#/definitions/nonNegativeIntegerDefault0"
    },
    "pattern": {
      "type": "string",
      "format": "regex"
    },
    "additionalItems": {
      "$ref": "#"
    },
    "items": {
      "anyOf": [{
        "$ref": "#"
      }, {
        "$ref": "#/definitions/schemaArray"
      }],
      "default": true
    },
    "maxItems": {
      "$ref": "#/definitions/nonNegativeInteger"
    },
    "minItems": {
      "$ref": "#/definitions/nonNegativeIntegerDefault0"
    },
    "uniqueItems": {
      "type": "boolean",
      "default": false
    },
    "contains": {
      "$ref": "#"
    },
    "maxProperties": {
      "$ref": "#/definitions/nonNegativeInteger"
    },
    "minProperties": {
      "$ref": "#/definitions/nonNegativeIntegerDefault0"
    },
    "required": {
      "$ref": "#/definitions/stringArray"
    },
    "additionalProperties": {
      "$ref": "#"
    },
    "definitions": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#"
      },
      "default": {}
    },
    "properties": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#"
      },
      "default": {}
    },
    "patternProperties": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#"
      },
      "propertyNames": {
        "format": "regex"
      },
      "default": {}
    },
    "dependencies": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [{
          "$ref": "#"
        }, {
          "$ref": "#/definitions/stringArray"
        }]
      }
    },
    "propertyNames": {
      "$ref": "#"
    },
    "const": true,
    "enum": {
      "type": "array",
      "items": true,
      "minItems": 1,
      "uniqueItems": true
    },
    "type": {
      "anyOf": [{
        "$ref": "#/definitions/simpleTypes"
      }, {
        "type": "array",
        "items": {
          "$ref": "#/definitions/simpleTypes"
        },
        "minItems": 1,
        "uniqueItems": true
      }]
    },
    "format": {
      "type": "string"
    },
    "contentMediaType": {
      "type": "string"
    },
    "contentEncoding": {
      "type": "string"
    },
    "if": {
      "$ref": "#"
    },
    "then": {
      "$ref": "#"
    },
    "else": {
      "$ref": "#"
    },
    "allOf": {
      "$ref": "#/definitions/schemaArray"
    },
    "anyOf": {
      "$ref": "#/definitions/schemaArray"
    },
    "oneOf": {
      "$ref": "#/definitions/schemaArray"
    },
    "not": {
      "$ref": "#"
    }
  },
  "default": true
};
validate.errors = null;
module.exports = validate;

},{"ajv/lib/compile/formats":"node_modules/ajv/lib/compile/formats.js","ajv/lib/compile/equal":"node_modules/ajv/lib/compile/equal.js"}],"node_modules/fast-json-stringify/index.js":[function(require,module,exports) {
'use strict'

/* eslint no-prototype-builtins: 0 */

var Ajv = require('ajv')
var merge = require('deepmerge')
var util = require('util')
var validate = require('./schema-validator')

var uglify = null
var isLong
try {
  isLong = require('long').isLong
} catch (e) {
  isLong = null
}

var addComma = `
  if (addComma) {
    json += ','
  }
  addComma = true
`

function isValidSchema (schema, name) {
  if (!validate(schema)) {
    if (name) {
      name = `"${name}" `
    } else {
      name = ''
    }
    const first = validate.errors[0]
    const err = new Error(`${name}schema is invalid: data${first.dataPath} ${first.message}`)
    err.errors = isValidSchema.errors
    throw err
  }
}

function build (schema, options) {
  options = options || {}
  isValidSchema(schema)
  if (options.schema) {
    for (const key of Object.keys(options.schema)) {
      isValidSchema(options.schema[key], key)
    }
  }

  /* eslint no-new-func: "off" */
  var code = `
    'use strict'
  `

  code += `
    ${$asString.toString()}
    ${$asStringNullable.toString()}
    ${$asStringSmall.toString()}
    ${$asNumber.toString()}
    ${$asNumberNullable.toString()}
    ${$asIntegerNullable.toString()}
    ${$asNull.toString()}
    ${$asBoolean.toString()}
    ${$asBooleanNullable.toString()}
  `

  // only handle longs if the module is used
  if (isLong) {
    code += `
      var isLong = ${isLong.toString()}
      ${$asInteger.toString()}
    `
  } else {
    code += `
      var $asInteger = $asNumber
    `
  }

  if (schema.$ref) {
    schema = refFinder(schema.$ref, schema, options.schema)
  }

  if (schema.type === undefined) {
    schema.type = inferTypeByKeyword(schema)
  }

  var hasSchemaSomeIf = hasIf(schema)

  var main

  switch (schema.type) {
    case 'object':
      main = '$main'
      code = buildObject(schema, code, main, options.schema, schema)
      break
    case 'string':
      main = schema.nullable ? $asStringNullable.name : $asString.name
      break
    case 'integer':
      main = schema.nullable ? $asIntegerNullable.name : $asInteger.name
      break
    case 'number':
      main = schema.nullable ? $asNumberNullable.name : $asNumber.name
      break
    case 'boolean':
      main = schema.nullable ? $asBooleanNullable.name : $asBoolean.name
      break
    case 'null':
      main = $asNull.name
      break
    case 'array':
      main = '$main'
      code = buildArray(schema, code, main, options.schema, schema)
      break
    default:
      throw new Error(`${schema.type} unsupported`)
  }

  code += `
    ;
     return ${main}
  `

  if (options.uglify) {
    code = uglifyCode(code)
  }

  var dependencies = []
  var dependenciesName = []
  if (hasAnyOf(schema) || hasSchemaSomeIf) {
    dependencies.push(new Ajv(options.ajv))
    dependenciesName.push('ajv')
  }

  dependenciesName.push(code)
  return (Function.apply(null, dependenciesName).apply(null, dependencies))
}

const objectKeywords = [
  'maxProperties',
  'minProperties',
  'required',
  'properties',
  'patternProperties',
  'additionalProperties',
  'dependencies'
]

const arrayKeywords = [
  'items',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'contains'
]

const stringKeywords = [
  'maxLength',
  'minLength',
  'pattern'
]

const numberKeywords = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum'
]

/**
 * Infer type based on keyword in order to generate optimized code
 * https://json-schema.org/latest/json-schema-validation.html#rfc.section.6
 */
function inferTypeByKeyword (schema) {
  for (const keyword of objectKeywords) {
    if (keyword in schema) return 'object'
  }
  for (const keyword of arrayKeywords) {
    if (keyword in schema) return 'array'
  }
  for (const keyword of stringKeywords) {
    if (keyword in schema) return 'string'
  }
  for (const keyword of numberKeywords) {
    if (keyword in schema) return 'number'
  }
  return schema.type
}

function hasAnyOf (schema) {
  if (!schema) { return false }
  if ('anyOf' in schema) { return true }

  var objectKeys = Object.keys(schema)
  for (var i = 0; i < objectKeys.length; i++) {
    var value = schema[objectKeys[i]]
    if (typeof value === 'object') {
      if (hasAnyOf(value)) { return true }
    }
  }

  return false
}

function hasIf (schema) {
  const str = JSON.stringify(schema)
  return /"if":{/.test(str) && /"then":{/.test(str)
}

function $asNull () {
  return 'null'
}

function $asInteger (i) {
  if (isLong && isLong(i)) {
    return i.toString()
  } else {
    return $asNumber(i)
  }
}

function $asIntegerNullable (i) {
  return i === null ? null : $asInteger(i)
}

function $asNumber (i) {
  var num = Number(i)
  if (isNaN(num)) {
    return 'null'
  } else {
    return '' + num
  }
}

function $asNumberNullable (i) {
  return i === null ? null : $asNumber(i)
}

function $asBoolean (bool) {
  return bool && 'true' || 'false' // eslint-disable-line
}

function $asBooleanNullable (bool) {
  return bool === null ? null : $asBoolean(bool)
}

function $asString (str) {
  if (str instanceof Date) {
    return '"' + str.toISOString() + '"'
  } else if (str === null) {
    return '""'
  } else if (str instanceof RegExp) {
    str = str.source
  } else if (typeof str !== 'string') {
    str = str.toString()
  }

  if (str.length < 42) {
    return $asStringSmall(str)
  } else {
    return JSON.stringify(str)
  }
}

function $asStringNullable (str) {
  return str === null ? null : $asString(str)
}

// magically escape strings for json
// relying on their charCodeAt
// everything below 32 needs JSON.stringify()
// every string that contain surrogate needs JSON.stringify()
// 34 and 92 happens all the time, so we
// have a fast case for them
function $asStringSmall (str) {
  var result = ''
  var last = 0
  var found = false
  var surrogateFound = false
  var l = str.length
  var point = 255
  for (var i = 0; i < l && point >= 32; i++) {
    point = str.charCodeAt(i)
    if (point >= 0xD800 && point <= 0xDFFF) {
      // The current character is a surrogate.
      surrogateFound = true
    }
    if (point === 34 || point === 92) {
      result += str.slice(last, i) + '\\'
      last = i
      found = true
    }
  }

  if (!found) {
    result = str
  } else {
    result += str.slice(last)
  }
  return ((point < 32) || (surrogateFound === true)) ? JSON.stringify(str) : '"' + result + '"'
}

function addPatternProperties (schema, externalSchema, fullSchema) {
  var pp = schema.patternProperties
  var code = `
      var properties = ${JSON.stringify(schema.properties)} || {}
      var keys = Object.keys(obj)
      for (var i = 0; i < keys.length; i++) {
        if (properties[keys[i]]) continue
  `
  Object.keys(pp).forEach((regex, index) => {
    if (pp[regex].$ref) {
      pp[regex] = refFinder(pp[regex].$ref, fullSchema, externalSchema, fullSchema)
    }
    var type = pp[regex].type
    code += `
        if (/${regex.replace(/\\*\//g, '\\/')}/.test(keys[i])) {
    `
    if (type === 'object') {
      code += buildObject(pp[regex], '', 'buildObjectPP' + index, externalSchema, fullSchema)
      code += `
          ${addComma}
          json += $asString(keys[i]) + ':' + buildObjectPP${index}(obj[keys[i]])
      `
    } else if (type === 'array') {
      code += buildArray(pp[regex], '', 'buildArrayPP' + index, externalSchema, fullSchema)
      code += `
          ${addComma}
          json += $asString(keys[i]) + ':' + buildArrayPP${index}(obj[keys[i]])
      `
    } else if (type === 'null') {
      code += `
          ${addComma}
          json += $asString(keys[i]) +':null'
      `
    } else if (type === 'string') {
      code += `
          ${addComma}
          json += $asString(keys[i]) + ':' + $asString(obj[keys[i]])
      `
    } else if (type === 'integer') {
      code += `
          ${addComma}
          json += $asString(keys[i]) + ':' + $asInteger(obj[keys[i]])
      `
    } else if (type === 'number') {
      code += `
          ${addComma}
          json += $asString(keys[i]) + ':' + $asNumber(obj[keys[i]])
      `
    } else if (type === 'boolean') {
      code += `
          ${addComma}
          json += $asString(keys[i]) + ':' + $asBoolean(obj[keys[i]])
      `
    } else {
      code += `
        throw new Error('Cannot coerce ' + obj[keys[i]] + ' to ${type}')
      `
    }

    code += `
          continue
        }
    `
  })
  if (schema.additionalProperties) {
    code += additionalProperty(schema, externalSchema, fullSchema)
  }

  code += `
      }
  `
  return code
}

function additionalProperty (schema, externalSchema, fullSchema) {
  var ap = schema.additionalProperties
  var code = ''
  if (ap === true) {
    return `
        if (obj[keys[i]] !== undefined) {
          ${addComma}
          json += $asString(keys[i]) + ':' + JSON.stringify(obj[keys[i]])
        }
    `
  }
  if (ap.$ref) {
    ap = refFinder(ap.$ref, fullSchema, externalSchema)
  }

  var type = ap.type
  if (type === 'object') {
    code += buildObject(ap, '', 'buildObjectAP', externalSchema)
    code += `
        ${addComma}
        json += $asString(keys[i]) + ':' + buildObjectAP(obj[keys[i]])
    `
  } else if (type === 'array') {
    code += buildArray(ap, '', 'buildArrayAP', externalSchema, fullSchema)
    code += `
        ${addComma}
        json += $asString(keys[i]) + ':' + buildArrayAP(obj[keys[i]])
    `
  } else if (type === 'null') {
    code += `
        ${addComma}
        json += $asString(keys[i]) +':null'
    `
  } else if (type === 'string') {
    code += `
        ${addComma}
        json += $asString(keys[i]) + ':' + $asString(obj[keys[i]])
    `
  } else if (type === 'integer') {
    code += `
        var t = Number(obj[keys[i]])
    `
    if (isLong) {
      code += `
          if (isLong(obj[keys[i]]) || !isNaN(t)) {
            ${addComma}
            json += $asString(keys[i]) + ':' + $asInteger(obj[keys[i]])
          }
      `
    } else {
      code += `
          if (!isNaN(t)) {
            ${addComma}
            json += $asString(keys[i]) + ':' + t
          }
      `
    }
  } else if (type === 'number') {
    code += `
        var t = Number(obj[keys[i]])
        if (!isNaN(t)) {
          ${addComma}
          json += $asString(keys[i]) + ':' + t
        }
    `
  } else if (type === 'boolean') {
    code += `
        ${addComma}
        json += $asString(keys[i]) + ':' + $asBoolean(obj[keys[i]])
    `
  } else {
    code += `
        throw new Error('Cannot coerce ' + obj[keys[i]] + ' to ${type}')
    `
  }
  return code
}

function addAdditionalProperties (schema, externalSchema, fullSchema) {
  return `
      var properties = ${JSON.stringify(schema.properties)} || {}
      var keys = Object.keys(obj)
      for (var i = 0; i < keys.length; i++) {
        if (properties[keys[i]]) continue
        ${additionalProperty(schema, externalSchema, fullSchema)}
      }
  `
}

function idFinder (schema, searchedId) {
  let objSchema
  const explore = (schema, searchedId) => {
    Object.keys(schema || {}).forEach((key, i, a) => {
      if (key === '$id' && schema[key] === searchedId) {
        objSchema = schema
      } else if (objSchema === undefined && typeof schema[key] === 'object') {
        explore(schema[key], searchedId)
      }
    })
  }
  explore(schema, searchedId)
  return objSchema
}

function refFinder (ref, schema, externalSchema) {
  // Split file from walk
  ref = ref.split('#')

  // If external file
  if (ref[0]) {
    schema = externalSchema[ref[0]]

    if (schema.$ref) {
      return refFinder(schema.$ref, schema, externalSchema)
    }
  }

  var code = 'return schema'
  // If it has a path
  if (ref[1]) {
    // ref[1] could contain a JSON pointer - ex: /definitions/num
    // or plain name fragment id without suffix # - ex: customId
    var walk = ref[1].split('/')
    if (walk.length === 1) {
      var targetId = `#${ref[1]}`
      var dereferenced = idFinder(schema, targetId)
      if (dereferenced === undefined && !ref[0]) {
        for (var key of Object.keys(externalSchema)) {
          dereferenced = idFinder(externalSchema[key], targetId)
          if (dereferenced !== undefined) break
        }
      }
      return dereferenced
    } else {
      for (var i = 1; i < walk.length; i++) {
        code += `['${sanitizeKey(walk[i])}']`
      }
    }
  }
  return (new Function('schema', code))(schema)
}

function sanitizeKey (key) {
  const rep = key.replace(/(\\*)'/g, function (match, p1) {
    var base = ''
    if (p1.length % 2 === 1) {
      base = p1.slice(2)
    } else {
      base = p1
    }
    var rep = base + '\\\''
    return rep
  })
  return rep
}

function buildCode (schema, code, laterCode, name, externalSchema, fullSchema) {
  Object.keys(schema.properties || {}).forEach((key, i, a) => {
    if (schema.properties[key].$ref) {
      // if the schema object is deep in the tree, we must resolve the ref in the parent scope
      const isRelative = schema.definitions && schema.properties[key].$ref[0] === '#'
      schema.properties[key] = refFinder(schema.properties[key].$ref, isRelative ? schema : fullSchema, externalSchema)
    }

    // Using obj['key'] !== undefined instead of obj.hasOwnProperty(prop) for perf reasons,
    // see https://github.com/mcollina/fast-json-stringify/pull/3 for discussion.

    var type = schema.properties[key].type
    var nullable = schema.properties[key].nullable
    var sanitized = sanitizeKey(key)
    var asString = sanitizeKey($asString(key).replace(/\\/g, '\\\\'))

    if (nullable) {
      code += `
        if (obj['${sanitized}'] === null) {
          ${addComma}
          json += '${asString}:null'
          var rendered = true
        } else {
      `
    }

    if (type === 'number') {
      code += `
          var t = Number(obj['${sanitized}'])
          if (!isNaN(t)) {
            ${addComma}
            json += '${asString}:' + t
      `
    } else if (type === 'integer') {
      code += `
          var rendered = false
      `
      if (isLong) {
        code += `
            if (isLong(obj['${sanitized}'])) {
              ${addComma}
              json += '${asString}:' + obj['${sanitized}'].toString()
              rendered = true
            } else {
              var t = Number(obj['${sanitized}'])
              if (!isNaN(t)) {
                ${addComma}
                json += '${asString}:' + t
                rendered = true
              }
            }
        `
      } else {
        code += `
            var t = Number(obj['${sanitized}'])
            if (!isNaN(t)) {
              ${addComma}
              json += '${asString}:' + t
              rendered = true
            }
        `
      }
      code += `
          if (rendered) {
      `
    } else {
      code += `
        if (obj['${sanitized}'] !== undefined) {
          ${addComma}
          json += '${asString}:'
        `

      var result = nested(laterCode, name, key, schema.properties[key], externalSchema, fullSchema)
      code += result.code
      laterCode = result.laterCode
    }

    var defaultValue = schema.properties[key].default
    if (defaultValue !== undefined) {
      code += `
      } else {
        ${addComma}
        json += '${asString}:${sanitizeKey(JSON.stringify(defaultValue).replace(/\\/g, '\\\\'))}'
      `
    } else if (schema.required && schema.required.indexOf(key) !== -1) {
      code += `
      } else {
        throw new Error('${sanitized} is required!')
      `
    }

    code += `
      }
    `

    if (nullable) {
      code += `
        }
      `
    }
  })
  return { code: code, laterCode: laterCode }
}

function buildCodeWithAllOfs (schema, code, laterCode, name, externalSchema, fullSchema) {
  if (schema.allOf) {
    schema.allOf.forEach((ss) => {
      var builtCode = buildCodeWithAllOfs(ss, code, laterCode, name, externalSchema, fullSchema)

      code = builtCode.code
      laterCode = builtCode.laterCode
    })
  } else {
    var builtCode = buildCode(schema, code, laterCode, name, externalSchema, fullSchema)

    code = builtCode.code
    laterCode = builtCode.laterCode
  }

  return { code: code, laterCode: laterCode }
}

function buildInnerObject (schema, name, externalSchema, fullSchema) {
  var laterCode = ''
  var code = ''
  if (schema.patternProperties) {
    code += addPatternProperties(schema, externalSchema, fullSchema)
  } else if (schema.additionalProperties && !schema.patternProperties) {
    code += addAdditionalProperties(schema, externalSchema, fullSchema)
  }

  return buildCodeWithAllOfs(schema, code, laterCode, name, externalSchema, fullSchema)
}

function addIfThenElse (schema, name, externalSchema, fullSchema) {
  var code = ''
  var r
  var laterCode = ''
  var innerR

  const copy = merge({}, schema)
  const i = copy.if
  const then = copy.then
  const e = copy.else
  delete copy.if
  delete copy.then
  delete copy.else
  var merged = merge(copy, then)

  code += `
    valid = ajv.validate(${util.inspect(i, { depth: null })}, obj)
    if (valid) {
  `
  if (merged.if && merged.then) {
    innerR = addIfThenElse(merged, name + 'Then', externalSchema, fullSchema)
    code += innerR.code
    laterCode = innerR.laterCode
  }

  r = buildInnerObject(merged, name + 'Then', externalSchema, fullSchema)
  code += r.code
  laterCode += r.laterCode

  code += `
    }
  `
  if (e) {
    merged = merge(copy, e)

    code += `
      else {
    `

    if (merged.if && merged.then) {
      innerR = addIfThenElse(merged, name + 'Else', externalSchema, fullSchema)
      code += innerR.code
      laterCode += innerR.laterCode
    }

    r = buildInnerObject(merged, name + 'Else', externalSchema, fullSchema)
    code += r.code
    laterCode += r.laterCode

    code += `
      }
    `
  }
  return { code: code, laterCode: laterCode }
}

function toJSON (variableName) {
  return `typeof ${variableName}.toJSON === 'function'
    ? ${variableName}.toJSON()
    : ${variableName}
  `
}

function buildObject (schema, code, name, externalSchema, fullSchema) {
  code += `
    function ${name} (input) {
  `
  if (schema.nullable) {
    code += `
      if(input === null) {
        return '${$asNull()}';
      }
  `
  }
  code += `
      var obj = ${toJSON('input')}
      var json = '{'
      var addComma = false
  `

  var laterCode = ''
  var r
  if (schema.if && schema.then) {
    code += `
      var valid
    `
    r = addIfThenElse(schema, name, externalSchema, fullSchema)
  } else {
    r = buildInnerObject(schema, name, externalSchema, fullSchema)
  }

  code += r.code
  laterCode = r.laterCode

  // Removes the comma if is the last element of the string (in case there are not properties)
  code += `
      json += '}'
      return json
    }
  `

  code += laterCode
  return code
}

function buildArray (schema, code, name, externalSchema, fullSchema) {
  code += `
    function ${name} (obj) {
  `
  if (schema.nullable) {
    code += `
      if(obj === null) {
        return '${$asNull()}';
      }
    `
  }
  code += `
      var json = '['
  `
  var laterCode = ''

  if (schema.items.$ref) {
    schema.items = refFinder(schema.items.$ref, fullSchema, externalSchema)
  }

  var result = { code: '', laterCode: '' }
  if (Array.isArray(schema.items)) {
    result = schema.items.reduce((res, item, i) => {
      var accessor = '[i]'
      const tmpRes = nested(laterCode, name, accessor, item, externalSchema, fullSchema, i)
      var condition = `i === ${i} && ${buildArrayTypeCondition(item.type, accessor)}`
      return {
        code: `${res.code}
        ${i > 0 ? 'else' : ''} if (${condition}) {
          ${tmpRes.code}
        }`,
        laterCode: `${res.laterCode}
        ${tmpRes.laterCode}`
      }
    }, result)
    result.code += `
    else {
      throw new Error(\`Item at $\{i} does not match schema definition.\`)
    }
    `
  } else {
    result = nested(laterCode, name, '[i]', schema.items, externalSchema, fullSchema)
  }

  code += `
    var l = obj.length
    var w = l - 1
    for (var i = 0; i < l; i++) {
      if (i > 0) {
        json += ','
      }
      ${result.code}
    }
  `

  laterCode = result.laterCode

  code += `
      json += ']'
      return json
    }
  `

  code += laterCode

  return code
}

function buildArrayTypeCondition (type, accessor) {
  var condition
  switch (type) {
    case 'null':
      condition = `obj${accessor} === null`
      break
    case 'string':
      condition = `typeof obj${accessor} === 'string'`
      break
    case 'integer':
      condition = `Number.isInteger(obj${accessor})`
      break
    case 'number':
      condition = `Number.isFinite(obj${accessor})`
      break
    case 'boolean':
      condition = `typeof obj${accessor} === 'boolean'`
      break
    case 'object':
      condition = `obj${accessor} && typeof obj${accessor} === 'object' && obj${accessor}.constructor === Object`
      break
    case 'array':
      condition = `Array.isArray(obj${accessor})`
      break
    default:
      if (Array.isArray(type)) {
        var conditions = type.map((subType) => {
          return buildArrayTypeCondition(subType, accessor)
        })
        condition = `(${conditions.join(' || ')})`
      } else {
        throw new Error(`${type} unsupported`)
      }
  }
  return condition
}

function nested (laterCode, name, key, schema, externalSchema, fullSchema, subKey) {
  var code = ''
  var funcName

  subKey = subKey || ''

  if (schema.type === undefined) {
    var inferedType = inferTypeByKeyword(schema)
    if (inferedType) {
      schema.type = inferedType
    }
  }

  var type = schema.type
  var nullable = schema.nullable === true

  var accessor = key.indexOf('[') === 0 ? sanitizeKey(key) : `['${sanitizeKey(key)}']`
  switch (type) {
    case 'null':
      code += `
        json += $asNull()
      `
      break
    case 'string':
      code += nullable ? `json += obj${accessor} === null ? null : $asString(obj${accessor})` : `json += $asString(obj${accessor})`
      break
    case 'integer':
      code += nullable ? `json += obj${accessor} === null ? null : $asInteger(obj${accessor})` : `json += $asInteger(obj${accessor})`
      break
    case 'number':
      code += nullable ? `json += obj${accessor} === null ? null : $asNumber(obj${accessor})` : `json += $asNumber(obj${accessor})`
      break
    case 'boolean':
      code += nullable ? `json += obj${accessor} === null ? null : $asBoolean(obj${accessor})` : `json += $asBoolean(obj${accessor})`
      break
    case 'object':
      funcName = (name + key + subKey).replace(/[-.\[\] ]/g, '') // eslint-disable-line
      laterCode = buildObject(schema, laterCode, funcName, externalSchema, fullSchema)
      code += `
        json += ${funcName}(obj${accessor})
      `
      break
    case 'array':
      funcName = '$arr' + (name + key + subKey).replace(/[-.\[\] ]/g, '') // eslint-disable-line
      laterCode = buildArray(schema, laterCode, funcName, externalSchema, fullSchema)
      code += `
        json += ${funcName}(obj${accessor})
      `
      break
    case undefined:
      if ('anyOf' in schema) {
        schema.anyOf.forEach((s, index) => {
          var nestedResult = nested(laterCode, name, key, s, externalSchema, fullSchema, subKey !== '' ? subKey : 'i' + index)
          code += `
            ${index === 0 ? 'if' : 'else if'}(ajv.validate(${require('util').inspect(s, { depth: null })}, obj${accessor}))
              ${nestedResult.code}
          `
          laterCode = nestedResult.laterCode
        })
        code += `
          else json+= null
        `
      } else if (isEmpty(schema)) {
        code += `
          json += JSON.stringify(obj${accessor})
        `
      } else {
        throw new Error(`${schema.type} unsupported`)
      }
      break
    default:
      if (Array.isArray(type)) {
        const nullIndex = type.indexOf('null')
        const sortedTypes = nullIndex !== -1 ? [type[nullIndex]].concat(type.slice(0, nullIndex)).concat(type.slice(nullIndex + 1)) : type
        sortedTypes.forEach((type, index) => {
          var tempSchema = Object.assign({}, schema, { type })
          var nestedResult = nested(laterCode, name, key, tempSchema, externalSchema, fullSchema, subKey)
          if (type === 'string') {
            code += `
              ${index === 0 ? 'if' : 'else if'}(typeof obj${accessor} === "${type}" || obj${accessor} instanceof Date || obj${accessor} instanceof RegExp)
                ${nestedResult.code}
            `
          } else if (type === 'null') {
            code += `
              ${index === 0 ? 'if' : 'else if'}(obj${accessor} == null)
              ${nestedResult.code}
            `
          } else if (type === 'array') {
            code += `
              ${index === 0 ? 'if' : 'else if'}(Array.isArray(obj${accessor}))
              ${nestedResult.code}
            `
          } else if (type === 'integer') {
            code += `
              ${index === 0 ? 'if' : 'else if'}(Number.isInteger(obj${accessor}) || obj${accessor} === null)
              ${nestedResult.code}
            `
          } else if (type === 'number') {
            code += `
              ${index === 0 ? 'if' : 'else if'}(isNaN(obj${accessor}) === false)
              ${nestedResult.code}
            `
          } else {
            code += `
              ${index === 0 ? 'if' : 'else if'}(typeof obj${accessor} === "${type}")
              ${nestedResult.code}
            `
          }
          laterCode = nestedResult.laterCode
        })
        code += `
          else json+= null
        `
      } else {
        throw new Error(`${type} unsupported`)
      }
  }

  return {
    code,
    laterCode
  }
}

function uglifyCode (code) {
  if (!uglify) {
    loadUglify()
  }

  var uglified = uglify.minify(code, { parse: { bare_returns: true } })

  if (uglified.error) {
    throw uglified.error
  }

  return uglified.code
}

function loadUglify () {
  try {
    uglify = require('uglify-es')
    var uglifyVersion = require('uglify-es/package.json').version

    if (uglifyVersion[0] !== '3') {
      throw new Error('Only version 3 of uglify-es is supported')
    }
  } catch (e) {
    uglify = null
    if (e.code === 'MODULE_NOT_FOUND') {
      throw new Error('In order to use uglify, you have to manually install `uglify-es`')
    }

    throw e
  }
}

function isEmpty (schema) {
  for (var key in schema) {
    if (schema.hasOwnProperty(key)) return false
  }
  return true
}

module.exports = build

},{"ajv":"node_modules/ajv/lib/ajv.js","deepmerge":"node_modules/deepmerge/dist/cjs.js","util":"node_modules/util/util.js","./schema-validator":"node_modules/fast-json-stringify/schema-validator.js"}],"node_modules/fastify/lib/hooks.js":[function(require,module,exports) {
'use strict';

var supportedHooks = ['onRequest', 'preParsing', 'preValidation', 'preSerialization', 'preHandler', 'onResponse', 'onSend', 'onError', // executed at start/close time
'onRoute', 'onRegister', 'onClose'];

var {
  codes: {
    FST_ERR_HOOK_INVALID_TYPE: FST_ERR_HOOK_INVALID_TYPE,
    FST_ERR_HOOK_INVALID_HANDLER: FST_ERR_HOOK_INVALID_HANDLER
  }
} = require('./errors');

function Hooks() {
  this.onRequest = [];
  this.preParsing = [];
  this.preValidation = [];
  this.preSerialization = [];
  this.preHandler = [];
  this.onResponse = [];
  this.onSend = [];
  this.onError = [];
}

Hooks.prototype.validate = function (hook, fn) {
  if (typeof hook !== 'string') throw new FST_ERR_HOOK_INVALID_TYPE();
  if (typeof fn !== 'function') throw new FST_ERR_HOOK_INVALID_HANDLER();

  if (supportedHooks.indexOf(hook) === -1) {
    throw new Error("".concat(hook, " hook not supported!"));
  }
};

Hooks.prototype.add = function (hook, fn) {
  this.validate(hook, fn);
  this[hook].push(fn);
};

function buildHooks(h) {
  var hooks = new Hooks();
  hooks.onRequest = h.onRequest.slice();
  hooks.preParsing = h.preParsing.slice();
  hooks.preValidation = h.preValidation.slice();
  hooks.preSerialization = h.preSerialization.slice();
  hooks.preHandler = h.preHandler.slice();
  hooks.onSend = h.onSend.slice();
  hooks.onResponse = h.onResponse.slice();
  hooks.onError = h.onError.slice();
  return hooks;
}

function hookRunner(functions, runner, request, reply, cb) {
  var i = 0;

  function next(err) {
    if (err || i === functions.length) {
      cb(err, request, reply);
      return;
    }

    var result = runner(functions[i++], request, reply, next);

    if (result && typeof result.then === 'function') {
      result.then(handleResolve, handleReject);
    }
  }

  function handleResolve() {
    next();
  }

  function handleReject(err) {
    cb(err, request, reply);
  }

  next();
}

function onSendHookRunner(functions, request, reply, payload, cb) {
  var i = 0;

  function next(err, newPayload) {
    if (err) {
      cb(err, request, reply, payload);
      return;
    }

    if (newPayload !== undefined) {
      payload = newPayload;
    }

    if (i === functions.length) {
      cb(null, request, reply, payload);
      return;
    }

    var result = functions[i++](request, reply, payload, next);

    if (result && typeof result.then === 'function') {
      result.then(handleResolve, handleReject);
    }
  }

  function handleResolve(newPayload) {
    next(null, newPayload);
  }

  function handleReject(err) {
    cb(err, request, reply, payload);
  }

  next();
}

function hookIterator(fn, request, reply, next) {
  if (reply.sent === true) return undefined;
  return fn(request, reply, next);
}

module.exports = {
  Hooks: Hooks,
  buildHooks: buildHooks,
  hookRunner: hookRunner,
  onSendHookRunner: onSendHookRunner,
  hookIterator: hookIterator
};
},{"./errors":"node_modules/fastify/lib/errors.js"}],"node_modules/fastify/lib/validation.js":[function(require,module,exports) {
'use strict';

var fastJsonStringify = require('fast-json-stringify');

var Ajv = require('ajv');

var bodySchema = Symbol('body-schema');
var querystringSchema = Symbol('querystring-schema');
var paramsSchema = Symbol('params-schema');
var responseSchema = Symbol('response-schema');
var headersSchema = Symbol('headers-schema');
var kFluentSchema = Symbol.for('fluent-schema-object');

function getValidatorForStatusCodeSchema(statusCodeDefinition, externalSchema) {
  return fastJsonStringify(statusCodeDefinition, {
    schema: externalSchema
  });
}

function getResponseSchema(responseSchemaDefinition, sharedSchemas) {
  var statusCodes = Object.keys(responseSchemaDefinition);
  return statusCodes.reduce(function (r, statusCode) {
    r[statusCode] = getValidatorForStatusCodeSchema(responseSchemaDefinition[statusCode], sharedSchemas);
    return r;
  }, {});
}

function build(context, compile, schemas, schemaResolver) {
  if (!context.schema) {
    return;
  }

  generateFluentSchema(context.schema);
  context.schema = schemas.resolveRefs(context.schema, false, schemaResolver);
  var headers = context.schema.headers;

  if (headers && Object.getPrototypeOf(headers) !== Object.prototype) {
    // do not mess with non-literals, e.g. Joi schemas
    context[headersSchema] = compile(headers);
  } else if (headers) {
    // The header keys are case insensitive
    //  https://tools.ietf.org/html/rfc2616#section-4.2
    var headersSchemaLowerCase = {};
    Object.keys(headers).forEach(function (k) {
      headersSchemaLowerCase[k] = headers[k];
    });

    if (headersSchemaLowerCase.required instanceof Array) {
      headersSchemaLowerCase.required = headersSchemaLowerCase.required.map(function (h) {
        return h.toLowerCase();
      });
    }

    if (headers.properties) {
      headersSchemaLowerCase.properties = {};
      Object.keys(headers.properties).forEach(function (k) {
        headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
      });
    }

    context[headersSchema] = compile(headersSchemaLowerCase);
  }

  if (context.schema.response) {
    context[responseSchema] = getResponseSchema(context.schema.response, schemas.getSchemas());
  }

  if (context.schema.body) {
    context[bodySchema] = compile(context.schema.body);
  }

  if (context.schema.querystring) {
    context[querystringSchema] = compile(context.schema.querystring);
  }

  if (context.schema.params) {
    context[paramsSchema] = compile(context.schema.params);
  }
}

function generateFluentSchema(schema) {
  ;
  ['params', 'body', 'querystring', 'query', 'headers'].forEach(function (key) {
    if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
      schema[key] = schema[key].valueOf();
    }
  });

  if (schema.response) {
    Object.keys(schema.response).forEach(function (code) {
      if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
        schema.response[code] = schema.response[code].valueOf();
      }
    });
  }
}

function validateParam(validatorFunction, request, paramName) {
  var ret = validatorFunction && validatorFunction(request[paramName]);
  if (ret === false) return validatorFunction.errors;
  if (ret && ret.error) return ret.error;
  if (ret && ret.value) request[paramName] = ret.value;
  return false;
}

function validate(context, request) {
  var params = validateParam(context[paramsSchema], request, 'params');

  if (params) {
    return wrapValidationError(params, 'params');
  }

  var body = validateParam(context[bodySchema], request, 'body');

  if (body) {
    return wrapValidationError(body, 'body');
  }

  var query = validateParam(context[querystringSchema], request, 'query');

  if (query) {
    return wrapValidationError(query, 'querystring');
  }

  var headers = validateParam(context[headersSchema], request, 'headers');

  if (headers) {
    return wrapValidationError(headers, 'headers');
  }

  return null;
}

function wrapValidationError(result, dataVar) {
  if (result instanceof Error) {
    return result;
  }

  var error = new Error(schemaErrorsText(result, dataVar));
  error.validation = result;
  return error;
}

function serialize(context, data, statusCode) {
  var responseSchemaDef = context[responseSchema];

  if (!responseSchemaDef) {
    return JSON.stringify(data);
  }

  if (responseSchemaDef[statusCode]) {
    return responseSchemaDef[statusCode](data);
  }

  var fallbackStatusCode = (statusCode + '')[0] + 'xx';

  if (responseSchemaDef[fallbackStatusCode]) {
    return responseSchemaDef[fallbackStatusCode](data);
  }

  return JSON.stringify(data);
}

function isValidLogger(logger) {
  if (!logger) {
    return false;
  }

  var result = true;
  var methods = ['info', 'error', 'debug', 'fatal', 'warn', 'trace', 'child'];

  for (var i = 0; i < methods.length; i += 1) {
    if (!logger[methods[i]] || typeof logger[methods[i]] !== 'function') {
      result = false;
      break;
    }
  }

  return result;
}

function schemaErrorsText(errors, dataVar) {
  var text = '';
  var separator = ', ';

  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    text += dataVar + (e.dataPath || '') + ' ' + e.message + separator;
  }

  return text.slice(0, -separator.length);
}

function buildSchemaCompiler(externalSchemas, cache) {
  // This instance of Ajv is private
  // it should not be customized or used
  var ajv = new Ajv({
    coerceTypes: true,
    useDefaults: true,
    removeAdditional: true,
    allErrors: true,
    nullable: true,
    cache: cache
  });

  if (Array.isArray(externalSchemas)) {
    externalSchemas.forEach(function (s) {
      return ajv.addSchema(s);
    });
  }

  return ajv.compile.bind(ajv);
}

module.exports = {
  build: build,
  validate: validate,
  serialize: serialize,
  isValidLogger: isValidLogger,
  buildSchemaCompiler: buildSchemaCompiler
};
module.exports.symbols = {
  bodySchema: bodySchema,
  querystringSchema: querystringSchema,
  responseSchema: responseSchema,
  paramsSchema: paramsSchema,
  headersSchema: headersSchema
};
},{"fast-json-stringify":"node_modules/fast-json-stringify/index.js","ajv":"node_modules/ajv/lib/ajv.js"}],"node_modules/abstract-logging/index.js":[function(require,module,exports) {
'use strict'

function noop () {}

module.exports = {
  fatal: noop,
  error: noop,
  warn: noop,
  info: noop,
  debug: noop,
  trace: noop
}

},{}],"node_modules/quick-format-unescaped/index.js":[function(require,module,exports) {
'use strict'
function tryStringify (o) {
  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
}

module.exports = format 

function format(f, args, opts) {
  var ss = (opts && opts.stringify) || tryStringify
  var offset = 1
  if (f === null) {
    f = args[0]
    offset = 0
  }
  if (typeof f === 'object' && f !== null) {
    var len = args.length + offset
    if (len === 1) return f
    var objects = new Array(len)
    objects[0] = ss(f)
    for (var index = 1; index < len; index++) {
      objects[index] = ss(args[index])
    }
    return objects.join(' ')
  }
  var argLen = args.length
  if (argLen === 0) return f
  var x = ''
  var str = ''
  var a = 1 - offset
  var lastPos = 0
  var flen = (f && f.length) || 0
  for (var i = 0; i < flen;) {
    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
      switch (f.charCodeAt(i + 1)) {
        case 100: // 'd'
          if (a >= argLen)
            break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          if (args[a] == null)  break
          str += Number(args[a])
          lastPos = i = i + 2
          break
        case 79: // 'O'
        case 111: // 'o'
        case 106: // 'j'
          if (a >= argLen)
            break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          if (args[a] === undefined) break
          var type = typeof args[a]
          if (type === 'string') {
            str += '\'' + args[a] + '\''
            lastPos = i + 2
            i++
            break
          }
          if (type === 'function') {
            str += args[a].name || '<anonymous>'
            lastPos = i + 2
            i++
            break
          }
          str += ss(args[a])
          lastPos = i + 2
          i++
          break
        case 115: // 's'
          if (a >= argLen)
            break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += String(args[a])
          lastPos = i + 2
          i++
          break
        case 37: // '%'
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += '%'
          lastPos = i + 2
          i++
          break
      }
      ++a
    }
    ++i
  }
  if (lastPos === 0)
    str = f
  else if (lastPos < flen) {
    str += f.slice(lastPos)
  }
  while (a < argLen) {
    x = args[a++]
    if (x === null || (typeof x !== 'object')) {
      str += ' ' + String(x)
    } else {
      str += ' ' + ss(x)
    }
  }

  return str
}

},{}],"node_modules/pino/browser.js":[function(require,module,exports) {
'use strict'

var format = require('quick-format-unescaped')

module.exports = pino

var _console = pfGlobalThisOrFallback().console || {}
var stdSerializers = {
  mapHttpRequest: mock,
  mapHttpResponse: mock,
  wrapRequestSerializer: passthrough,
  wrapResponseSerializer: passthrough,
  wrapErrorSerializer: passthrough,
  req: mock,
  res: mock,
  err: asErrValue
}

function pino (opts) {
  opts = opts || {}
  opts.browser = opts.browser || {}

  var transmit = opts.browser.transmit
  if (transmit && typeof transmit.send !== 'function') { throw Error('pino: transmit option must have a send function') }

  var proto = opts.browser.write || _console
  if (opts.browser.write) opts.browser.asObject = true
  var serializers = opts.serializers || {}
  var serialize = Array.isArray(opts.browser.serialize)
    ? opts.browser.serialize.filter(function (k) {
      return k !== '!stdSerializers.err'
    })
    : opts.browser.serialize === true ? Object.keys(serializers) : false
  var stdErrSerialize = opts.browser.serialize

  if (
    Array.isArray(opts.browser.serialize) &&
    opts.browser.serialize.indexOf('!stdSerializers.err') > -1
  ) stdErrSerialize = false

  var levels = ['error', 'fatal', 'warn', 'info', 'debug', 'trace']

  if (typeof proto === 'function') {
    proto.error = proto.fatal = proto.warn =
    proto.info = proto.debug = proto.trace = proto
  }
  if (opts.enabled === false) opts.level = 'silent'
  var level = opts.level || 'info'
  var logger = Object.create(proto)
  if (!logger.log) logger.log = noop

  Object.defineProperty(logger, 'levelVal', {
    get: getLevelVal
  })
  Object.defineProperty(logger, 'level', {
    get: getLevel,
    set: setLevel
  })

  var setOpts = {
    transmit: transmit,
    serialize: serialize,
    asObject: opts.browser.asObject,
    levels: levels
  }
  logger.levels = pino.levels
  logger.level = level

  logger.setMaxListeners = logger.getMaxListeners =
  logger.emit = logger.addListener = logger.on =
  logger.prependListener = logger.once =
  logger.prependOnceListener = logger.removeListener =
  logger.removeAllListeners = logger.listeners =
  logger.listenerCount = logger.eventNames =
  logger.write = logger.flush = noop
  logger.serializers = serializers
  logger._serialize = serialize
  logger._stdErrSerialize = stdErrSerialize
  logger.child = child

  if (transmit) logger._logEvent = createLogEventShape()

  function getLevelVal () {
    return this.level === 'silent'
      ? Infinity
      : this.levels.values[this.level]
  }

  function getLevel () {
    return this._level
  }
  function setLevel (level) {
    if (level !== 'silent' && !this.levels.values[level]) {
      throw Error('unknown level ' + level)
    }
    this._level = level

    set(setOpts, logger, 'error', 'log') // <-- must stay first
    set(setOpts, logger, 'fatal', 'error')
    set(setOpts, logger, 'warn', 'error')
    set(setOpts, logger, 'info', 'log')
    set(setOpts, logger, 'debug', 'log')
    set(setOpts, logger, 'trace', 'log')
  }

  function child (bindings) {
    if (!bindings) {
      throw new Error('missing bindings for child Pino')
    }
    var bindingsSerializers = bindings.serializers
    if (serialize && bindingsSerializers) {
      var childSerializers = Object.assign({}, serializers, bindingsSerializers)
      var childSerialize = opts.browser.serialize === true
        ? Object.keys(childSerializers)
        : serialize
      delete bindings.serializers
      applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize)
    }
    function Child (parent) {
      this._childLevel = (parent._childLevel | 0) + 1
      this.error = bind(parent, bindings, 'error')
      this.fatal = bind(parent, bindings, 'fatal')
      this.warn = bind(parent, bindings, 'warn')
      this.info = bind(parent, bindings, 'info')
      this.debug = bind(parent, bindings, 'debug')
      this.trace = bind(parent, bindings, 'trace')
      if (childSerializers) {
        this.serializers = childSerializers
        this._serialize = childSerialize
      }
      if (transmit) {
        this._logEvent = createLogEventShape(
          [].concat(parent._logEvent.bindings, bindings)
        )
      }
    }
    Child.prototype = this
    return new Child(this)
  }
  return logger
}

pino.LOG_VERSION = 1

pino.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: 'trace',
    20: 'debug',
    30: 'info',
    40: 'warn',
    50: 'error',
    60: 'fatal'
  }
}

pino.stdSerializers = stdSerializers

function set (opts, logger, level, fallback) {
  var proto = Object.getPrototypeOf(logger)
  logger[level] = logger.levelVal > logger.levels.values[level] ? noop
    : (proto[level] ? proto[level] : (_console[level] || _console[fallback] || noop))

  wrap(opts, logger, level)
}

function wrap (opts, logger, level) {
  if (!opts.transmit && logger[level] === noop) return

  logger[level] = (function (write) {
    return function LOG () {
      var ts = Date.now()
      var args = new Array(arguments.length)
      var proto = (Object.getPrototypeOf && Object.getPrototypeOf(this) === _console) ? _console : this
      for (var i = 0; i < args.length; i++) args[i] = arguments[i]

      if (opts.serialize && !opts.asObject) {
        applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize)
      }
      if (opts.asObject) write.call(proto, asObject(this, level, args, ts))
      else write.apply(proto, args)

      if (opts.transmit) {
        var transmitLevel = opts.transmit.level || logger.level
        var transmitValue = pino.levels.values[transmitLevel]
        var methodValue = pino.levels.values[level]
        if (methodValue < transmitValue) return
        transmit(this, {
          ts: ts,
          methodLevel: level,
          methodValue: methodValue,
          transmitLevel: transmitLevel,
          transmitValue: pino.levels.values[opts.transmit.level || logger.level],
          send: opts.transmit.send,
          val: logger.levelVal
        }, args)
      }
    }
  })(logger[level])
}

function asObject (logger, level, args, ts) {
  if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize)
  var argsCloned = args.slice()
  var msg = argsCloned[0]
  var o = { time: ts, level: pino.levels.values[level] }
  var lvl = (logger._childLevel | 0) + 1
  if (lvl < 1) lvl = 1
  // deliberate, catching objects, arrays
  if (msg !== null && typeof msg === 'object') {
    while (lvl-- && typeof argsCloned[0] === 'object') {
      Object.assign(o, argsCloned.shift())
    }
    msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : undefined
  } else if (typeof msg === 'string') msg = format(argsCloned.shift(), argsCloned)
  if (msg !== undefined) o.msg = msg
  return o
}

function applySerializers (args, serialize, serializers, stdErrSerialize) {
  for (var i in args) {
    if (stdErrSerialize && args[i] instanceof Error) {
      args[i] = pino.stdSerializers.err(args[i])
    } else if (typeof args[i] === 'object' && !Array.isArray(args[i])) {
      for (var k in args[i]) {
        if (serialize && serialize.indexOf(k) > -1 && k in serializers) {
          args[i][k] = serializers[k](args[i][k])
        }
      }
    }
  }
}

function bind (parent, bindings, level) {
  return function () {
    var args = new Array(1 + arguments.length)
    args[0] = bindings
    for (var i = 1; i < args.length; i++) {
      args[i] = arguments[i - 1]
    }
    return parent[level].apply(this, args)
  }
}

function transmit (logger, opts, args) {
  var send = opts.send
  var ts = opts.ts
  var methodLevel = opts.methodLevel
  var methodValue = opts.methodValue
  var val = opts.val
  var bindings = logger._logEvent.bindings

  applySerializers(
    args,
    logger._serialize || Object.keys(logger.serializers),
    logger.serializers,
    logger._stdErrSerialize === undefined ? true : logger._stdErrSerialize
  )
  logger._logEvent.ts = ts
  logger._logEvent.messages = args.filter(function (arg) {
    // bindings can only be objects, so reference equality check via indexOf is fine
    return bindings.indexOf(arg) === -1
  })

  logger._logEvent.level.label = methodLevel
  logger._logEvent.level.value = methodValue

  send(methodLevel, logger._logEvent, val)

  logger._logEvent = createLogEventShape(bindings)
}

function createLogEventShape (bindings) {
  return {
    ts: 0,
    messages: [],
    bindings: bindings || [],
    level: { label: '', value: 0 }
  }
}

function asErrValue (err) {
  var obj = {
    type: err.constructor.name,
    msg: err.message,
    stack: err.stack
  }
  for (var key in err) {
    if (obj[key] === undefined) {
      obj[key] = err[key]
    }
  }
  return obj
}

function mock () { return {} }
function passthrough (a) { return a }
function noop () {}

/* eslint-disable */
/* istanbul ignore next */
function pfGlobalThisOrFallback () {
  function defd (o) { return typeof o !== 'undefined' && o }
  try { 
    if (typeof globalThis !== 'undefined') return globalThis
    Object.defineProperty(Object.prototype, 'globalThis', {
      get: function () {
        delete Object.prototype.globalThis
        return (this.globalThis = this)
      },
      configurable: true
    })
    return globalThis
  } catch (e) { 
    return defd(self) || defd(window) || defd(this) || {}
  }
}
/* eslint-enable */

},{"quick-format-unescaped":"node_modules/quick-format-unescaped/index.js"}],"node_modules/fastify/lib/logger.js":[function(require,module,exports) {
var process = require("process");
'use strict';
/**
 * Code imported from `pino-http`
 * Repo: https://github.com/pinojs/pino-http
 * License: MIT (https://raw.githubusercontent.com/pinojs/pino-http/master/LICENSE)
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var abstractLogging = require('abstract-logging');

var pino = require('pino');

var {
  serializersSym: serializersSym
} = pino.symbols;

var {
  isValidLogger: isValidLogger
} = require('./validation');

var {
  codes: {
    FST_ERR_LOG_INVALID_DESTINATION: FST_ERR_LOG_INVALID_DESTINATION
  }
} = require('./errors');

function createPinoLogger(opts, stream) {
  stream = stream || opts.stream;
  delete opts.stream;

  if (stream && opts.file) {
    throw new FST_ERR_LOG_INVALID_DESTINATION();
  } else if (opts.file) {
    // we do not have stream
    stream = pino.destination(opts.file);
    delete opts.file;
  }

  var prevLogger = opts.logger;
  var prevGenReqId = opts.genReqId;
  var logger = null;

  if (prevLogger) {
    opts.logger = undefined;
    opts.genReqId = undefined; // we need to tap into pino internals because in v5 it supports
    // adding serializers in child loggers

    if (prevLogger[serializersSym]) {
      opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
    }

    logger = prevLogger.child(opts);
    opts.logger = prevLogger;
    opts.genReqId = prevGenReqId;
  } else {
    logger = pino(opts, stream);
  }

  return logger;
}

var serializers = {
  req: function asReqValue(req) {
    return {
      method: req.method,
      url: req.url,
      version: req.headers['accept-version'],
      hostname: req.hostname,
      remoteAddress: req.ip,
      remotePort: req.connection.remotePort
    };
  },
  err: pino.stdSerializers.err,
  res: function asResValue(res) {
    return {
      statusCode: res.statusCode
    };
  }
};

function now() {
  var ts = process.hrtime();
  return ts[0] * 1e3 + ts[1] / 1e6;
}

function createLogger(options) {
  if (isValidLogger(options.logger)) {
    var logger = createPinoLogger({
      logger: options.logger,
      serializers: Object.assign({}, serializers, options.logger.serializers)
    });
    return {
      logger: logger,
      hasLogger: true
    };
  } else if (!options.logger) {
    var _logger = Object.create(abstractLogging);

    _logger.child = function () {
      return _logger;
    };

    return {
      logger: _logger,
      hasLogger: false
    };
  } else {
    options.logger = _typeof(options.logger) === 'object' ? options.logger : {};
    options.logger.level = options.logger.level || 'info';
    options.logger.serializers = Object.assign({}, serializers, options.logger.serializers);

    var _logger2 = createPinoLogger(options.logger);

    return {
      logger: _logger2,
      hasLogger: true
    };
  }
}

module.exports = {
  createLogger: createLogger,
  serializers: serializers,
  now: now
};
},{"abstract-logging":"node_modules/abstract-logging/index.js","pino":"node_modules/pino/browser.js","./validation":"node_modules/fastify/lib/validation.js","./errors":"node_modules/fastify/lib/errors.js","process":"node_modules/process/browser.js"}],"node_modules/fastify/lib/wrapThenable.js":[function(require,module,exports) {
'use strict';

var {
  kReplyIsError: kReplyIsError,
  kReplySent: kReplySent,
  kReplySentOverwritten: kReplySentOverwritten
} = require('./symbols');

var {
  codes: {
    FST_ERR_PROMISE_NOT_FULLFILLED: FST_ERR_PROMISE_NOT_FULLFILLED
  }
} = require('./errors');

function wrapThenable(thenable, reply) {
  thenable.then(function (payload) {
    if (reply[kReplySentOverwritten] === true) {
      return;
    } // this is for async functions that
    // are using reply.send directly


    if (payload !== undefined || reply.res.statusCode === 204 && reply[kReplySent] === false) {
      // we use a try-catch internally to avoid adding a catch to another
      // promise, increase promise perf by 10%
      try {
        reply.send(payload);
      } catch (err) {
        reply[kReplySent] = false;
        reply[kReplyIsError] = true;
        reply.send(err);
      }
    } else if (reply[kReplySent] === false) {
      reply.log.error({
        err: new FST_ERR_PROMISE_NOT_FULLFILLED()
      }, "Promise may not be fulfilled with 'undefined' when statusCode is not 204");
    }
  }, function (err) {
    if (reply[kReplySentOverwritten] === true) {
      reply.log.error({
        err: err
      }, 'Promise errored, but reply.sent = true was set');
      return;
    }

    reply[kReplySent] = false;
    reply[kReplyIsError] = true;
    reply.send(err);
  });
}

module.exports = wrapThenable;
},{"./symbols":"node_modules/fastify/lib/symbols.js","./errors":"node_modules/fastify/lib/errors.js"}],"node_modules/fastify/lib/reply.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var process = require("process");
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var eos = require('readable-stream').finished;

var statusCodes = require('http').STATUS_CODES;

var flatstr = require('flatstr');

var FJS = require('fast-json-stringify');

var {
  kFourOhFourContext: kFourOhFourContext,
  kReplyErrorHandlerCalled: kReplyErrorHandlerCalled,
  kReplySent: kReplySent,
  kReplySentOverwritten: kReplySentOverwritten,
  kReplyStartTime: kReplyStartTime,
  kReplySerializer: kReplySerializer,
  kReplySerializerDefault: kReplySerializerDefault,
  kReplyIsError: kReplyIsError,
  kReplyHeaders: kReplyHeaders,
  kReplyHasStatusCode: kReplyHasStatusCode,
  kReplyIsRunningOnErrorHook: kReplyIsRunningOnErrorHook,
  kDisableRequestLogging: kDisableRequestLogging
} = require('./symbols.js');

var {
  hookRunner: hookRunner,
  onSendHookRunner: onSendHookRunner
} = require('./hooks');

var validation = require('./validation');

var serialize = validation.serialize;

var loggerUtils = require('./logger');

var now = loggerUtils.now;

var wrapThenable = require('./wrapThenable');

var serializeError = FJS({
  type: 'object',
  properties: {
    statusCode: {
      type: 'number'
    },
    code: {
      type: 'string'
    },
    error: {
      type: 'string'
    },
    message: {
      type: 'string'
    }
  }
});
var CONTENT_TYPE = {
  JSON: 'application/json; charset=utf-8',
  PLAIN: 'text/plain; charset=utf-8',
  OCTET: 'application/octet-stream'
};

var {
  codes: {
    FST_ERR_REP_INVALID_PAYLOAD_TYPE: FST_ERR_REP_INVALID_PAYLOAD_TYPE,
    FST_ERR_REP_ALREADY_SENT: FST_ERR_REP_ALREADY_SENT,
    FST_ERR_REP_SENT_VALUE: FST_ERR_REP_SENT_VALUE,
    FST_ERR_SEND_INSIDE_ONERR: FST_ERR_SEND_INSIDE_ONERR
  }
} = require('./errors');

var getHeader;

function Reply(res, context, request, log) {
  this.res = res;
  this.context = context;
  this[kReplySent] = false;
  this[kReplySerializer] = null;
  this[kReplyErrorHandlerCalled] = false;
  this[kReplyIsError] = false;
  this[kReplyIsRunningOnErrorHook] = false;
  this.request = request;
  this[kReplyHeaders] = {};
  this[kReplyHasStatusCode] = false;
  this[kReplyStartTime] = undefined;
  this.log = log;
}

Object.defineProperty(Reply.prototype, 'sent', {
  enumerable: true,
  get: function () {
    return this[kReplySent];
  },
  set: function (value) {
    if (value !== true) {
      throw new FST_ERR_REP_SENT_VALUE();
    }

    if (this[kReplySent]) {
      throw new FST_ERR_REP_ALREADY_SENT();
    }

    this[kReplySentOverwritten] = true;
    this[kReplySent] = true;
  }
});
Object.defineProperty(Reply.prototype, 'statusCode', {
  get: function () {
    return this.res.statusCode;
  },
  set: function (value) {
    this.code(value);
  }
});

Reply.prototype.send = function (payload) {
  if (this[kReplyIsRunningOnErrorHook] === true) {
    throw new FST_ERR_SEND_INSIDE_ONERR();
  }

  if (this[kReplySent]) {
    this.log.warn({
      err: new FST_ERR_REP_ALREADY_SENT()
    }, 'Reply already sent');
    return this;
  }

  if (payload instanceof Error || this[kReplyIsError] === true) {
    onErrorHook(this, payload, onSendHook);
    return this;
  }

  if (payload === undefined) {
    onSendHook(this, payload);
    return this;
  }

  var contentType = getHeader(this, 'content-type');
  var hasContentType = contentType !== undefined;

  if (payload !== null) {
    if (Buffer.isBuffer(payload) || typeof payload.pipe === 'function') {
      if (hasContentType === false) {
        this[kReplyHeaders]['content-type'] = CONTENT_TYPE.OCTET;
      }

      onSendHook(this, payload);
      return this;
    }

    if (hasContentType === false && typeof payload === 'string') {
      this[kReplyHeaders]['content-type'] = CONTENT_TYPE.PLAIN;
      onSendHook(this, payload);
      return this;
    }
  }

  if (this[kReplySerializer] !== null) {
    payload = this[kReplySerializer](payload);
  } else if (hasContentType === false || contentType.indexOf('application/json') > -1) {
    if (hasContentType === false || contentType.indexOf('charset') === -1) {
      this[kReplyHeaders]['content-type'] = CONTENT_TYPE.JSON;
    }

    preserializeHook(this, payload);
    return this;
  }

  onSendHook(this, payload);
  return this;
};

Reply.prototype.getHeader = function (key) {
  return getHeader(this, key);
};

Reply.prototype.hasHeader = function (key) {
  return this[kReplyHeaders][key.toLowerCase()] !== undefined;
};

Reply.prototype.removeHeader = function (key) {
  // Node.js does not like headers with keys set to undefined,
  // so we have to delete the key.
  delete this[kReplyHeaders][key.toLowerCase()];
  return this;
};

Reply.prototype.header = function (key, value) {
  var _key = key.toLowerCase(); // default the value to ''


  value = value === undefined ? '' : value;

  if (this[kReplyHeaders][_key] && _key === 'set-cookie') {
    // https://tools.ietf.org/html/rfc7230#section-3.2.2
    if (typeof this[kReplyHeaders][_key] === 'string') {
      this[kReplyHeaders][_key] = [this[kReplyHeaders][_key]];
    }

    if (Array.isArray(value)) {
      Array.prototype.push.apply(this[kReplyHeaders][_key], value);
    } else {
      this[kReplyHeaders][_key].push(value);
    }
  } else {
    this[kReplyHeaders][_key] = value;
  }

  return this;
};

Reply.prototype.headers = function (headers) {
  var keys = Object.keys(headers);

  for (var i = 0; i < keys.length; i++) {
    this.header(keys[i], headers[keys[i]]);
  }

  return this;
};

Reply.prototype.code = function (code) {
  this.res.statusCode = code;
  this[kReplyHasStatusCode] = true;
  return this;
};

Reply.prototype.status = Reply.prototype.code;

Reply.prototype.serialize = function (payload) {
  if (this[kReplySerializer] !== null) {
    return this[kReplySerializer](payload);
  } else {
    if (this.context && this.context[kReplySerializerDefault]) {
      return this.context[kReplySerializerDefault](payload, this.res.statusCode);
    } else {
      return serialize(this.context, payload, this.res.statusCode);
    }
  }
};

Reply.prototype.serializer = function (fn) {
  this[kReplySerializer] = fn;
  return this;
};

Reply.prototype.type = function (type) {
  this[kReplyHeaders]['content-type'] = type;
  return this;
};

Reply.prototype.redirect = function (code, url) {
  if (typeof code === 'string') {
    url = code;
    code = this[kReplyHasStatusCode] ? this.res.statusCode : 302;
  }

  this.header('location', url).code(code).send();
};

Reply.prototype.callNotFound = function () {
  notFound(this);
};

Reply.prototype.getResponseTime = function () {
  var responseTime = 0;

  if (this[kReplyStartTime] !== undefined) {
    responseTime = now() - this[kReplyStartTime];
  }

  return responseTime;
}; // Make reply a thenable, so it could be used with async/await.
// See
// - https://github.com/fastify/fastify/issues/1864 for the discussions
// - https://promisesaplus.com/ for the definition of thenable
// - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then for the signature


Reply.prototype.then = function (fullfilled, rejected) {
  if (this.sent) {
    fullfilled();
    return;
  }

  eos(this.res, function (err) {
    // We must not treat ERR_STREAM_PREMATURE_CLOSE as
    // an error because it is created by eos, not by the stream.
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      if (rejected) {
        rejected(err);
      }
    } else {
      fullfilled();
    }
  });
};

function preserializeHook(reply, payload) {
  if (reply.context.preSerialization !== null) {
    onSendHookRunner(reply.context.preSerialization, reply.request, reply, payload, preserializeHookEnd);
  } else {
    preserializeHookEnd(null, reply.request, reply, payload);
  }
}

function preserializeHookEnd(err, request, reply, payload) {
  if (err != null) {
    onErrorHook(reply, err);
    return;
  }

  if (reply.context && reply.context[kReplySerializerDefault]) {
    payload = reply.context[kReplySerializerDefault](payload, reply.res.statusCode);
  } else {
    payload = serialize(reply.context, payload, reply.res.statusCode);
  }

  flatstr(payload);
  onSendHook(reply, payload);
}

function onSendHook(reply, payload) {
  reply[kReplySent] = true;

  if (reply.context.onSend !== null) {
    onSendHookRunner(reply.context.onSend, reply.request, reply, payload, wrapOnSendEnd);
  } else {
    onSendEnd(reply, payload);
  }
}

function wrapOnSendEnd(err, request, reply, payload) {
  if (err != null) {
    onErrorHook(reply, err);
  } else {
    onSendEnd(reply, payload);
  }
}

function onSendEnd(reply, payload) {
  var res = reply.res;
  var statusCode = res.statusCode;

  if (payload === undefined || payload === null) {
    reply[kReplySent] = true; // according to https://tools.ietf.org/html/rfc7230#section-3.3.2
    // we cannot send a content-length for 304 and 204, and all status code
    // < 200.

    if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304) {
      reply[kReplyHeaders]['content-length'] = '0';
    }

    res.writeHead(statusCode, reply[kReplyHeaders]); // avoid ArgumentsAdaptorTrampoline from V8

    res.end(null, null, null);
    return;
  }

  if (typeof payload.pipe === 'function') {
    sendStream(payload, res, reply);
    return;
  }

  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {
    throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(_typeof(payload));
  }

  if (!reply[kReplyHeaders]['content-length']) {
    reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload);
  }

  reply[kReplySent] = true;
  res.writeHead(statusCode, reply[kReplyHeaders]); // avoid ArgumentsAdaptorTrampoline from V8

  res.end(payload, null, null);
}

function sendStream(payload, res, reply) {
  var sourceOpen = true;
  eos(payload, {
    readable: true,
    writable: false
  }, function (err) {
    sourceOpen = false;

    if (err != null) {
      if (res.headersSent) {
        reply.log.warn({
          err: err
        }, 'response terminated with an error with headers already sent');
        res.destroy();
      } else {
        onErrorHook(reply, err);
      }
    } // there is nothing to do if there is not an error

  });
  eos(res, function (err) {
    if (err != null) {
      if (res.headersSent) {
        reply.log.warn({
          err: err
        }, 'response terminated with an error with headers already sent');
      }

      if (sourceOpen) {
        if (payload.destroy) {
          payload.destroy();
        } else if (typeof payload.close === 'function') {
          payload.close(noop);
        } else if (typeof payload.abort === 'function') {
          payload.abort();
        }
      }
    }
  }); // streams will error asynchronously, and we want to handle that error
  // appropriately, e.g. a 404 for a missing file. So we cannot use
  // writeHead, and we need to resort to setHeader, which will trigger
  // a writeHead when there is data to send.

  if (!res.headersSent) {
    for (var key in reply[kReplyHeaders]) {
      res.setHeader(key, reply[kReplyHeaders][key]);
    }
  } else {
    reply.log.warn('response will send, but you shouldn\'t use res.writeHead in stream mode');
  }

  payload.pipe(res);
}

function onErrorHook(reply, error, cb) {
  reply[kReplySent] = true;

  if (reply.context.onError !== null && reply[kReplyErrorHandlerCalled] === true) {
    reply[kReplyIsRunningOnErrorHook] = true;
    onSendHookRunner(reply.context.onError, reply.request, reply, error, function () {
      return handleError(reply, error, cb);
    });
  } else {
    handleError(reply, error, cb);
  }
}

function handleError(reply, error, cb) {
  reply[kReplyIsRunningOnErrorHook] = false;
  var res = reply.res;
  var statusCode = res.statusCode;
  statusCode = statusCode >= 400 ? statusCode : 500; // treat undefined and null as same

  if (error != null) {
    if (error.headers !== undefined) {
      reply.headers(error.headers);
    }

    if (error.status >= 400) {
      statusCode = error.status;
    } else if (error.statusCode >= 400) {
      statusCode = error.statusCode;
    }
  }

  res.statusCode = statusCode;
  var errorHandler = reply.context.errorHandler;

  if (errorHandler && reply[kReplyErrorHandlerCalled] === false) {
    reply[kReplySent] = false;
    reply[kReplyIsError] = false;
    reply[kReplyErrorHandlerCalled] = true;
    var result = errorHandler(error, reply.request, reply);

    if (result && typeof result.then === 'function') {
      wrapThenable(result, reply);
    }

    return;
  }

  var payload = serializeError({
    error: statusCodes[statusCode + ''],
    code: error.code,
    message: error.message || '',
    statusCode: statusCode
  });
  flatstr(payload);
  reply[kReplyHeaders]['content-type'] = CONTENT_TYPE.JSON;

  if (cb) {
    cb(reply, payload);
    return;
  }

  reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload);
  reply[kReplySent] = true;
  res.writeHead(res.statusCode, reply[kReplyHeaders]);
  res.end(payload);
}

function setupResponseListeners(reply) {
  reply[kReplyStartTime] = now();

  var onResFinished = function (err) {
    reply.res.removeListener('finish', onResFinished);
    reply.res.removeListener('error', onResFinished);
    var ctx = reply.context;

    if (ctx && ctx.onResponse !== null) {
      hookRunner(ctx.onResponse, onResponseIterator, reply.request, reply, onResponseCallback);
    } else {
      onResponseCallback(err, reply.request, reply);
    }
  };

  reply.res.on('finish', onResFinished);
  reply.res.on('error', onResFinished);
}

function onResponseIterator(fn, request, reply, next) {
  return fn(request, reply, next);
}

function onResponseCallback(err, request, reply) {
  if (reply.log[kDisableRequestLogging]) {
    return;
  }

  var responseTime = reply.getResponseTime();

  if (err != null) {
    reply.log.error({
      res: reply.res,
      err: err,
      responseTime: responseTime
    }, 'request errored');
    return;
  }

  reply.log.info({
    res: reply.res,
    responseTime: responseTime
  }, 'request completed');
}

function buildReply(R) {
  function _Reply(res, context, request, log) {
    this.res = res;
    this.context = context;
    this[kReplyIsError] = false;
    this[kReplyErrorHandlerCalled] = false;
    this[kReplySent] = false;
    this[kReplySentOverwritten] = false;
    this[kReplySerializer] = null;
    this.request = request;
    this[kReplyHeaders] = {};
    this[kReplyStartTime] = undefined;
    this.log = log;
  }

  _Reply.prototype = new R();
  return _Reply;
}

function notFound(reply) {
  reply[kReplySent] = false;
  reply[kReplyIsError] = false;

  if (reply.context[kFourOhFourContext] === null) {
    reply.log.warn('Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.');
    reply.code(404).send('404 Not Found');
    return;
  }

  reply.context = reply.context[kFourOhFourContext];
  reply.context.handler(reply.request, reply);
}

function noop() {}

function getHeaderProper(reply, key) {
  key = key.toLowerCase();
  var res = reply.res;
  var value = reply[kReplyHeaders][key];

  if (value === undefined && res.hasHeader(key)) {
    value = res.getHeader(key);
  }

  return value;
}

function getHeaderFallback(reply, key) {
  key = key.toLowerCase();
  var res = reply.res;
  var value = reply[kReplyHeaders][key];

  if (value === undefined) {
    value = res.getHeader(key);
  }

  return value;
} // ponyfill for hasHeader. It has been introduced into Node 7.7,
// so it's ok to use it in 8+


{
  var v = process.version.match(/v(\d+)/)[1];

  if (Number(v) > 7) {
    getHeader = getHeaderProper;
  } else {
    getHeader = getHeaderFallback;
  }
}
module.exports = Reply;
module.exports.buildReply = buildReply;
module.exports.setupResponseListeners = setupResponseListeners;
},{"readable-stream":"node_modules/fastify/node_modules/readable-stream/readable-browser.js","http":"node_modules/stream-http/index.js","flatstr":"node_modules/flatstr/index.js","fast-json-stringify":"node_modules/fast-json-stringify/index.js","./symbols.js":"node_modules/fastify/lib/symbols.js","./hooks":"node_modules/fastify/lib/hooks.js","./validation":"node_modules/fastify/lib/validation.js","./logger":"node_modules/fastify/lib/logger.js","./wrapThenable":"node_modules/fastify/lib/wrapThenable.js","./errors":"node_modules/fastify/lib/errors.js","buffer":"node_modules/buffer/index.js","process":"node_modules/process/browser.js"}],"node_modules/fastify/lib/request.js":[function(require,module,exports) {
'use strict';

function Request(params, req, query, headers, log, ip, ips, hostname) {
  this.params = params;
  this.raw = req;
  this.query = query;
  this.headers = headers;
  this.log = log;
  this.body = null;
  this.ip = ip;
  this.ips = ips;
  this.hostname = hostname;
}

function buildRequest(R) {
  function _Request(params, req, query, headers, log, ip, ips, hostname) {
    this.params = params;
    this.raw = req;
    this.query = query;
    this.headers = headers;
    this.log = log;
    this.body = null;
    this.ip = ip;
    this.ips = ips;
    this.hostname = hostname;
  }

  _Request.prototype = new R();
  return _Request;
}

Object.defineProperties(Request.prototype, {
  req: {
    get: function () {
      return this.raw;
    }
  },
  id: {
    get: function () {
      return this.raw.id;
    }
  }
});
module.exports = Request;
module.exports.buildRequest = buildRequest;
},{}],"node_modules/fastify/lib/decorate.js":[function(require,module,exports) {
'use strict';
/* eslint no-prototype-builtins: 0 */

var {
  kReply: kReply,
  kRequest: kRequest
} = require('./symbols.js');

var {
  codes: {
    FST_ERR_DEC_ALREADY_PRESENT: FST_ERR_DEC_ALREADY_PRESENT,
    FST_ERR_DEC_MISSING_DEPENDENCY: FST_ERR_DEC_MISSING_DEPENDENCY
  }
} = require('./errors');

function decorate(instance, name, fn, dependencies) {
  if (instance.hasOwnProperty(name)) {
    throw new FST_ERR_DEC_ALREADY_PRESENT(name);
  }

  if (dependencies) {
    checkDependencies(instance, dependencies);
  }

  if (fn && (typeof fn.getter === 'function' || typeof fn.setter === 'function')) {
    Object.defineProperty(instance, name, {
      get: fn.getter,
      set: fn.setter
    });
  } else {
    instance[name] = fn;
  }
}

function decorateFastify(name, fn, dependencies) {
  decorate(this, name, fn, dependencies);
  return this;
}

function checkExistence(instance, name) {
  if (name) {
    return name in instance;
  }

  return instance in this;
}

function checkRequestExistence(name) {
  return checkExistence(this[kRequest].prototype, name);
}

function checkReplyExistence(name) {
  return checkExistence(this[kReply].prototype, name);
}

function checkDependencies(instance, deps) {
  for (var i = 0; i < deps.length; i++) {
    if (!checkExistence(instance, deps[i])) {
      throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
    }
  }
}

function decorateReply(name, fn, dependencies) {
  decorate(this[kReply].prototype, name, fn, dependencies);
  return this;
}

function decorateRequest(name, fn, dependencies) {
  decorate(this[kRequest].prototype, name, fn, dependencies);
  return this;
}

module.exports = {
  add: decorateFastify,
  exist: checkExistence,
  existRequest: checkRequestExistence,
  existReply: checkReplyExistence,
  dependencies: checkDependencies,
  decorateReply: decorateReply,
  decorateRequest: decorateRequest
};
},{"./symbols.js":"node_modules/fastify/lib/symbols.js","./errors":"node_modules/fastify/lib/errors.js"}],"node_modules/tiny-lru/lib/tiny-lru.js":[function(require,module,exports) {
var define;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (t, i) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).tinyLru = i();
}(this, function () {
  "use strict";

  var t =
  /*#__PURE__*/
  function () {
    function t() {
      var _t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _classCallCheck(this, t);

      this.first = null, this.items = {}, this.last = null, this.max = _t, this.size = 0, this.ttl = i;
    }

    _createClass(t, [{
      key: "has",
      value: function has(t) {
        return t in this.items;
      }
    }, {
      key: "clear",
      value: function clear() {
        return this.first = null, this.items = {}, this.last = null, this.size = 0, this;
      }
    }, {
      key: "delete",
      value: function _delete(t) {
        if (this.has(t)) {
          var i = this.items[t];
          delete this.items[t], this.size--, null !== i.prev && (i.prev.next = i.next), null !== i.next && (i.next.prev = i.prev), this.first === i && (this.first = i.next), this.last === i && (this.last = i.prev);
        }

        return this;
      }
    }, {
      key: "evict",
      value: function evict() {
        var t = this.first;
        return delete this.items[t.key], this.first = t.next, this.first.prev = null, this.size--, this;
      }
    }, {
      key: "get",
      value: function get(t) {
        var i;

        if (this.has(t)) {
          var s = this.items[t];
          this.ttl > 0 && s.expiry <= new Date().getTime() ? this.delete(t) : (i = s.value, this.set(t, i, !0));
        }

        return i;
      }
    }, {
      key: "keys",
      value: function keys() {
        return Object.keys(this.items);
      }
    }, {
      key: "set",
      value: function set(t, i) {
        var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
        var e;

        if (s || this.has(t)) {
          if ((e = this.items[t]).value = i, this.last !== e) {
            var _t2 = this.last,
                _i = e.next,
                _s = e.prev;
            this.first === e && (this.first = e.next), e.next = null, e.prev = this.last, _t2.next = e, null !== _s && (_s.next = _i), null !== _i && (_i.prev = _s);
          }
        } else this.max > 0 && this.size === this.max && this.evict(), e = this.items[t] = {
          expiry: this.ttl > 0 ? new Date().getTime() + this.ttl : this.ttl,
          key: t,
          prev: this.last,
          next: null,
          value: i
        }, 1 == ++this.size ? this.first = e : this.last.next = e;

        return this.last = e, this;
      }
    }]);

    return t;
  }();

  return function () {
    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1e3;
    var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (isNaN(i) || i < 0) throw new TypeError("Invalid max value");
    if (isNaN(s) || s < 0) throw new TypeError("Invalid ttl value");
    return new t(i, s);
  };
});
},{}],"node_modules/secure-json-parse/index.js":[function(require,module,exports) {
'use strict'

const suspectRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/

function parse (text, reviver, options) {
  // Normalize arguments
  if (options == null) {
    if (reviver != null && typeof reviver === 'object') {
      options = reviver
      reviver = undefined
    } else {
      options = {}
    }
  }

  // Parse normally, allowing exceptions
  const obj = JSON.parse(text, reviver)

  // options.protoAction: 'error' (default) / 'remove' / 'ignore'
  if (options.protoAction === 'ignore') {
    return obj
  }

  // Ignore null and non-objects
  if (!obj || typeof obj !== 'object') {
    return obj
  }

  // Check original string for potential exploit
  if (!text.match(suspectRx)) {
    return obj
  }

  // Scan result for proto keys
  scan(obj, options)

  return obj
}

function scan (obj, options) {
  options = options || {}

  var next = [obj]

  while (next.length) {
    const nodes = next
    next = []

    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly
        if (options.protoAction !== 'remove') {
          throw new SyntaxError('Object contains forbidden prototype property')
        }

        delete node.__proto__ // eslint-disable-line
      }

      for (const key in node) {
        const value = node[key]
        if (value && typeof value === 'object') {
          next.push(node[key])
        }
      }
    }
  }
}

function safeParse (text, reviver) {
  try {
    return parse(text, reviver)
  } catch (ignoreError) {
    return null
  }
}

module.exports = {
  parse,
  scan,
  safeParse
}

},{}],"node_modules/fastify/lib/contentTypeParser.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';

var lru = require('tiny-lru');

var secureJson = require('secure-json-parse');

var {
  kDefaultJsonParse: kDefaultJsonParse,
  kContentTypeParser: kContentTypeParser,
  kBodyLimit: kBodyLimit,
  kState: kState
} = require('./symbols');

var {
  codes: {
    FST_ERR_CTP_INVALID_TYPE: FST_ERR_CTP_INVALID_TYPE,
    FST_ERR_CTP_EMPTY_TYPE: FST_ERR_CTP_EMPTY_TYPE,
    FST_ERR_CTP_ALREADY_PRESENT: FST_ERR_CTP_ALREADY_PRESENT,
    FST_ERR_CTP_INVALID_HANDLER: FST_ERR_CTP_INVALID_HANDLER,
    FST_ERR_CTP_INVALID_PARSE_TYPE: FST_ERR_CTP_INVALID_PARSE_TYPE,
    FST_ERR_CTP_BODY_TOO_LARGE: FST_ERR_CTP_BODY_TOO_LARGE,
    FST_ERR_CTP_INVALID_MEDIA_TYPE: FST_ERR_CTP_INVALID_MEDIA_TYPE,
    FST_ERR_CTP_INVALID_CONTENT_LENGTH: FST_ERR_CTP_INVALID_CONTENT_LENGTH,
    FST_ERR_CTP_EMPTY_JSON_BODY: FST_ERR_CTP_EMPTY_JSON_BODY
  }
} = require('./errors');

function ContentTypeParser(bodyLimit, onProtoPoisoning) {
  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning);
  this.customParsers = {};
  this.customParsers['application/json'] = new Parser(true, false, bodyLimit, this[kDefaultJsonParse]);
  this.customParsers['text/plain'] = new Parser(true, false, bodyLimit, defaultPlainTextParser);
  this.parserList = ['application/json', 'text/plain'];
  this.cache = lru(100);
}

ContentTypeParser.prototype.add = function (contentType, opts, parserFn) {
  if (typeof contentType !== 'string') throw new FST_ERR_CTP_INVALID_TYPE();
  if (contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE();
  if (typeof parserFn !== 'function') throw new FST_ERR_CTP_INVALID_HANDLER();

  if (this.hasParser(contentType)) {
    throw new FST_ERR_CTP_ALREADY_PRESENT(contentType);
  }

  if (opts.parseAs !== undefined) {
    if (opts.parseAs !== 'string' && opts.parseAs !== 'buffer') {
      throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
    }
  }

  var parser = new Parser(opts.parseAs === 'string', opts.parseAs === 'buffer', opts.bodyLimit, parserFn);

  if (contentType === '*') {
    this.parserList.push('');
    this.customParsers[''] = parser;
  } else {
    if (contentType !== 'application/json') {
      this.parserList.unshift(contentType);
    }

    this.customParsers[contentType] = parser;
  }
};

ContentTypeParser.prototype.hasParser = function (contentType) {
  if (contentType === 'application/json') {
    return this.customParsers['application/json'].fn !== this[kDefaultJsonParse];
  }

  if (contentType === 'text/plain') {
    return this.customParsers['text/plain'].fn !== defaultPlainTextParser;
  }

  return contentType in this.customParsers;
};

ContentTypeParser.prototype.getParser = function (contentType) {
  for (var i = 0; i < this.parserList.length; i++) {
    if (contentType.indexOf(this.parserList[i]) > -1) {
      var parser = this.customParsers[this.parserList[i]];
      this.cache.set(contentType, parser);
      return parser;
    }
  }

  return this.customParsers[''];
};

ContentTypeParser.prototype.run = function (contentType, handler, request, reply) {
  var parser = this.cache.get(contentType) || this.getParser(contentType);

  if (parser === undefined) {
    reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType));
  } else {
    if (parser.asString === true || parser.asBuffer === true) {
      rawBody(request, reply, reply.context._parserOptions, parser, done);
    } else {
      var result = parser.fn(request.raw, done);

      if (result && typeof result.then === 'function') {
        result.then(function (body) {
          return done(null, body);
        }, done);
      }
    }
  }

  function done(error, body) {
    if (error) {
      reply.send(error);
    } else {
      request.body = body;
      handler(request, reply);
    }
  }
};

function rawBody(request, reply, options, parser, done) {
  var asString = parser.asString;
  var limit = options.limit === null ? parser.bodyLimit : options.limit;
  var contentLength = request.headers['content-length'] === undefined ? NaN : Number.parseInt(request.headers['content-length'], 10);

  if (contentLength > limit) {
    reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
    return;
  }

  var receivedLength = 0;
  var body = asString === true ? '' : [];
  var req = request.raw;

  if (asString === true) {
    req.setEncoding('utf8');
  }

  req.on('data', onData);
  req.on('end', onEnd);
  req.on('error', onEnd);

  function onData(chunk) {
    receivedLength += chunk.length;

    if (receivedLength > limit) {
      req.removeListener('data', onData);
      req.removeListener('end', onEnd);
      req.removeListener('error', onEnd);
      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
      return;
    }

    if (asString === true) {
      body += chunk;
    } else {
      body.push(chunk);
    }
  }

  function onEnd(err) {
    req.removeListener('data', onData);
    req.removeListener('end', onEnd);
    req.removeListener('error', onEnd);

    if (err !== undefined) {
      err.statusCode = 400;
      reply.code(err.statusCode).send(err);
      return;
    }

    if (asString === true) {
      receivedLength = Buffer.byteLength(body);
    }

    if (!Number.isNaN(contentLength) && receivedLength !== contentLength) {
      reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH());
      return;
    }

    if (asString === false) {
      body = Buffer.concat(body);
    }

    var result = parser.fn(req, body, done);

    if (result && typeof result.then === 'function') {
      result.then(function (body) {
        return done(null, body);
      }, done);
    }
  }
}

function getDefaultJsonParser(onProtoPoisoning) {
  return defaultJsonParser;

  function defaultJsonParser(req, body, done) {
    if (body === '' || body == null) {
      return done(new FST_ERR_CTP_EMPTY_JSON_BODY(), undefined);
    }

    try {
      var json = secureJson.parse(body, {
        protoAction: onProtoPoisoning
      });
    } catch (err) {
      err.statusCode = 400;
      return done(err, undefined);
    }

    done(null, json);
  }
}

function defaultPlainTextParser(req, body, done) {
  done(null, body);
}

function Parser(asString, asBuffer, bodyLimit, fn) {
  this.asString = asString;
  this.asBuffer = asBuffer;
  this.bodyLimit = bodyLimit;
  this.fn = fn;
}

function buildContentTypeParser(c) {
  var contentTypeParser = new ContentTypeParser();
  contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse];
  Object.assign(contentTypeParser.customParsers, c.customParsers);
  contentTypeParser.parserList = c.parserList.slice();
  return contentTypeParser;
}

function addContentTypeParser(contentType, opts, parser) {
  var _this = this;

  if (this[kState].started) {
    throw new Error('Cannot call "addContentTypeParser" when fastify instance is already started!');
  }

  if (typeof opts === 'function') {
    parser = opts;
    opts = {};
  }

  if (!opts) opts = {};
  if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit];

  if (Array.isArray(contentType)) {
    contentType.forEach(function (type) {
      return _this[kContentTypeParser].add(type, opts, parser);
    });
  } else {
    this[kContentTypeParser].add(contentType, opts, parser);
  }

  return this;
}

function hasContentTypeParser(contentType) {
  return this[kContentTypeParser].hasParser(contentType);
}

module.exports = ContentTypeParser;
module.exports.helpers = {
  buildContentTypeParser: buildContentTypeParser,
  addContentTypeParser: addContentTypeParser,
  hasContentTypeParser: hasContentTypeParser
};
module.exports[Symbol.for('internals')] = {
  rawBody: rawBody
};
},{"tiny-lru":"node_modules/tiny-lru/lib/tiny-lru.js","secure-json-parse":"node_modules/secure-json-parse/index.js","./symbols":"node_modules/fastify/lib/symbols.js","./errors":"node_modules/fastify/lib/errors.js","buffer":"node_modules/buffer/index.js"}],"node_modules/rfdc/index.js":[function(require,module,exports) {
'use strict'
module.exports = rfdc

function rfdc (opts) {
  opts = opts || {}

  if (opts.circles) return rfdcCircles(opts)
  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a)
    var a2 = new Array(keys.length)
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]
      var cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur)
      } else {
        a2[k] = fn(cur)
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    var o2 = {}
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else {
        o2[k] = clone(cur)
      }
    }
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    var o2 = {}
    for (var k in o) {
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else {
        o2[k] = cloneProto(cur)
      }
    }
    return o2
  }
}

function rfdcCircles (opts) {
  var refs = []
  var refsNew = []

  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a)
    var a2 = new Array(keys.length)
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]
      var cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur)
      } else {
        var index = refs.indexOf(cur)
        if (index !== -1) {
          a2[k] = refsNew[index]
        } else {
          a2[k] = fn(cur)
        }
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    var o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else {
        var i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = clone(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    var o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (var k in o) {
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else {
        var i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = cloneProto(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }
}

},{}],"node_modules/fastify/lib/schemas.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var fastClone = require('rfdc')({
  circles: false,
  proto: true
});

var kFluentSchema = Symbol.for('fluent-schema-object');

var {
  codes: {
    FST_ERR_SCH_MISSING_ID: FST_ERR_SCH_MISSING_ID,
    FST_ERR_SCH_ALREADY_PRESENT: FST_ERR_SCH_ALREADY_PRESENT,
    FST_ERR_SCH_NOT_PRESENT: FST_ERR_SCH_NOT_PRESENT,
    FST_ERR_SCH_DUPLICATE: FST_ERR_SCH_DUPLICATE
  }
} = require('./errors');

var URI_NAME_FRAGMENT = /^#[A-Za-z]{1}[\w-:.]{0,}$/;

function Schemas() {
  this.store = {};
}

Schemas.prototype.add = function (inputSchema, refResolver) {
  var schema = fastClone(inputSchema.isFluentSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema);
  var id = schema.$id;

  if (id === undefined) {
    throw new FST_ERR_SCH_MISSING_ID();
  }

  if (this.store[id] !== undefined) {
    throw new FST_ERR_SCH_ALREADY_PRESENT(id);
  }

  this.store[id] = this.resolveRefs(schema, true, refResolver);
};

Schemas.prototype.resolve = function (id) {
  if (this.store[id] === undefined) {
    throw new FST_ERR_SCH_NOT_PRESENT(id);
  }

  return Object.assign({}, this.store[id]);
};

Schemas.prototype.resolveRefs = function (routeSchemas, dontClearId, refResolver) {
  // alias query to querystring schema
  if (routeSchemas.query) {
    // check if our schema has both querystring and query
    if (routeSchemas.querystring) {
      throw new FST_ERR_SCH_DUPLICATE('querystring');
    }

    routeSchemas.querystring = routeSchemas.query;
  } // let's check if our schemas have a custom prototype


  for (var key of ['headers', 'querystring', 'params', 'body']) {
    if (_typeof(routeSchemas[key]) === 'object' && Object.getPrototypeOf(routeSchemas[key]) !== Object.prototype) {
      return routeSchemas;
    }
  } // See issue https://github.com/fastify/fastify/issues/1767


  var cachedSchema = Object.assign({}, routeSchemas);

  try {
    // this will work only for standard json schemas
    // other compilers such as Joi will fail
    this.traverse(routeSchemas, refResolver); // when a plugin uses the 'skip-override' and call addSchema
    // the same JSON will be pass throug all the avvio tree. In this case
    // it is not possible clean the id. The id will be cleared
    // in the startup phase by the call of validation.js. Details PR #1496

    if (dontClearId !== true) {
      this.cleanId(routeSchemas);
    }
  } catch (err) {
    // if we have failed because `resolve` has thrown
    // let's rethrow the error and let avvio handle it
    if (/FST_ERR_SCH_*/.test(err.code)) throw err; // otherwise, the schema must not be a JSON schema
    // so we let the user configured schemaCompiler handle it

    return cachedSchema;
  }

  if (routeSchemas.headers) {
    routeSchemas.headers = this.getSchemaAnyway(routeSchemas.headers);
  }

  if (routeSchemas.querystring) {
    routeSchemas.querystring = this.getSchemaAnyway(routeSchemas.querystring);
  }

  if (routeSchemas.params) {
    routeSchemas.params = this.getSchemaAnyway(routeSchemas.params);
  }

  return routeSchemas;
};

Schemas.prototype.traverse = function (schema, refResolver) {
  for (var key in schema) {
    // resolve the `sharedSchemaId#' only if is not a standard $ref JSON Pointer
    if (typeof schema[key] === 'string' && key !== '$schema' && key !== '$ref' && schema[key].slice(-1) === '#') {
      schema[key] = this.resolve(schema[key].slice(0, -1));
    } else if (key === '$ref' && refResolver) {
      var refValue = schema[key];
      var framePos = refValue.indexOf('#');
      var refId = framePos >= 0 ? refValue.slice(0, framePos) : refValue;

      if (refId.length > 0 && !this.store[refId]) {
        var resolvedSchema = refResolver(refId);

        if (resolvedSchema) {
          this.add(resolvedSchema, refResolver);
        }
      }
    }

    if (schema[key] !== null && _typeof(schema[key]) === 'object') {
      this.traverse(schema[key], refResolver);
    }
  }
};

Schemas.prototype.cleanId = function (schema) {
  for (var key in schema) {
    if (key === '$id' && !URI_NAME_FRAGMENT.test(schema[key])) {
      delete schema[key];
    }

    if (schema[key] !== null && _typeof(schema[key]) === 'object') {
      this.cleanId(schema[key]);
    }
  }
};

Schemas.prototype.getSchemaAnyway = function (schema) {
  if (schema.oneOf || schema.allOf || schema.anyOf) return schema;

  if (!schema.type || !schema.properties) {
    return {
      type: 'object',
      properties: schema
    };
  }

  return schema;
};

Schemas.prototype.getSchemas = function () {
  return Object.assign({}, this.store);
};

Schemas.prototype.getJsonSchemas = function (options) {
  var store = this.getSchemas();
  var schemasArray = Object.keys(store).map(function (schemaKey) {
    // if the shared-schema "replace-way" has been used, the $id field has been removed
    if (store[schemaKey].$id === undefined) {
      store[schemaKey].$id = schemaKey;
    }

    return store[schemaKey];
  });

  if (options && options.onlyAbsoluteUri === true) {
    // the caller wants only the absolute URI (without the shared schema - "replace-way" usage)
    return schemasArray.filter(function (_) {
      return !/^\w*$/g.test(_.$id);
    });
  }

  return schemasArray;
};

function buildSchemas(s) {
  var schema = new Schemas();
  s.getJsonSchemas().forEach(function (_) {
    return schema.add(_);
  });
  return schema;
}

module.exports = {
  Schemas: Schemas,
  buildSchemas: buildSchemas
};
},{"rfdc":"node_modules/rfdc/index.js","./errors":"node_modules/fastify/lib/errors.js"}],"node_modules/fastify/lib/pluginUtils.js":[function(require,module,exports) {
'use strict';

var assert = require('assert');

var registeredPlugins = Symbol.for('registered-plugin');

var {
  kReply: kReply,
  kRequest: kRequest
} = require('./symbols.js');

function getMeta(fn) {
  return fn[Symbol.for('plugin-meta')];
}

function getPluginName(func) {
  // let's see if this is a file, and in that case use that
  // this is common for plugins
  var cache = require.cache;
  var keys = Object.keys(cache);

  for (var i = 0; i < keys.length; i++) {
    if (cache[keys[i]].exports === func) {
      return keys[i];
    }
  } // if not maybe it's a named function, so use that


  if (func.name) {
    return func.name;
  }

  return null;
}

function getFuncPreview(func) {
  // takes the first two lines of the function if nothing else works
  return func.toString().split('\n').slice(0, 2).map(function (s) {
    return s.trim();
  }).join(' -- ');
}

function getDisplayName(fn) {
  return fn[Symbol.for('fastify.display-name')];
}

function shouldSkipOverride(fn) {
  return !!fn[Symbol.for('skip-override')];
}

function checkDependencies(fn) {
  var _this = this;

  var meta = getMeta(fn);
  if (!meta) return;
  var dependencies = meta.dependencies;
  if (!dependencies) return;
  assert(Array.isArray(dependencies), 'The dependencies should be an array of strings');
  dependencies.forEach(function (dependency) {
    assert(_this[registeredPlugins].indexOf(dependency) > -1, "The dependency '".concat(dependency, "' of plugin '").concat(meta.name, "' is not registered"));
  });
}

function checkDecorators(fn) {
  var meta = getMeta(fn);
  if (!meta) return;
  var decorators = meta.decorators;
  if (!decorators) return;
  if (decorators.fastify) _checkDecorators.call(this, 'Fastify', decorators.fastify);
  if (decorators.reply) _checkDecorators.call(this[kReply], 'Reply', decorators.reply);
  if (decorators.request) _checkDecorators.call(this[kRequest], 'Request', decorators.request);
}

function _checkDecorators(instance, decorators) {
  var _this2 = this;

  assert(Array.isArray(decorators), 'The decorators should be an array of strings');
  decorators.forEach(function (decorator) {
    assert(instance === 'Fastify' ? decorator in _this2 : decorator in _this2.prototype, "The decorator '".concat(decorator, "' is not present in ").concat(instance));
  });
}

function registerPluginName(fn) {
  var meta = getMeta(fn);
  if (!meta) return;
  var name = meta.name;
  if (!name) return;
  this[registeredPlugins].push(name);
}

function registerPlugin(fn) {
  registerPluginName.call(this, fn);
  checkDecorators.call(this, fn);
  checkDependencies.call(this, fn);
  return shouldSkipOverride(fn);
}

module.exports = {
  getPluginName: getPluginName,
  getFuncPreview: getFuncPreview,
  registeredPlugins: registeredPlugins,
  getDisplayName: getDisplayName,
  registerPlugin: registerPlugin
};
module.exports[Symbol.for('internals')] = {
  shouldSkipOverride: shouldSkipOverride,
  getMeta: getMeta,
  checkDecorators: checkDecorators,
  checkDependencies: checkDependencies
};
},{"assert":"node_modules/assert/assert.js","./symbols.js":"node_modules/fastify/lib/symbols.js"}],"node_modules/fastify/lib/reqIdGenFactory.js":[function(require,module,exports) {
'use strict';

module.exports = function () {
  var maxInt = 2147483647;
  var nextReqId = 0;
  return function genReqId(req) {
    return nextReqId = nextReqId + 1 & maxInt;
  };
};
},{}],"node_modules/fast-decode-uri-component/index.js":[function(require,module,exports) {
'use strict'

var UTF8_ACCEPT = 12
var UTF8_REJECT = 0
var UTF8_DATA = [
  // The first part of the table maps bytes to character to a transition.
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,
  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,

  // The second part of the table maps a state to a new state when adding a
  // transition.
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,
  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  // The third part maps the current transition to a mask that needs to apply
  // to the byte.
  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07
]

function decodeURIComponent (uri) {
  var percentPosition = uri.indexOf('%')
  if (percentPosition === -1) return uri

  var length = uri.length
  var decoded = ''
  var last = 0
  var codepoint = 0
  var startOfOctets = percentPosition
  var state = UTF8_ACCEPT

  while (percentPosition > -1 && percentPosition < length) {
    var high = hexCodeToInt(uri[percentPosition + 1], 4)
    var low = hexCodeToInt(uri[percentPosition + 2], 0)
    var byte = high | low
    var type = UTF8_DATA[byte]
    state = UTF8_DATA[256 + state + type]
    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])

    if (state === UTF8_ACCEPT) {
      decoded += uri.slice(last, startOfOctets)

      decoded += (codepoint <= 0xFFFF)
        ? String.fromCharCode(codepoint)
        : String.fromCharCode(
          (0xD7C0 + (codepoint >> 10)),
          (0xDC00 + (codepoint & 0x3FF))
        )

      codepoint = 0
      last = percentPosition + 3
      percentPosition = startOfOctets = uri.indexOf('%', last)
    } else if (state === UTF8_REJECT) {
      return null
    } else {
      percentPosition += 3
      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue
      return null
    }
  }

  return decoded + uri.slice(last)
}

var HEX = {
  '0': 0,
  '1': 1,
  '2': 2,
  '3': 3,
  '4': 4,
  '5': 5,
  '6': 6,
  '7': 7,
  '8': 8,
  '9': 9,
  'a': 10,
  'A': 10,
  'b': 11,
  'B': 11,
  'c': 12,
  'C': 12,
  'd': 13,
  'D': 13,
  'e': 14,
  'E': 14,
  'f': 15,
  'F': 15
}

function hexCodeToInt (c, shift) {
  var i = HEX[c]
  return i === undefined ? 255 : i << shift
}

module.exports = decodeURIComponent

},{}],"node_modules/ret/lib/types.js":[function(require,module,exports) {
module.exports = {
  ROOT: 0,
  GROUP: 1,
  POSITION: 2,
  SET: 3,
  RANGE: 4,
  REPETITION: 5,
  REFERENCE: 6,
  CHAR: 7
};
},{}],"node_modules/ret/lib/sets.js":[function(require,module,exports) {
const types = require('./types');

const INTS = () => [{
  type: types.RANGE,
  from: 48,
  to: 57
}];

const WORDS = () => {
  return [{
    type: types.CHAR,
    value: 95
  }, {
    type: types.RANGE,
    from: 97,
    to: 122
  }, {
    type: types.RANGE,
    from: 65,
    to: 90
  }].concat(INTS());
};

const WHITESPACE = () => {
  return [{
    type: types.CHAR,
    value: 9
  }, {
    type: types.CHAR,
    value: 10
  }, {
    type: types.CHAR,
    value: 11
  }, {
    type: types.CHAR,
    value: 12
  }, {
    type: types.CHAR,
    value: 13
  }, {
    type: types.CHAR,
    value: 32
  }, {
    type: types.CHAR,
    value: 160
  }, {
    type: types.CHAR,
    value: 5760
  }, {
    type: types.RANGE,
    from: 8192,
    to: 8202
  }, {
    type: types.CHAR,
    value: 8232
  }, {
    type: types.CHAR,
    value: 8233
  }, {
    type: types.CHAR,
    value: 8239
  }, {
    type: types.CHAR,
    value: 8287
  }, {
    type: types.CHAR,
    value: 12288
  }, {
    type: types.CHAR,
    value: 65279
  }];
};

const NOTANYCHAR = () => {
  return [{
    type: types.CHAR,
    value: 10
  }, {
    type: types.CHAR,
    value: 13
  }, {
    type: types.CHAR,
    value: 8232
  }, {
    type: types.CHAR,
    value: 8233
  }];
}; // Predefined class objects.


exports.words = () => ({
  type: types.SET,
  set: WORDS(),
  not: false
});

exports.notWords = () => ({
  type: types.SET,
  set: WORDS(),
  not: true
});

exports.ints = () => ({
  type: types.SET,
  set: INTS(),
  not: false
});

exports.notInts = () => ({
  type: types.SET,
  set: INTS(),
  not: true
});

exports.whitespace = () => ({
  type: types.SET,
  set: WHITESPACE(),
  not: false
});

exports.notWhitespace = () => ({
  type: types.SET,
  set: WHITESPACE(),
  not: true
});

exports.anyChar = () => ({
  type: types.SET,
  set: NOTANYCHAR(),
  not: true
});
},{"./types":"node_modules/ret/lib/types.js"}],"node_modules/ret/lib/util.js":[function(require,module,exports) {
const types = require('./types');

const sets = require('./sets');

const CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
const SLSH = {
  '0': 0,
  't': 9,
  'n': 10,
  'v': 11,
  'f': 12,
  'r': 13
};
/**
 * Finds character representations in str and convert all to
 * their respective characters
 *
 * @param {String} str
 * @return {String}
 */

exports.strToChars = function (str) {
  /* jshint maxlen: false */
  var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
  str = str.replace(chars_regex, function (s, b, lbs, a16, b16, c8, dctrl, eslsh) {
    if (lbs) {
      return s;
    }

    var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
    var c = String.fromCharCode(code); // Escape special regex characters.

    if (/[[\]{}^$.|?*+()]/.test(c)) {
      c = '\\' + c;
    }

    return c;
  });
  return str;
};
/**
 * turns class into tokens
 * reads str until it encounters a ] not preceeded by a \
 *
 * @param {String} str
 * @param {String} regexpStr
 * @return {Array.<Array.<Object>, Number>}
 */


exports.tokenizeClass = (str, regexpStr) => {
  /* jshint maxlen: false */
  var tokens = [];
  var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g;
  var rs, c;

  while ((rs = regexp.exec(str)) != null) {
    if (rs[1]) {
      tokens.push(sets.words());
    } else if (rs[2]) {
      tokens.push(sets.ints());
    } else if (rs[3]) {
      tokens.push(sets.whitespace());
    } else if (rs[4]) {
      tokens.push(sets.notWords());
    } else if (rs[5]) {
      tokens.push(sets.notInts());
    } else if (rs[6]) {
      tokens.push(sets.notWhitespace());
    } else if (rs[7]) {
      tokens.push({
        type: types.RANGE,
        from: (rs[8] || rs[9]).charCodeAt(0),
        to: rs[10].charCodeAt(0)
      });
    } else if (c = rs[12]) {
      tokens.push({
        type: types.CHAR,
        value: c.charCodeAt(0)
      });
    } else {
      return [tokens, regexp.lastIndex];
    }
  }

  exports.error(regexpStr, 'Unterminated character class');
};
/**
 * Shortcut to throw errors.
 *
 * @param {String} regexp
 * @param {String} msg
 */


exports.error = (regexp, msg) => {
  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);
};
},{"./types":"node_modules/ret/lib/types.js","./sets":"node_modules/ret/lib/sets.js"}],"node_modules/ret/lib/positions.js":[function(require,module,exports) {
const types = require('./types');

exports.wordBoundary = () => ({
  type: types.POSITION,
  value: 'b'
});

exports.nonWordBoundary = () => ({
  type: types.POSITION,
  value: 'B'
});

exports.begin = () => ({
  type: types.POSITION,
  value: '^'
});

exports.end = () => ({
  type: types.POSITION,
  value: '$'
});
},{"./types":"node_modules/ret/lib/types.js"}],"node_modules/ret/lib/index.js":[function(require,module,exports) {
const util = require('./util');

const types = require('./types');

const sets = require('./sets');

const positions = require('./positions');

module.exports = regexpStr => {
  var i = 0,
      l,
      c,
      start = {
    type: types.ROOT,
    stack: []
  },
      // Keep track of last clause/group and stack.
  lastGroup = start,
      last = start.stack,
      groupStack = [];

  var repeatErr = i => {
    util.error(regexpStr, "Nothing to repeat at column ".concat(i - 1));
  }; // Decode a few escaped characters.


  var str = util.strToChars(regexpStr);
  l = str.length; // Iterate through each character in string.

  while (i < l) {
    c = str[i++];

    switch (c) {
      // Handle escaped characters, inclues a few sets.
      case '\\':
        c = str[i++];

        switch (c) {
          case 'b':
            last.push(positions.wordBoundary());
            break;

          case 'B':
            last.push(positions.nonWordBoundary());
            break;

          case 'w':
            last.push(sets.words());
            break;

          case 'W':
            last.push(sets.notWords());
            break;

          case 'd':
            last.push(sets.ints());
            break;

          case 'D':
            last.push(sets.notInts());
            break;

          case 's':
            last.push(sets.whitespace());
            break;

          case 'S':
            last.push(sets.notWhitespace());
            break;

          default:
            // Check if c is integer.
            // In which case it's a reference.
            if (/\d/.test(c)) {
              last.push({
                type: types.REFERENCE,
                value: parseInt(c, 10)
              }); // Escaped character.
            } else {
              last.push({
                type: types.CHAR,
                value: c.charCodeAt(0)
              });
            }

        }

        break;
      // Positionals.

      case '^':
        last.push(positions.begin());
        break;

      case '$':
        last.push(positions.end());
        break;
      // Handle custom sets.

      case '[':
        // Check if this class is 'anti' i.e. [^abc].
        var not;

        if (str[i] === '^') {
          not = true;
          i++;
        } else {
          not = false;
        } // Get all the characters in class.


        var classTokens = util.tokenizeClass(str.slice(i), regexpStr); // Increase index by length of class.

        i += classTokens[1];
        last.push({
          type: types.SET,
          set: classTokens[0],
          not: not
        });
        break;
      // Class of any character except \n.

      case '.':
        last.push(sets.anyChar());
        break;
      // Push group onto stack.

      case '(':
        // Create group.
        var group = {
          type: types.GROUP,
          stack: [],
          remember: true
        };
        c = str[i]; // If if this is a special kind of group.

        if (c === '?') {
          c = str[i + 1];
          i += 2; // Match if followed by.

          if (c === '=') {
            group.followedBy = true; // Match if not followed by.
          } else if (c === '!') {
            group.notFollowedBy = true;
          } else if (c !== ':') {
            util.error(regexpStr, "Invalid group, character '".concat(c, "'") + " after '?' at column ".concat(i - 1));
          }

          group.remember = false;
        } // Insert subgroup into current group stack.


        last.push(group); // Remember the current group for when the group closes.

        groupStack.push(lastGroup); // Make this new group the current group.

        lastGroup = group;
        last = group.stack;
        break;
      // Pop group out of stack.

      case ')':
        if (groupStack.length === 0) {
          util.error(regexpStr, "Unmatched ) at column ".concat(i - 1));
        }

        lastGroup = groupStack.pop(); // Check if this group has a PIPE.
        // To get back the correct last stack.

        last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
        break;
      // Use pipe character to give more choices.

      case '|':
        // Create array where options are if this is the first PIPE
        // in this clause.
        if (!lastGroup.options) {
          lastGroup.options = [lastGroup.stack];
          delete lastGroup.stack;
        } // Create a new stack and add to options for rest of clause.


        var stack = [];
        lastGroup.options.push(stack);
        last = stack;
        break;
      // Repetition.
      // For every repetition, remove last element from last stack
      // then insert back a RANGE object.
      // This design is chosen because there could be more than
      // one repetition symbols in a regex i.e. `a?+{2,3}`.

      case '{':
        var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)),
            min,
            max;

        if (rs !== null) {
          if (last.length === 0) {
            repeatErr(i);
          }

          min = parseInt(rs[1], 10);
          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
          i += rs[0].length;
          last.push({
            type: types.REPETITION,
            min: min,
            max: max,
            value: last.pop()
          });
        } else {
          last.push({
            type: types.CHAR,
            value: 123
          });
        }

        break;

      case '?':
        if (last.length === 0) {
          repeatErr(i);
        }

        last.push({
          type: types.REPETITION,
          min: 0,
          max: 1,
          value: last.pop()
        });
        break;

      case '+':
        if (last.length === 0) {
          repeatErr(i);
        }

        last.push({
          type: types.REPETITION,
          min: 1,
          max: Infinity,
          value: last.pop()
        });
        break;

      case '*':
        if (last.length === 0) {
          repeatErr(i);
        }

        last.push({
          type: types.REPETITION,
          min: 0,
          max: Infinity,
          value: last.pop()
        });
        break;
      // Default is a character that is not `\[](){}?+*^$`.

      default:
        last.push({
          type: types.CHAR,
          value: c.charCodeAt(0)
        });
    }
  } // Check if any groups have not been closed.


  if (groupStack.length !== 0) {
    util.error(regexpStr, 'Unterminated group');
  }

  return start;
};

module.exports.types = types;
},{"./util":"node_modules/ret/lib/util.js","./types":"node_modules/ret/lib/types.js","./sets":"node_modules/ret/lib/sets.js","./positions":"node_modules/ret/lib/positions.js"}],"node_modules/safe-regex2/index.js":[function(require,module,exports) {
'use strict'

var parse = require('ret')
var types = parse.types

module.exports = function (re, opts) {
  if (!opts) opts = {}
  var replimit = opts.limit === undefined ? 25 : opts.limit

  if (isRegExp(re)) re = re.source
  else if (typeof re !== 'string') re = String(re)

  try { re = parse(re) } catch (err) { return false }

  var reps = 0
  return (function walk (node, starHeight) {
    var i
    var ok
    var len

    if (node.type === types.REPETITION) {
      starHeight++
      reps++
      if (starHeight > 1) return false
      if (reps > replimit) return false
    }

    if (node.options) {
      for (i = 0, len = node.options.length; i < len; i++) {
        ok = walk({ stack: node.options[i] }, starHeight)
        if (!ok) return false
      }
    }
    var stack = node.stack || (node.value && node.value.stack)
    if (!stack) return true

    for (i = 0; i < stack.length; i++) {
      ok = walk(stack[i], starHeight)
      if (!ok) return false
    }

    return true
  })(re, 0)
}

function isRegExp (x) {
  return {}.toString.call(x) === '[object RegExp]'
}

},{"ret":"node_modules/ret/lib/index.js"}],"node_modules/find-my-way/node.js":[function(require,module,exports) {
'use strict';

var assert = require('assert');

var http = require('http');

var Handlers = buildHandlers();
var types = {
  STATIC: 0,
  PARAM: 1,
  MATCH_ALL: 2,
  REGEX: 3,
  // It's used for a parameter, that is followed by another parameter in the same part
  MULTI_PARAM: 4
};

function Node(options) {
  // former arguments order: prefix, children, kind, handlers, regex, versions
  options = options || {};
  this.prefix = options.prefix || '/';
  this.label = this.prefix[0];
  this.children = options.children || {};
  this.numberOfChildren = Object.keys(this.children).length;
  this.kind = options.kind || this.types.STATIC;
  this.handlers = new Handlers(options.handlers);
  this.regex = options.regex || null;
  this.wildcardChild = null;
  this.parametricBrother = null;
  this.versions = options.versions;
}

Object.defineProperty(Node.prototype, 'types', {
  value: types
});

Node.prototype.getLabel = function () {
  return this.prefix[0];
};

Node.prototype.addChild = function (node) {
  var _this = this;

  var label = '';

  switch (node.kind) {
    case this.types.STATIC:
      label = node.getLabel();
      break;

    case this.types.PARAM:
    case this.types.REGEX:
    case this.types.MULTI_PARAM:
      label = ':';
      break;

    case this.types.MATCH_ALL:
      this.wildcardChild = node;
      label = '*';
      break;

    default:
      throw new Error("Unknown node kind: ".concat(node.kind));
  }

  assert(this.children[label] === undefined, "There is already a child with label '".concat(label, "'"));
  this.children[label] = node;
  this.numberOfChildren = Object.keys(this.children).length;
  var labels = Object.keys(this.children);
  var parametricBrother = this.parametricBrother;

  for (var i = 0; i < labels.length; i++) {
    var child = this.children[labels[i]];

    if (child.label === ':') {
      parametricBrother = child;
      break;
    }
  } // Save the parametric brother inside static children


  var iterate = function (node) {
    if (!node) {
      return;
    }

    if (node.kind !== _this.types.STATIC) {
      return;
    }

    if (node !== _this) {
      node.parametricBrother = parametricBrother || node.parametricBrother;
    }

    var labels = Object.keys(node.children);

    for (var i = 0; i < labels.length; i++) {
      iterate(node.children[labels[i]]);
    }
  };

  iterate(this);
  return this;
};

Node.prototype.reset = function (prefix, versions) {
  this.prefix = prefix;
  this.children = {};
  this.kind = this.types.STATIC;
  this.handlers = new Handlers();
  this.numberOfChildren = 0;
  this.regex = null;
  this.wildcardChild = null;
  this.versions = versions;
  return this;
};

Node.prototype.findByLabel = function (path) {
  return this.children[path[0]];
};

Node.prototype.findChild = function (path, method) {
  var child = this.children[path[0]];

  if (child !== undefined && (child.numberOfChildren > 0 || child.handlers[method] !== null)) {
    if (path.slice(0, child.prefix.length) === child.prefix) {
      return child;
    }
  }

  child = this.children[':'] || this.children['*'];

  if (child !== undefined && (child.numberOfChildren > 0 || child.handlers[method] !== null)) {
    return child;
  }

  return null;
};

Node.prototype.findVersionChild = function (version, path, method) {
  var child = this.children[path[0]];

  if (child !== undefined && (child.numberOfChildren > 0 || child.getVersionHandler(version, method) !== null)) {
    if (path.slice(0, child.prefix.length) === child.prefix) {
      return child;
    }
  }

  child = this.children[':'] || this.children['*'];

  if (child !== undefined && (child.numberOfChildren > 0 || child.getVersionHandler(version, method) !== null)) {
    return child;
  }

  return null;
};

Node.prototype.setHandler = function (method, handler, params, store) {
  if (!handler) return;
  assert(this.handlers[method] !== undefined, "There is already an handler with method '".concat(method, "'"));
  this.handlers[method] = {
    handler: handler,
    params: params,
    store: store || null,
    paramsLength: params.length
  };
};

Node.prototype.setVersionHandler = function (version, method, handler, params, store) {
  if (!handler) return;
  var handlers = this.versions.get(version) || new Handlers();
  assert(handlers[method] === null, "There is already an handler with version '".concat(version, "' and method '").concat(method, "'"));
  handlers[method] = {
    handler: handler,
    params: params,
    store: store || null,
    paramsLength: params.length
  };
  this.versions.set(version, handlers);
};

Node.prototype.getHandler = function (method) {
  return this.handlers[method];
};

Node.prototype.getVersionHandler = function (version, method) {
  var handlers = this.versions.get(version);
  return handlers === null ? handlers : handlers[method];
};

Node.prototype.prettyPrint = function (prefix, tail) {
  var _this2 = this;

  var paramName = '';
  var handlers = this.handlers || {};
  var methods = Object.keys(handlers).filter(function (method) {
    return handlers[method] && handlers[method].handler;
  });

  if (this.prefix === ':') {
    methods.forEach(function (method, index) {
      var params = _this2.handlers[method].params;
      var param = params[params.length - 1];

      if (methods.length > 1) {
        if (index === 0) {
          paramName += param + " (".concat(method, ")\n");
          return;
        }

        paramName += prefix + '    :' + param + " (".concat(method, ")");
        paramName += index === methods.length - 1 ? '' : '\n';
      } else {
        paramName = params[params.length - 1] + " (".concat(method, ")");
      }
    });
  } else if (methods.length) {
    paramName = " (".concat(methods.join('|'), ")");
  }

  var tree = "".concat(prefix).concat(tail ? '└── ' : '├── ').concat(this.prefix).concat(paramName, "\n");
  prefix = "".concat(prefix).concat(tail ? '    ' : '│   ');
  var labels = Object.keys(this.children);

  for (var i = 0; i < labels.length - 1; i++) {
    tree += this.children[labels[i]].prettyPrint(prefix, false);
  }

  if (labels.length > 0) {
    tree += this.children[labels[labels.length - 1]].prettyPrint(prefix, true);
  }

  return tree;
};

function buildHandlers(handlers) {
  var code = "handlers = handlers || {}\n  ";

  for (var i = 0; i < http.METHODS.length; i++) {
    var m = http.METHODS[i];
    code += "this['".concat(m, "'] = handlers['").concat(m, "'] || null\n    ");
  }

  return new Function('handlers', code); // eslint-disable-line
}

module.exports = Node;
module.exports.Handlers = Handlers;
},{"assert":"node_modules/assert/assert.js","http":"node_modules/stream-http/index.js"}],"node_modules/semver-store/index.js":[function(require,module,exports) {
'use strict'

function SemVerStore () {
  if (!(this instanceof SemVerStore)) {
    return new SemVerStore()
  }
  this.tree = new Node()
}

SemVerStore.prototype.set = function (version, store) {
  if (typeof version !== 'string') {
    throw new TypeError('Version should be a string')
  }
  var currentNode = this.tree
  version = version.split('.')
  while (version.length) {
    currentNode = currentNode.addChild(
      new Node(version.shift())
    )
  }
  currentNode.setStore(store)
  return this
}

SemVerStore.prototype.get = function (version) {
  if (typeof version !== 'string') return null
  if (version === '*') version = 'x.x.x'
  var node = this.tree
  var firstDot = version.indexOf('.')
  var secondDot = version.indexOf('.', firstDot + 1)
  var major = version.slice(0, firstDot)
  var minor = secondDot === -1
    ? version.slice(firstDot + 1)
    : version.slice(firstDot + 1, secondDot)
  var patch = secondDot === -1
    ? 'x'
    : version.slice(secondDot + 1)

  node = node.getChild(major)
  if (node === null) return null
  node = node.getChild(minor)
  if (node === null) return null
  node = node.getChild(patch)
  if (node === null) return null
  return node.store
}

SemVerStore.prototype.del = function (version) {
  if (typeof version !== 'string') {
    throw new TypeError('Version should be a string')
  }
  var firstDot = version.indexOf('.')
  var secondDot = version.indexOf('.', firstDot + 1)
  var major = version.slice(0, firstDot)
  var minor = secondDot === -1
    ? version.slice(firstDot + 1)
    : version.slice(firstDot + 1, secondDot)
  var patch = secondDot === -1
    ? 'x'
    : version.slice(secondDot + 1)

  // check existence of major node
  var majorNode = this.tree.children[major]
  if (majorNode == null) return this

  // if minor is the wildcard, then remove the full major node
  if (minor === 'x') {
    this.tree.removeChild(major)
    return this
  }

  // check existence of minor node
  var minorNode = majorNode.children[minor]
  if (minorNode == null) return this

  // if patch is the wildcard, then remove the full minor node
  // and also the major if there are no more children
  if (patch === 'x') {
    this.tree.children[major].removeChild(minor)
    if (this.tree.children[major].length === 0) {
      this.tree.removeChild(major)
    }
    return this
  }

  // check existence of patch node
  var patchNode = minorNode.children[patch]
  if (patchNode == null) return this

  // Specific delete
  this.tree
    .children[major]
    .children[minor]
    .removeChild(patch)

  // check if the minor node has no more children, if so removes it
  // same for the major node
  if (this.tree.children[major].children[minor].length === 0) {
    this.tree.children[major].removeChild(minor)
    if (this.tree.children[major].length === 0) {
      this.tree.removeChild(major)
    }
  }

  return this
}

SemVerStore.prototype.empty = function () {
  this.tree = new Node()
  return this
}

function getMax (arr) {
  var l = arr.length
  var max = arr[0]
  for (var i = 1; i < l; i++) {
    if (arr[i] > max) {
      max = arr[i]
    }
  }
  return max
}

function Node (prefix, children, store) {
  this.prefix = Number(prefix) || 0
  this.children = children || null
  this.childrenPrefixes = children ? Object.keys(children) : []
  this.store = store || null
}

Node.prototype.getChild = function (prefix) {
  if (this.children === null) return null
  if (prefix === 'x') {
    var max = getMax(this.childrenPrefixes)
    return this.children[max]
  }
  return this.children[prefix] || null
}

Node.prototype.addChild = function (node) {
  this.children = this.children || {}
  var child = this.getChild(node.prefix)
  if (child === null) {
    this.children[node.prefix] = node
    this.childrenPrefixes.push(node.prefix)
  }
  return child || node
}

Node.prototype.removeChild = function (prefix) {
  if (prefix === 'x') {
    this.children = null
    this.childrenPrefixes = []
    return this
  }
  if (this.children[prefix] !== undefined) {
    prefix = Number(prefix)
    delete this.children[prefix]
    this.childrenPrefixes.splice(
      this.childrenPrefixes.indexOf(prefix), 1
    )
  }
  return this
}

Node.prototype.setStore = function (store) {
  this.store = store
  return this
}

Object.defineProperty(Node.prototype, 'length', {
  get: function () {
    return this.childrenPrefixes.length
  }
})

module.exports = SemVerStore

},{}],"node_modules/find-my-way/lib/accept-version.js":[function(require,module,exports) {
'use strict';

var SemVerStore = require('semver-store');

module.exports = {
  storage: SemVerStore,
  deriveVersion: function (req, ctx) {
    return req.headers['accept-version'];
  }
};
},{"semver-store":"node_modules/semver-store/index.js"}],"node_modules/find-my-way/index.js":[function(require,module,exports) {
'use strict';
/*
  Char codes:
    '#': 35
    '*': 42
    '-': 45
    '/': 47
    ':': 58
    ';': 59
    '?': 63
*/

var assert = require('assert');

var http = require('http');

var fastDecode = require('fast-decode-uri-component');

var isRegexSafe = require('safe-regex2');

var Node = require('./node');

var NODE_TYPES = Node.prototype.types;
var httpMethods = http.METHODS;
var FULL_PATH_REGEXP = /^https?:\/\/.*\//;

if (!isRegexSafe(FULL_PATH_REGEXP)) {
  throw new Error('the FULL_PATH_REGEXP is not safe, update this module');
}

var acceptVersionStrategy = require('./lib/accept-version');

function Router(opts) {
  if (!(this instanceof Router)) {
    return new Router(opts);
  }

  opts = opts || {};

  if (opts.defaultRoute) {
    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function');
    this.defaultRoute = opts.defaultRoute;
  } else {
    this.defaultRoute = null;
  }

  if (opts.onBadUrl) {
    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function');
    this.onBadUrl = opts.onBadUrl;
  } else {
    this.onBadUrl = null;
  }

  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive;
  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
  this.maxParamLength = opts.maxParamLength || 100;
  this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
  this.versioning = opts.versioning || acceptVersionStrategy;
  this.tree = new Node({
    versions: this.versioning.storage()
  });
  this.routes = [];
}

Router.prototype.on = function on(method, path, opts, handler, store) {
  if (typeof opts === 'function') {
    if (handler !== undefined) {
      store = handler;
    }

    handler = opts;
    opts = {};
  } // path validation


  assert(typeof path === 'string', 'Path should be a string');
  assert(path.length > 0, 'The path could not be empty');
  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`'); // handler validation

  assert(typeof handler === 'function', 'Handler should be a function');

  this._on(method, path, opts, handler, store);

  if (this.ignoreTrailingSlash && path !== '/' && !path.endsWith('*')) {
    if (path.endsWith('/')) {
      this._on(method, path.slice(0, -1), opts, handler, store);
    } else {
      this._on(method, path + '/', opts, handler, store);
    }
  }
};

Router.prototype._on = function _on(method, path, opts, handler, store) {
  if (Array.isArray(method)) {
    for (var k = 0; k < method.length; k++) {
      this._on(method[k], path, opts, handler, store);
    }

    return;
  } // method validation


  assert(typeof method === 'string', 'Method should be a string');
  assert(httpMethods.indexOf(method) !== -1, "Method '".concat(method, "' is not an http method."));
  var params = [];
  var j = 0;
  this.routes.push({
    method: method,
    path: path,
    opts: opts,
    handler: handler,
    store: store
  });
  var version = opts.version;

  for (var i = 0, len = path.length; i < len; i++) {
    // search for parametric or wildcard routes
    // parametric route
    if (path.charCodeAt(i) === 58) {
      var nodeType = NODE_TYPES.PARAM;
      j = i + 1;
      var staticPart = path.slice(0, i);

      if (this.caseSensitive === false) {
        staticPart = staticPart.toLowerCase();
      } // add the static part of the route to the tree


      this._insert(method, staticPart, NODE_TYPES.STATIC, null, null, null, null, version); // isolate the parameter name


      var isRegex = false;

      while (i < len && path.charCodeAt(i) !== 47) {
        isRegex = isRegex || path[i] === '(';

        if (isRegex) {
          i = getClosingParenthensePosition(path, i) + 1;
          break;
        } else if (path.charCodeAt(i) !== 45) {
          i++;
        } else {
          break;
        }
      }

      if (isRegex && (i === len || path.charCodeAt(i) === 47)) {
        nodeType = NODE_TYPES.REGEX;
      } else if (i < len && path.charCodeAt(i) !== 47) {
        nodeType = NODE_TYPES.MULTI_PARAM;
      }

      var parameter = path.slice(j, i);
      var regex = isRegex ? parameter.slice(parameter.indexOf('('), i) : null;

      if (isRegex) {
        regex = new RegExp(regex);

        if (!this.allowUnsafeRegex) {
          assert(isRegexSafe(regex), "The regex '".concat(regex.toString(), "' is not safe!"));
        }
      }

      params.push(parameter.slice(0, isRegex ? parameter.indexOf('(') : i));
      path = path.slice(0, j) + path.slice(i);
      i = j;
      len = path.length; // if the path is ended

      if (i === len) {
        var completedPath = path.slice(0, i);

        if (this.caseSensitive === false) {
          completedPath = completedPath.toLowerCase();
        }

        return this._insert(method, completedPath, nodeType, params, handler, store, regex, version);
      } // add the parameter and continue with the search


      staticPart = path.slice(0, i);

      if (this.caseSensitive === false) {
        staticPart = staticPart.toLowerCase();
      }

      this._insert(method, staticPart, nodeType, params, null, null, regex, version);

      i--; // wildcard route
    } else if (path.charCodeAt(i) === 42) {
      this._insert(method, path.slice(0, i), NODE_TYPES.STATIC, null, null, null, null, version); // add the wildcard parameter


      params.push('*');
      return this._insert(method, path.slice(0, len), NODE_TYPES.MATCH_ALL, params, handler, store, null, version);
    }
  }

  if (this.caseSensitive === false) {
    path = path.toLowerCase();
  } // static route


  this._insert(method, path, NODE_TYPES.STATIC, params, handler, store, null, version);
};

Router.prototype._insert = function _insert(method, path, kind, params, handler, store, regex, version) {
  var route = path;
  var currentNode = this.tree;
  var prefix = '';
  var pathLen = 0;
  var prefixLen = 0;
  var len = 0;
  var max = 0;
  var node = null;

  while (true) {
    prefix = currentNode.prefix;
    prefixLen = prefix.length;
    pathLen = path.length;
    len = 0; // search for the longest common prefix

    max = pathLen < prefixLen ? pathLen : prefixLen;

    while (len < max && path[len] === prefix[len]) {
      len++;
    } // the longest common prefix is smaller than the current prefix
    // let's split the node and add a new child


    if (len < prefixLen) {
      node = new Node({
        prefix: prefix.slice(len),
        children: currentNode.children,
        kind: currentNode.kind,
        handlers: new Node.Handlers(currentNode.handlers),
        regex: currentNode.regex,
        versions: currentNode.versions
      });

      if (currentNode.wildcardChild !== null) {
        node.wildcardChild = currentNode.wildcardChild;
      } // reset the parent


      currentNode.reset(prefix.slice(0, len), this.versioning.storage()).addChild(node); // if the longest common prefix has the same length of the current path
      // the handler should be added to the current node, to a child otherwise

      if (len === pathLen) {
        if (version) {
          assert(!currentNode.getVersionHandler(version, method), "Method '".concat(method, "' already declared for route '").concat(route, "' version '").concat(version, "'"));
          currentNode.setVersionHandler(version, method, handler, params, store);
        } else {
          assert(!currentNode.getHandler(method), "Method '".concat(method, "' already declared for route '").concat(route, "'"));
          currentNode.setHandler(method, handler, params, store);
        }

        currentNode.kind = kind;
      } else {
        node = new Node({
          prefix: path.slice(len),
          kind: kind,
          handlers: null,
          regex: regex,
          versions: this.versioning.storage()
        });

        if (version) {
          node.setVersionHandler(version, method, handler, params, store);
        } else {
          node.setHandler(method, handler, params, store);
        }

        currentNode.addChild(node);
      } // the longest common prefix is smaller than the path length,
      // but is higher than the prefix

    } else if (len < pathLen) {
      // remove the prefix
      path = path.slice(len); // check if there is a child with the label extracted from the new path

      node = currentNode.findByLabel(path); // there is a child within the given label, we must go deepen in the tree

      if (node) {
        currentNode = node;
        continue;
      } // there are not children within the given label, let's create a new one!


      node = new Node({
        prefix: path,
        kind: kind,
        handlers: null,
        regex: regex,
        versions: this.versioning.storage()
      });

      if (version) {
        node.setVersionHandler(version, method, handler, params, store);
      } else {
        node.setHandler(method, handler, params, store);
      }

      currentNode.addChild(node); // the node already exist
    } else if (handler) {
      if (version) {
        assert(!currentNode.getVersionHandler(version, method), "Method '".concat(method, "' already declared for route '").concat(route, "' version '").concat(version, "'"));
        currentNode.setVersionHandler(version, method, handler, params, store);
      } else {
        assert(!currentNode.getHandler(method), "Method '".concat(method, "' already declared for route '").concat(route, "'"));
        currentNode.setHandler(method, handler, params, store);
      }
    }

    return;
  }
};

Router.prototype.reset = function reset() {
  this.tree = new Node({
    versions: this.versioning.storage()
  });
  this.routes = [];
};

Router.prototype.off = function off(method, path) {
  var self = this;

  if (Array.isArray(method)) {
    return method.map(function (method) {
      return self.off(method, path);
    });
  } // method validation


  assert(typeof method === 'string', 'Method should be a string');
  assert(httpMethods.indexOf(method) !== -1, "Method '".concat(method, "' is not an http method.")); // path validation

  assert(typeof path === 'string', 'Path should be a string');
  assert(path.length > 0, 'The path could not be empty');
  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`'); // Rebuild tree without the specific route

  var ignoreTrailingSlash = this.ignoreTrailingSlash;
  var newRoutes = self.routes.filter(function (route) {
    if (!ignoreTrailingSlash) {
      return !(method === route.method && path === route.path);
    }

    if (path.endsWith('/')) {
      var _routeMatches = path === route.path || path.slice(0, -1) === route.path;

      return !(method === route.method && _routeMatches);
    }

    var routeMatches = path === route.path || path + '/' === route.path;
    return !(method === route.method && routeMatches);
  });

  if (ignoreTrailingSlash) {
    newRoutes = newRoutes.filter(function (route, i, ar) {
      if (route.path.endsWith('/') && i < ar.length - 1) {
        return route.path.slice(0, -1) !== ar[i + 1].path;
      } else if (route.path.endsWith('/') === false && i < ar.length - 1) {
        return route.path + '/' !== ar[i + 1].path;
      }

      return true;
    });
  }

  self.reset();
  newRoutes.forEach(function (route) {
    self.on(route.method, route.path, route.opts, route.handler, route.store);
  });
};

Router.prototype.lookup = function lookup(req, res, ctx) {
  var handle = this.find(req.method, sanitizeUrl(req.url), this.versioning.deriveVersion(req, ctx));
  if (handle === null) return this._defaultRoute(req, res, ctx);
  return ctx === undefined ? handle.handler(req, res, handle.params, handle.store) : handle.handler.call(ctx, req, res, handle.params, handle.store);
};

Router.prototype.find = function find(method, path, version) {
  if (path.charCodeAt(0) !== 47) {
    // 47 is '/'
    path = path.replace(FULL_PATH_REGEXP, '/');
  }

  var originalPath = path;
  var originalPathLength = path.length;

  if (this.caseSensitive === false) {
    path = path.toLowerCase();
  }

  var maxParamLength = this.maxParamLength;
  var currentNode = this.tree;
  var wildcardNode = null;
  var pathLenWildcard = 0;
  var decoded = null;
  var pindex = 0;
  var params = [];
  var i = 0;
  var idxInOriginalPath = 0;

  while (true) {
    var pathLen = path.length;
    var prefix = currentNode.prefix;
    var prefixLen = prefix.length;
    var len = 0;
    var previousPath = path; // found the route

    if (pathLen === 0 || path === prefix) {
      var handle = version === undefined ? currentNode.handlers[method] : currentNode.getVersionHandler(version, method);

      if (handle !== null && handle !== undefined) {
        var paramsObj = {};

        if (handle.paramsLength > 0) {
          var paramNames = handle.params;

          for (i = 0; i < handle.paramsLength; i++) {
            paramsObj[paramNames[i]] = params[i];
          }
        }

        return {
          handler: handle.handler,
          params: paramsObj,
          store: handle.store
        };
      }
    } // search for the longest common prefix


    i = pathLen < prefixLen ? pathLen : prefixLen;

    while (len < i && path.charCodeAt(len) === prefix.charCodeAt(len)) {
      len++;
    }

    if (len === prefixLen) {
      path = path.slice(len);
      pathLen = path.length;
      idxInOriginalPath += len;
    }

    var node = version === undefined ? currentNode.findChild(path, method) : currentNode.findVersionChild(version, path, method);

    if (node === null) {
      node = currentNode.parametricBrother;

      if (node === null) {
        return this._getWildcardNode(wildcardNode, method, originalPath, pathLenWildcard);
      }

      if (originalPath.indexOf('/' + previousPath) === -1) {
        // we need to know the outstanding path so far from the originalPath since the last encountered "/" and assign it to previousPath.
        // e.g originalPath: /aa/bbb/cc, path: bb/cc
        // outstanding path: /bbb/cc
        var pathDiff = originalPath.slice(0, originalPathLength - pathLen);
        previousPath = pathDiff.slice(pathDiff.lastIndexOf('/') + 1, pathDiff.length) + path;
      }

      idxInOriginalPath = idxInOriginalPath - (previousPath.length - path.length);
      path = previousPath;
      pathLen = previousPath.length;
      len = prefixLen;
    }

    var kind = node.kind; // static route

    if (kind === NODE_TYPES.STATIC) {
      // if exist, save the wildcard child
      if (currentNode.wildcardChild !== null && currentNode.wildcardChild.handlers[method] !== null) {
        wildcardNode = currentNode.wildcardChild;
        pathLenWildcard = pathLen;
      }

      currentNode = node;
      continue;
    }

    if (len !== prefixLen) {
      return this._getWildcardNode(wildcardNode, method, originalPath, pathLenWildcard);
    } // if exist, save the wildcard child


    if (currentNode.wildcardChild !== null && currentNode.wildcardChild.handlers[method] !== null) {
      wildcardNode = currentNode.wildcardChild;
      pathLenWildcard = pathLen;
    } // parametric route


    if (kind === NODE_TYPES.PARAM) {
      currentNode = node;
      i = path.indexOf('/');
      if (i === -1) i = pathLen;
      if (i > maxParamLength) return null;
      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i));

      if (decoded === null) {
        return this.onBadUrl !== null ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i)) : null;
      }

      params[pindex++] = decoded;
      path = path.slice(i);
      idxInOriginalPath += i;
      continue;
    } // wildcard route


    if (kind === NODE_TYPES.MATCH_ALL) {
      decoded = fastDecode(originalPath.slice(idxInOriginalPath));

      if (decoded === null) {
        return this.onBadUrl !== null ? this._onBadUrl(originalPath.slice(idxInOriginalPath)) : null;
      }

      params[pindex] = decoded;
      currentNode = node;
      path = '';
      continue;
    } // parametric(regex) route


    if (kind === NODE_TYPES.REGEX) {
      currentNode = node;
      i = path.indexOf('/');
      if (i === -1) i = pathLen;
      if (i > maxParamLength) return null;
      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i));

      if (decoded === null) {
        return this.onBadUrl !== null ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i)) : null;
      }

      if (!node.regex.test(decoded)) return null;
      params[pindex++] = decoded;
      path = path.slice(i);
      idxInOriginalPath += i;
      continue;
    } // multiparametric route


    if (kind === NODE_TYPES.MULTI_PARAM) {
      currentNode = node;
      i = 0;

      if (node.regex !== null) {
        var matchedParameter = path.match(node.regex);
        if (matchedParameter === null) return null;
        i = matchedParameter[1].length;
      } else {
        while (i < pathLen && path.charCodeAt(i) !== 47 && path.charCodeAt(i) !== 45) {
          i++;
        }

        if (i > maxParamLength) return null;
      }

      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i));

      if (decoded === null) {
        return this.onBadUrl !== null ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i)) : null;
      }

      params[pindex++] = decoded;
      path = path.slice(i);
      idxInOriginalPath += i;
      continue;
    }

    wildcardNode = null;
  }
};

Router.prototype._getWildcardNode = function (node, method, path, len) {
  if (node === null) return null;
  var decoded = fastDecode(path.slice(-len));

  if (decoded === null) {
    return this.onBadUrl !== null ? this._onBadUrl(path.slice(-len)) : null;
  }

  var handle = node.handlers[method];

  if (handle !== null && handle !== undefined) {
    return {
      handler: handle.handler,
      params: {
        '*': decoded
      },
      store: handle.store
    };
  }

  return null;
};

Router.prototype._defaultRoute = function (req, res, ctx) {
  if (this.defaultRoute !== null) {
    return ctx === undefined ? this.defaultRoute(req, res) : this.defaultRoute.call(ctx, req, res);
  } else {
    res.statusCode = 404;
    res.end();
  }
};

Router.prototype._onBadUrl = function (path) {
  var onBadUrl = this.onBadUrl;
  return {
    handler: function (req, res, ctx) {
      return onBadUrl(path, req, res);
    },
    params: {},
    store: null
  };
};

Router.prototype.prettyPrint = function () {
  return this.tree.prettyPrint('', true);
};

var _loop = function () {
  if (!http.METHODS.hasOwnProperty(i)) return "continue";
  var m = http.METHODS[i];
  var methodName = m.toLowerCase();
  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName);

  Router.prototype[methodName] = function (path, handler, store) {
    return this.on(m, path, handler, store);
  };
};

for (var i in http.METHODS) {
  var _ret = _loop();

  if (_ret === "continue") continue;
}

Router.prototype.all = function (path, handler, store) {
  this.on(httpMethods, path, handler, store);
};

module.exports = Router;

function sanitizeUrl(url) {
  for (var i = 0, len = url.length; i < len; i++) {
    var charCode = url.charCodeAt(i); // Some systems do not follow RFC and separate the path and query
    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.
    // Thus, we need to split on `;` as well as `?` and `#`.

    if (charCode === 63 || charCode === 59 || charCode === 35) {
      return url.slice(0, i);
    }
  }

  return url;
}

function getClosingParenthensePosition(path, idx) {
  // `path.indexOf()` will always return the first position of the closing parenthese,
  // but it's inefficient for grouped or wrong regexp expressions.
  // see issues #62 and #63 for more info
  var parentheses = 1;

  while (idx < path.length) {
    idx++; // ignore skipped chars

    if (path[idx] === '\\') {
      idx++;
      continue;
    }

    if (path[idx] === ')') {
      parentheses--;
    } else if (path[idx] === '(') {
      parentheses++;
    }

    if (!parentheses) return idx;
  }

  throw new TypeError('Invalid regexp expression in "' + path + '"');
}
},{"assert":"node_modules/assert/assert.js","http":"node_modules/stream-http/index.js","fast-decode-uri-component":"node_modules/fast-decode-uri-component/index.js","safe-regex2":"node_modules/safe-regex2/index.js","./node":"node_modules/find-my-way/node.js","./lib/accept-version":"node_modules/find-my-way/lib/accept-version.js"}],"node_modules/forwarded/index.js":[function(require,module,exports) {
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module exports.
 * @public
 */

module.exports = forwarded;
/**
 * Get all addresses in the request, using the `X-Forwarded-For` header.
 *
 * @param {object} req
 * @return {array}
 * @public
 */

function forwarded(req) {
  if (!req) {
    throw new TypeError('argument req is required');
  } // simple header parsing


  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');
  var socketAddr = req.connection.remoteAddress;
  var addrs = [socketAddr].concat(proxyAddrs); // return all addresses

  return addrs;
}
/**
 * Parse the X-Forwarded-For header.
 *
 * @param {string} header
 * @private
 */


function parse(header) {
  var end = header.length;
  var list = [];
  var start = header.length; // gather addresses, backwards

  for (var i = header.length - 1; i >= 0; i--) {
    switch (header.charCodeAt(i)) {
      case 0x20:
        /*   */
        if (start === end) {
          start = end = i;
        }

        break;

      case 0x2c:
        /* , */
        if (start !== end) {
          list.push(header.substring(start, end));
        }

        start = end = i;
        break;

      default:
        start = i;
        break;
    }
  } // final address


  if (start !== end) {
    list.push(header.substring(start, end));
  }

  return list;
}
},{}],"node_modules/ipaddr.js/lib/ipaddr.js":[function(require,module,exports) {
(function () {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
  ipaddr = {};
  root = this;

  if (typeof module !== "undefined" && module !== null && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function (first, second, partSize, cidrBits) {
    var part, shift;

    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }

    part = 0;

    while (cidrBits > 0) {
      shift = partSize - cidrBits;

      if (shift < 0) {
        shift = 0;
      }

      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }

      cidrBits -= partSize;
      part += 1;
    }

    return true;
  };

  ipaddr.subnetMatch = function (address, rangeList, defaultName) {
    var k, len, rangeName, rangeSubnets, subnet;

    if (defaultName == null) {
      defaultName = 'unicast';
    }

    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];

      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }

      for (k = 0, len = rangeSubnets.length; k < len; k++) {
        subnet = rangeSubnets[k];

        if (address.kind() === subnet[0].kind()) {
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
    }

    return defaultName;
  };

  ipaddr.IPv4 = function () {
    function IPv4(octets) {
      var k, len, octet;

      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }

      for (k = 0, len = octets.length; k < len; k++) {
        octet = octets[k];

        if (!(0 <= octet && octet <= 255)) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }

      this.octets = octets;
    }

    IPv4.prototype.kind = function () {
      return 'ipv4';
    };

    IPv4.prototype.toString = function () {
      return this.octets.join(".");
    };

    IPv4.prototype.toNormalizedString = function () {
      return this.toString();
    };

    IPv4.prototype.toByteArray = function () {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function (other, cidrRange) {
      var ref;

      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }

      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }

      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function () {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function () {
      return ipaddr.IPv6.parse("::ffff:" + this.toString());
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function () {
      var cidr, i, k, octet, stop, zeros, zerotable;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;

      for (i = k = 3; k >= 0; i = k += -1) {
        octet = this.octets[i];

        if (octet in zerotable) {
          zeros = zerotable[octet];

          if (stop && zeros !== 0) {
            return null;
          }

          if (zeros !== 8) {
            stop = true;
          }

          cidr += zeros;
        } else {
          return null;
        }
      }

      return 32 - cidr;
    };

    return IPv4;
  }();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function (string) {
    var match, parseIntAuto, part, shift, value;

    parseIntAuto = function (string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };

    if (match = string.match(ipv4Regexes.fourOctet)) {
      return function () {
        var k, len, ref, results;
        ref = match.slice(1, 6);
        results = [];

        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(parseIntAuto(part));
        }

        return results;
      }();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);

      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }

      return function () {
        var k, results;
        results = [];

        for (shift = k = 0; k <= 24; shift = k += 8) {
          results.push(value >> shift & 0xff);
        }

        return results;
      }().reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = function () {
    function IPv6(parts, zoneId) {
      var i, k, l, len, part, ref;

      if (parts.length === 16) {
        this.parts = [];

        for (i = k = 0; k <= 14; i = k += 2) {
          this.parts.push(parts[i] << 8 | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }

      ref = this.parts;

      for (l = 0, len = ref.length; l < len; l++) {
        part = ref[l];

        if (!(0 <= part && part <= 0xffff)) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }

      if (zoneId) {
        this.zoneId = zoneId;
      }
    }

    IPv6.prototype.kind = function () {
      return 'ipv6';
    };

    IPv6.prototype.toString = function () {
      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
    };

    IPv6.prototype.toRFC5952String = function () {
      var bestMatchIndex, bestMatchLength, match, regex, string;
      regex = /((^|:)(0(:|$)){2,})/g;
      string = this.toNormalizedString();
      bestMatchIndex = 0;
      bestMatchLength = -1;

      while (match = regex.exec(string)) {
        if (match[0].length > bestMatchLength) {
          bestMatchIndex = match.index;
          bestMatchLength = match[0].length;
        }
      }

      if (bestMatchLength < 0) {
        return string;
      }

      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
    };

    IPv6.prototype.toByteArray = function () {
      var bytes, k, len, part, ref;
      bytes = [];
      ref = this.parts;

      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }

      return bytes;
    };

    IPv6.prototype.toNormalizedString = function () {
      var addr, part, suffix;

      addr = function () {
        var k, len, ref, results;
        ref = this.parts;
        results = [];

        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16));
        }

        return results;
      }.call(this).join(":");

      suffix = '';

      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }

      return addr + suffix;
    };

    IPv6.prototype.toFixedLengthString = function () {
      var addr, part, suffix;

      addr = function () {
        var k, len, ref, results;
        ref = this.parts;
        results = [];

        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16).padStart(4, '0'));
        }

        return results;
      }.call(this).join(":");

      suffix = '';

      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }

      return addr + suffix;
    };

    IPv6.prototype.match = function (other, cidrRange) {
      var ref;

      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }

      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }

      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function () {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function () {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function () {
      var high, low, ref;

      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }

      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    IPv6.prototype.prefixLengthFromSubnetMask = function () {
      var cidr, i, k, part, stop, zeros, zerotable;
      zerotable = {
        0: 16,
        32768: 15,
        49152: 14,
        57344: 13,
        61440: 12,
        63488: 11,
        64512: 10,
        65024: 9,
        65280: 8,
        65408: 7,
        65472: 6,
        65504: 5,
        65520: 4,
        65528: 3,
        65532: 2,
        65534: 1,
        65535: 0
      };
      cidr = 0;
      stop = false;

      for (i = k = 7; k >= 0; i = k += -1) {
        part = this.parts[i];

        if (part in zerotable) {
          zeros = zerotable[part];

          if (stop && zeros !== 0) {
            return null;
          }

          if (zeros !== 16) {
            stop = true;
          }

          cidr += zeros;
        } else {
          return null;
        }
      }

      return 128 - cidr;
    };

    return IPv6;
  }();

  ipv6Part = "(?:[0-9a-f]+::?)+";
  zoneIndex = "%[0-9a-z]{1,}";
  ipv6Regexes = {
    zoneIndex: new RegExp(zoneIndex, 'i'),
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
    transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
  };

  expandIPv6 = function (string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount, zoneId;

    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }

    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];

    if (zoneId) {
      zoneId = zoneId.substring(1);
      string = string.replace(/%.+$/, '');
    }

    colonCount = 0;
    lastColon = -1;

    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }

    if (string.substr(0, 2) === '::') {
      colonCount--;
    }

    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }

    if (colonCount > parts) {
      return null;
    }

    replacementCount = parts - colonCount;
    replacement = ':';

    while (replacementCount--) {
      replacement += '0:';
    }

    string = string.replace('::', replacement);

    if (string[0] === ':') {
      string = string.slice(1);
    }

    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }

    parts = function () {
      var k, len, ref, results;
      ref = string.split(":");
      results = [];

      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        results.push(parseInt(part, 16));
      }

      return results;
    }();

    return {
      parts: parts,
      zoneId: zoneId
    };
  };

  ipaddr.IPv6.parser = function (string) {
    var addr, k, len, match, octet, octets, zoneId;

    if (ipv6Regexes['native'].test(string)) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      zoneId = match[6] || '';
      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);

      if (addr.parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];

        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];

          if (!(0 <= octet && octet <= 255)) {
            return null;
          }
        }

        addr.parts.push(octets[0] << 8 | octets[1]);
        addr.parts.push(octets[2] << 8 | octets[3]);
        return {
          parts: addr.parts,
          zoneId: addr.zoneId
        };
      }
    }

    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function (string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function (string) {
    var e;

    try {
      new this(this.parser(string));
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.isValidFourPartDecimal = function (string) {
    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
      return true;
    } else {
      return false;
    }
  };

  ipaddr.IPv6.isValid = function (string) {
    var addr, e;

    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }

    try {
      addr = this.parser(string);
      new this(addr.parts, addr.zoneId);
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.parse = function (string) {
    var parts;
    parts = this.parser(string);

    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }

    return new this(parts);
  };

  ipaddr.IPv6.parse = function (string) {
    var addr;
    addr = this.parser(string);

    if (addr.parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }

    return new this(addr.parts, addr.zoneId);
  };

  ipaddr.IPv4.parseCIDR = function (string) {
    var maskLength, match, parsed;

    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);

      if (maskLength >= 0 && maskLength <= 32) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function () {
            return this.join('/');
          }
        });
        return parsed;
      }
    }

    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {
    var filledOctetCount, j, octets;
    prefix = parseInt(prefix);

    if (prefix < 0 || prefix > 32) {
      throw new Error('ipaddr: invalid IPv4 prefix length');
    }

    octets = [0, 0, 0, 0];
    j = 0;
    filledOctetCount = Math.floor(prefix / 8);

    while (j < filledOctetCount) {
      octets[j] = 255;
      j++;
    }

    if (filledOctetCount < 4) {
      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
    }

    return new this(octets);
  };

  ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;

    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;

      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
        i++;
      }

      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv4.networkAddressFromCIDR = function (string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;

    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;

      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
        i++;
      }

      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv6.parseCIDR = function (string) {
    var maskLength, match, parsed;

    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);

      if (maskLength >= 0 && maskLength <= 128) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function () {
            return this.join('/');
          }
        });
        return parsed;
      }
    }

    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function (string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function (string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function (string) {
    var e;

    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (error1) {
      e = error1;

      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (error1) {
        e = error1;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function (bytes) {
    var length;
    length = bytes.length;

    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function (string) {
    var addr;
    addr = this.parse(string);

    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };
}).call(this);
},{}],"node_modules/proxy-addr/index.js":[function(require,module,exports) {
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module exports.
 * @public
 */

module.exports = proxyaddr;
module.exports.all = alladdrs;
module.exports.compile = compile;
/**
 * Module dependencies.
 * @private
 */

var forwarded = require('forwarded');

var ipaddr = require('ipaddr.js');
/**
 * Variables.
 * @private
 */


var DIGIT_REGEXP = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;
/**
 * Pre-defined IP ranges.
 * @private
 */

var IP_RANGES = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
};
/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @public
 */

function alladdrs(req, trust) {
  // get addresses
  var addrs = forwarded(req);

  if (!trust) {
    // Return all addresses
    return addrs;
  }

  if (typeof trust !== 'function') {
    trust = compile(trust);
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue;
    addrs.length = i + 1;
  }

  return addrs;
}
/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */


function compile(val) {
  if (!val) {
    throw new TypeError('argument is required');
  }

  var trust;

  if (typeof val === 'string') {
    trust = [val];
  } else if (Array.isArray(val)) {
    trust = val.slice();
  } else {
    throw new TypeError('unsupported trust argument');
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i];

    if (!IP_RANGES.hasOwnProperty(val)) {
      continue;
    } // Splice in pre-defined range


    val = IP_RANGES[val];
    trust.splice.apply(trust, [i, 1].concat(val));
    i += val.length - 1;
  }

  return compileTrust(compileRangeSubnets(trust));
}
/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */


function compileRangeSubnets(arr) {
  var rangeSubnets = new Array(arr.length);

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i]);
  }

  return rangeSubnets;
}
/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */


function compileTrust(rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length;
  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */


function parseipNotation(note) {
  var pos = note.lastIndexOf('/');
  var str = pos !== -1 ? note.substring(0, pos) : note;

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str);
  }

  var ip = parseip(str);

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address();
  }

  var max = ip.kind() === 'ipv6' ? 128 : 32;
  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;

  if (range === null) {
    range = max;
  } else if (DIGIT_REGEXP.test(range)) {
    range = parseInt(range, 10);
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range);
  } else {
    range = null;
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note);
  }

  return [ip, range];
}
/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */


function parseNetmask(netmask) {
  var ip = parseip(netmask);
  var kind = ip.kind();
  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;
}
/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */


function proxyaddr(req, trust) {
  if (!req) {
    throw new TypeError('req argument is required');
  }

  if (!trust) {
    throw new TypeError('trust argument is required');
  }

  var addrs = alladdrs(req, trust);
  var addr = addrs[addrs.length - 1];
  return addr;
}
/**
 * Static trust function to trust nothing.
 *
 * @private
 */


function trustNone() {
  return false;
}
/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */


function trustMulti(subnets) {
  return function trust(addr) {
    if (!isip(addr)) return false;
    var ip = parseip(addr);
    var ipconv;
    var kind = ip.kind();

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i];
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetrange = subnet[1];
      var trusted = ip;

      if (kind !== subnetkind) {
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
          continue;
        }

        if (!ipconv) {
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }

        trusted = ipconv;
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true;
      }
    }

    return false;
  };
}
/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */


function trustSingle(subnet) {
  var subnetip = subnet[0];
  var subnetkind = subnetip.kind();
  var subnetisipv4 = subnetkind === 'ipv4';
  var subnetrange = subnet[1];
  return function trust(addr) {
    if (!isip(addr)) return false;
    var ip = parseip(addr);
    var kind = ip.kind();

    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        // Incompatible IP addresses
        return false;
      } // Convert IP to match subnet IP kind


      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
    }

    return ip.match(subnetip, subnetrange);
  };
}
},{"forwarded":"node_modules/forwarded/index.js","ipaddr.js":"node_modules/ipaddr.js/lib/ipaddr.js"}],"node_modules/fastify/lib/context.js":[function(require,module,exports) {
'use strict';

var {
  kFourOhFourContext: kFourOhFourContext,
  kReplySerializerDefault: kReplySerializerDefault
} = require('./symbols.js'); // Objects that holds the context of every request
// Every route holds an instance of this object.


function Context(schema, handler, Reply, Request, contentTypeParser, config, errorHandler, bodyLimit, logLevel, attachValidation, replySerializer) {
  this.schema = schema;
  this.handler = handler;
  this.Reply = Reply;
  this.Request = Request;
  this.contentTypeParser = contentTypeParser;
  this.onRequest = null;
  this.onSend = null;
  this.onError = null;
  this.preHandler = null;
  this.onResponse = null;
  this.config = config;
  this.errorHandler = errorHandler || defaultErrorHandler;
  this._middie = null;
  this._parserOptions = {
    limit: bodyLimit || null
  };
  this.logLevel = logLevel;
  this[kFourOhFourContext] = null;
  this.attachValidation = attachValidation;
  this[kReplySerializerDefault] = replySerializer;
}

function defaultErrorHandler(error, request, reply) {
  var res = reply.res;

  if (res.statusCode >= 500) {
    reply.log.error({
      req: reply.request.raw,
      res: res,
      err: error
    }, error && error.message);
  } else if (res.statusCode >= 400) {
    reply.log.info({
      res: res,
      err: error
    }, error && error.message);
  }

  reply.send(error);
}

module.exports = Context;
},{"./symbols.js":"node_modules/fastify/lib/symbols.js"}],"node_modules/path-to-regexp/index.js":[function(require,module,exports) {
/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * Default configs.
 */
var DEFAULT_DELIMITER = '/'

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
  // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
  '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER
  var whitelist = (options && options.whitelist) || undefined
  var pathEscaped = false
  var res

  while ((res = PATH_REGEXP.exec(str)) !== null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      pathEscaped = true
      continue
    }

    var prev = ''
    var name = res[2]
    var capture = res[3]
    var group = res[4]
    var modifier = res[5]

    if (!pathEscaped && path.length) {
      var k = path.length - 1
      var c = path[k]
      var matches = whitelist ? whitelist.indexOf(c) > -1 : true

      if (matches) {
        prev = c
        path = path.slice(0, k)
      }
    }

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
      pathEscaped = false
    }

    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var pattern = capture || group
    var delimiter = prev || defaultDelimiter

    tokens.push({
      name: name || key++,
      prefix: prev,
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      pattern: pattern
        ? escapeGroup(pattern)
        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'
    })
  }

  // Push any remaining characters.
  if (path || index < str.length) {
    tokens.push(path + str.substr(index))
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))
    }
  }

  return function (data, options) {
    var path = ''
    var encode = (options && options.encode) || encodeURIComponent
    var validate = options ? options.validate !== false : true

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token
        continue
      }

      var value = data ? data[token.name] : undefined
      var segment

      if (Array.isArray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but got array')
        }

        if (value.length === 0) {
          if (token.optional) continue

          throw new TypeError('Expected "' + token.name + '" to not be empty')
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j], token)

          if (validate && !matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        segment = encode(String(value), token)

        if (validate && !matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"')
        }

        path += token.prefix + segment
        continue
      }

      if (token.optional) continue

      throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'))
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$/()])/g, '\\$1')
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {Array=}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  if (!keys) return path

  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        pattern: null
      })
    }
  }

  return path
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  return new RegExp('(?:' + parts.join('|') + ')', flags(options))
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}  tokens
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  options = options || {}

  var strict = options.strict
  var start = options.start !== false
  var end = options.end !== false
  var delimiter = options.delimiter || DEFAULT_DELIMITER
  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')
  var route = start ? '^' : ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var capture = token.repeat
        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'
        : token.pattern

      if (keys) keys.push(token)

      if (token.optional) {
        if (!token.prefix) {
          route += '(' + capture + ')?'
        } else {
          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'
        }
      } else {
        route += escapeString(token.prefix) + '(' + capture + ')'
      }
    }
  }

  if (end) {
    if (!strict) route += '(?:' + escapeString(delimiter) + ')?'

    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'
  } else {
    var endToken = tokens[tokens.length - 1]
    var isEndDelimited = typeof endToken === 'string'
      ? endToken[endToken.length - 1] === delimiter
      : endToken === undefined

    if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'
    if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'
  }

  return new RegExp(route, flags(options))
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {Array=}                keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys)
  }

  if (Array.isArray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)
  }

  return stringToRegexp(/** @type {string} */ (path), keys, options)
}

},{}],"node_modules/middie/middie.js":[function(require,module,exports) {
'use strict'

const reusify = require('reusify')
const pathToRegexp = require('path-to-regexp')

function middie (complete) {
  var middlewares = []
  var pool = reusify(Holder)

  return {
    use,
    run
  }

  function use (url, f) {
    if (f === undefined) {
      f = url
      url = null
    }

    var regexp
    if (url) {
      regexp = pathToRegexp(sanitizePrefixUrl(url), [], {
        end: false,
        strict: false
      })
    }

    if (Array.isArray(f)) {
      for (var val of f) {
        middlewares.push({
          regexp,
          fn: val
        })
      }
    } else {
      middlewares.push({
        regexp,
        fn: f
      })
    }

    return this
  }

  function run (req, res, ctx) {
    if (!middlewares.length) {
      complete(null, req, res, ctx)
      return
    }

    req.originalUrl = req.url

    var holder = pool.get()
    holder.req = req
    holder.res = res
    holder.url = sanitizeUrl(req.url)
    holder.context = ctx
    holder.done()
  }

  function Holder () {
    this.next = null
    this.req = null
    this.res = null
    this.url = null
    this.context = null
    this.i = 0

    var that = this
    this.done = function (err) {
      var req = that.req
      var res = that.res
      var url = that.url
      var context = that.context
      var i = that.i++

      req.url = req.originalUrl

      if (res.finished === true) {
        that.req = null
        that.res = null
        that.context = null
        that.i = 0
        pool.release(that)
        return
      }

      if (err || middlewares.length === i) {
        complete(err, req, res, context)
        that.req = null
        that.res = null
        that.context = null
        that.i = 0
        pool.release(that)
      } else {
        var middleware = middlewares[i]
        var fn = middleware.fn
        var regexp = middleware.regexp
        if (regexp) {
          var result = regexp.exec(url)
          if (result) {
            req.url = req.url.replace(result[0], '')
            if (req.url.startsWith('/') === false) {
              req.url = '/' + req.url
            }
            fn(req, res, that.done)
          } else {
            that.done()
          }
        } else {
          fn(req, res, that.done)
        }
      }
    }
  }
}

function sanitizeUrl (url) {
  for (var i = 0, len = url.length; i < len; i++) {
    var charCode = url.charCodeAt(i)
    if (charCode === 63 || charCode === 35) {
      return url.slice(0, i)
    }
  }
  return url
}

function sanitizePrefixUrl (url) {
  if (url === '') return url
  if (url === '/') return ''
  if (url[url.length - 1] === '/') return url.slice(0, -1)
  return url
}

module.exports = middie

},{"reusify":"node_modules/reusify/reusify.js","path-to-regexp":"node_modules/path-to-regexp/index.js"}],"node_modules/fastify/lib/handleRequest.js":[function(require,module,exports) {
'use strict';

var {
  validate: validateSchema
} = require('./validation');

var {
  hookRunner: hookRunner,
  hookIterator: hookIterator
} = require('./hooks');

var wrapThenable = require('./wrapThenable');

function handleRequest(err, request, reply) {
  if (reply.sent === true) return;

  if (err != null) {
    reply.send(err);
    return;
  }

  var method = request.raw.method;
  var headers = request.headers;

  if (method === 'GET' || method === 'HEAD') {
    handler(request, reply);
    return;
  }

  var contentType = headers['content-type'];

  if (method === 'POST' || method === 'PUT' || method === 'PATCH') {
    if (contentType === undefined) {
      if (headers['transfer-encoding'] === undefined && (headers['content-length'] === '0' || headers['content-length'] === undefined)) {
        // Request has no body to parse
        handler(request, reply);
      } else {
        reply.context.contentTypeParser.run('', handler, request, reply);
      }
    } else {
      reply.context.contentTypeParser.run(contentType, handler, request, reply);
    }

    return;
  }

  if (method === 'OPTIONS' || method === 'DELETE') {
    if (contentType !== undefined && (headers['transfer-encoding'] !== undefined || headers['content-length'] !== undefined)) {
      reply.context.contentTypeParser.run(contentType, handler, request, reply);
    } else {
      handler(request, reply);
    }

    return;
  } // Return 404 instead of 405 see https://github.com/fastify/fastify/pull/862 for discussion


  reply.code(404).send(new Error('Not Found'));
}

function handler(request, reply) {
  if (reply.context.preValidation !== null) {
    hookRunner(reply.context.preValidation, hookIterator, request, reply, preValidationCallback);
  } else {
    preValidationCallback(null, request, reply);
  }
}

function preValidationCallback(err, request, reply) {
  if (reply.sent === true || reply.res.finished === true) return;

  if (err != null) {
    reply.send(err);
    return;
  }

  var result = validateSchema(reply.context, request);

  if (result) {
    if (reply.context.attachValidation === false) {
      reply.code(400).send(result);
      return;
    }

    reply.request.validationError = result;
  } // preHandler hook


  if (reply.context.preHandler !== null) {
    hookRunner(reply.context.preHandler, hookIterator, request, reply, preHandlerCallback);
  } else {
    preHandlerCallback(null, request, reply);
  }
}

function preHandlerCallback(err, request, reply) {
  if (reply.sent || reply.res.finished === true) return;

  if (err != null) {
    reply.send(err);
    return;
  }

  var result = reply.context.handler(request, reply);

  if (result && typeof result.then === 'function') {
    wrapThenable(result, reply);
  }
}

module.exports = handleRequest;
module.exports[Symbol.for('internals')] = {
  handler: handler
};
},{"./validation":"node_modules/fastify/lib/validation.js","./hooks":"node_modules/fastify/lib/hooks.js","./wrapThenable":"node_modules/fastify/lib/wrapThenable.js"}],"node_modules/fastify/lib/middleware.js":[function(require,module,exports) {
'use strict';

var Middie = require('middie');

var handleRequest = require('./handleRequest');

var {
  hookRunner: hookRunner,
  hookIterator: hookIterator
} = require('./hooks');

function onRunMiddlewares(err, req, res, reply) {
  if (err != null) {
    reply.send(err);
    return;
  }

  if (reply.context.preParsing !== null) {
    hookRunner(reply.context.preParsing, hookIterator, reply.request, reply, handleRequest);
  } else {
    handleRequest(null, reply.request, reply);
  }
}

module.exports.onRunMiddlewares = onRunMiddlewares;

module.exports.buildMiddie = function buildMiddie(middlewares) {
  if (!middlewares.length) {
    return null;
  }

  var middie = Middie(onRunMiddlewares);

  for (var i = 0; i < middlewares.length; i++) {
    middie.use.apply(middie, middlewares[i]);
  }

  return middie;
};
},{"middie":"node_modules/middie/middie.js","./handleRequest":"node_modules/fastify/lib/handleRequest.js","./hooks":"node_modules/fastify/lib/hooks.js"}],"node_modules/fastify/lib/warnings.js":[function(require,module,exports) {
var process = require("process");
'use strict';

module.exports.beforeHandlerWarning = function beforeHandlerWarning() {
  if (beforeHandlerWarning.called) return;
  beforeHandlerWarning.called = true;
  process.emitWarning('The route option `beforeHandler` has been deprecated, use `preHandler` instead');
};
},{"process":"node_modules/process/browser.js"}],"node_modules/fastify/lib/route.js":[function(require,module,exports) {
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FindMyWay = require('find-my-way');

var proxyAddr = require('proxy-addr');

var Context = require('./context');

var {
  buildMiddie: buildMiddie,
  onRunMiddlewares: onRunMiddlewares
} = require('./middleware');

var {
  hookRunner: hookRunner,
  hookIterator: hookIterator
} = require('./hooks');

var supportedMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS'];
var supportedHooks = ['preParsing', 'preValidation', 'onRequest', 'preHandler', 'preSerialization', 'onResponse'];

var validation = require('./validation');

var buildSchema = validation.build;
var {
  buildSchemaCompiler: buildSchemaCompiler
} = validation;

var {
  beforeHandlerWarning: beforeHandlerWarning
} = require('./warnings');

var {
  codes: {
    FST_ERR_SCH_BUILD: FST_ERR_SCH_BUILD,
    FST_ERR_SCH_MISSING_COMPILER: FST_ERR_SCH_MISSING_COMPILER
  }
} = require('./errors');

var {
  kRoutePrefix: kRoutePrefix,
  kLogLevel: kLogLevel,
  kHooks: kHooks,
  kSchemas: kSchemas,
  kSchemaCompiler: kSchemaCompiler,
  kSchemaResolver: kSchemaResolver,
  kContentTypeParser: kContentTypeParser,
  kReply: kReply,
  kReplySerializerDefault: kReplySerializerDefault,
  kRequest: kRequest,
  kMiddlewares: kMiddlewares,
  kGlobalHooks: kGlobalHooks,
  kDisableRequestLogging: kDisableRequestLogging
} = require('./symbols.js');

function buildRouting(options) {
  var router = FindMyWay(options.config);
  var schemaCache = new Map();
  schemaCache.put = schemaCache.set;
  var avvio;
  var fourOhFour;
  var trustProxy;
  var requestIdHeader;
  var querystringParser;
  var requestIdLogLabel;
  var logger;
  var hasLogger;
  var setupResponseListeners;
  var throwIfAlreadyStarted;
  var proxyFn;
  var modifyCoreObjects;
  var genReqId;
  var disableRequestLogging;
  var ignoreTrailingSlash;
  var return503OnClosing;
  var closing = false;
  return {
    setup: function (options, fastifyArgs) {
      avvio = fastifyArgs.avvio;
      fourOhFour = fastifyArgs.fourOhFour;
      logger = fastifyArgs.logger;
      hasLogger = fastifyArgs.hasLogger;
      setupResponseListeners = fastifyArgs.setupResponseListeners;
      throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
      proxyFn = getTrustProxyFn(options);
      trustProxy = options.trustProxy;
      requestIdHeader = options.requestIdHeader;
      querystringParser = options.querystringParser;
      requestIdLogLabel = options.requestIdLogLabel;
      modifyCoreObjects = options.modifyCoreObjects;
      genReqId = options.genReqId;
      disableRequestLogging = options.disableRequestLogging;
      ignoreTrailingSlash = options.ignoreTrailingSlash;
      return503OnClosing = Object.prototype.hasOwnProperty.call(options, 'return503OnClosing') ? options.return503OnClosing : true;
    },
    routing: router.lookup.bind(router),
    // router func to find the right handler to call
    route: route,
    // configure a route in the fastify instance
    prepareRoute: prepareRoute,
    routeHandler: routeHandler,
    closeRoutes: function () {
      closing = true;
    },
    printRoutes: router.prettyPrint.bind(router)
  }; // Convert shorthand to extended route declaration

  function prepareRoute(method, url, options, handler) {
    if (!handler && typeof options === 'function') {
      handler = options;
      options = {};
    } else if (handler && typeof handler === 'function') {
      if (Object.prototype.toString.call(options) !== '[object Object]') {
        throw new Error("Options for ".concat(method, ":").concat(url, " route must be an object"));
      } else if (options.handler) {
        if (typeof options.handler === 'function') {
          throw new Error("Duplicate handler for ".concat(method, ":").concat(url, " route is not allowed!"));
        } else {
          throw new Error("Handler for ".concat(method, ":").concat(url, " route must be a function"));
        }
      }
    }

    options = Object.assign({}, options, {
      method: method,
      url: url,
      handler: handler || options && options.handler
    });
    return route.call(this, options);
  } // Route management


  function route(opts) {
    var _this = this;

    throwIfAlreadyStarted('Cannot add route when fastify instance is already started!');

    if (Array.isArray(opts.method)) {
      for (var i = 0; i < opts.method.length; i++) {
        if (supportedMethods.indexOf(opts.method[i]) === -1) {
          throw new Error("".concat(opts.method[i], " method is not supported!"));
        }
      }
    } else {
      if (supportedMethods.indexOf(opts.method) === -1) {
        throw new Error("".concat(opts.method, " method is not supported!"));
      }
    }

    if (!opts.handler) {
      throw new Error("Missing handler function for ".concat(opts.method, ":").concat(opts.url, " route."));
    }

    validateBodyLimitOption(opts.bodyLimit);

    if (opts.preHandler == null && opts.beforeHandler != null) {
      beforeHandlerWarning();
      opts.preHandler = opts.beforeHandler;
    }

    var prefix = this[kRoutePrefix];
    this.after(function (notHandledErr, done) {
      var path = opts.url || opts.path;

      if (path === '/' && prefix.length > 0) {
        switch (opts.prefixTrailingSlash) {
          case 'slash':
            afterRouteAdded.call(_this, path, notHandledErr, done);
            break;

          case 'no-slash':
            afterRouteAdded.call(_this, '', notHandledErr, done);
            break;

          case 'both':
          default:
            afterRouteAdded.call(_this, '', notHandledErr, done); // If ignoreTrailingSlash is set to true we need to add only the '' route to prevent adding an incomplete one.

            if (ignoreTrailingSlash !== true) {
              afterRouteAdded.call(_this, path, notHandledErr, done);
            }

        }
      } else if (path[0] === '/' && prefix.endsWith('/')) {
        // Ensure that '/prefix/' + '/route' gets registered as '/prefix/route'
        afterRouteAdded.call(_this, path.slice(1), notHandledErr, done);
      } else {
        afterRouteAdded.call(_this, path, notHandledErr, done);
      }
    }); // chainable api

    return this;

    function afterRouteAdded(path, notHandledErr, done) {
      var _this2 = this;

      var url = prefix + path;
      opts.url = url;
      opts.path = url;
      opts.prefix = prefix;
      opts.logLevel = opts.logLevel || this[kLogLevel];

      if (opts.attachValidation == null) {
        opts.attachValidation = false;
      } // run 'onRoute' hooks


      for (var hook of this[kGlobalHooks].onRoute) {
        try {
          hook.call(this, opts);
        } catch (error) {
          done(error);
          return;
        }
      }

      var config = opts.config || {};
      config.url = url;
      var context = new Context(opts.schema, opts.handler.bind(this), this[kReply], this[kRequest], this[kContentTypeParser], config, this._errorHandler, opts.bodyLimit, opts.logLevel, opts.attachValidation, this[kReplySerializerDefault]); // TODO this needs to be refactored so that buildSchemaCompiler is
      // not called for every single route. Creating a new one for every route
      // is going to be very expensive.

      if (opts.schema) {
        if (this[kSchemaCompiler] == null && this[kSchemaResolver]) {
          done(new FST_ERR_SCH_MISSING_COMPILER(opts.method, url));
          return;
        }

        try {
          if (opts.schemaCompiler == null && this[kSchemaCompiler] == null) {
            var externalSchemas = this[kSchemas].getJsonSchemas({
              onlyAbsoluteUri: true
            });
            this.setSchemaCompiler(buildSchemaCompiler(externalSchemas, schemaCache));
          }

          buildSchema(context, opts.schemaCompiler || this[kSchemaCompiler], this[kSchemas], this[kSchemaResolver]);
        } catch (error) {
          // bubble up the FastifyError instance
          done(error.code ? error : new FST_ERR_SCH_BUILD(opts.method, url, error.message));
          return;
        }
      }

      for (var _hook of supportedHooks) {
        if (opts[_hook]) {
          if (Array.isArray(opts[_hook])) {
            opts[_hook] = opts[_hook].map(function (fn) {
              return fn.bind(_this2);
            });
          } else {
            opts[_hook] = opts[_hook].bind(this);
          }
        }
      }

      try {
        router.on(opts.method, url, {
          version: opts.version
        }, routeHandler, context);
      } catch (err) {
        done(err);
        return;
      } // It can happen that a user register a plugin with some hooks/middlewares *after*
      // the route registration. To be sure to load also that hooks/middlewares,
      // we must listen for the avvio's preReady event, and update the context object accordingly.


      avvio.once('preReady', function () {
        var onResponse = _this2[kHooks].onResponse;
        var onSend = _this2[kHooks].onSend;
        var onError = _this2[kHooks].onError;
        context.onSend = onSend.length ? onSend : null;
        context.onError = onError.length ? onError : null;
        context.onResponse = onResponse.length ? onResponse : null;

        for (var _hook2 of supportedHooks) {
          var toSet = _this2[kHooks][_hook2].concat(opts[_hook2] || []);

          context[_hook2] = toSet.length ? toSet : null;
        }

        context._middie = buildMiddie(_this2[kMiddlewares]); // Must store the 404 Context in 'preReady' because it is only guaranteed to
        // be available after all of the plugins and routes have been loaded.

        fourOhFour.setContext(_this2, context);
      });
      done(notHandledErr);
    }
  } // HTTP request entry point, the routing has already been executed


  function routeHandler(req, res, params, context) {
    var _logger$child;

    if (closing === true) {
      if (req.httpVersionMajor !== 2) {
        res.once('finish', function () {
          return req.destroy();
        });
        res.setHeader('Connection', 'close');
      }

      if (return503OnClosing) {
        var headers = {
          'Content-Type': 'application/json',
          'Content-Length': '80'
        };
        res.writeHead(503, headers);
        res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
        return;
      }
    }

    req.id = req.headers[requestIdHeader] || genReqId(req);
    req.originalUrl = req.url;
    var hostname = req.headers.host;
    var ip = req.connection.remoteAddress;
    var ips;

    if (trustProxy) {
      ip = proxyAddr(req, proxyFn);
      ips = proxyAddr.all(req, proxyFn);

      if (ip !== undefined && req.headers['x-forwarded-host']) {
        hostname = req.headers['x-forwarded-host'];
      }
    }

    var childLogger = logger.child((_logger$child = {}, _defineProperty(_logger$child, requestIdLogLabel, req.id), _defineProperty(_logger$child, "level", context.logLevel), _logger$child));
    childLogger[kDisableRequestLogging] = disableRequestLogging; // added hostname, ip, and ips back to the Node req object to maintain backward compatibility

    if (modifyCoreObjects) {
      req.hostname = hostname;
      req.ip = ip;
      req.ips = ips;
      req.log = res.log = childLogger;
    }

    if (disableRequestLogging === false) {
      childLogger.info({
        req: req
      }, 'incoming request');
    }

    var queryPrefix = req.url.indexOf('?');
    var query = querystringParser(queryPrefix > -1 ? req.url.slice(queryPrefix + 1) : '');
    var request = new context.Request(params, req, query, req.headers, childLogger, ip, ips, hostname);
    var reply = new context.Reply(res, context, request, childLogger);

    if (hasLogger === true || context.onResponse !== null) {
      setupResponseListeners(reply);
    }

    if (context.onRequest !== null) {
      hookRunner(context.onRequest, hookIterator, request, reply, middlewareCallback);
    } else {
      middlewareCallback(null, request, reply);
    }
  }
}

function validateBodyLimitOption(bodyLimit) {
  if (bodyLimit === undefined) return;

  if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
    throw new TypeError("'bodyLimit' option must be an integer > 0. Got '".concat(bodyLimit, "'"));
  }
}

function middlewareCallback(err, request, reply) {
  if (reply.sent === true) return;

  if (err != null) {
    reply.send(err);
    return;
  }

  if (reply.context._middie !== null) {
    reply.context._middie.run(request.raw, reply.res, reply);
  } else {
    onRunMiddlewares(null, null, null, reply);
  }
}

function getTrustProxyFn(options) {
  var tp = options.trustProxy;

  if (typeof tp === 'function') {
    return tp;
  }

  if (tp === true) {
    // Support plain true/false
    return function () {
      return true;
    };
  }

  if (typeof tp === 'number') {
    // Support trusting hop count
    return function (a, i) {
      return i < tp;
    };
  }

  if (typeof tp === 'string') {
    // Support comma-separated tps
    var vals = tp.split(',').map(function (it) {
      return it.trim();
    });
    return proxyAddr.compile(vals);
  }

  return proxyAddr.compile(tp || []);
}

module.exports = {
  buildRouting: buildRouting,
  validateBodyLimitOption: validateBodyLimitOption
};
},{"find-my-way":"node_modules/find-my-way/index.js","proxy-addr":"node_modules/proxy-addr/index.js","./context":"node_modules/fastify/lib/context.js","./middleware":"node_modules/fastify/lib/middleware.js","./hooks":"node_modules/fastify/lib/hooks.js","./validation":"node_modules/fastify/lib/validation.js","./warnings":"node_modules/fastify/lib/warnings.js","./errors":"node_modules/fastify/lib/errors.js","./symbols.js":"node_modules/fastify/lib/symbols.js"}],"node_modules/fastify/lib/fourOhFour.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var FindMyWay = require('find-my-way');

var Reply = require('./reply');

var Request = require('./request');

var Context = require('./context');

var {
  kRoutePrefix: kRoutePrefix,
  kCanSetNotFoundHandler: kCanSetNotFoundHandler,
  kFourOhFourLevelInstance: kFourOhFourLevelInstance,
  kReply: kReply,
  kRequest: kRequest,
  kContentTypeParser: kContentTypeParser,
  kBodyLimit: kBodyLimit,
  kLogLevel: kLogLevel,
  kFourOhFourContext: kFourOhFourContext,
  kMiddlewares: kMiddlewares,
  kHooks: kHooks
} = require('./symbols.js');

var {
  beforeHandlerWarning: beforeHandlerWarning
} = require('./warnings');

var {
  buildMiddie: buildMiddie
} = require('./middleware');
/**
 * Each fastify instance have a:
 * kFourOhFourLevelInstance: point to a fastify instance that has the 404 handler setted
 * kCanSetNotFoundHandler: bool to track if the 404 handler has alredy been set
 * kFourOhFour: the singleton instance of this 404 module
 * kFourOhFourContext: the context in the reply object where the handler will be executed
 */


function fourOhFour(options) {
  var {
    logger: logger,
    modifyCoreObjects: modifyCoreObjects,
    genReqId: genReqId
  } = options; // 404 router, used for handling encapsulated 404 handlers

  var router = FindMyWay({
    defaultRoute: fourOhFourFallBack
  });
  return {
    router: router,
    setNotFoundHandler: setNotFoundHandler,
    setContext: setContext,
    arrange404: arrange404
  };

  function arrange404(instance) {
    // Change the pointer of the fastify instance to itself, so register + prefix can add new 404 handler
    instance[kFourOhFourLevelInstance] = instance;
    instance[kCanSetNotFoundHandler] = true;
  }

  function basic404(request, reply) {
    var {
      url: url,
      method: method
    } = request.raw;
    var message = "Route ".concat(method, ":").concat(url, " not found");
    request.log.info(message);
    reply.code(404).send({
      message: message,
      error: 'Not Found',
      statusCode: 404
    });
  }

  function setContext(instance, context) {
    var _404Context = Object.assign({}, instance[kFourOhFourContext]);

    _404Context.onSend = context.onSend;
    context[kFourOhFourContext] = _404Context;
  }

  function setNotFoundHandler(opts, handler, avvio, routeHandler) {
    var _this = this;

    // First initialization of the fastify root instance
    if (this[kCanSetNotFoundHandler] === undefined) {
      this[kCanSetNotFoundHandler] = true;
    }

    if (this[kFourOhFourContext] === undefined) {
      this[kFourOhFourContext] = null;
    }

    var _fastify = this;

    var prefix = this[kRoutePrefix] || '/';

    if (this[kCanSetNotFoundHandler] === false) {
      throw new Error("Not found handler already set for Fastify instance with prefix: '".concat(prefix, "'"));
    }

    if (_typeof(opts) === 'object') {
      if (opts.preHandler == null && opts.beforeHandler != null) {
        beforeHandlerWarning();
        opts.preHandler = opts.beforeHandler;
      }

      if (opts.preHandler) {
        if (Array.isArray(opts.preHandler)) {
          opts.preHandler = opts.preHandler.map(function (hook) {
            return hook.bind(_fastify);
          });
        } else {
          opts.preHandler = opts.preHandler.bind(_fastify);
        }
      }

      if (opts.preValidation) {
        if (Array.isArray(opts.preValidation)) {
          opts.preValidation = opts.preValidation.map(function (hook) {
            return hook.bind(_fastify);
          });
        } else {
          opts.preValidation = opts.preValidation.bind(_fastify);
        }
      }
    }

    if (typeof opts === 'function') {
      handler = opts;
      opts = undefined;
    }

    opts = opts || {};

    if (handler) {
      this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
      handler = handler.bind(this);
    } else {
      handler = basic404;
    }

    this.after(function (notHandledErr, done) {
      _setNotFoundHandler.call(_this, prefix, opts, handler, avvio, routeHandler);

      done(notHandledErr);
    });
  }

  function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
    var _this2 = this;

    var context = new Context(opts.schema, handler, this[kReply], this[kRequest], this[kContentTypeParser], opts.config || {}, this._errorHandler, this[kBodyLimit], this[kLogLevel]);
    avvio.once('preReady', function () {
      var context = _this2[kFourOhFourContext];
      var onRequest = _this2[kHooks].onRequest;

      var preParsing = _this2[kHooks].preParsing.concat(opts.preParsing || []);

      var preValidation = _this2[kHooks].preValidation.concat(opts.preValidation || []);

      var preSerialization = _this2[kHooks].preSerialization.concat(opts.preSerialization || []);

      var preHandler = _this2[kHooks].preHandler.concat(opts.beforeHandler || opts.preHandler || []);

      var onSend = _this2[kHooks].onSend;
      var onError = _this2[kHooks].onError;
      var onResponse = _this2[kHooks].onResponse;
      context.onRequest = onRequest.length ? onRequest : null;
      context.preParsing = preParsing.length ? preParsing : null;
      context.preValidation = preValidation.length ? preValidation : null;
      context.preSerialization = preSerialization.length ? preSerialization : null;
      context.preHandler = preHandler.length ? preHandler : null;
      context.onSend = onSend.length ? onSend : null;
      context.onError = onError.length ? onError : null;
      context.onResponse = onResponse.length ? onResponse : null;
      context._middie = buildMiddie(_this2[kMiddlewares]);
    });

    if (this[kFourOhFourContext] !== null && prefix === '/') {
      Object.assign(this[kFourOhFourContext], context); // Replace the default 404 handler

      return;
    }

    this[kFourOhFourLevelInstance][kFourOhFourContext] = context;
    router.all(prefix + (prefix.endsWith('/') ? '*' : '/*'), routeHandler, context);
    router.all(prefix || '/', routeHandler, context);
  }

  function fourOhFourFallBack(req, res) {
    // if this happen, we have a very bad bug
    // we might want to do some hard debugging
    // here, let's print out as much info as
    // we can
    req.id = genReqId(req);
    req.originalUrl = req.url;
    var childLogger = logger.child({
      reqId: req.id
    });

    if (modifyCoreObjects) {
      req.log = res.log = childLogger;
    }

    childLogger.info({
      req: req
    }, 'incoming request');
    var request = new Request(null, req, null, req.headers, childLogger);
    var reply = new Reply(res, {
      onSend: [],
      onError: []
    }, request, childLogger);
    request.log.warn('the default handler for 404 did not catch this, this is likely a fastify bug, please report it');
    request.log.warn(router.prettyPrint());
    reply.code(404).send(new Error('Not Found'));
  }
}

module.exports = fourOhFour;
},{"find-my-way":"node_modules/find-my-way/index.js","./reply":"node_modules/fastify/lib/reply.js","./request":"node_modules/fastify/lib/request.js","./context":"node_modules/fastify/lib/context.js","./symbols.js":"node_modules/fastify/lib/symbols.js","./warnings":"node_modules/fastify/lib/warnings.js","./middleware":"node_modules/fastify/lib/middleware.js"}],"node_modules/fastify/lib/configValidator.js":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// This file is autogenerated by build/build-validation.js, do not edit

/* istanbul ignore file */
// constant needed for customRule0 to work
var self = {};
'use strict';

var validate = function () {
  var refVal = [];
  return function validate(data, dataPath, parentData, parentDataProperty, rootData) {
    'use strict';

    var vErrors = null;
    var errors = 0;
    if (rootData === undefined) rootData = data;

    if (data && _typeof(data) === "object" && !Array.isArray(data)) {
      if (data.bodyLimit === undefined) data.bodyLimit = 1048576;
      if (data.caseSensitive === undefined) data.caseSensitive = true;
      if (data.disableRequestLogging === undefined) data.disableRequestLogging = false;
      if (data.ignoreTrailingSlash === undefined) data.ignoreTrailingSlash = false;
      if (data.maxParamLength === undefined) data.maxParamLength = 100;
      if (data.onProtoPoisoning === undefined) data.onProtoPoisoning = "error";
      if (data.pluginTimeout === undefined) data.pluginTimeout = 10000;
      if (data.requestIdHeader === undefined) data.requestIdHeader = "request-id";
      if (data.requestIdLogLabel === undefined) data.requestIdLogLabel = "reqId";
      var errs__0 = errors;
      var valid1 = true;

      for (var key0 in data) {
        var isAdditional0 = !(false || validate.schema.properties.hasOwnProperty(key0));

        if (isAdditional0) {
          delete data[key0];
        }
      }

      if (valid1) {
        var data1 = data.bodyLimit;
        var errs_1 = errors;

        if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
          var dataType1 = _typeof(data1);

          var coerced1 = undefined;
          if (dataType1 == 'boolean' || data1 === null || dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1)) coerced1 = +data1;

          if (coerced1 === undefined) {
            validate.errors = [{
              keyword: 'type',
              dataPath: (dataPath || '') + '.bodyLimit',
              schemaPath: '#/properties/bodyLimit/type',
              params: {
                type: 'integer'
              },
              message: 'should be integer'
            }];
            return false;
          } else {
            data1 = coerced1;
            data['bodyLimit'] = coerced1;
          }
        }

        var valid1 = errors === errs_1;

        if (valid1) {
          var data1 = data.caseSensitive;
          var errs_1 = errors;

          if (typeof data1 !== "boolean") {
            var dataType1 = _typeof(data1);

            var coerced1 = undefined;
            if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;else if (data1 === 'true' || data1 === 1) coerced1 = true;

            if (coerced1 === undefined) {
              validate.errors = [{
                keyword: 'type',
                dataPath: (dataPath || '') + '.caseSensitive',
                schemaPath: '#/properties/caseSensitive/type',
                params: {
                  type: 'boolean'
                },
                message: 'should be boolean'
              }];
              return false;
            } else {
              data1 = coerced1;
              data['caseSensitive'] = coerced1;
            }
          }

          var valid1 = errors === errs_1;

          if (valid1) {
            var data1 = data.http2;

            if (data1 === undefined) {
              valid1 = true;
            } else {
              var errs_1 = errors;

              if (typeof data1 !== "boolean") {
                var dataType1 = _typeof(data1);

                var coerced1 = undefined;
                if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;else if (data1 === 'true' || data1 === 1) coerced1 = true;

                if (coerced1 === undefined) {
                  validate.errors = [{
                    keyword: 'type',
                    dataPath: (dataPath || '') + '.http2',
                    schemaPath: '#/properties/http2/type',
                    params: {
                      type: 'boolean'
                    },
                    message: 'should be boolean'
                  }];
                  return false;
                } else {
                  data1 = coerced1;
                  data['http2'] = coerced1;
                }
              }

              var valid1 = errors === errs_1;
            }

            if (valid1) {
              var data1 = data.https;

              if (data1 === undefined) {
                valid1 = true;
              } else {
                var errs_1 = errors;
                var errs__1 = errors;
                var valid1 = true;
                var errs_2 = errors;
                var errs__2 = errors;
                var errs_3 = errors;
                var errs__3 = errors,
                    prevValid3 = false,
                    valid3 = false,
                    passingSchemas3 = null;
                var errs_4 = errors;

                if (typeof data1 !== "boolean") {
                  var dataType4 = _typeof(data1);

                  var coerced4 = undefined;
                  if (data1 === 'false' || data1 === 0 || data1 === null) coerced4 = false;else if (data1 === 'true' || data1 === 1) coerced4 = true;

                  if (coerced4 === undefined) {
                    var err = {};
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    data1 = coerced4;
                    data['https'] = coerced4;
                  }
                }

                var valid4 = errors === errs_4;

                if (valid4) {
                  valid3 = prevValid3 = true;
                  passingSchemas3 = 0;
                }

                var errs_4 = errors;

                if (data1 !== null) {
                  var dataType4 = _typeof(data1);

                  var coerced4 = undefined;
                  if (data1 === '' || data1 === 0 || data1 === false) coerced4 = null;

                  if (coerced4 === undefined) {
                    var err = {};
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    data1 = coerced4;
                    data['https'] = coerced4;
                  }
                }

                var valid4 = errors === errs_4;

                if (valid4 && prevValid3) {
                  valid3 = false;
                  passingSchemas3 = [passingSchemas3, 1];
                } else {
                  if (valid4) {
                    valid3 = prevValid3 = true;
                    passingSchemas3 = 1;
                  }

                  var errs_4 = errors;

                  if (data1 && _typeof(data1) === "object" && !Array.isArray(data1)) {
                    if (true) {
                      var errs__4 = errors;
                      var valid5 = true;

                      for (var key4 in data1) {
                        var isAdditional4 = !(false || key4 == 'allowHTTP1');

                        if (isAdditional4) {
                          delete data1[key4];
                        }
                      }

                      if (valid5) {
                        var data2 = data1.allowHTTP1;

                        if (data2 === undefined) {
                          valid5 = false;
                          var err = {};
                          if (vErrors === null) vErrors = [err];else vErrors.push(err);
                          errors++;
                        } else {
                          var errs_5 = errors;

                          if (typeof data2 !== "boolean") {
                            var dataType5 = _typeof(data2);

                            var coerced5 = undefined;
                            if (data2 === 'false' || data2 === 0 || data2 === null) coerced5 = false;else if (data2 === 'true' || data2 === 1) coerced5 = true;

                            if (coerced5 === undefined) {
                              var err = {};
                              if (vErrors === null) vErrors = [err];else vErrors.push(err);
                              errors++;
                            } else {
                              data2 = coerced5;
                              data1['allowHTTP1'] = coerced5;
                            }
                          }

                          var valid5 = errors === errs_5;
                        }
                      }
                    }
                  } else {
                    var err = {};
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4 && prevValid3) {
                    valid3 = false;
                    passingSchemas3 = [passingSchemas3, 2];
                  } else {
                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 2;
                    }
                  }
                }

                if (!valid3) {
                  var err = {};
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {
                  errors = errs__3;

                  if (vErrors !== null) {
                    if (errs__3) vErrors.length = errs__3;else vErrors = null;
                  }
                }

                var valid3 = errors === errs_3;

                if (valid3) {
                  var err = {};
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {
                  errors = errs__2;

                  if (vErrors !== null) {
                    if (errs__2) vErrors.length = errs__2;else vErrors = null;
                  }
                }

                var valid2 = errors === errs_2;
                errors = errs__1;

                if (vErrors !== null) {
                  if (errs__1) vErrors.length = errs__1;else vErrors = null;
                }

                if (valid2) {
                  var errs_2 = errors;
                  customRule0.errors = null;
                  var errs__2 = errors;
                  var valid2;
                  valid2 = customRule0.call(self, validate.schema.properties.https.then.setDefaultValue, data1, validate.schema.properties.https.then, (dataPath || '') + '.https', data, 'https', rootData);
                  if (data) data1 = data['https'];

                  if (!valid2) {
                    validate.errors = [{
                      keyword: 'setDefaultValue',
                      dataPath: (dataPath || '') + '.https',
                      schemaPath: '#/properties/https/then/setDefaultValue',
                      params: {
                        keyword: 'setDefaultValue'
                      },
                      message: 'should pass "setDefaultValue" keyword validation'
                    }];
                    return false;
                  }

                  var valid2 = errors === errs_2;
                  valid1 = valid2;
                }

                if (!valid1) {
                  var err = {
                    keyword: 'if',
                    dataPath: (dataPath || '') + '.https',
                    schemaPath: '#/properties/https/if',
                    params: {
                      failingKeyword: 'then'
                    },
                    message: 'should match "' + 'then' + '" schema'
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                  validate.errors = vErrors;
                  return false;
                }

                var valid1 = errors === errs_1;
              }

              if (valid1) {
                var data1 = data.ignoreTrailingSlash;
                var errs_1 = errors;

                if (typeof data1 !== "boolean") {
                  var dataType1 = _typeof(data1);

                  var coerced1 = undefined;
                  if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;else if (data1 === 'true' || data1 === 1) coerced1 = true;

                  if (coerced1 === undefined) {
                    validate.errors = [{
                      keyword: 'type',
                      dataPath: (dataPath || '') + '.ignoreTrailingSlash',
                      schemaPath: '#/properties/ignoreTrailingSlash/type',
                      params: {
                        type: 'boolean'
                      },
                      message: 'should be boolean'
                    }];
                    return false;
                  } else {
                    data1 = coerced1;
                    data['ignoreTrailingSlash'] = coerced1;
                  }
                }

                var valid1 = errors === errs_1;

                if (valid1) {
                  var data1 = data.maxParamLength;
                  var errs_1 = errors;

                  if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                    var dataType1 = _typeof(data1);

                    var coerced1 = undefined;
                    if (dataType1 == 'boolean' || data1 === null || dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1)) coerced1 = +data1;

                    if (coerced1 === undefined) {
                      validate.errors = [{
                        keyword: 'type',
                        dataPath: (dataPath || '') + '.maxParamLength',
                        schemaPath: '#/properties/maxParamLength/type',
                        params: {
                          type: 'integer'
                        },
                        message: 'should be integer'
                      }];
                      return false;
                    } else {
                      data1 = coerced1;
                      data['maxParamLength'] = coerced1;
                    }
                  }

                  var valid1 = errors === errs_1;

                  if (valid1) {
                    var data1 = data.onProtoPoisoning;
                    var errs_1 = errors;

                    if (typeof data1 !== "string") {
                      var dataType1 = _typeof(data1);

                      var coerced1 = undefined;
                      if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;else if (data1 === null) coerced1 = '';

                      if (coerced1 === undefined) {
                        validate.errors = [{
                          keyword: 'type',
                          dataPath: (dataPath || '') + '.onProtoPoisoning',
                          schemaPath: '#/properties/onProtoPoisoning/type',
                          params: {
                            type: 'string'
                          },
                          message: 'should be string'
                        }];
                        return false;
                      } else {
                        data1 = coerced1;
                        data['onProtoPoisoning'] = coerced1;
                      }
                    }

                    var valid1 = errors === errs_1;

                    if (valid1) {
                      var data1 = data.pluginTimeout;
                      var errs_1 = errors;

                      if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                        var dataType1 = _typeof(data1);

                        var coerced1 = undefined;
                        if (dataType1 == 'boolean' || data1 === null || dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1)) coerced1 = +data1;

                        if (coerced1 === undefined) {
                          validate.errors = [{
                            keyword: 'type',
                            dataPath: (dataPath || '') + '.pluginTimeout',
                            schemaPath: '#/properties/pluginTimeout/type',
                            params: {
                              type: 'integer'
                            },
                            message: 'should be integer'
                          }];
                          return false;
                        } else {
                          data1 = coerced1;
                          data['pluginTimeout'] = coerced1;
                        }
                      }

                      var valid1 = errors === errs_1;

                      if (valid1) {
                        var data1 = data.requestIdHeader;
                        var errs_1 = errors;

                        if (typeof data1 !== "string") {
                          var dataType1 = _typeof(data1);

                          var coerced1 = undefined;
                          if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;else if (data1 === null) coerced1 = '';

                          if (coerced1 === undefined) {
                            validate.errors = [{
                              keyword: 'type',
                              dataPath: (dataPath || '') + '.requestIdHeader',
                              schemaPath: '#/properties/requestIdHeader/type',
                              params: {
                                type: 'string'
                              },
                              message: 'should be string'
                            }];
                            return false;
                          } else {
                            data1 = coerced1;
                            data['requestIdHeader'] = coerced1;
                          }
                        }

                        var valid1 = errors === errs_1;

                        if (valid1) {
                          var data1 = data.requestIdLogLabel;
                          var errs_1 = errors;

                          if (typeof data1 !== "string") {
                            var dataType1 = _typeof(data1);

                            var coerced1 = undefined;
                            if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;else if (data1 === null) coerced1 = '';

                            if (coerced1 === undefined) {
                              validate.errors = [{
                                keyword: 'type',
                                dataPath: (dataPath || '') + '.requestIdLogLabel',
                                schemaPath: '#/properties/requestIdLogLabel/type',
                                params: {
                                  type: 'string'
                                },
                                message: 'should be string'
                              }];
                              return false;
                            } else {
                              data1 = coerced1;
                              data['requestIdLogLabel'] = coerced1;
                            }
                          }

                          var valid1 = errors === errs_1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate.errors = [{
        keyword: 'type',
        dataPath: (dataPath || '') + "",
        schemaPath: '#/type',
        params: {
          type: 'object'
        },
        message: 'should be object'
      }];
      return false;
    }

    validate.errors = vErrors;
    return errors === 0;
  };
}();

validate.schema = {
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "bodyLimit": {
      "type": "integer",
      "default": 1048576
    },
    "caseSensitive": {
      "type": "boolean",
      "default": true
    },
    "http2": {
      "type": "boolean"
    },
    "https": {
      "if": {
        "not": {
          "oneOf": [{
            "type": "boolean"
          }, {
            "type": "null"
          }, {
            "type": "object",
            "additionalProperties": false,
            "required": ["allowHTTP1"],
            "properties": {
              "allowHTTP1": {
                "type": "boolean"
              }
            }
          }]
        }
      },
      "then": {
        "setDefaultValue": true
      }
    },
    "disableRequestLogging": {
      "type": "boolean",
      "default": false
    },
    "ignoreTrailingSlash": {
      "type": "boolean",
      "default": false
    },
    "maxParamLength": {
      "type": "integer",
      "default": 100
    },
    "onProtoPoisoning": {
      "type": "string",
      "default": "error"
    },
    "pluginTimeout": {
      "type": "integer",
      "default": 10000
    },
    "requestIdHeader": {
      "type": "string",
      "default": "request-id"
    },
    "requestIdLogLabel": {
      "type": "string",
      "default": "reqId"
    }
  }
};
validate.errors = null;
module.exports = validate;

function customRule0(schemaParamValue, validatedParamValue, validationSchemaObject, currentDataPath, validatedParamObject, validatedParam) {
  validatedParamObject[validatedParam] = schemaParamValue;
  return true;
}

module.exports.defaultInitOptions = {
  "bodyLimit": 1048576,
  "caseSensitive": true,
  "disableRequestLogging": false,
  "ignoreTrailingSlash": false,
  "maxParamLength": 100,
  "onProtoPoisoning": "error",
  "pluginTimeout": 10000,
  "requestIdHeader": "request-id",
  "requestIdLogLabel": "reqId"
};
},{}],"node_modules/fastify/lib/initialConfigValidation.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var validate = require('./configValidator');

var deepClone = require('rfdc')({
  circles: true,
  proto: false
});

var {
  codes: {
    FST_ERR_INIT_OPTS_INVALID: FST_ERR_INIT_OPTS_INVALID
  }
} = require('./errors');

function validateInitialConfig(options) {
  var opts = deepClone(options);

  if (!validate(opts)) {
    var error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map(function (e) {
      return e.message;
    })));
    error.errors = validate.errors;
    throw error;
  }

  return deepFreezeObject(opts);
}

function deepFreezeObject(object) {
  var properties = Object.getOwnPropertyNames(object);

  for (var name of properties) {
    var value = object[name];

    if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
      continue;
    }

    object[name] = value && _typeof(value) === 'object' ? deepFreezeObject(value) : value;
  }

  return Object.freeze(object);
}

module.exports = validateInitialConfig;
module.exports.defaultInitOptions = validate.defaultInitOptions;
module.exports.utils = {
  deepFreezeObject: deepFreezeObject
};
},{"./configValidator":"node_modules/fastify/lib/configValidator.js","rfdc":"node_modules/rfdc/index.js","./errors":"node_modules/fastify/lib/errors.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;
},{"events":"node_modules/events/events.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/buffer_list.js":[function(require,module,exports) {

'use strict';

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  var _proto = BufferList.prototype;

  _proto.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  _proto.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  _proto.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  _proto.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  _proto.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  _proto.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  } // Consumes a specified amount of bytes or characters from the buffered data.
  ;

  _proto.consume = function consume(n, hasStrings) {
    var ret;

    if (n < this.head.data.length) {
      // `slice` is the same for buffers and strings.
      ret = this.head.data.slice(0, n);
      this.head.data = this.head.data.slice(n);
    } else if (n === this.head.data.length) {
      // First chunk is a perfect match.
      ret = this.shift();
    } else {
      // Result spans more than one buffer.
      ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    }

    return ret;
  };

  _proto.first = function first() {
    return this.head.data;
  } // Consumes a specified amount of characters from the buffered data.
  ;

  _proto._getString = function _getString(n) {
    var p = this.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;

    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;

      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = str.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Consumes a specified amount of bytes from the buffered data.
  ;

  _proto._getBuffer = function _getBuffer(n) {
    var ret = Buffer.allocUnsafe(n);
    var p = this.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;

    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;

      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = buf.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Make sure the linked list only shows the minimal necessary information.
  ;

  _proto[custom] = function (_, options) {
    return inspect(this, _objectSpread({}, options, {
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    }));
  };

  return BufferList;
}();
},{"buffer":"node_modules/buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
var process = require("process");
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      process.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      process.nextTick(emitErrorAndCloseNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process":"node_modules/process/browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/errors-browser.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;
},{}],"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/state.js":[function(require,module,exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":"node_modules/light-my-request/node_modules/readable-stream/errors-browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/experimentalWarning.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var experimentalWarnings = new Set();

function emitExperimentalWarning(feature) {
  if (experimentalWarnings.has(feature)) return;
  var msg = feature + ' is an experimental feature. This feature could ' + 'change at any time';
  experimentalWarnings.add(feature);
  process.emitWarning(msg, 'ExperimentalWarning');
}

function noop() {}

module.exports.emitExperimentalWarning = process.emitWarning ? emitExperimentalWarning : noop;
},{"process":"node_modules/process/browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    stream.emit('error', er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
},{"util-deprecate":"node_modules/util-deprecate/browser.js","./internal/streams/stream":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/stream-browser.js","buffer":"node_modules/buffer/index.js","./internal/streams/destroy":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/state.js","../errors":"node_modules/light-my-request/node_modules/readable-stream/errors-browser.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_duplex":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_duplex.js","process":"node_modules/process/browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
},{"./_stream_readable":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_writable.js","inherits":"node_modules/inherits/inherits_browser.js","process":"node_modules/process/browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":"node_modules/light-my-request/node_modules/readable-stream/errors-browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/async_iterator.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
},{"./end-of-stream":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","process":"node_modules/process/browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

var _require2 = require('../experimentalWarning'),
    emitExperimentalWarning = _require2.emitExperimentalWarning; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;

require('inherits')(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc); // if setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    emitExperimentalWarning('Readable[Symbol.asyncIterator]');

    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
},{"events":"node_modules/events/events.js","./internal/streams/stream":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/stream-browser.js","buffer":"node_modules/buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/buffer_list":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/state.js","../errors":"node_modules/light-my-request/node_modules/readable-stream/errors-browser.js","../experimentalWarning":"node_modules/light-my-request/node_modules/readable-stream/experimentalWarning.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_duplex":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"node_modules/string_decoder/lib/string_decoder.js","./internal/streams/async_iterator":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/async_iterator.js","process":"node_modules/process/browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":"node_modules/light-my-request/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_transform.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/pipeline.js":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":"node_modules/light-my-request/node_modules/readable-stream/errors-browser.js","./end-of-stream":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}],"node_modules/light-my-request/node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');
},{"./lib/_stream_readable.js":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"node_modules/light-my-request/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/internal/streams/end-of-stream.js":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"node_modules/light-my-request/node_modules/readable-stream/lib/internal/streams/pipeline.js"}],"node_modules/light-my-request/lib/parseURL.js":[function(require,module,exports) {
'use strict'

const { URL } = require('url')

const BASE_URL = 'http://localhost'

/**
 * Parse URL
 *
 * @param {(Object|String)} url
 * @param {Object} [query]
 * @return {URL}
 */
module.exports = function parseURL (url, query) {
  const result = typeof url === 'object'
    ? Object.assign(new URL(BASE_URL), url)
    : new URL(url, BASE_URL)

  const merged = Object.assign({}, url.query, query)
  Object.keys(merged).forEach(key => {
    const value = merged[key]

    if (Array.isArray(value)) {
      result.searchParams.delete(key)
      value.forEach(param => {
        result.searchParams.append(key, param)
      })
    } else {
      result.searchParams.set(key, value)
    }
  })

  return result
}

},{"url":"node_modules/url/url.js"}],"node_modules/light-my-request/lib/request.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict'

const { Readable } = require('readable-stream')
const util = require('util')

const parseURL = require('./parseURL')

/**
 * Get hostname:port
 *
 * @param {URL} parsedURL
 * @return {String}
 */
function hostHeaderFromURL (parsedURL) {
  return parsedURL.port
    ? parsedURL.host
    : parsedURL.hostname + (parsedURL.protocol === 'https:' ? ':443' : ':80')
}

/**
 * Request
 *
 * @constructor
 * @param {Object} options
 * @param {(Object|String)} options.url || options.path
 * @param {String} [options.method='GET']
 * @param {String} [options.remoteAddress]
 * @param {Object} [options.headers]
 * @param {Object} [options.query]
 * @param {any} [options.payload]
 */
function Request (options) {
  Readable.call(this)

  const parsedURL = parseURL(options.url || options.path, options.query)

  this.url = parsedURL.pathname + parsedURL.search

  this.httpVersion = '1.1'
  this.method = options.method ? options.method.toUpperCase() : 'GET'

  this.headers = {}
  const headers = options.headers || {}
  Object.keys(headers).forEach((field) => {
    this.headers[field.toLowerCase()] = headers[field]
  })

  this.headers['user-agent'] = this.headers['user-agent'] || 'lightMyRequest'
  this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL)

  this.connection = {
    remoteAddress: options.remoteAddress || '127.0.0.1'
  }

  // we keep both payload and body for compatibility reasons
  var payload = options.payload || options.body || null
  if (payload && typeof payload !== 'string' && !(typeof payload.resume === 'function') && !Buffer.isBuffer(payload)) {
    payload = JSON.stringify(payload)
    this.headers['content-type'] = this.headers['content-type'] || 'application/json'
  }

  // Set the content-length for the corresponding payload if none set
  if (payload && !(typeof payload.resume === 'function') && !this.headers.hasOwnProperty('content-length')) {
    this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString()
  }

  // Use _lightMyRequest namespace to avoid collision with Node
  this._lightMyRequest = {
    payload,
    isDone: false,
    simulate: options.simulate || {}
  }

  return this
}

util.inherits(Request, Readable)

Request.prototype.prepare = function (next) {
  const payload = this._lightMyRequest.payload
  if (!payload || typeof payload.resume !== 'function') { // does not quack like a stream
    return next()
  }

  const chunks = []

  payload.on('data', (chunk) => chunks.push(Buffer.from(chunk)))

  payload.on('end', () => {
    const payload = Buffer.concat(chunks)
    this.headers['content-length'] = this.headers['content-length'] || ('' + payload.length)
    this._lightMyRequest.payload = payload
    return next()
  })

  // Force to resume the stream. Needed for Stream 1
  payload.resume()
}

Request.prototype._read = function (size) {
  setImmediate(() => {
    if (this._lightMyRequest.isDone) {
      // 'end' defaults to true
      if (this._lightMyRequest.simulate.end !== false) {
        this.push(null)
      }

      return
    }

    this._lightMyRequest.isDone = true

    if (this._lightMyRequest.payload) {
      if (this._lightMyRequest.simulate.split) {
        this.push(this._lightMyRequest.payload.slice(0, 1))
        this.push(this._lightMyRequest.payload.slice(1))
      } else {
        this.push(this._lightMyRequest.payload)
      }
    }

    if (this._lightMyRequest.simulate.error) {
      this.emit('error', new Error('Simulated'))
    }

    if (this._lightMyRequest.simulate.close) {
      this.emit('close')
    }

    // 'end' defaults to true
    if (this._lightMyRequest.simulate.end !== false) {
      this.push(null)
    }
  })
}

Request.prototype.destroy = function () {}

module.exports = Request

},{"readable-stream":"node_modules/light-my-request/node_modules/readable-stream/readable-browser.js","util":"node_modules/util/util.js","./parseURL":"node_modules/light-my-request/lib/parseURL.js","buffer":"node_modules/buffer/index.js"}],"node_modules/light-my-request/lib/response.js":[function(require,module,exports) {
var process = require("process");
var Buffer = require("buffer").Buffer;
'use strict'

const http = require('http')
const { Writable } = require('readable-stream')
const util = require('util')

function Response (req, onEnd, reject) {
  http.ServerResponse.call(this, {
    method: req.method,
    httpVersionMajor: 1,
    httpVersionMinor: 1
  })

  this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] }
  // This forces node@8 to always render the headers
  this.setHeader('foo', 'bar'); this.removeHeader('foo')

  this.assignSocket(getNullSocket())

  this._promiseCallback = typeof reject === 'function'

  const onEndSuccess = (payload) => {
    if (this._promiseCallback) {
      return process.nextTick(() => onEnd(payload))
    }
    process.nextTick(() => onEnd(null, payload))
  }

  const onEndFailure = (err) => {
    if (this._promiseCallback) {
      return process.nextTick(() => reject(err))
    }
    process.nextTick(() => onEnd(err, null))
  }

  this.once('finish', () => {
    const res = generatePayload(this)
    res.raw.req = req
    onEndSuccess(res)
  })

  this.connection.once('error', onEndFailure)

  this.once('error', onEndFailure)
}

util.inherits(Response, http.ServerResponse)

Response.prototype.writeHead = function () {
  const result = http.ServerResponse.prototype.writeHead.apply(this, arguments)

  const _headers = this.getHeaders ? this.getHeaders() : this._headers
  this._lightMyRequest.headers = Object.assign({}, _headers)

  // Add raw headers
  ;['Date', 'Connection', 'Transfer-Encoding'].forEach((name) => {
    const regex = new RegExp('\\r\\n' + name + ': ([^\\r]*)\\r\\n')
    const field = this._header.match(regex)
    if (field) {
      this._lightMyRequest.headers[name.toLowerCase()] = field[1]
    }
  })

  return result
}

Response.prototype.write = function (data, encoding, callback) {
  http.ServerResponse.prototype.write.call(this, data, encoding, callback)
  this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding))
  return true
}

Response.prototype.end = function (data, encoding, callback) {
  if (data) {
    this.write(data, encoding)
  }

  http.ServerResponse.prototype.end.call(this, callback)
  this.emit('finish')
}

Response.prototype.destroy = function () {}

Response.prototype.addTrailers = function (trailers) {
  for (const key in trailers) {
    this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim()
  }
}

function generatePayload (response) {
  // Prepare response object
  const res = {
    raw: {
      res: response
    },
    headers: response._lightMyRequest.headers,
    statusCode: response.statusCode,
    statusMessage: response.statusMessage,
    trailers: {}
  }

  // Prepare payload and trailers
  const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks)
  res.rawPayload = rawBuffer

  // we keep both of them for compatibility reasons
  res.payload = rawBuffer.toString()
  res.body = res.payload
  res.trailers = response._lightMyRequest.trailers

  return res
}

// Throws away all written data to prevent response from buffering payload
function getNullSocket () {
  return new Writable({
    write (chunk, encoding, callback) {
      setImmediate(callback)
    }
  })
}

module.exports = Response

},{"http":"node_modules/stream-http/index.js","readable-stream":"node_modules/light-my-request/node_modules/readable-stream/readable-browser.js","util":"node_modules/util/util.js","process":"node_modules/process/browser.js","buffer":"node_modules/buffer/index.js"}],"node_modules/light-my-request/index.js":[function(require,module,exports) {
'use strict'

const assert = require('assert')
const http = require('http')
const Ajv = require('ajv')
const Request = require('./lib/request')
const Response = require('./lib/response')

const urlSchema = {
  oneOf: [
    { type: 'string' },
    {
      type: 'object',
      properties: {
        protocol: { type: 'string' },
        hostname: { type: 'string' },
        pathname: { type: 'string' }
        // port type => any
        // query type => any
      },
      additionalProperties: true,
      required: ['pathname']
    }
  ]
}

const ajv = new Ajv()
const schema = {
  type: 'object',
  properties: {
    url: urlSchema,
    path: urlSchema,
    headers: {
      type: 'object',
      additionalProperties: true
    },
    query: {
      type: 'object',
      additionalProperties: true
    },
    simulate: {
      type: 'object',
      properties: {
        end: { type: 'boolean' },
        split: { type: 'boolean' },
        error: { type: 'boolean' },
        close: { type: 'boolean' }
      }
    },
    authority: { type: 'string' },
    remoteAddress: { type: 'string' },
    method: { type: 'string', enum: http.METHODS.concat(http.METHODS.map(toLowerCase)) },
    validate: { type: 'boolean' }
    // payload type => any
  },
  additionalProperties: true,
  oneOf: [
    { required: ['url'] },
    { required: ['path'] }
  ]
}

const optsValidator = ajv.compile(schema)

function inject (dispatchFunc, options, callback) {
  options = (typeof options === 'string' ? { url: options } : options)

  if (options.validate !== false) {
    assert(typeof dispatchFunc === 'function', 'dispatchFunc should be a function')
    const isOptionValid = optsValidator(options)
    if (!isOptionValid) {
      throw new Error(optsValidator.errors.map(e => e.message))
    }
  }

  const server = options.server || {}

  if (typeof callback === 'function') {
    const req = new Request(options)
    const res = new Response(req, callback)

    return req.prepare(() => dispatchFunc.call(server, req, res))
  } else {
    return new Promise((resolve, reject) => {
      const req = new Request(options)
      const res = new Response(req, resolve, reject)

      req.prepare(() => dispatchFunc.call(server, req, res))
    })
  }
}

function isInjection (obj) {
  return (obj instanceof Request || obj instanceof Response)
}

function toLowerCase (m) { return m.toLowerCase() }

module.exports = inject
module.exports.isInjection = isInjection

},{"assert":"node_modules/assert/assert.js","http":"node_modules/stream-http/index.js","ajv":"node_modules/ajv/lib/ajv.js","./lib/request":"node_modules/light-my-request/lib/request.js","./lib/response":"node_modules/light-my-request/lib/response.js"}],"node_modules/fastify/fastify.js":[function(require,module,exports) {
var process = require("process");
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Avvio = require('avvio');

var http = require('http');

var querystring = require('querystring');

var lightMyRequest;

var {
  kChildren: kChildren,
  kBodyLimit: kBodyLimit,
  kRoutePrefix: kRoutePrefix,
  kLogLevel: kLogLevel,
  kHooks: kHooks,
  kSchemas: kSchemas,
  kSchemaCompiler: kSchemaCompiler,
  kSchemaResolver: kSchemaResolver,
  kReplySerializerDefault: kReplySerializerDefault,
  kContentTypeParser: kContentTypeParser,
  kReply: kReply,
  kRequest: kRequest,
  kMiddlewares: kMiddlewares,
  kFourOhFour: kFourOhFour,
  kState: kState,
  kOptions: kOptions,
  kGlobalHooks: kGlobalHooks,
  kPluginNameChain: kPluginNameChain
} = require('./lib/symbols.js');

var {
  createServer: createServer
} = require('./lib/server');

var Reply = require('./lib/reply');

var Request = require('./lib/request');

var supportedMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS'];

var decorator = require('./lib/decorate');

var ContentTypeParser = require('./lib/contentTypeParser');

var {
  Hooks: Hooks,
  buildHooks: buildHooks
} = require('./lib/hooks');

var {
  Schemas: Schemas,
  buildSchemas: buildSchemas
} = require('./lib/schemas');

var {
  createLogger: createLogger
} = require('./lib/logger');

var pluginUtils = require('./lib/pluginUtils');

var reqIdGenFactory = require('./lib/reqIdGenFactory');

var {
  buildRouting: buildRouting,
  validateBodyLimitOption: validateBodyLimitOption
} = require('./lib/route');

var build404 = require('./lib/fourOhFour');

var getSecuredInitialConfig = require('./lib/initialConfigValidation');

var {
  defaultInitOptions: defaultInitOptions
} = getSecuredInitialConfig;

function build(options) {
  var _fastify;

  // Options validations
  options = options || {};

  if (_typeof(options) !== 'object') {
    throw new TypeError('Options must be an object');
  }

  if (options.querystringParser && typeof options.querystringParser !== 'function') {
    throw new Error("querystringParser option should be a function, instead got '".concat(_typeof(options.querystringParser), "'"));
  }

  validateBodyLimitOption(options.bodyLimit);

  if (options.logger && options.logger.genReqId) {
    process.emitWarning("Using 'genReqId' in logger options is deprecated. Use fastify options instead. See: https://www.fastify.io/docs/latest/Server/#gen-request-id");
    options.genReqId = options.logger.genReqId;
  }

  var modifyCoreObjects = options.modifyCoreObjects !== false;
  var requestIdHeader = options.requestIdHeader || defaultInitOptions.requestIdHeader;
  var querystringParser = options.querystringParser || querystring.parse;
  var genReqId = options.genReqId || reqIdGenFactory();
  var requestIdLogLabel = options.requestIdLogLabel || 'reqId';
  var bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
  var disableRequestLogging = options.disableRequestLogging || false; // Instance Fastify components

  var {
    logger: logger,
    hasLogger: hasLogger
  } = createLogger(options); // Update the options with the fixed values

  options.logger = logger;
  options.modifyCoreObjects = modifyCoreObjects;
  options.genReqId = genReqId;
  options.requestIdHeader = requestIdHeader;
  options.querystringParser = querystringParser;
  options.requestIdLogLabel = requestIdLogLabel;
  options.modifyCoreObjects = modifyCoreObjects;
  options.disableRequestLogging = disableRequestLogging; // Default router

  var router = buildRouting({
    config: {
      defaultRoute: defaultRoute,
      ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
      maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
      caseSensitive: options.caseSensitive,
      versioning: options.versioning
    }
  }); // 404 router, used for handling encapsulated 404 handlers

  var fourOhFour = build404(options); // HTTP server and its handler

  var httpHandler = router.routing;
  var {
    server: server,
    listen: listen
  } = createServer(options, httpHandler);

  if (Number(process.version.match(/v(\d+)/)[1]) >= 6) {
    server.on('clientError', handleClientError);
  }

  var setupResponseListeners = Reply.setupResponseListeners;
  var schemas = new Schemas(); // Public API

  var fastify = (_fastify = {}, _defineProperty(_fastify, kState, {
    listening: false,
    closing: false,
    started: false
  }), _defineProperty(_fastify, kOptions, options), _defineProperty(_fastify, kChildren, []), _defineProperty(_fastify, kBodyLimit, bodyLimit), _defineProperty(_fastify, kRoutePrefix, ''), _defineProperty(_fastify, kLogLevel, ''), _defineProperty(_fastify, kHooks, new Hooks()), _defineProperty(_fastify, kSchemas, schemas), _defineProperty(_fastify, kSchemaCompiler, null), _defineProperty(_fastify, kSchemaResolver, null), _defineProperty(_fastify, kReplySerializerDefault, null), _defineProperty(_fastify, kContentTypeParser, new ContentTypeParser(bodyLimit, options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning)), _defineProperty(_fastify, kReply, Reply.buildReply(Reply)), _defineProperty(_fastify, kRequest, Request.buildRequest(Request)), _defineProperty(_fastify, kMiddlewares, []), _defineProperty(_fastify, kFourOhFour, fourOhFour), _defineProperty(_fastify, kGlobalHooks, {
    onRoute: [],
    onRegister: []
  }), _defineProperty(_fastify, pluginUtils.registeredPlugins, []), _defineProperty(_fastify, kPluginNameChain, []), _defineProperty(_fastify, "delete", function _delete(url, opts, handler) {
    return router.prepareRoute.call(this, 'DELETE', url, opts, handler);
  }), _defineProperty(_fastify, "get", function _get(url, opts, handler) {
    return router.prepareRoute.call(this, 'GET', url, opts, handler);
  }), _defineProperty(_fastify, "head", function _head(url, opts, handler) {
    return router.prepareRoute.call(this, 'HEAD', url, opts, handler);
  }), _defineProperty(_fastify, "patch", function _patch(url, opts, handler) {
    return router.prepareRoute.call(this, 'PATCH', url, opts, handler);
  }), _defineProperty(_fastify, "post", function _post(url, opts, handler) {
    return router.prepareRoute.call(this, 'POST', url, opts, handler);
  }), _defineProperty(_fastify, "put", function _put(url, opts, handler) {
    return router.prepareRoute.call(this, 'PUT', url, opts, handler);
  }), _defineProperty(_fastify, "options", function _options(url, opts, handler) {
    return router.prepareRoute.call(this, 'OPTIONS', url, opts, handler);
  }), _defineProperty(_fastify, "all", function _all(url, opts, handler) {
    return router.prepareRoute.call(this, supportedMethods, url, opts, handler);
  }), _defineProperty(_fastify, "route", function _route(opts) {
    // we need the fastify object that we are producing so we apply a lazy loading of the function,
    // otherwise we should bind it after the declaration
    return router.route.call(this, opts);
  }), _defineProperty(_fastify, "log", logger), _defineProperty(_fastify, "addHook", addHook), _defineProperty(_fastify, "addSchema", addSchema), _defineProperty(_fastify, "getSchemas", schemas.getSchemas.bind(schemas)), _defineProperty(_fastify, "setSchemaCompiler", setSchemaCompiler), _defineProperty(_fastify, "setSchemaResolver", setSchemaResolver), _defineProperty(_fastify, "setReplySerializer", setReplySerializer), _defineProperty(_fastify, "addContentTypeParser", ContentTypeParser.helpers.addContentTypeParser), _defineProperty(_fastify, "hasContentTypeParser", ContentTypeParser.helpers.hasContentTypeParser), _defineProperty(_fastify, "register", null), _defineProperty(_fastify, "after", null), _defineProperty(_fastify, "ready", null), _defineProperty(_fastify, "onClose", null), _defineProperty(_fastify, "close", null), _defineProperty(_fastify, "listen", listen), _defineProperty(_fastify, "server", server), _defineProperty(_fastify, "decorate", decorator.add), _defineProperty(_fastify, "hasDecorator", decorator.exist), _defineProperty(_fastify, "decorateReply", decorator.decorateReply), _defineProperty(_fastify, "decorateRequest", decorator.decorateRequest), _defineProperty(_fastify, "hasRequestDecorator", decorator.existRequest), _defineProperty(_fastify, "hasReplyDecorator", decorator.existReply), _defineProperty(_fastify, "use", use), _defineProperty(_fastify, "inject", inject), _defineProperty(_fastify, "printRoutes", router.printRoutes), _defineProperty(_fastify, "setNotFoundHandler", setNotFoundHandler), _defineProperty(_fastify, "setErrorHandler", setErrorHandler), _defineProperty(_fastify, "initialConfig", getSecuredInitialConfig(options)), _fastify);
  Object.defineProperty(fastify, 'schemaCompiler', {
    get: function () {
      return this[kSchemaCompiler];
    },
    set: function (schemaCompiler) {
      this.setSchemaCompiler(schemaCompiler);
    }
  });
  Object.defineProperty(fastify, 'prefix', {
    get: function () {
      return this[kRoutePrefix];
    }
  });
  Object.defineProperty(fastify, 'basePath', {
    get: function () {
      process.emitWarning('basePath is deprecated. Use prefix instead. See: https://www.fastify.io/docs/latest/Server/#prefix');
      return this[kRoutePrefix];
    }
  });
  Object.defineProperty(fastify, 'pluginName', {
    get: function () {
      if (this[kPluginNameChain].length > 1) {
        return this[kPluginNameChain].join(' -> ');
      }

      return this[kPluginNameChain][0];
    }
  }); // Install and configure Avvio
  // Avvio will update the following Fastify methods:
  // - register
  // - after
  // - ready
  // - onClose
  // - close

  var avvio = Avvio(fastify, {
    autostart: false,
    timeout: Number(options.pluginTimeout) || defaultInitOptions.pluginTimeout,
    expose: {
      use: 'register'
    }
  }); // Override to allow the plugin incapsulation

  avvio.override = override;
  avvio.on('start', function () {
    return fastify[kState].started = true;
  }); // cache the closing value, since we are checking it in an hot path

  avvio.once('preReady', function () {
    fastify.onClose(function (instance, done) {
      fastify[kState].closing = true;
      router.closeRoutes();

      if (fastify[kState].listening) {
        // No new TCP connections are accepted
        instance.server.close(done);
      } else {
        done(null);
      }
    });
  }); // Set the default 404 handler

  fastify.setNotFoundHandler();
  fourOhFour.arrange404(fastify);
  router.setup(options, {
    avvio: avvio,
    fourOhFour: fourOhFour,
    logger: logger,
    hasLogger: hasLogger,
    setupResponseListeners: setupResponseListeners,
    throwIfAlreadyStarted: throwIfAlreadyStarted
  });
  return fastify;

  function throwIfAlreadyStarted(msg) {
    if (fastify[kState].started) throw new Error(msg);
  } // HTTP injection handling
  // If the server is not ready yet, this
  // utility will automatically force it.


  function inject(opts, cb) {
    // lightMyRequest is dynamically laoded as it seems very expensive
    // because of Ajv
    if (lightMyRequest === undefined) {
      lightMyRequest = require('light-my-request');
    }

    if (fastify[kState].started) {
      if (fastify[kState].closing) {
        // Force to return an error
        var error = new Error('Server is closed');

        if (cb) {
          cb(error);
          return;
        } else {
          return Promise.reject(error);
        }
      }

      return lightMyRequest(httpHandler, opts, cb);
    }

    if (cb) {
      this.ready(function (err) {
        if (err) cb(err, null);else lightMyRequest(httpHandler, opts, cb);
      });
    } else {
      return this.ready().then(function () {
        return lightMyRequest(httpHandler, opts);
      });
    }
  } // wrapper tha we expose to the user for middlewares handling


  function use(url, fn) {
    var _this = this;

    throwIfAlreadyStarted('Cannot call "use" when fastify instance is already started!');

    if (typeof url === 'string') {
      var prefix = this[kRoutePrefix];
      url = prefix + (url === '/' && prefix.length > 0 ? '' : url);
    }

    return this.after(function (err, done) {
      addMiddleware.call(_this, [url, fn]);
      done(err);
    });

    function addMiddleware(middleware) {
      this[kMiddlewares].push(middleware);
      this[kChildren].forEach(function (child) {
        return addMiddleware.call(child, middleware);
      });
    }
  } // wrapper that we expose to the user for hooks handling


  function addHook(name, fn) {
    var _this2 = this;

    throwIfAlreadyStarted('Cannot call "addHook" when fastify instance is already started!'); // TODO: v3 instead of log a warning, throw an error

    if (name === 'onSend' || name === 'preSerialization' || name === 'onError') {
      if (fn.constructor.name === 'AsyncFunction' && fn.length === 4) {
        fastify.log.warn("Async function has too many arguments. Async hooks should not use the 'next' argument.", new Error().stack);
      }
    } else {
      if (fn.constructor.name === 'AsyncFunction' && fn.length === 3) {
        fastify.log.warn("Async function has too many arguments. Async hooks should not use the 'next' argument.", new Error().stack);
      }
    }

    if (name === 'onClose') {
      this[kHooks].validate(name, fn);
      this.onClose(fn);
    } else if (name === 'onRoute') {
      this[kHooks].validate(name, fn);
      this[kGlobalHooks].onRoute.push(fn);
    } else if (name === 'onRegister') {
      this[kHooks].validate(name, fn);
      this[kGlobalHooks].onRegister.push(fn);
    } else {
      this.after(function (err, done) {
        _addHook.call(_this2, name, fn);

        done(err);
      });
    }

    return this;

    function _addHook(name, fn) {
      this[kHooks].add(name, fn.bind(this));
      this[kChildren].forEach(function (child) {
        return _addHook.call(child, name, fn);
      });
    }
  } // wrapper that we expose to the user for schemas handling


  function addSchema(schema) {
    throwIfAlreadyStarted('Cannot call "addSchema" when fastify instance is already started!');
    this[kSchemas].add(schema);
    this[kChildren].forEach(function (child) {
      return child.addSchema(schema);
    });
    return this;
  }

  function handleClientError(err, socket) {
    var body = JSON.stringify({
      error: http.STATUS_CODES['400'],
      message: 'Client Error',
      statusCode: 400
    });
    logger.debug({
      err: err
    }, 'client error');
    socket.end("HTTP/1.1 400 Bad Request\r\nContent-Length: ".concat(body.length, "\r\nContent-Type: application/json\r\n\r\n").concat(body));
  } // If the router does not match any route, every request will land here
  // req and res are Node.js core objects


  function defaultRoute(req, res) {
    if (req.headers['accept-version'] !== undefined) {
      req.headers['accept-version'] = undefined;
    }

    fourOhFour.router.lookup(req, res);
  }

  function setNotFoundHandler(opts, handler) {
    throwIfAlreadyStarted('Cannot call "setNotFoundHandler" when fastify instance is already started!');
    fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
  } // wrapper that we expose to the user for schemas compiler handling


  function setSchemaCompiler(schemaCompiler) {
    throwIfAlreadyStarted('Cannot call "setSchemaCompiler" when fastify instance is already started!');
    this[kSchemaCompiler] = schemaCompiler;
    return this;
  }

  function setSchemaResolver(schemaRefResolver) {
    throwIfAlreadyStarted('Cannot call "setSchemaResolver" when fastify instance is already started!');
    this[kSchemaResolver] = schemaRefResolver;
    return this;
  }

  function setReplySerializer(replySerializer) {
    throwIfAlreadyStarted('Cannot call "setReplySerializer" when fastify instance is already started!');
    this[kReplySerializerDefault] = replySerializer;
    return this;
  } // wrapper that we expose to the user for configure the custom error handler


  function setErrorHandler(func) {
    throwIfAlreadyStarted('Cannot call "setErrorHandler" when fastify instance is already started!');
    this._errorHandler = func;
    return this;
  }
} // Function that runs the encapsulation magic.
// Everything that need to be encapsulated must be handled in this function.


function override(old, fn, opts) {
  var shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);

  if (shouldSkipOverride) {
    // after every plugin registration we will enter a new name
    old[kPluginNameChain].push(pluginUtils.getDisplayName(fn));
    return old;
  }

  var instance = Object.create(old);
  old[kChildren].push(instance);
  instance[kChildren] = [];
  instance[kReply] = Reply.buildReply(instance[kReply]);
  instance[kRequest] = Request.buildRequest(instance[kRequest]);
  instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
  instance[kHooks] = buildHooks(instance[kHooks]);
  instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
  instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
  instance[kMiddlewares] = old[kMiddlewares].slice();
  instance[kSchemas] = buildSchemas(old[kSchemas]);
  instance.getSchemas = instance[kSchemas].getSchemas.bind(instance[kSchemas]);
  instance[pluginUtils.registeredPlugins] = Object.create(instance[pluginUtils.registeredPlugins]);
  instance[kPluginNameChain] = [pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn)];

  if (opts.prefix) {
    instance[kFourOhFour].arrange404(instance);
  }

  for (var hook of instance[kGlobalHooks].onRegister) {
    hook.call(this, instance);
  }

  return instance;
}

function buildRoutePrefix(instancePrefix, pluginPrefix) {
  if (!pluginPrefix) {
    return instancePrefix;
  } // Ensure that there is a '/' between the prefixes


  if (instancePrefix.endsWith('/')) {
    if (pluginPrefix[0] === '/') {
      // Remove the extra '/' to avoid: '/first//second'
      pluginPrefix = pluginPrefix.slice(1);
    }
  } else if (pluginPrefix[0] !== '/') {
    pluginPrefix = '/' + pluginPrefix;
  }

  return instancePrefix + pluginPrefix;
}

module.exports = build;
},{"avvio":"node_modules/avvio/boot.js","http":"node_modules/stream-http/index.js","querystring":"node_modules/querystring-es3/index.js","./lib/symbols.js":"node_modules/fastify/lib/symbols.js","./lib/server":"node_modules/fastify/lib/server.js","./lib/reply":"node_modules/fastify/lib/reply.js","./lib/request":"node_modules/fastify/lib/request.js","./lib/decorate":"node_modules/fastify/lib/decorate.js","./lib/contentTypeParser":"node_modules/fastify/lib/contentTypeParser.js","./lib/hooks":"node_modules/fastify/lib/hooks.js","./lib/schemas":"node_modules/fastify/lib/schemas.js","./lib/logger":"node_modules/fastify/lib/logger.js","./lib/pluginUtils":"node_modules/fastify/lib/pluginUtils.js","./lib/reqIdGenFactory":"node_modules/fastify/lib/reqIdGenFactory.js","./lib/route":"node_modules/fastify/lib/route.js","./lib/fourOhFour":"node_modules/fastify/lib/fourOhFour.js","./lib/initialConfigValidation":"node_modules/fastify/lib/initialConfigValidation.js","light-my-request":"node_modules/light-my-request/index.js","process":"node_modules/process/browser.js"}],"node_modules/fastify-plugin/node_modules/semver/semver.js":[function(require,module,exports) {
var process = require("process");
exports = module.exports = SemVer;
var debug;
/* istanbul ignore next */

if (typeof process === 'object' && process.env && undefined && /\bsemver\b/i.test(undefined)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('SEMVER');
    console.log.apply(console, args);
  };
} else {
  debug = function () {};
} // Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.


exports.SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re

var re = exports.re = [];
var src = exports.src = [];
var t = exports.tokens = {};
var R = 0;

function tok(n) {
  t[n] = R++;
} // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.


tok('NUMERICIDENTIFIER');
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
tok('NUMERICIDENTIFIERLOOSE');
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER');
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION');
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
tok('MAINVERSIONLOOSE');
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER');
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
tok('PRERELEASEIDENTIFIERLOOSE');
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE');
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
tok('PRERELEASELOOSE');
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER');
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD');
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'; // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL');
tok('FULLPLAIN');
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

tok('LOOSEPLAIN');
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
tok('LOOSE');
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
tok('GTLT');
src[t.GTLT] = '((?:<|>)?=?)'; // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

tok('XRANGEIDENTIFIERLOOSE');
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
tok('XRANGEIDENTIFIER');
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
tok('XRANGEPLAIN');
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
tok('XRANGEPLAINLOOSE');
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
tok('XRANGE');
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
tok('XRANGELOOSE');
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'; // Coercion.
// Extract anything that could conceivably be a part of a valid semver

tok('COERCE');
src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
tok('COERCERTL');
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g'); // Tilde ranges.
// Meaning is "reasonably at or greater than"

tok('LONETILDE');
src[t.LONETILDE] = '(?:~>?)';
tok('TILDETRIM');
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
var tildeTrimReplace = '$1~';
tok('TILDE');
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
tok('TILDELOOSE');
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'; // Caret ranges.
// Meaning is "at least and backwards compatible with"

tok('LONECARET');
src[t.LONECARET] = '(?:\\^)';
tok('CARETTRIM');
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
var caretTrimReplace = '$1^';
tok('CARET');
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
tok('CARETLOOSE');
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just "" to indicate "any version"

tok('COMPARATORLOOSE');
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
tok('COMPARATOR');
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

tok('COMPARATORTRIM');
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'; // this one has to use the /g flag

re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

tok('HYPHENRANGE');
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
tok('HYPHENRANGELOOSE');
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$'; // Star ranges basically just allow anything at all.

tok('STAR');
src[t.STAR] = '(<|>)?=?\\s*\\*'; // Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.

for (var i = 0; i < R; i++) {
  debug(i, src[i]);

  if (!re[i]) {
    re[i] = new RegExp(src[i]);
  }
}

exports.parse = parse;

function parse(version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;

function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}

exports.clean = clean;

function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version;
    } else {
      version = version.version;
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options);
  }

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;
  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

  if (!m) {
    throw new TypeError('Invalid Version: ' + version);
  }

  this.raw = version; // these are actually numbers

  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version');
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version');
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version');
  } // numberify any prerelease numeric ids


  if (!m[4]) {
    this.prerelease = [];
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;

        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num;
        }
      }

      return id;
    });
  }

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;

  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.');
  }

  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other);

  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  } // NOT having a prerelease is > having one


  if (this.prerelease.length && !other.prerelease.length) {
    return -1;
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1;
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0;
  }

  var i = 0;

  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
};

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  var i = 0;

  do {
    var a = this.build[i];
    var b = other.build[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
}; // preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.


SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;

    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;

    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.

    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier);
      }

      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
        this.major++;
      }

      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;

    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++;
      }

      this.patch = 0;
      this.prerelease = [];
      break;

    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++;
      }

      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0];
      } else {
        var i = this.prerelease.length;

        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }

        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0);
        }
      }

      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0];
          }
        } else {
          this.prerelease = [identifier, 0];
        }
      }

      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }

  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;

function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;

function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var prefix = '';

    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre';
      var defaultResult = 'prerelease';
    }

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers;
var numeric = /^[0-9]+$/;

function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
}

exports.rcompareIdentifiers = rcompareIdentifiers;

function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;

function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;

function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;

function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;

function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;

function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.compareBuild = compareBuild;

function compareBuild(a, b, loose) {
  var versionA = new SemVer(a, loose);
  var versionB = new SemVer(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
}

exports.rcompare = rcompare;

function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;

function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose);
  });
}

exports.rsort = rsort;

function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose);
  });
}

exports.gt = gt;

function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;

function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;

function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;

function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;

function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;

function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;

function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      return a === b;

    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt(a, b, loose);

    case '>=':
      return gte(a, b, loose);

    case '<':
      return lt(a, b, loose);

    case '<=':
      return lte(a, b, loose);

    default:
      throw new TypeError('Invalid operator: ' + op);
  }
}

exports.Comparator = Comparator;

function Comparator(comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp;
    } else {
      comp = comp.value;
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options);
  }

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY) {
    this.value = '';
  } else {
    this.value = this.operator + this.semver.version;
  }

  debug('comp', this);
}

var ANY = {};

Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
  var m = comp.match(r);

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp);
  }

  this.operator = m[1] !== undefined ? m[1] : '';

  if (this.operator === '=') {
    this.operator = '';
  } // if it literally is just '>' or '' then allow anything.


  if (!m[2]) {
    this.semver = ANY;
  } else {
    this.semver = new SemVer(m[2], this.options.loose);
  }
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY || version === ANY) {
    return true;
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options);
    } catch (er) {
      return false;
    }
  }

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  var rangeTmp;

  if (this.operator === '') {
    if (this.value === '') {
      return true;
    }

    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true;
    }

    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;

function Range(range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range)) {
    return new Range(range, options);
  }

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose;
  range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

  range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

  range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces

  range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);

  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }

  set = set.map(function (comp) {
    return new Comparator(comp, this.options);
  }, this);
  return set;
};

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
      return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
}; // take a set of comparators and determine whether there
// exists a version which can satisfy it


function isSatisfiable(comparators, options) {
  var result = true;
  var remainingComparators = comparators.slice();
  var testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }

  return result;
} // Mostly just for testing and legacy API reasons


exports.toComparators = toComparators;

function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
} // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
} // ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0


function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
    }

    debug('tilde return', ret);
    return ret;
  });
} // ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0


function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
      }
    } else {
      debug('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
      }
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    } // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value


    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr;
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
    }

    debug('xRange return', ret);
    return ret;
  });
} // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


function replaceStars(comp, options) {
  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  return comp.trim().replace(re[t.STAR], '');
} // This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0


function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0';
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0';
  } else {
    from = '>=' + from;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0';
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  } else {
    to = '<=' + to;
  }

  return (from + ' ' + to).trim();
} // if ANY of the sets match ALL of its comparators, then pass


Range.prototype.test = function (version) {
  if (!version) {
    return false;
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options);
    } catch (er) {
      return false;
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true;
    }
  }

  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver);

      if (set[i].semver === ANY) {
        continue;
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    return false;
  }

  return true;
}

exports.satisfies = satisfies;

function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;

function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;

function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
}

exports.minVersion = minVersion;

function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        default:
          throw new Error('Unexpected operation: ' + comparator.operator);
      }
    });
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
}

exports.validRange = validRange;

function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
} // Determine if version is less than all the versions possible in the range


exports.ltr = ltr;

function ltr(version, range, options) {
  return outside(version, range, '<', options);
} // Determine if version is greater than all the versions possible in the range.


exports.gtr = gtr;

function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;

function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisifes the range it is not outside


  if (satisfies(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    if (high.operator === comp || high.operator === ecomp) {
      return false;
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }

  return true;
}

exports.prerelease = prerelease;

function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;

function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2);
}

exports.coerce = coerce;

function coerce(version, options) {
  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null;
  }

  options = options || {};
  var match = null;

  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next;

    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }

      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    } // leave it in a clean state


    re[t.COERCERTL].lastIndex = -1;
  }

  if (match === null) {
    return null;
  }

  return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
}
},{"process":"node_modules/process/browser.js"}],"node_modules/date-now/index.js":[function(require,module,exports) {
module.exports = now

function now() {
    return new Date().getTime()
}

},{}],"node_modules/console-browserify/index.js":[function(require,module,exports) {
var global = arguments[3];
/*global window, global*/
var util = require("util")
var assert = require("assert")
var now = require("date-now")

var slice = Array.prototype.slice
var console
var times = {}

if (typeof global !== "undefined" && global.console) {
    console = global.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}

},{"util":"node_modules/util/util.js","assert":"node_modules/assert/assert.js","date-now":"node_modules/date-now/index.js"}],"node_modules/fastify-plugin/stackParser.js":[function(require,module,exports) {
'use strict'

const fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/
const fileNamePattern = /(\w*(\.\w*)*)\..*/

module.exports = function extractPluginName (stack) {
  const m = stack.match(fpStackTracePattern)

  // get last section of path and match for filename
  return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : 'anonymous'
}

},{}],"node_modules/fastify/package.json":[function(require,module,exports) {
module.exports = {
  "name": "fastify",
  "version": "2.10.0",
  "description": "Fast and low overhead web framework, for Node.js",
  "main": "fastify.js",
  "typings": "fastify.d.ts",
  "scripts": {
    "lint": "npm run lint:standard && npm run lint:typescript",
    "lint:standard": "standard --verbose | snazzy",
    "lint:typescript": "standard --parser @typescript-eslint/parser --plugin @typescript-eslint/eslint-plugin test/types/*.ts fastify.d.ts",
    "unit": "tap --no-esm -J test/*.test.js test/*/*.test.js",
    "unit:report": "tap --no-esm -J test/*.test.js test/*/*.test.js --cov --coverage-report=html --coverage-report=cobertura | tee out.tap",
    "unit:junit": "tap-mocha-reporter xunit < out.tap > test/junit-testresults.xml",
    "typescript": "tsc --project ./test/types/tsconfig.json",
    "test:report": "npm run lint && npm run unit:report && npm run typescript",
    "test": "npm run lint && npm run unit && npm run typescript",
    "coverage": "npm run unit -- --cov --coverage-report=html",
    "test:ci": "npm run lint && npm run unit -- --cov --coverage-report=lcovonly && npm run typescript",
    "bench": "branchcmp -r 2 -g -s \"npm run benchmark\"",
    "benchmark": "npx concurrently -k -s first \"node ./examples/simple.js\" \"npx autocannon -c 100 -d 5 -p 10 localhost:3000/\"",
    "license-checker": "license-checker --production --onlyAllow=\"MIT;ISC;BSD-3-Clause;BSD-2-Clause\""
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/fastify/fastify.git"
  },
  "keywords": ["web", "framework", "json", "schema", "open", "api"],
  "author": "Matteo Collina <hello@matteocollina.com>",
  "contributors": [{
    "name": "Tomas Della Vedova",
    "url": "http://delved.org",
    "author": true
  }, {
    "name": "Tommaso Allevi",
    "email": "tomallevi@gmail.com"
  }, {
    "name": "Ethan Arrowood",
    "url": "https://github.com/Ethan-Arrowood",
    "email": "ethan.arrowood@gmail.com"
  }, {
    "name": "Dustin Deus",
    "url": "http://starptech.de",
    "email": "deusdustin@gmail.com"
  }, {
    "name": "Trivikram Kamat",
    "url": "http://trivikr.github.io",
    "email": "trivikr.dev@gmail.com"
  }, {
    "name": "Luciano Mammino",
    "url": "https://loige.co"
  }, {
    "name": "Cemre Mengu",
    "email": "cemremengu@gmail.com"
  }, {
    "name": "Evan Shortiss",
    "email": "evanshortiss@gmail.com"
  }, {
    "name": "Manuel Spigolon",
    "email": "behemoth89@gmail.com"
  }, {
    "name": "James Sumners",
    "url": "https://james.sumners.info"
  }, {
    "name": "Denis Fäcke",
    "url": "https://github.com/SerayaEryn"
  }],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/fastify/fastify/issues"
  },
  "homepage": "https://www.fastify.io/",
  "engines": {
    "node": ">=6"
  },
  "devDependencies": {
    "@types/node": "^11.13.19",
    "@typescript-eslint/eslint-plugin": "^2.3.0",
    "@typescript-eslint/parser": "^2.3.0",
    "JSONStream": "^1.3.5",
    "ajv-pack": "^0.3.1",
    "autocannon": "^3.2.0",
    "branch-comparer": "^0.4.0",
    "concurrently": "^5.0.0",
    "cors": "^2.8.5",
    "coveralls": "^3.0.6",
    "dns-prefetch-control": "^0.2.0",
    "eslint": "^6.4.0",
    "eslint-import-resolver-node": "^0.3.2",
    "fast-json-body": "^1.1.0",
    "fastify-plugin": "^1.5.0",
    "fluent-schema": "^0.7.4",
    "form-data": "^2.5.0",
    "frameguard": "^3.0.0",
    "h2url": "^0.1.2",
    "helmet": "^3.20.0",
    "hide-powered-by": "^1.0.0",
    "hsts": "^2.1.0",
    "http-errors": "^1.7.1",
    "ienoopen": "^1.0.0",
    "joi": "^12.0.0",
    "license-checker": "^25.0.1",
    "lolex": "^4.2.0",
    "pre-commit": "^1.2.2",
    "proxyquire": "^2.1.3",
    "pump": "^3.0.0",
    "semver": "^6.3.0",
    "send": "^0.17.0",
    "serve-static": "^1.13.2",
    "simple-get": "^3.0.3",
    "snazzy": "^8.0.0",
    "split2": "^3.1.0",
    "standard": "^14.0.0",
    "tap": "^12.5.2",
    "tap-mocha-reporter": "^3.0.7",
    "then-sleep": "^1.0.1",
    "typescript": "^3.6.3",
    "x-xss-protection": "^1.1.0"
  },
  "dependencies": {
    "abstract-logging": "^1.0.0",
    "ajv": "^6.10.2",
    "avvio": "^6.2.2",
    "fast-json-stringify": "^1.15.5",
    "find-my-way": "^2.0.0",
    "flatstr": "^1.0.12",
    "light-my-request": "^3.4.1",
    "middie": "^4.0.1",
    "pino": "^5.13.2",
    "proxy-addr": "^2.0.4",
    "readable-stream": "^3.1.1",
    "rfdc": "^1.1.2",
    "secure-json-parse": "^1.0.0",
    "tiny-lru": "^7.0.0"
  },
  "greenkeeper": {
    "ignore": ["autocannon", "boom", "joi", "@types/node", "tap", "tap-mocha-reporter", "@typescript-eslint/eslint-plugin", "lolex"]
  },
  "standard": {
    "ignore": ["lib/configValidator.js"]
  }
};
},{}],"node_modules/fastify-plugin/index.js":[function(require,module,exports) {
'use strict'

const semver = require('semver')
const console = require('console')
const extractPluginName = require('./stackParser')

function plugin (fn, options = {}) {
  if (typeof fn.default !== 'undefined') { // Support for 'export default' behaviour in transpiled ECMAScript module
    fn = fn.default
  }

  if (typeof fn !== 'function') {
    throw new TypeError(`fastify-plugin expects a function, instead got a '${typeof fn}'`)
  }

  fn[Symbol.for('skip-override')] = true

  if (typeof options === 'string') {
    checkVersion(options)
    options = {}
  }

  if (typeof options !== 'object' || Array.isArray(options) || options === null) {
    throw new TypeError('The options object should be an object')
  }

  if (!options.name) {
    options.name = checkName(fn)
  }

  fn[Symbol.for('fastify.display-name')] = options.name

  if (options.fastify) {
    checkVersion(options.fastify)
  }

  fn[Symbol.for('plugin-meta')] = options

  return fn
}

function checkName (fn) {
  if (fn.name.length > 0) return fn.name

  try {
    throw new Error('anonymous function')
  } catch (e) {
    return extractPluginName(e.stack)
  }
}

function checkVersion (version) {
  if (typeof version !== 'string') {
    throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof version}'`)
  }

  var fastifyVersion
  try {
    fastifyVersion = require('fastify/package.json').version.replace(/-rc\.\d+/, '')
  } catch (_) {
    console.info('fastify not found, proceeding anyway')
  }

  if (fastifyVersion && !semver.satisfies(fastifyVersion, version)) {
    throw new Error(`fastify-plugin - expected '${version}' fastify version, '${fastifyVersion}' is installed`)
  }
}

module.exports = plugin

},{"semver":"node_modules/fastify-plugin/node_modules/semver/semver.js","console":"node_modules/console-browserify/index.js","./stackParser":"node_modules/fastify-plugin/stackParser.js","fastify/package.json":"node_modules/fastify/package.json"}],"node_modules/media-typer/index.js":[function(require,module,exports) {
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * SHT           = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */

var qescRegExp = /\\([\u0000-\u007f])/g;
/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */

var quoteRegExp = /([\\"])/g;
/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */

var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
/**
 * Module exports.
 */

exports.format = format;
exports.parse = parse;
/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @api public
 */

function format(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required');
  }

  var parameters = obj.parameters;
  var subtype = obj.subtype;
  var suffix = obj.suffix;
  var type = obj.type;

  if (!type || !typeNameRegExp.test(type)) {
    throw new TypeError('invalid type');
  }

  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError('invalid subtype');
  } // format as type/subtype


  var string = type + '/' + subtype; // append +suffix

  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError('invalid suffix');
    }

    string += '+' + suffix;
  } // append parameters


  if (parameters && typeof parameters === 'object') {
    var param;
    var params = Object.keys(parameters).sort();

    for (var i = 0; i < params.length; i++) {
      param = params[i];

      if (!tokenRegExp.test(param)) {
        throw new TypeError('invalid parameter name');
      }

      string += '; ' + param + '=' + qstring(parameters[param]);
    }
  }

  return string;
}
/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @api public
 */


function parse(string) {
  if (!string) {
    throw new TypeError('argument string is required');
  } // support req/res-like objects as argument


  if (typeof string === 'object') {
    string = getcontenttype(string);
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string');
  }

  var index = string.indexOf(';');
  var type = index !== -1 ? string.substr(0, index) : string;
  var key;
  var match;
  var obj = splitType(type);
  var params = {};
  var value;
  paramRegExp.lastIndex = index;

  while (match = paramRegExp.exec(string)) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format');
    }

    index += match[0].length;
    key = match[1].toLowerCase();
    value = match[2];

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
    }

    params[key] = value;
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format');
  }

  obj.parameters = params;
  return obj;
}
/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @api private
 */


function getcontenttype(obj) {
  if (typeof obj.getHeader === 'function') {
    // res-like
    return obj.getHeader('content-type');
  }

  if (typeof obj.headers === 'object') {
    // req-like
    return obj.headers && obj.headers['content-type'];
  }
}
/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */


function qstring(val) {
  var str = String(val); // no need to quote tokens

  if (tokenRegExp.test(str)) {
    return str;
  }

  if (str.length > 0 && !textRegExp.test(str)) {
    throw new TypeError('invalid parameter value');
  }

  return '"' + str.replace(quoteRegExp, '\\$1') + '"';
}
/**
 * Simply "type/subtype+siffx" into parts.
 *
 * @param {string} string
 * @return {Object}
 * @api private
 */


function splitType(string) {
  var match = typeRegExp.exec(string.toLowerCase());

  if (!match) {
    throw new TypeError('invalid media type');
  }

  var type = match[1];
  var subtype = match[2];
  var suffix; // suffix after last +

  var index = subtype.lastIndexOf('+');

  if (index !== -1) {
    suffix = subtype.substr(index + 1);
    subtype = subtype.substr(0, index);
  }

  var obj = {
    type: type,
    subtype: subtype,
    suffix: suffix
  };
  return obj;
}
},{}],"node_modules/mime-db/db.json":[function(require,module,exports) {
module.exports = {
  "application/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/3gpp-ims+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/a2l": {
    "source": "iana"
  },
  "application/activemessage": {
    "source": "iana"
  },
  "application/activity+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-directory+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcost+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcostparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointprop+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointpropparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-error+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/aml": {
    "source": "iana"
  },
  "application/andrew-inset": {
    "source": "iana",
    "extensions": ["ez"]
  },
  "application/applefile": {
    "source": "iana"
  },
  "application/applixware": {
    "source": "apache",
    "extensions": ["aw"]
  },
  "application/atf": {
    "source": "iana"
  },
  "application/atfx": {
    "source": "iana"
  },
  "application/atom+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atom"]
  },
  "application/atomcat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomcat"]
  },
  "application/atomdeleted+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/atomicmail": {
    "source": "iana"
  },
  "application/atomsvc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomsvc"]
  },
  "application/atsc-dwd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/atsc-held+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/atsc-rsat+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/atxml": {
    "source": "iana"
  },
  "application/auth-policy+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/bacnet-xdd+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/batch-smtp": {
    "source": "iana"
  },
  "application/bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/beep+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/calendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/calendar+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/call-completion": {
    "source": "iana"
  },
  "application/cals-1840": {
    "source": "iana"
  },
  "application/cbor": {
    "source": "iana"
  },
  "application/cccex": {
    "source": "iana"
  },
  "application/ccmp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ccxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ccxml"]
  },
  "application/cdfx+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cdmi-capability": {
    "source": "iana",
    "extensions": ["cdmia"]
  },
  "application/cdmi-container": {
    "source": "iana",
    "extensions": ["cdmic"]
  },
  "application/cdmi-domain": {
    "source": "iana",
    "extensions": ["cdmid"]
  },
  "application/cdmi-object": {
    "source": "iana",
    "extensions": ["cdmio"]
  },
  "application/cdmi-queue": {
    "source": "iana",
    "extensions": ["cdmiq"]
  },
  "application/cdni": {
    "source": "iana"
  },
  "application/cea": {
    "source": "iana"
  },
  "application/cea-2018+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cellml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cfw": {
    "source": "iana"
  },
  "application/clue_info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cms": {
    "source": "iana"
  },
  "application/cnrp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-group+json": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-payload": {
    "source": "iana"
  },
  "application/commonground": {
    "source": "iana"
  },
  "application/conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cose": {
    "source": "iana"
  },
  "application/cose-key": {
    "source": "iana"
  },
  "application/cose-key-set": {
    "source": "iana"
  },
  "application/cpl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csrattrs": {
    "source": "iana"
  },
  "application/csta+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cstadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csvm+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cu-seeme": {
    "source": "apache",
    "extensions": ["cu"]
  },
  "application/cwt": {
    "source": "iana"
  },
  "application/cybercash": {
    "source": "iana"
  },
  "application/dart": {
    "compressible": true
  },
  "application/dash+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpd"]
  },
  "application/dashdelta": {
    "source": "iana"
  },
  "application/davmount+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["davmount"]
  },
  "application/dca-rft": {
    "source": "iana"
  },
  "application/dcd": {
    "source": "iana"
  },
  "application/dec-dx": {
    "source": "iana"
  },
  "application/dialog-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom": {
    "source": "iana"
  },
  "application/dicom+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dii": {
    "source": "iana"
  },
  "application/dit": {
    "source": "iana"
  },
  "application/dns": {
    "source": "iana"
  },
  "application/dns+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dns-message": {
    "source": "iana"
  },
  "application/docbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dbk"]
  },
  "application/dskpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dssc+der": {
    "source": "iana",
    "extensions": ["dssc"]
  },
  "application/dssc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdssc"]
  },
  "application/dvcs": {
    "source": "iana"
  },
  "application/ecmascript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ecma", "es"]
  },
  "application/edi-consent": {
    "source": "iana"
  },
  "application/edi-x12": {
    "source": "iana",
    "compressible": false
  },
  "application/edifact": {
    "source": "iana",
    "compressible": false
  },
  "application/efi": {
    "source": "iana"
  },
  "application/emergencycalldata.comment+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.ecall.msd": {
    "source": "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.veds+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emma+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emma"]
  },
  "application/emotionml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/encaprtp": {
    "source": "iana"
  },
  "application/epp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/epub+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["epub"]
  },
  "application/eshop": {
    "source": "iana"
  },
  "application/exi": {
    "source": "iana",
    "extensions": ["exi"]
  },
  "application/expect-ct-report+json": {
    "source": "iana",
    "compressible": true
  },
  "application/fastinfoset": {
    "source": "iana"
  },
  "application/fastsoap": {
    "source": "iana"
  },
  "application/fdt+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/fhir+json": {
    "source": "iana",
    "compressible": true
  },
  "application/fhir+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/fido.trusted-apps+json": {
    "compressible": true
  },
  "application/fits": {
    "source": "iana"
  },
  "application/font-sfnt": {
    "source": "iana"
  },
  "application/font-tdpfr": {
    "source": "iana",
    "extensions": ["pfr"]
  },
  "application/font-woff": {
    "source": "iana",
    "compressible": false
  },
  "application/framework-attributes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/geo+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["geojson"]
  },
  "application/geo+json-seq": {
    "source": "iana"
  },
  "application/geopackage+sqlite3": {
    "source": "iana"
  },
  "application/geoxacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/gltf-buffer": {
    "source": "iana"
  },
  "application/gml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gml"]
  },
  "application/gpx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["gpx"]
  },
  "application/gxf": {
    "source": "apache",
    "extensions": ["gxf"]
  },
  "application/gzip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gz"]
  },
  "application/h224": {
    "source": "iana"
  },
  "application/held+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/hjson": {
    "extensions": ["hjson"]
  },
  "application/http": {
    "source": "iana"
  },
  "application/hyperstudio": {
    "source": "iana",
    "extensions": ["stk"]
  },
  "application/ibe-key-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pkg-reply+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pp-data": {
    "source": "iana"
  },
  "application/iges": {
    "source": "iana"
  },
  "application/im-iscomposing+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/index": {
    "source": "iana"
  },
  "application/index.cmd": {
    "source": "iana"
  },
  "application/index.obj": {
    "source": "iana"
  },
  "application/index.response": {
    "source": "iana"
  },
  "application/index.vnd": {
    "source": "iana"
  },
  "application/inkml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ink", "inkml"]
  },
  "application/iotp": {
    "source": "iana"
  },
  "application/ipfix": {
    "source": "iana",
    "extensions": ["ipfix"]
  },
  "application/ipp": {
    "source": "iana"
  },
  "application/isup": {
    "source": "iana"
  },
  "application/its+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/java-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jar", "war", "ear"]
  },
  "application/java-serialized-object": {
    "source": "apache",
    "compressible": false,
    "extensions": ["ser"]
  },
  "application/java-vm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["class"]
  },
  "application/javascript": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["js", "mjs"]
  },
  "application/jf2feed+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jose": {
    "source": "iana"
  },
  "application/jose+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jrd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["json", "map"]
  },
  "application/json-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json-seq": {
    "source": "iana"
  },
  "application/json5": {
    "extensions": ["json5"]
  },
  "application/jsonml+json": {
    "source": "apache",
    "compressible": true,
    "extensions": ["jsonml"]
  },
  "application/jwk+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwk-set+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwt": {
    "source": "iana"
  },
  "application/kpml-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/kpml-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ld+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["jsonld"]
  },
  "application/lgr+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/link-format": {
    "source": "iana"
  },
  "application/load-control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lost+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lostxml"]
  },
  "application/lostsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lxf": {
    "source": "iana"
  },
  "application/mac-binhex40": {
    "source": "iana",
    "extensions": ["hqx"]
  },
  "application/mac-compactpro": {
    "source": "apache",
    "extensions": ["cpt"]
  },
  "application/macwriteii": {
    "source": "iana"
  },
  "application/mads+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mads"]
  },
  "application/manifest+json": {
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["webmanifest"]
  },
  "application/marc": {
    "source": "iana",
    "extensions": ["mrc"]
  },
  "application/marcxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mrcx"]
  },
  "application/mathematica": {
    "source": "iana",
    "extensions": ["ma", "nb", "mb"]
  },
  "application/mathml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mathml"]
  },
  "application/mathml-content+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mathml-presentation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-associated-procedure-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-deregister+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-envelope+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-protection-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-reception-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-schedule+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-user-service-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbox": {
    "source": "iana",
    "extensions": ["mbox"]
  },
  "application/media-policy-dataset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/media_control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mediaservercontrol+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mscml"]
  },
  "application/merge-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/metalink+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["metalink"]
  },
  "application/metalink4+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["meta4"]
  },
  "application/mets+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mets"]
  },
  "application/mf4": {
    "source": "iana"
  },
  "application/mikey": {
    "source": "iana"
  },
  "application/mmt-aei+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mmt-usd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mods+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mods"]
  },
  "application/moss-keys": {
    "source": "iana"
  },
  "application/moss-signature": {
    "source": "iana"
  },
  "application/mosskey-data": {
    "source": "iana"
  },
  "application/mosskey-request": {
    "source": "iana"
  },
  "application/mp21": {
    "source": "iana",
    "extensions": ["m21", "mp21"]
  },
  "application/mp4": {
    "source": "iana",
    "extensions": ["mp4s", "m4p"]
  },
  "application/mpeg4-generic": {
    "source": "iana"
  },
  "application/mpeg4-iod": {
    "source": "iana"
  },
  "application/mpeg4-iod-xmt": {
    "source": "iana"
  },
  "application/mrb-consumer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mrb-publish+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/msc-ivr+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/msc-mixer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/msword": {
    "source": "iana",
    "compressible": false,
    "extensions": ["doc", "dot"]
  },
  "application/mud+json": {
    "source": "iana",
    "compressible": true
  },
  "application/mxf": {
    "source": "iana",
    "extensions": ["mxf"]
  },
  "application/n-quads": {
    "source": "iana",
    "extensions": ["nq"]
  },
  "application/n-triples": {
    "source": "iana",
    "extensions": ["nt"]
  },
  "application/nasdata": {
    "source": "iana"
  },
  "application/news-checkgroups": {
    "source": "iana"
  },
  "application/news-groupinfo": {
    "source": "iana"
  },
  "application/news-transmission": {
    "source": "iana"
  },
  "application/nlsml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/node": {
    "source": "iana"
  },
  "application/nss": {
    "source": "iana"
  },
  "application/ocsp-request": {
    "source": "iana"
  },
  "application/ocsp-response": {
    "source": "iana"
  },
  "application/octet-stream": {
    "source": "iana",
    "compressible": false,
    "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
  },
  "application/oda": {
    "source": "iana",
    "extensions": ["oda"]
  },
  "application/odm+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/odx": {
    "source": "iana"
  },
  "application/oebps-package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["opf"]
  },
  "application/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogx"]
  },
  "application/omdoc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["omdoc"]
  },
  "application/onenote": {
    "source": "apache",
    "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"]
  },
  "application/oscore": {
    "source": "iana"
  },
  "application/oxps": {
    "source": "iana",
    "extensions": ["oxps"]
  },
  "application/p2p-overlay+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/parityfec": {
    "source": "iana"
  },
  "application/passport": {
    "source": "iana"
  },
  "application/patch-ops-error+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xer"]
  },
  "application/pdf": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pdf"]
  },
  "application/pdx": {
    "source": "iana"
  },
  "application/pem-certificate-chain": {
    "source": "iana"
  },
  "application/pgp-encrypted": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pgp"]
  },
  "application/pgp-keys": {
    "source": "iana"
  },
  "application/pgp-signature": {
    "source": "iana",
    "extensions": ["asc", "sig"]
  },
  "application/pics-rules": {
    "source": "apache",
    "extensions": ["prf"]
  },
  "application/pidf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/pidf-diff+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/pkcs10": {
    "source": "iana",
    "extensions": ["p10"]
  },
  "application/pkcs12": {
    "source": "iana"
  },
  "application/pkcs7-mime": {
    "source": "iana",
    "extensions": ["p7m", "p7c"]
  },
  "application/pkcs7-signature": {
    "source": "iana",
    "extensions": ["p7s"]
  },
  "application/pkcs8": {
    "source": "iana",
    "extensions": ["p8"]
  },
  "application/pkcs8-encrypted": {
    "source": "iana"
  },
  "application/pkix-attr-cert": {
    "source": "iana",
    "extensions": ["ac"]
  },
  "application/pkix-cert": {
    "source": "iana",
    "extensions": ["cer"]
  },
  "application/pkix-crl": {
    "source": "iana",
    "extensions": ["crl"]
  },
  "application/pkix-pkipath": {
    "source": "iana",
    "extensions": ["pkipath"]
  },
  "application/pkixcmp": {
    "source": "iana",
    "extensions": ["pki"]
  },
  "application/pls+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pls"]
  },
  "application/poc-settings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/postscript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ai", "eps", "ps"]
  },
  "application/ppsp-tracker+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/provenance+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/prs.alvestrand.titrax-sheet": {
    "source": "iana"
  },
  "application/prs.cww": {
    "source": "iana",
    "extensions": ["cww"]
  },
  "application/prs.hpub+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/prs.nprend": {
    "source": "iana"
  },
  "application/prs.plucker": {
    "source": "iana"
  },
  "application/prs.rdf-xml-crypt": {
    "source": "iana"
  },
  "application/prs.xsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/pskc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pskcxml"]
  },
  "application/qsig": {
    "source": "iana"
  },
  "application/raml+yaml": {
    "compressible": true,
    "extensions": ["raml"]
  },
  "application/raptorfec": {
    "source": "iana"
  },
  "application/rdap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/rdf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rdf", "owl"]
  },
  "application/reginfo+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rif"]
  },
  "application/relax-ng-compact-syntax": {
    "source": "iana",
    "extensions": ["rnc"]
  },
  "application/remote-printing": {
    "source": "iana"
  },
  "application/reputon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/resource-lists+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rl"]
  },
  "application/resource-lists-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rld"]
  },
  "application/rfc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/riscos": {
    "source": "iana"
  },
  "application/rlmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/rls-services+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rs"]
  },
  "application/route-apd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/route-s-tsid+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/route-usd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/rpki-ghostbusters": {
    "source": "iana",
    "extensions": ["gbr"]
  },
  "application/rpki-manifest": {
    "source": "iana",
    "extensions": ["mft"]
  },
  "application/rpki-publication": {
    "source": "iana"
  },
  "application/rpki-roa": {
    "source": "iana",
    "extensions": ["roa"]
  },
  "application/rpki-updown": {
    "source": "iana"
  },
  "application/rsd+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rsd"]
  },
  "application/rss+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rss"]
  },
  "application/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "application/rtploopback": {
    "source": "iana"
  },
  "application/rtx": {
    "source": "iana"
  },
  "application/samlassertion+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/samlmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sbml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sbml"]
  },
  "application/scaip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/scim+json": {
    "source": "iana",
    "compressible": true
  },
  "application/scvp-cv-request": {
    "source": "iana",
    "extensions": ["scq"]
  },
  "application/scvp-cv-response": {
    "source": "iana",
    "extensions": ["scs"]
  },
  "application/scvp-vp-request": {
    "source": "iana",
    "extensions": ["spq"]
  },
  "application/scvp-vp-response": {
    "source": "iana",
    "extensions": ["spp"]
  },
  "application/sdp": {
    "source": "iana",
    "extensions": ["sdp"]
  },
  "application/secevent+jwt": {
    "source": "iana"
  },
  "application/senml+cbor": {
    "source": "iana"
  },
  "application/senml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/senml-exi": {
    "source": "iana"
  },
  "application/sensml+cbor": {
    "source": "iana"
  },
  "application/sensml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sensml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sensml-exi": {
    "source": "iana"
  },
  "application/sep+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sep-exi": {
    "source": "iana"
  },
  "application/session-info": {
    "source": "iana"
  },
  "application/set-payment": {
    "source": "iana"
  },
  "application/set-payment-initiation": {
    "source": "iana",
    "extensions": ["setpay"]
  },
  "application/set-registration": {
    "source": "iana"
  },
  "application/set-registration-initiation": {
    "source": "iana",
    "extensions": ["setreg"]
  },
  "application/sgml": {
    "source": "iana"
  },
  "application/sgml-open-catalog": {
    "source": "iana"
  },
  "application/shf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["shf"]
  },
  "application/sieve": {
    "source": "iana",
    "extensions": ["siv", "sieve"]
  },
  "application/simple-filter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/simple-message-summary": {
    "source": "iana"
  },
  "application/simplesymbolcontainer": {
    "source": "iana"
  },
  "application/slate": {
    "source": "iana"
  },
  "application/smil": {
    "source": "iana"
  },
  "application/smil+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["smi", "smil"]
  },
  "application/smpte336m": {
    "source": "iana"
  },
  "application/soap+fastinfoset": {
    "source": "iana"
  },
  "application/soap+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sparql-query": {
    "source": "iana",
    "extensions": ["rq"]
  },
  "application/sparql-results+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["srx"]
  },
  "application/spirits-event+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sql": {
    "source": "iana"
  },
  "application/srgs": {
    "source": "iana",
    "extensions": ["gram"]
  },
  "application/srgs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["grxml"]
  },
  "application/sru+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sru"]
  },
  "application/ssdl+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ssdl"]
  },
  "application/ssml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ssml"]
  },
  "application/stix+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tamp-apex-update": {
    "source": "iana"
  },
  "application/tamp-apex-update-confirm": {
    "source": "iana"
  },
  "application/tamp-community-update": {
    "source": "iana"
  },
  "application/tamp-community-update-confirm": {
    "source": "iana"
  },
  "application/tamp-error": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    "source": "iana"
  },
  "application/tamp-status-query": {
    "source": "iana"
  },
  "application/tamp-status-response": {
    "source": "iana"
  },
  "application/tamp-update": {
    "source": "iana"
  },
  "application/tamp-update-confirm": {
    "source": "iana"
  },
  "application/tar": {
    "compressible": true
  },
  "application/taxii+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tei", "teicorpus"]
  },
  "application/tetra_isi": {
    "source": "iana"
  },
  "application/thraud+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tfi"]
  },
  "application/timestamp-query": {
    "source": "iana"
  },
  "application/timestamp-reply": {
    "source": "iana"
  },
  "application/timestamped-data": {
    "source": "iana",
    "extensions": ["tsd"]
  },
  "application/tlsrpt+gzip": {
    "source": "iana"
  },
  "application/tlsrpt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tnauthlist": {
    "source": "iana"
  },
  "application/trickle-ice-sdpfrag": {
    "source": "iana"
  },
  "application/trig": {
    "source": "iana"
  },
  "application/ttml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/tve-trigger": {
    "source": "iana"
  },
  "application/tzif": {
    "source": "iana"
  },
  "application/tzif-leap": {
    "source": "iana"
  },
  "application/ulpfec": {
    "source": "iana"
  },
  "application/urc-grpsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/urc-ressheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/urc-targetdesc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/urc-uisocketdesc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vemmi": {
    "source": "iana"
  },
  "application/vividence.scriptfile": {
    "source": "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    "source": "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.bsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.gmop+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-payload": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mid-call+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.pic-bw-large": {
    "source": "iana",
    "extensions": ["plb"]
  },
  "application/vnd.3gpp.pic-bw-small": {
    "source": "iana",
    "extensions": ["psb"]
  },
  "application/vnd.3gpp.pic-bw-var": {
    "source": "iana",
    "extensions": ["pvb"]
  },
  "application/vnd.3gpp.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.ussd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp2.tcap": {
    "source": "iana",
    "extensions": ["tcap"]
  },
  "application/vnd.3lightssoftware.imagescal": {
    "source": "iana"
  },
  "application/vnd.3m.post-it-notes": {
    "source": "iana",
    "extensions": ["pwn"]
  },
  "application/vnd.accpac.simply.aso": {
    "source": "iana",
    "extensions": ["aso"]
  },
  "application/vnd.accpac.simply.imp": {
    "source": "iana",
    "extensions": ["imp"]
  },
  "application/vnd.acucobol": {
    "source": "iana",
    "extensions": ["acu"]
  },
  "application/vnd.acucorp": {
    "source": "iana",
    "extensions": ["atc", "acutc"]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["air"]
  },
  "application/vnd.adobe.flash.movie": {
    "source": "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    "source": "iana",
    "extensions": ["fcdt"]
  },
  "application/vnd.adobe.fxp": {
    "source": "iana",
    "extensions": ["fxp", "fxpl"]
  },
  "application/vnd.adobe.partial-upload": {
    "source": "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdp"]
  },
  "application/vnd.adobe.xfdf": {
    "source": "iana",
    "extensions": ["xfdf"]
  },
  "application/vnd.aether.imp": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata": {
    "source": "iana"
  },
  "application/vnd.afpc.modca": {
    "source": "iana"
  },
  "application/vnd.ah-barcode": {
    "source": "iana"
  },
  "application/vnd.ahead.space": {
    "source": "iana",
    "extensions": ["ahead"]
  },
  "application/vnd.airzip.filesecure.azf": {
    "source": "iana",
    "extensions": ["azf"]
  },
  "application/vnd.airzip.filesecure.azs": {
    "source": "iana",
    "extensions": ["azs"]
  },
  "application/vnd.amadeus+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.amazon.ebook": {
    "source": "apache",
    "extensions": ["azw"]
  },
  "application/vnd.amazon.mobi8-ebook": {
    "source": "iana"
  },
  "application/vnd.americandynamics.acc": {
    "source": "iana",
    "extensions": ["acc"]
  },
  "application/vnd.amiga.ami": {
    "source": "iana",
    "extensions": ["ami"]
  },
  "application/vnd.amundsen.maze+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.android.package-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["apk"]
  },
  "application/vnd.anki": {
    "source": "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    "source": "iana",
    "extensions": ["cii"]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    "source": "apache",
    "extensions": ["fti"]
  },
  "application/vnd.antix.game-component": {
    "source": "iana",
    "extensions": ["atx"]
  },
  "application/vnd.apache.thrift.binary": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.compact": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.json": {
    "source": "iana"
  },
  "application/vnd.api+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apothekende.reservation+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apple.installer+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpkg"]
  },
  "application/vnd.apple.keynote": {
    "source": "iana",
    "extensions": ["keynote"]
  },
  "application/vnd.apple.mpegurl": {
    "source": "iana",
    "extensions": ["m3u8"]
  },
  "application/vnd.apple.numbers": {
    "source": "iana",
    "extensions": ["numbers"]
  },
  "application/vnd.apple.pages": {
    "source": "iana",
    "extensions": ["pages"]
  },
  "application/vnd.apple.pkpass": {
    "compressible": false,
    "extensions": ["pkpass"]
  },
  "application/vnd.arastra.swi": {
    "source": "iana"
  },
  "application/vnd.aristanetworks.swi": {
    "source": "iana",
    "extensions": ["swi"]
  },
  "application/vnd.artisan+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.artsquare": {
    "source": "iana"
  },
  "application/vnd.astraea-software.iota": {
    "source": "iana",
    "extensions": ["iota"]
  },
  "application/vnd.audiograph": {
    "source": "iana",
    "extensions": ["aep"]
  },
  "application/vnd.autopackage": {
    "source": "iana"
  },
  "application/vnd.avalon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.avistar+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.balsamiq.bmml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.balsamiq.bmpr": {
    "source": "iana"
  },
  "application/vnd.banana-accounting": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bekitzur-stech+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bint.med-content": {
    "source": "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.blink-idb-value-wrapper": {
    "source": "iana"
  },
  "application/vnd.blueice.multipass": {
    "source": "iana",
    "extensions": ["mpm"]
  },
  "application/vnd.bluetooth.ep.oob": {
    "source": "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    "source": "iana"
  },
  "application/vnd.bmi": {
    "source": "iana",
    "extensions": ["bmi"]
  },
  "application/vnd.businessobjects": {
    "source": "iana",
    "extensions": ["rep"]
  },
  "application/vnd.byu.uapi+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cab-jscript": {
    "source": "iana"
  },
  "application/vnd.canon-cpdl": {
    "source": "iana"
  },
  "application/vnd.canon-lips": {
    "source": "iana"
  },
  "application/vnd.capasystems-pg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    "source": "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    "source": "iana"
  },
  "application/vnd.chemdraw+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdxml"]
  },
  "application/vnd.chess-pgn": {
    "source": "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    "source": "iana",
    "extensions": ["mmd"]
  },
  "application/vnd.cinderella": {
    "source": "iana",
    "extensions": ["cdy"]
  },
  "application/vnd.cirpack.isdn-ext": {
    "source": "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csl"]
  },
  "application/vnd.claymore": {
    "source": "iana",
    "extensions": ["cla"]
  },
  "application/vnd.cloanto.rp9": {
    "source": "iana",
    "extensions": ["rp9"]
  },
  "application/vnd.clonk.c4group": {
    "source": "iana",
    "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    "source": "iana",
    "extensions": ["c11amc"]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    "source": "iana",
    "extensions": ["c11amz"]
  },
  "application/vnd.coffeescript": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    "source": "iana"
  },
  "application/vnd.collection+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.doc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.next+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.comicbook+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.comicbook-rar": {
    "source": "iana"
  },
  "application/vnd.commerce-battelle": {
    "source": "iana"
  },
  "application/vnd.commonspace": {
    "source": "iana",
    "extensions": ["csp"]
  },
  "application/vnd.contact.cmsg": {
    "source": "iana",
    "extensions": ["cdbcmsg"]
  },
  "application/vnd.coreos.ignition+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cosmocaller": {
    "source": "iana",
    "extensions": ["cmc"]
  },
  "application/vnd.crick.clicker": {
    "source": "iana",
    "extensions": ["clkx"]
  },
  "application/vnd.crick.clicker.keyboard": {
    "source": "iana",
    "extensions": ["clkk"]
  },
  "application/vnd.crick.clicker.palette": {
    "source": "iana",
    "extensions": ["clkp"]
  },
  "application/vnd.crick.clicker.template": {
    "source": "iana",
    "extensions": ["clkt"]
  },
  "application/vnd.crick.clicker.wordbank": {
    "source": "iana",
    "extensions": ["clkw"]
  },
  "application/vnd.criticaltools.wbs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wbs"]
  },
  "application/vnd.ctc-posml": {
    "source": "iana",
    "extensions": ["pml"]
  },
  "application/vnd.ctct.ws+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cups-pdf": {
    "source": "iana"
  },
  "application/vnd.cups-postscript": {
    "source": "iana"
  },
  "application/vnd.cups-ppd": {
    "source": "iana",
    "extensions": ["ppd"]
  },
  "application/vnd.cups-raster": {
    "source": "iana"
  },
  "application/vnd.cups-raw": {
    "source": "iana"
  },
  "application/vnd.curl": {
    "source": "iana"
  },
  "application/vnd.curl.car": {
    "source": "apache",
    "extensions": ["car"]
  },
  "application/vnd.curl.pcurl": {
    "source": "apache",
    "extensions": ["pcurl"]
  },
  "application/vnd.cyan.dean.root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cybank": {
    "source": "iana"
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.dart": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dart"]
  },
  "application/vnd.data-vision.rdz": {
    "source": "iana",
    "extensions": ["rdz"]
  },
  "application/vnd.datapackage+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dataresource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.debian.binary-package": {
    "source": "iana"
  },
  "application/vnd.dece.data": {
    "source": "iana",
    "extensions": ["uvf", "uvvf", "uvd", "uvvd"]
  },
  "application/vnd.dece.ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uvt", "uvvt"]
  },
  "application/vnd.dece.unspecified": {
    "source": "iana",
    "extensions": ["uvx", "uvvx"]
  },
  "application/vnd.dece.zip": {
    "source": "iana",
    "extensions": ["uvz", "uvvz"]
  },
  "application/vnd.denovo.fcselayout-link": {
    "source": "iana",
    "extensions": ["fe_launch"]
  },
  "application/vnd.desmume.movie": {
    "source": "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    "source": "iana"
  },
  "application/vnd.dm.delegation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dna": {
    "source": "iana",
    "extensions": ["dna"]
  },
  "application/vnd.document+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dolby.mlp": {
    "source": "apache",
    "extensions": ["mlp"]
  },
  "application/vnd.dolby.mobile.1": {
    "source": "iana"
  },
  "application/vnd.dolby.mobile.2": {
    "source": "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    "source": "iana"
  },
  "application/vnd.dpgraph": {
    "source": "iana",
    "extensions": ["dpg"]
  },
  "application/vnd.dreamfactory": {
    "source": "iana",
    "extensions": ["dfac"]
  },
  "application/vnd.drive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ds-keypoint": {
    "source": "apache",
    "extensions": ["kpxx"]
  },
  "application/vnd.dtg.local": {
    "source": "iana"
  },
  "application/vnd.dtg.local.flash": {
    "source": "iana"
  },
  "application/vnd.dtg.local.html": {
    "source": "iana"
  },
  "application/vnd.dvb.ait": {
    "source": "iana",
    "extensions": ["ait"]
  },
  "application/vnd.dvb.dvbj": {
    "source": "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-container+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-generic+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-init+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.pfr": {
    "source": "iana"
  },
  "application/vnd.dvb.service": {
    "source": "iana",
    "extensions": ["svc"]
  },
  "application/vnd.dxr": {
    "source": "iana"
  },
  "application/vnd.dynageo": {
    "source": "iana",
    "extensions": ["geo"]
  },
  "application/vnd.dzr": {
    "source": "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    "source": "iana"
  },
  "application/vnd.ecdis-update": {
    "source": "iana"
  },
  "application/vnd.ecip.rlp": {
    "source": "iana"
  },
  "application/vnd.ecowin.chart": {
    "source": "iana",
    "extensions": ["mag"]
  },
  "application/vnd.ecowin.filerequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    "source": "iana"
  },
  "application/vnd.ecowin.series": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    "source": "iana"
  },
  "application/vnd.efi.img": {
    "source": "iana"
  },
  "application/vnd.efi.iso": {
    "source": "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.enliven": {
    "source": "iana",
    "extensions": ["nml"]
  },
  "application/vnd.enphase.envoy": {
    "source": "iana"
  },
  "application/vnd.eprints.data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.epson.esf": {
    "source": "iana",
    "extensions": ["esf"]
  },
  "application/vnd.epson.msf": {
    "source": "iana",
    "extensions": ["msf"]
  },
  "application/vnd.epson.quickanime": {
    "source": "iana",
    "extensions": ["qam"]
  },
  "application/vnd.epson.salt": {
    "source": "iana",
    "extensions": ["slt"]
  },
  "application/vnd.epson.ssf": {
    "source": "iana",
    "extensions": ["ssf"]
  },
  "application/vnd.ericsson.quickcall": {
    "source": "iana"
  },
  "application/vnd.espass-espass+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.eszigno3+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["es3", "et3"]
  },
  "application/vnd.etsi.aoc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.asic-e+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.asic-s+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.cug+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvservice+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mcid+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mheg5": {
    "source": "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.pstn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.sci+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.simservs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.timestamp-token": {
    "source": "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.tsl.der": {
    "source": "iana"
  },
  "application/vnd.eudora.data": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    "source": "iana"
  },
  "application/vnd.exstream-empower+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.exstream-package": {
    "source": "iana"
  },
  "application/vnd.ezpix-album": {
    "source": "iana",
    "extensions": ["ez2"]
  },
  "application/vnd.ezpix-package": {
    "source": "iana",
    "extensions": ["ez3"]
  },
  "application/vnd.f-secure.mobile": {
    "source": "iana"
  },
  "application/vnd.fastcopy-disk-image": {
    "source": "iana"
  },
  "application/vnd.fdf": {
    "source": "iana",
    "extensions": ["fdf"]
  },
  "application/vnd.fdsn.mseed": {
    "source": "iana",
    "extensions": ["mseed"]
  },
  "application/vnd.fdsn.seed": {
    "source": "iana",
    "extensions": ["seed", "dataless"]
  },
  "application/vnd.ffsns": {
    "source": "iana"
  },
  "application/vnd.filmit.zfc": {
    "source": "iana"
  },
  "application/vnd.fints": {
    "source": "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    "source": "iana"
  },
  "application/vnd.flographit": {
    "source": "iana",
    "extensions": ["gph"]
  },
  "application/vnd.fluxtime.clip": {
    "source": "iana",
    "extensions": ["ftc"]
  },
  "application/vnd.font-fontforge-sfd": {
    "source": "iana"
  },
  "application/vnd.framemaker": {
    "source": "iana",
    "extensions": ["fm", "frame", "maker", "book"]
  },
  "application/vnd.frogans.fnc": {
    "source": "iana",
    "extensions": ["fnc"]
  },
  "application/vnd.frogans.ltf": {
    "source": "iana",
    "extensions": ["ltf"]
  },
  "application/vnd.fsc.weblaunch": {
    "source": "iana",
    "extensions": ["fsc"]
  },
  "application/vnd.fujitsu.oasys": {
    "source": "iana",
    "extensions": ["oas"]
  },
  "application/vnd.fujitsu.oasys2": {
    "source": "iana",
    "extensions": ["oa2"]
  },
  "application/vnd.fujitsu.oasys3": {
    "source": "iana",
    "extensions": ["oa3"]
  },
  "application/vnd.fujitsu.oasysgp": {
    "source": "iana",
    "extensions": ["fg5"]
  },
  "application/vnd.fujitsu.oasysprs": {
    "source": "iana",
    "extensions": ["bh2"]
  },
  "application/vnd.fujixerox.art-ex": {
    "source": "iana"
  },
  "application/vnd.fujixerox.art4": {
    "source": "iana"
  },
  "application/vnd.fujixerox.ddd": {
    "source": "iana",
    "extensions": ["ddd"]
  },
  "application/vnd.fujixerox.docuworks": {
    "source": "iana",
    "extensions": ["xdw"]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    "source": "iana",
    "extensions": ["xbd"]
  },
  "application/vnd.fujixerox.docuworks.container": {
    "source": "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    "source": "iana"
  },
  "application/vnd.fut-misnet": {
    "source": "iana"
  },
  "application/vnd.futoin+cbor": {
    "source": "iana"
  },
  "application/vnd.futoin+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.fuzzysheet": {
    "source": "iana",
    "extensions": ["fzs"]
  },
  "application/vnd.genomatix.tuxedo": {
    "source": "iana",
    "extensions": ["txd"]
  },
  "application/vnd.geo+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geocube+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geogebra.file": {
    "source": "iana",
    "extensions": ["ggb"]
  },
  "application/vnd.geogebra.tool": {
    "source": "iana",
    "extensions": ["ggt"]
  },
  "application/vnd.geometry-explorer": {
    "source": "iana",
    "extensions": ["gex", "gre"]
  },
  "application/vnd.geonext": {
    "source": "iana",
    "extensions": ["gxt"]
  },
  "application/vnd.geoplan": {
    "source": "iana",
    "extensions": ["g2w"]
  },
  "application/vnd.geospace": {
    "source": "iana",
    "extensions": ["g3w"]
  },
  "application/vnd.gerber": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    "source": "iana"
  },
  "application/vnd.gmx": {
    "source": "iana",
    "extensions": ["gmx"]
  },
  "application/vnd.google-apps.document": {
    "compressible": false,
    "extensions": ["gdoc"]
  },
  "application/vnd.google-apps.presentation": {
    "compressible": false,
    "extensions": ["gslides"]
  },
  "application/vnd.google-apps.spreadsheet": {
    "compressible": false,
    "extensions": ["gsheet"]
  },
  "application/vnd.google-earth.kml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["kml"]
  },
  "application/vnd.google-earth.kmz": {
    "source": "iana",
    "compressible": false,
    "extensions": ["kmz"]
  },
  "application/vnd.gov.sk.e-form+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gov.sk.e-form+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.grafeq": {
    "source": "iana",
    "extensions": ["gqf", "gqs"]
  },
  "application/vnd.gridmp": {
    "source": "iana"
  },
  "application/vnd.groove-account": {
    "source": "iana",
    "extensions": ["gac"]
  },
  "application/vnd.groove-help": {
    "source": "iana",
    "extensions": ["ghf"]
  },
  "application/vnd.groove-identity-message": {
    "source": "iana",
    "extensions": ["gim"]
  },
  "application/vnd.groove-injector": {
    "source": "iana",
    "extensions": ["grv"]
  },
  "application/vnd.groove-tool-message": {
    "source": "iana",
    "extensions": ["gtm"]
  },
  "application/vnd.groove-tool-template": {
    "source": "iana",
    "extensions": ["tpl"]
  },
  "application/vnd.groove-vcard": {
    "source": "iana",
    "extensions": ["vcg"]
  },
  "application/vnd.hal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hal+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["hal"]
  },
  "application/vnd.handheld-entertainment+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zmm"]
  },
  "application/vnd.hbci": {
    "source": "iana",
    "extensions": ["hbci"]
  },
  "application/vnd.hc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hcl-bireports": {
    "source": "iana"
  },
  "application/vnd.hdt": {
    "source": "iana"
  },
  "application/vnd.heroku+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hhe.lesson-player": {
    "source": "iana",
    "extensions": ["les"]
  },
  "application/vnd.hp-hpgl": {
    "source": "iana",
    "extensions": ["hpgl"]
  },
  "application/vnd.hp-hpid": {
    "source": "iana",
    "extensions": ["hpid"]
  },
  "application/vnd.hp-hps": {
    "source": "iana",
    "extensions": ["hps"]
  },
  "application/vnd.hp-jlyt": {
    "source": "iana",
    "extensions": ["jlt"]
  },
  "application/vnd.hp-pcl": {
    "source": "iana",
    "extensions": ["pcl"]
  },
  "application/vnd.hp-pclxl": {
    "source": "iana",
    "extensions": ["pclxl"]
  },
  "application/vnd.httphone": {
    "source": "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    "source": "iana",
    "extensions": ["sfd-hdstx"]
  },
  "application/vnd.hyper+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyper-item+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyperdrive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hzn-3d-crossword": {
    "source": "iana"
  },
  "application/vnd.ibm.afplinedata": {
    "source": "iana"
  },
  "application/vnd.ibm.electronic-media": {
    "source": "iana"
  },
  "application/vnd.ibm.minipay": {
    "source": "iana",
    "extensions": ["mpy"]
  },
  "application/vnd.ibm.modcap": {
    "source": "iana",
    "extensions": ["afp", "listafp", "list3820"]
  },
  "application/vnd.ibm.rights-management": {
    "source": "iana",
    "extensions": ["irm"]
  },
  "application/vnd.ibm.secure-container": {
    "source": "iana",
    "extensions": ["sc"]
  },
  "application/vnd.iccprofile": {
    "source": "iana",
    "extensions": ["icc", "icm"]
  },
  "application/vnd.ieee.1905": {
    "source": "iana"
  },
  "application/vnd.igloader": {
    "source": "iana",
    "extensions": ["igl"]
  },
  "application/vnd.imagemeter.folder+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.imagemeter.image+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.immervision-ivp": {
    "source": "iana",
    "extensions": ["ivp"]
  },
  "application/vnd.immervision-ivu": {
    "source": "iana",
    "extensions": ["ivu"]
  },
  "application/vnd.ims.imsccv1p1": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    "source": "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informedcontrol.rms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informix-visionary": {
    "source": "iana"
  },
  "application/vnd.infotech.project": {
    "source": "iana"
  },
  "application/vnd.infotech.project+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.innopath.wamp.notification": {
    "source": "iana"
  },
  "application/vnd.insors.igm": {
    "source": "iana",
    "extensions": ["igm"]
  },
  "application/vnd.intercon.formnet": {
    "source": "iana",
    "extensions": ["xpw", "xpx"]
  },
  "application/vnd.intergeo": {
    "source": "iana",
    "extensions": ["i2g"]
  },
  "application/vnd.intertrust.digibox": {
    "source": "iana"
  },
  "application/vnd.intertrust.nncp": {
    "source": "iana"
  },
  "application/vnd.intu.qbo": {
    "source": "iana",
    "extensions": ["qbo"]
  },
  "application/vnd.intu.qfx": {
    "source": "iana",
    "extensions": ["qfx"]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ipunplugged.rcprofile": {
    "source": "iana",
    "extensions": ["rcprofile"]
  },
  "application/vnd.irepository.package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["irp"]
  },
  "application/vnd.is-xpr": {
    "source": "iana",
    "extensions": ["xpr"]
  },
  "application/vnd.isac.fcs": {
    "source": "iana",
    "extensions": ["fcs"]
  },
  "application/vnd.jam": {
    "source": "iana",
    "extensions": ["jam"]
  },
  "application/vnd.japannet-directory-service": {
    "source": "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-registration": {
    "source": "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-verification": {
    "source": "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    "source": "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    "source": "iana",
    "extensions": ["rms"]
  },
  "application/vnd.jisp": {
    "source": "iana",
    "extensions": ["jisp"]
  },
  "application/vnd.joost.joda-archive": {
    "source": "iana",
    "extensions": ["joda"]
  },
  "application/vnd.jsk.isdn-ngn": {
    "source": "iana"
  },
  "application/vnd.kahootz": {
    "source": "iana",
    "extensions": ["ktz", "ktr"]
  },
  "application/vnd.kde.karbon": {
    "source": "iana",
    "extensions": ["karbon"]
  },
  "application/vnd.kde.kchart": {
    "source": "iana",
    "extensions": ["chrt"]
  },
  "application/vnd.kde.kformula": {
    "source": "iana",
    "extensions": ["kfo"]
  },
  "application/vnd.kde.kivio": {
    "source": "iana",
    "extensions": ["flw"]
  },
  "application/vnd.kde.kontour": {
    "source": "iana",
    "extensions": ["kon"]
  },
  "application/vnd.kde.kpresenter": {
    "source": "iana",
    "extensions": ["kpr", "kpt"]
  },
  "application/vnd.kde.kspread": {
    "source": "iana",
    "extensions": ["ksp"]
  },
  "application/vnd.kde.kword": {
    "source": "iana",
    "extensions": ["kwd", "kwt"]
  },
  "application/vnd.kenameaapp": {
    "source": "iana",
    "extensions": ["htke"]
  },
  "application/vnd.kidspiration": {
    "source": "iana",
    "extensions": ["kia"]
  },
  "application/vnd.kinar": {
    "source": "iana",
    "extensions": ["kne", "knp"]
  },
  "application/vnd.koan": {
    "source": "iana",
    "extensions": ["skp", "skd", "skt", "skm"]
  },
  "application/vnd.kodak-descriptor": {
    "source": "iana",
    "extensions": ["sse"]
  },
  "application/vnd.las.las+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.las.las+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lasxml"]
  },
  "application/vnd.leap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.liberty-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    "source": "iana",
    "extensions": ["lbd"]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lbe"]
  },
  "application/vnd.lotus-1-2-3": {
    "source": "iana",
    "extensions": ["123"]
  },
  "application/vnd.lotus-approach": {
    "source": "iana",
    "extensions": ["apr"]
  },
  "application/vnd.lotus-freelance": {
    "source": "iana",
    "extensions": ["pre"]
  },
  "application/vnd.lotus-notes": {
    "source": "iana",
    "extensions": ["nsf"]
  },
  "application/vnd.lotus-organizer": {
    "source": "iana",
    "extensions": ["org"]
  },
  "application/vnd.lotus-screencam": {
    "source": "iana",
    "extensions": ["scm"]
  },
  "application/vnd.lotus-wordpro": {
    "source": "iana",
    "extensions": ["lwp"]
  },
  "application/vnd.macports.portpkg": {
    "source": "iana",
    "extensions": ["portpkg"]
  },
  "application/vnd.mapbox-vector-tile": {
    "source": "iana"
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.license+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.mdcf": {
    "source": "iana"
  },
  "application/vnd.mason+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.maxmind.maxmind-db": {
    "source": "iana"
  },
  "application/vnd.mcd": {
    "source": "iana",
    "extensions": ["mcd"]
  },
  "application/vnd.medcalcdata": {
    "source": "iana",
    "extensions": ["mc1"]
  },
  "application/vnd.mediastation.cdkey": {
    "source": "iana",
    "extensions": ["cdkey"]
  },
  "application/vnd.meridian-slingshot": {
    "source": "iana"
  },
  "application/vnd.mfer": {
    "source": "iana",
    "extensions": ["mwf"]
  },
  "application/vnd.mfmp": {
    "source": "iana",
    "extensions": ["mfm"]
  },
  "application/vnd.micro+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.micrografx.flo": {
    "source": "iana",
    "extensions": ["flo"]
  },
  "application/vnd.micrografx.igx": {
    "source": "iana",
    "extensions": ["igx"]
  },
  "application/vnd.microsoft.portable-executable": {
    "source": "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    "source": "iana"
  },
  "application/vnd.miele+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.mif": {
    "source": "iana",
    "extensions": ["mif"]
  },
  "application/vnd.minisoft-hp3000-save": {
    "source": "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    "source": "iana"
  },
  "application/vnd.mobius.daf": {
    "source": "iana",
    "extensions": ["daf"]
  },
  "application/vnd.mobius.dis": {
    "source": "iana",
    "extensions": ["dis"]
  },
  "application/vnd.mobius.mbk": {
    "source": "iana",
    "extensions": ["mbk"]
  },
  "application/vnd.mobius.mqy": {
    "source": "iana",
    "extensions": ["mqy"]
  },
  "application/vnd.mobius.msl": {
    "source": "iana",
    "extensions": ["msl"]
  },
  "application/vnd.mobius.plc": {
    "source": "iana",
    "extensions": ["plc"]
  },
  "application/vnd.mobius.txf": {
    "source": "iana",
    "extensions": ["txf"]
  },
  "application/vnd.mophun.application": {
    "source": "iana",
    "extensions": ["mpn"]
  },
  "application/vnd.mophun.certificate": {
    "source": "iana",
    "extensions": ["mpc"]
  },
  "application/vnd.motorola.flexsuite": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    "source": "iana"
  },
  "application/vnd.motorola.iprm": {
    "source": "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xul"]
  },
  "application/vnd.ms-3mfdocument": {
    "source": "iana"
  },
  "application/vnd.ms-artgalry": {
    "source": "iana",
    "extensions": ["cil"]
  },
  "application/vnd.ms-asf": {
    "source": "iana"
  },
  "application/vnd.ms-cab-compressed": {
    "source": "iana",
    "extensions": ["cab"]
  },
  "application/vnd.ms-color.iccprofile": {
    "source": "apache"
  },
  "application/vnd.ms-excel": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlam"]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsb"]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsm"]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["xltm"]
  },
  "application/vnd.ms-fontobject": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eot"]
  },
  "application/vnd.ms-htmlhelp": {
    "source": "iana",
    "extensions": ["chm"]
  },
  "application/vnd.ms-ims": {
    "source": "iana",
    "extensions": ["ims"]
  },
  "application/vnd.ms-lrm": {
    "source": "iana",
    "extensions": ["lrm"]
  },
  "application/vnd.ms-office.activex+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-officetheme": {
    "source": "iana",
    "extensions": ["thmx"]
  },
  "application/vnd.ms-opentype": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-outlook": {
    "compressible": false,
    "extensions": ["msg"]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    "source": "apache"
  },
  "application/vnd.ms-pki.seccat": {
    "source": "apache",
    "extensions": ["cat"]
  },
  "application/vnd.ms-pki.stl": {
    "source": "apache",
    "extensions": ["stl"]
  },
  "application/vnd.ms-playready.initiator+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-powerpoint": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ppt", "pps", "pot"]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppam"]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    "source": "iana",
    "extensions": ["pptm"]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    "source": "iana",
    "extensions": ["sldm"]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppsm"]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["potm"]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-printing.printticket+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-printschematicket+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-project": {
    "source": "iana",
    "extensions": ["mpp", "mpt"]
  },
  "application/vnd.ms-tnef": {
    "source": "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    "source": "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    "source": "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    "source": "iana",
    "extensions": ["docm"]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["dotm"]
  },
  "application/vnd.ms-works": {
    "source": "iana",
    "extensions": ["wps", "wks", "wcm", "wdb"]
  },
  "application/vnd.ms-wpl": {
    "source": "iana",
    "extensions": ["wpl"]
  },
  "application/vnd.ms-xpsdocument": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xps"]
  },
  "application/vnd.msa-disk-image": {
    "source": "iana"
  },
  "application/vnd.mseq": {
    "source": "iana",
    "extensions": ["mseq"]
  },
  "application/vnd.msign": {
    "source": "iana"
  },
  "application/vnd.multiad.creator": {
    "source": "iana"
  },
  "application/vnd.multiad.creator.cif": {
    "source": "iana"
  },
  "application/vnd.music-niff": {
    "source": "iana"
  },
  "application/vnd.musician": {
    "source": "iana",
    "extensions": ["mus"]
  },
  "application/vnd.muvee.style": {
    "source": "iana",
    "extensions": ["msty"]
  },
  "application/vnd.mynfc": {
    "source": "iana",
    "extensions": ["taglet"]
  },
  "application/vnd.ncd.control": {
    "source": "iana"
  },
  "application/vnd.ncd.reference": {
    "source": "iana"
  },
  "application/vnd.nearst.inv+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nervana": {
    "source": "iana"
  },
  "application/vnd.netfpx": {
    "source": "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    "source": "iana",
    "extensions": ["nlu"]
  },
  "application/vnd.nimn": {
    "source": "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    "source": "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    "source": "iana"
  },
  "application/vnd.nitf": {
    "source": "iana",
    "extensions": ["ntf", "nitf"]
  },
  "application/vnd.noblenet-directory": {
    "source": "iana",
    "extensions": ["nnd"]
  },
  "application/vnd.noblenet-sealer": {
    "source": "iana",
    "extensions": ["nns"]
  },
  "application/vnd.noblenet-web": {
    "source": "iana",
    "extensions": ["nnw"]
  },
  "application/vnd.nokia.catalogs": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.iptv.config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.isds-radio-presets": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.n-gage.data": {
    "source": "iana",
    "extensions": ["ngdat"]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    "source": "iana",
    "extensions": ["n-gage"]
  },
  "application/vnd.nokia.ncd": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.radio-preset": {
    "source": "iana",
    "extensions": ["rpst"]
  },
  "application/vnd.nokia.radio-presets": {
    "source": "iana",
    "extensions": ["rpss"]
  },
  "application/vnd.novadigm.edm": {
    "source": "iana",
    "extensions": ["edm"]
  },
  "application/vnd.novadigm.edx": {
    "source": "iana",
    "extensions": ["edx"]
  },
  "application/vnd.novadigm.ext": {
    "source": "iana",
    "extensions": ["ext"]
  },
  "application/vnd.ntt-local.content-share": {
    "source": "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    "source": "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    "source": "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    "source": "iana",
    "extensions": ["odc"]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    "source": "iana",
    "extensions": ["otc"]
  },
  "application/vnd.oasis.opendocument.database": {
    "source": "iana",
    "extensions": ["odb"]
  },
  "application/vnd.oasis.opendocument.formula": {
    "source": "iana",
    "extensions": ["odf"]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    "source": "iana",
    "extensions": ["odft"]
  },
  "application/vnd.oasis.opendocument.graphics": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odg"]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    "source": "iana",
    "extensions": ["otg"]
  },
  "application/vnd.oasis.opendocument.image": {
    "source": "iana",
    "extensions": ["odi"]
  },
  "application/vnd.oasis.opendocument.image-template": {
    "source": "iana",
    "extensions": ["oti"]
  },
  "application/vnd.oasis.opendocument.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odp"]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    "source": "iana",
    "extensions": ["otp"]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ods"]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    "source": "iana",
    "extensions": ["ots"]
  },
  "application/vnd.oasis.opendocument.text": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odt"]
  },
  "application/vnd.oasis.opendocument.text-master": {
    "source": "iana",
    "extensions": ["odm"]
  },
  "application/vnd.oasis.opendocument.text-template": {
    "source": "iana",
    "extensions": ["ott"]
  },
  "application/vnd.oasis.opendocument.text-web": {
    "source": "iana",
    "extensions": ["oth"]
  },
  "application/vnd.obn": {
    "source": "iana"
  },
  "application/vnd.ocf+cbor": {
    "source": "iana"
  },
  "application/vnd.oftn.l10n+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    "source": "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.pae.gem": {
    "source": "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.spdlist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.ueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.userprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.olpc-sugar": {
    "source": "iana",
    "extensions": ["xo"]
  },
  "application/vnd.oma-scws-config": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-request": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-response": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.imd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.ltkm": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sgdu": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.stkm": {
    "source": "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-pcc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.dcd": {
    "source": "iana"
  },
  "application/vnd.oma.dcdc": {
    "source": "iana"
  },
  "application/vnd.oma.dd2+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dd2"]
  },
  "application/vnd.oma.drm.risd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.group-usage-list+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+tlv": {
    "source": "iana"
  },
  "application/vnd.oma.pal+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.final-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.groups+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.push": {
    "source": "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.xcap-directory+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.omads-email+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.omads-file+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.omads-folder+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.omaloc-supl-init": {
    "source": "iana"
  },
  "application/vnd.onepager": {
    "source": "iana"
  },
  "application/vnd.onepagertamp": {
    "source": "iana"
  },
  "application/vnd.onepagertamx": {
    "source": "iana"
  },
  "application/vnd.onepagertat": {
    "source": "iana"
  },
  "application/vnd.onepagertatp": {
    "source": "iana"
  },
  "application/vnd.onepagertatx": {
    "source": "iana"
  },
  "application/vnd.openblox.game+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openblox.game-binary": {
    "source": "iana"
  },
  "application/vnd.openeye.oeb": {
    "source": "iana"
  },
  "application/vnd.openofficeorg.extension": {
    "source": "apache",
    "extensions": ["oxt"]
  },
  "application/vnd.openstreetmap.data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pptx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    "source": "iana",
    "extensions": ["sldx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    "source": "iana",
    "extensions": ["ppsx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    "source": "iana",
    "extensions": ["potx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xlsx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    "source": "iana",
    "extensions": ["xltx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    "source": "iana",
    "compressible": false,
    "extensions": ["docx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    "source": "iana",
    "extensions": ["dotx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oracle.resource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.orange.indata": {
    "source": "iana"
  },
  "application/vnd.osa.netdeploy": {
    "source": "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    "source": "iana",
    "extensions": ["mgp"]
  },
  "application/vnd.osgi.bundle": {
    "source": "iana"
  },
  "application/vnd.osgi.dp": {
    "source": "iana",
    "extensions": ["dp"]
  },
  "application/vnd.osgi.subsystem": {
    "source": "iana",
    "extensions": ["esa"]
  },
  "application/vnd.otps.ct-kip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oxli.countgraph": {
    "source": "iana"
  },
  "application/vnd.pagerduty+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.palm": {
    "source": "iana",
    "extensions": ["pdb", "pqa", "oprc"]
  },
  "application/vnd.panoply": {
    "source": "iana"
  },
  "application/vnd.paos.xml": {
    "source": "iana"
  },
  "application/vnd.patentdive": {
    "source": "iana"
  },
  "application/vnd.patientecommsdoc": {
    "source": "iana"
  },
  "application/vnd.pawaafile": {
    "source": "iana",
    "extensions": ["paw"]
  },
  "application/vnd.pcos": {
    "source": "iana"
  },
  "application/vnd.pg.format": {
    "source": "iana",
    "extensions": ["str"]
  },
  "application/vnd.pg.osasli": {
    "source": "iana",
    "extensions": ["ei6"]
  },
  "application/vnd.piaccess.application-licence": {
    "source": "iana"
  },
  "application/vnd.picsel": {
    "source": "iana",
    "extensions": ["efif"]
  },
  "application/vnd.pmi.widget": {
    "source": "iana",
    "extensions": ["wg"]
  },
  "application/vnd.poc.group-advertisement+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.pocketlearn": {
    "source": "iana",
    "extensions": ["plf"]
  },
  "application/vnd.powerbuilder6": {
    "source": "iana",
    "extensions": ["pbd"]
  },
  "application/vnd.powerbuilder6-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75-s": {
    "source": "iana"
  },
  "application/vnd.preminet": {
    "source": "iana"
  },
  "application/vnd.previewsystems.box": {
    "source": "iana",
    "extensions": ["box"]
  },
  "application/vnd.proteus.magazine": {
    "source": "iana",
    "extensions": ["mgz"]
  },
  "application/vnd.psfs": {
    "source": "iana"
  },
  "application/vnd.publishare-delta-tree": {
    "source": "iana",
    "extensions": ["qps"]
  },
  "application/vnd.pvi.ptid1": {
    "source": "iana",
    "extensions": ["ptid"]
  },
  "application/vnd.pwg-multiplexed": {
    "source": "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.qualcomm.brew-app-res": {
    "source": "iana"
  },
  "application/vnd.quarantainenet": {
    "source": "iana"
  },
  "application/vnd.quark.quarkxpress": {
    "source": "iana",
    "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
  },
  "application/vnd.quobject-quoxdocument": {
    "source": "iana"
  },
  "application/vnd.radisys.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rainstor.data": {
    "source": "iana"
  },
  "application/vnd.rapid": {
    "source": "iana"
  },
  "application/vnd.rar": {
    "source": "iana"
  },
  "application/vnd.realvnc.bed": {
    "source": "iana",
    "extensions": ["bed"]
  },
  "application/vnd.recordare.musicxml": {
    "source": "iana",
    "extensions": ["mxl"]
  },
  "application/vnd.recordare.musicxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musicxml"]
  },
  "application/vnd.renlearn.rlprint": {
    "source": "iana"
  },
  "application/vnd.restful+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rig.cryptonote": {
    "source": "iana",
    "extensions": ["cryptonote"]
  },
  "application/vnd.rim.cod": {
    "source": "apache",
    "extensions": ["cod"]
  },
  "application/vnd.rn-realmedia": {
    "source": "apache",
    "extensions": ["rm"]
  },
  "application/vnd.rn-realmedia-vbr": {
    "source": "apache",
    "extensions": ["rmvb"]
  },
  "application/vnd.route66.link66+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["link66"]
  },
  "application/vnd.rs-274x": {
    "source": "iana"
  },
  "application/vnd.ruckus.download": {
    "source": "iana"
  },
  "application/vnd.s3sms": {
    "source": "iana"
  },
  "application/vnd.sailingtracker.track": {
    "source": "iana",
    "extensions": ["st"]
  },
  "application/vnd.sbm.cid": {
    "source": "iana"
  },
  "application/vnd.sbm.mid2": {
    "source": "iana"
  },
  "application/vnd.scribus": {
    "source": "iana"
  },
  "application/vnd.sealed.3df": {
    "source": "iana"
  },
  "application/vnd.sealed.csf": {
    "source": "iana"
  },
  "application/vnd.sealed.doc": {
    "source": "iana"
  },
  "application/vnd.sealed.eml": {
    "source": "iana"
  },
  "application/vnd.sealed.mht": {
    "source": "iana"
  },
  "application/vnd.sealed.net": {
    "source": "iana"
  },
  "application/vnd.sealed.ppt": {
    "source": "iana"
  },
  "application/vnd.sealed.tiff": {
    "source": "iana"
  },
  "application/vnd.sealed.xls": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    "source": "iana"
  },
  "application/vnd.seemail": {
    "source": "iana",
    "extensions": ["see"]
  },
  "application/vnd.sema": {
    "source": "iana",
    "extensions": ["sema"]
  },
  "application/vnd.semd": {
    "source": "iana",
    "extensions": ["semd"]
  },
  "application/vnd.semf": {
    "source": "iana",
    "extensions": ["semf"]
  },
  "application/vnd.shana.informed.formdata": {
    "source": "iana",
    "extensions": ["ifm"]
  },
  "application/vnd.shana.informed.formtemplate": {
    "source": "iana",
    "extensions": ["itp"]
  },
  "application/vnd.shana.informed.interchange": {
    "source": "iana",
    "extensions": ["iif"]
  },
  "application/vnd.shana.informed.package": {
    "source": "iana",
    "extensions": ["ipk"]
  },
  "application/vnd.shootproof+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.sigrok.session": {
    "source": "iana"
  },
  "application/vnd.simtech-mindmapper": {
    "source": "iana",
    "extensions": ["twd", "twds"]
  },
  "application/vnd.siren+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.smaf": {
    "source": "iana",
    "extensions": ["mmf"]
  },
  "application/vnd.smart.notebook": {
    "source": "iana"
  },
  "application/vnd.smart.teacher": {
    "source": "iana",
    "extensions": ["teacher"]
  },
  "application/vnd.software602.filler.form+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.software602.filler.form-xml-zip": {
    "source": "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sdkm", "sdkd"]
  },
  "application/vnd.spotfire.dxp": {
    "source": "iana",
    "extensions": ["dxp"]
  },
  "application/vnd.spotfire.sfs": {
    "source": "iana",
    "extensions": ["sfs"]
  },
  "application/vnd.sqlite3": {
    "source": "iana"
  },
  "application/vnd.sss-cod": {
    "source": "iana"
  },
  "application/vnd.sss-dtf": {
    "source": "iana"
  },
  "application/vnd.sss-ntf": {
    "source": "iana"
  },
  "application/vnd.stardivision.calc": {
    "source": "apache",
    "extensions": ["sdc"]
  },
  "application/vnd.stardivision.draw": {
    "source": "apache",
    "extensions": ["sda"]
  },
  "application/vnd.stardivision.impress": {
    "source": "apache",
    "extensions": ["sdd"]
  },
  "application/vnd.stardivision.math": {
    "source": "apache",
    "extensions": ["smf"]
  },
  "application/vnd.stardivision.writer": {
    "source": "apache",
    "extensions": ["sdw", "vor"]
  },
  "application/vnd.stardivision.writer-global": {
    "source": "apache",
    "extensions": ["sgl"]
  },
  "application/vnd.stepmania.package": {
    "source": "iana",
    "extensions": ["smzip"]
  },
  "application/vnd.stepmania.stepchart": {
    "source": "iana",
    "extensions": ["sm"]
  },
  "application/vnd.street-stream": {
    "source": "iana"
  },
  "application/vnd.sun.wadl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wadl"]
  },
  "application/vnd.sun.xml.calc": {
    "source": "apache",
    "extensions": ["sxc"]
  },
  "application/vnd.sun.xml.calc.template": {
    "source": "apache",
    "extensions": ["stc"]
  },
  "application/vnd.sun.xml.draw": {
    "source": "apache",
    "extensions": ["sxd"]
  },
  "application/vnd.sun.xml.draw.template": {
    "source": "apache",
    "extensions": ["std"]
  },
  "application/vnd.sun.xml.impress": {
    "source": "apache",
    "extensions": ["sxi"]
  },
  "application/vnd.sun.xml.impress.template": {
    "source": "apache",
    "extensions": ["sti"]
  },
  "application/vnd.sun.xml.math": {
    "source": "apache",
    "extensions": ["sxm"]
  },
  "application/vnd.sun.xml.writer": {
    "source": "apache",
    "extensions": ["sxw"]
  },
  "application/vnd.sun.xml.writer.global": {
    "source": "apache",
    "extensions": ["sxg"]
  },
  "application/vnd.sun.xml.writer.template": {
    "source": "apache",
    "extensions": ["stw"]
  },
  "application/vnd.sus-calendar": {
    "source": "iana",
    "extensions": ["sus", "susp"]
  },
  "application/vnd.svd": {
    "source": "iana",
    "extensions": ["svd"]
  },
  "application/vnd.swiftview-ics": {
    "source": "iana"
  },
  "application/vnd.symbian.install": {
    "source": "apache",
    "extensions": ["sis", "sisx"]
  },
  "application/vnd.syncml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xsm"]
  },
  "application/vnd.syncml.dm+wbxml": {
    "source": "iana",
    "extensions": ["bdm"]
  },
  "application/vnd.syncml.dm+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdm"]
  },
  "application/vnd.syncml.dm.notification": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.syncml.ds.notification": {
    "source": "iana"
  },
  "application/vnd.tableschema+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tao.intent-module-archive": {
    "source": "iana",
    "extensions": ["tao"]
  },
  "application/vnd.tcpdump.pcap": {
    "source": "iana",
    "extensions": ["pcap", "cap", "dmp"]
  },
  "application/vnd.think-cell.ppttc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tml": {
    "source": "iana"
  },
  "application/vnd.tmobile-livetv": {
    "source": "iana",
    "extensions": ["tmo"]
  },
  "application/vnd.tri.onesource": {
    "source": "iana"
  },
  "application/vnd.trid.tpt": {
    "source": "iana",
    "extensions": ["tpt"]
  },
  "application/vnd.triscape.mxs": {
    "source": "iana",
    "extensions": ["mxs"]
  },
  "application/vnd.trueapp": {
    "source": "iana",
    "extensions": ["tra"]
  },
  "application/vnd.truedoc": {
    "source": "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    "source": "iana"
  },
  "application/vnd.ufdl": {
    "source": "iana",
    "extensions": ["ufd", "ufdl"]
  },
  "application/vnd.uiq.theme": {
    "source": "iana",
    "extensions": ["utz"]
  },
  "application/vnd.umajin": {
    "source": "iana",
    "extensions": ["umj"]
  },
  "application/vnd.unity": {
    "source": "iana",
    "extensions": ["unityweb"]
  },
  "application/vnd.uoml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uoml"]
  },
  "application/vnd.uplanet.alert": {
    "source": "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.list": {
    "source": "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.signal": {
    "source": "iana"
  },
  "application/vnd.uri-map": {
    "source": "iana"
  },
  "application/vnd.valve.source.material": {
    "source": "iana"
  },
  "application/vnd.vcx": {
    "source": "iana",
    "extensions": ["vcx"]
  },
  "application/vnd.vd-study": {
    "source": "iana"
  },
  "application/vnd.vectorworks": {
    "source": "iana"
  },
  "application/vnd.vel+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.verimatrix.vcas": {
    "source": "iana"
  },
  "application/vnd.veryant.thin": {
    "source": "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    "source": "iana"
  },
  "application/vnd.visio": {
    "source": "iana",
    "extensions": ["vsd", "vst", "vss", "vsw"]
  },
  "application/vnd.visionary": {
    "source": "iana",
    "extensions": ["vis"]
  },
  "application/vnd.vividence.scriptfile": {
    "source": "iana"
  },
  "application/vnd.vsf": {
    "source": "iana",
    "extensions": ["vsf"]
  },
  "application/vnd.wap.sic": {
    "source": "iana"
  },
  "application/vnd.wap.slc": {
    "source": "iana"
  },
  "application/vnd.wap.wbxml": {
    "source": "iana",
    "extensions": ["wbxml"]
  },
  "application/vnd.wap.wmlc": {
    "source": "iana",
    "extensions": ["wmlc"]
  },
  "application/vnd.wap.wmlscriptc": {
    "source": "iana",
    "extensions": ["wmlsc"]
  },
  "application/vnd.webturbo": {
    "source": "iana",
    "extensions": ["wtb"]
  },
  "application/vnd.wfa.p2p": {
    "source": "iana"
  },
  "application/vnd.wfa.wsc": {
    "source": "iana"
  },
  "application/vnd.windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.wmc": {
    "source": "iana"
  },
  "application/vnd.wmf.bootstrap": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    "source": "iana"
  },
  "application/vnd.wolfram.player": {
    "source": "iana",
    "extensions": ["nbp"]
  },
  "application/vnd.wordperfect": {
    "source": "iana",
    "extensions": ["wpd"]
  },
  "application/vnd.wqd": {
    "source": "iana",
    "extensions": ["wqd"]
  },
  "application/vnd.wrq-hp3000-labelled": {
    "source": "iana"
  },
  "application/vnd.wt.stf": {
    "source": "iana",
    "extensions": ["stf"]
  },
  "application/vnd.wv.csp+wbxml": {
    "source": "iana"
  },
  "application/vnd.wv.csp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.wv.ssp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xacml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xara": {
    "source": "iana",
    "extensions": ["xar"]
  },
  "application/vnd.xfdl": {
    "source": "iana",
    "extensions": ["xfdl"]
  },
  "application/vnd.xfdl.webform": {
    "source": "iana"
  },
  "application/vnd.xmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xmpie.cpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.dpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.plan": {
    "source": "iana"
  },
  "application/vnd.xmpie.ppkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.xlim": {
    "source": "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    "source": "iana",
    "extensions": ["hvd"]
  },
  "application/vnd.yamaha.hv-script": {
    "source": "iana",
    "extensions": ["hvs"]
  },
  "application/vnd.yamaha.hv-voice": {
    "source": "iana",
    "extensions": ["hvp"]
  },
  "application/vnd.yamaha.openscoreformat": {
    "source": "iana",
    "extensions": ["osf"]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osfpvg"]
  },
  "application/vnd.yamaha.remote-setup": {
    "source": "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    "source": "iana",
    "extensions": ["saf"]
  },
  "application/vnd.yamaha.smaf-phrase": {
    "source": "iana",
    "extensions": ["spf"]
  },
  "application/vnd.yamaha.through-ngn": {
    "source": "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    "source": "iana"
  },
  "application/vnd.yaoweme": {
    "source": "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    "source": "iana",
    "extensions": ["cmp"]
  },
  "application/vnd.youtube.yt": {
    "source": "iana"
  },
  "application/vnd.zul": {
    "source": "iana",
    "extensions": ["zir", "zirz"]
  },
  "application/vnd.zzazz.deck+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zaz"]
  },
  "application/voicexml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vxml"]
  },
  "application/voucher-cms+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vq-rtcpxr": {
    "source": "iana"
  },
  "application/wasm": {
    "compressible": true,
    "extensions": ["wasm"]
  },
  "application/watcherinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/webpush-options+json": {
    "source": "iana",
    "compressible": true
  },
  "application/whoispp-query": {
    "source": "iana"
  },
  "application/whoispp-response": {
    "source": "iana"
  },
  "application/widget": {
    "source": "iana",
    "extensions": ["wgt"]
  },
  "application/winhlp": {
    "source": "apache",
    "extensions": ["hlp"]
  },
  "application/wita": {
    "source": "iana"
  },
  "application/wordperfect5.1": {
    "source": "iana"
  },
  "application/wsdl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wsdl"]
  },
  "application/wspolicy+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wspolicy"]
  },
  "application/x-7z-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["7z"]
  },
  "application/x-abiword": {
    "source": "apache",
    "extensions": ["abw"]
  },
  "application/x-ace-compressed": {
    "source": "apache",
    "extensions": ["ace"]
  },
  "application/x-amf": {
    "source": "apache"
  },
  "application/x-apple-diskimage": {
    "source": "apache",
    "extensions": ["dmg"]
  },
  "application/x-arj": {
    "compressible": false,
    "extensions": ["arj"]
  },
  "application/x-authorware-bin": {
    "source": "apache",
    "extensions": ["aab", "x32", "u32", "vox"]
  },
  "application/x-authorware-map": {
    "source": "apache",
    "extensions": ["aam"]
  },
  "application/x-authorware-seg": {
    "source": "apache",
    "extensions": ["aas"]
  },
  "application/x-bcpio": {
    "source": "apache",
    "extensions": ["bcpio"]
  },
  "application/x-bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/x-bittorrent": {
    "source": "apache",
    "extensions": ["torrent"]
  },
  "application/x-blorb": {
    "source": "apache",
    "extensions": ["blb", "blorb"]
  },
  "application/x-bzip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz"]
  },
  "application/x-bzip2": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz2", "boz"]
  },
  "application/x-cbr": {
    "source": "apache",
    "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"]
  },
  "application/x-cdlink": {
    "source": "apache",
    "extensions": ["vcd"]
  },
  "application/x-cfs-compressed": {
    "source": "apache",
    "extensions": ["cfs"]
  },
  "application/x-chat": {
    "source": "apache",
    "extensions": ["chat"]
  },
  "application/x-chess-pgn": {
    "source": "apache",
    "extensions": ["pgn"]
  },
  "application/x-chrome-extension": {
    "extensions": ["crx"]
  },
  "application/x-cocoa": {
    "source": "nginx",
    "extensions": ["cco"]
  },
  "application/x-compress": {
    "source": "apache"
  },
  "application/x-conference": {
    "source": "apache",
    "extensions": ["nsc"]
  },
  "application/x-cpio": {
    "source": "apache",
    "extensions": ["cpio"]
  },
  "application/x-csh": {
    "source": "apache",
    "extensions": ["csh"]
  },
  "application/x-deb": {
    "compressible": false
  },
  "application/x-debian-package": {
    "source": "apache",
    "extensions": ["deb", "udeb"]
  },
  "application/x-dgc-compressed": {
    "source": "apache",
    "extensions": ["dgc"]
  },
  "application/x-director": {
    "source": "apache",
    "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
  },
  "application/x-doom": {
    "source": "apache",
    "extensions": ["wad"]
  },
  "application/x-dtbncx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ncx"]
  },
  "application/x-dtbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dtb"]
  },
  "application/x-dtbresource+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["res"]
  },
  "application/x-dvi": {
    "source": "apache",
    "compressible": false,
    "extensions": ["dvi"]
  },
  "application/x-envoy": {
    "source": "apache",
    "extensions": ["evy"]
  },
  "application/x-eva": {
    "source": "apache",
    "extensions": ["eva"]
  },
  "application/x-font-bdf": {
    "source": "apache",
    "extensions": ["bdf"]
  },
  "application/x-font-dos": {
    "source": "apache"
  },
  "application/x-font-framemaker": {
    "source": "apache"
  },
  "application/x-font-ghostscript": {
    "source": "apache",
    "extensions": ["gsf"]
  },
  "application/x-font-libgrx": {
    "source": "apache"
  },
  "application/x-font-linux-psf": {
    "source": "apache",
    "extensions": ["psf"]
  },
  "application/x-font-pcf": {
    "source": "apache",
    "extensions": ["pcf"]
  },
  "application/x-font-snf": {
    "source": "apache",
    "extensions": ["snf"]
  },
  "application/x-font-speedo": {
    "source": "apache"
  },
  "application/x-font-sunos-news": {
    "source": "apache"
  },
  "application/x-font-type1": {
    "source": "apache",
    "extensions": ["pfa", "pfb", "pfm", "afm"]
  },
  "application/x-font-vfont": {
    "source": "apache"
  },
  "application/x-freearc": {
    "source": "apache",
    "extensions": ["arc"]
  },
  "application/x-futuresplash": {
    "source": "apache",
    "extensions": ["spl"]
  },
  "application/x-gca-compressed": {
    "source": "apache",
    "extensions": ["gca"]
  },
  "application/x-glulx": {
    "source": "apache",
    "extensions": ["ulx"]
  },
  "application/x-gnumeric": {
    "source": "apache",
    "extensions": ["gnumeric"]
  },
  "application/x-gramps-xml": {
    "source": "apache",
    "extensions": ["gramps"]
  },
  "application/x-gtar": {
    "source": "apache",
    "extensions": ["gtar"]
  },
  "application/x-gzip": {
    "source": "apache"
  },
  "application/x-hdf": {
    "source": "apache",
    "extensions": ["hdf"]
  },
  "application/x-httpd-php": {
    "compressible": true,
    "extensions": ["php"]
  },
  "application/x-install-instructions": {
    "source": "apache",
    "extensions": ["install"]
  },
  "application/x-iso9660-image": {
    "source": "apache",
    "extensions": ["iso"]
  },
  "application/x-java-archive-diff": {
    "source": "nginx",
    "extensions": ["jardiff"]
  },
  "application/x-java-jnlp-file": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jnlp"]
  },
  "application/x-javascript": {
    "compressible": true
  },
  "application/x-latex": {
    "source": "apache",
    "compressible": false,
    "extensions": ["latex"]
  },
  "application/x-lua-bytecode": {
    "extensions": ["luac"]
  },
  "application/x-lzh-compressed": {
    "source": "apache",
    "extensions": ["lzh", "lha"]
  },
  "application/x-makeself": {
    "source": "nginx",
    "extensions": ["run"]
  },
  "application/x-mie": {
    "source": "apache",
    "extensions": ["mie"]
  },
  "application/x-mobipocket-ebook": {
    "source": "apache",
    "extensions": ["prc", "mobi"]
  },
  "application/x-mpegurl": {
    "compressible": false
  },
  "application/x-ms-application": {
    "source": "apache",
    "extensions": ["application"]
  },
  "application/x-ms-shortcut": {
    "source": "apache",
    "extensions": ["lnk"]
  },
  "application/x-ms-wmd": {
    "source": "apache",
    "extensions": ["wmd"]
  },
  "application/x-ms-wmz": {
    "source": "apache",
    "extensions": ["wmz"]
  },
  "application/x-ms-xbap": {
    "source": "apache",
    "extensions": ["xbap"]
  },
  "application/x-msaccess": {
    "source": "apache",
    "extensions": ["mdb"]
  },
  "application/x-msbinder": {
    "source": "apache",
    "extensions": ["obd"]
  },
  "application/x-mscardfile": {
    "source": "apache",
    "extensions": ["crd"]
  },
  "application/x-msclip": {
    "source": "apache",
    "extensions": ["clp"]
  },
  "application/x-msdos-program": {
    "extensions": ["exe"]
  },
  "application/x-msdownload": {
    "source": "apache",
    "extensions": ["exe", "dll", "com", "bat", "msi"]
  },
  "application/x-msmediaview": {
    "source": "apache",
    "extensions": ["mvb", "m13", "m14"]
  },
  "application/x-msmetafile": {
    "source": "apache",
    "extensions": ["wmf", "wmz", "emf", "emz"]
  },
  "application/x-msmoney": {
    "source": "apache",
    "extensions": ["mny"]
  },
  "application/x-mspublisher": {
    "source": "apache",
    "extensions": ["pub"]
  },
  "application/x-msschedule": {
    "source": "apache",
    "extensions": ["scd"]
  },
  "application/x-msterminal": {
    "source": "apache",
    "extensions": ["trm"]
  },
  "application/x-mswrite": {
    "source": "apache",
    "extensions": ["wri"]
  },
  "application/x-netcdf": {
    "source": "apache",
    "extensions": ["nc", "cdf"]
  },
  "application/x-ns-proxy-autoconfig": {
    "compressible": true,
    "extensions": ["pac"]
  },
  "application/x-nzb": {
    "source": "apache",
    "extensions": ["nzb"]
  },
  "application/x-perl": {
    "source": "nginx",
    "extensions": ["pl", "pm"]
  },
  "application/x-pilot": {
    "source": "nginx",
    "extensions": ["prc", "pdb"]
  },
  "application/x-pkcs12": {
    "source": "apache",
    "compressible": false,
    "extensions": ["p12", "pfx"]
  },
  "application/x-pkcs7-certificates": {
    "source": "apache",
    "extensions": ["p7b", "spc"]
  },
  "application/x-pkcs7-certreqresp": {
    "source": "apache",
    "extensions": ["p7r"]
  },
  "application/x-rar-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["rar"]
  },
  "application/x-redhat-package-manager": {
    "source": "nginx",
    "extensions": ["rpm"]
  },
  "application/x-research-info-systems": {
    "source": "apache",
    "extensions": ["ris"]
  },
  "application/x-sea": {
    "source": "nginx",
    "extensions": ["sea"]
  },
  "application/x-sh": {
    "source": "apache",
    "compressible": true,
    "extensions": ["sh"]
  },
  "application/x-shar": {
    "source": "apache",
    "extensions": ["shar"]
  },
  "application/x-shockwave-flash": {
    "source": "apache",
    "compressible": false,
    "extensions": ["swf"]
  },
  "application/x-silverlight-app": {
    "source": "apache",
    "extensions": ["xap"]
  },
  "application/x-sql": {
    "source": "apache",
    "extensions": ["sql"]
  },
  "application/x-stuffit": {
    "source": "apache",
    "compressible": false,
    "extensions": ["sit"]
  },
  "application/x-stuffitx": {
    "source": "apache",
    "extensions": ["sitx"]
  },
  "application/x-subrip": {
    "source": "apache",
    "extensions": ["srt"]
  },
  "application/x-sv4cpio": {
    "source": "apache",
    "extensions": ["sv4cpio"]
  },
  "application/x-sv4crc": {
    "source": "apache",
    "extensions": ["sv4crc"]
  },
  "application/x-t3vm-image": {
    "source": "apache",
    "extensions": ["t3"]
  },
  "application/x-tads": {
    "source": "apache",
    "extensions": ["gam"]
  },
  "application/x-tar": {
    "source": "apache",
    "compressible": true,
    "extensions": ["tar"]
  },
  "application/x-tcl": {
    "source": "apache",
    "extensions": ["tcl", "tk"]
  },
  "application/x-tex": {
    "source": "apache",
    "extensions": ["tex"]
  },
  "application/x-tex-tfm": {
    "source": "apache",
    "extensions": ["tfm"]
  },
  "application/x-texinfo": {
    "source": "apache",
    "extensions": ["texinfo", "texi"]
  },
  "application/x-tgif": {
    "source": "apache",
    "extensions": ["obj"]
  },
  "application/x-ustar": {
    "source": "apache",
    "extensions": ["ustar"]
  },
  "application/x-virtualbox-hdd": {
    "compressible": true,
    "extensions": ["hdd"]
  },
  "application/x-virtualbox-ova": {
    "compressible": true,
    "extensions": ["ova"]
  },
  "application/x-virtualbox-ovf": {
    "compressible": true,
    "extensions": ["ovf"]
  },
  "application/x-virtualbox-vbox": {
    "compressible": true,
    "extensions": ["vbox"]
  },
  "application/x-virtualbox-vbox-extpack": {
    "compressible": false,
    "extensions": ["vbox-extpack"]
  },
  "application/x-virtualbox-vdi": {
    "compressible": true,
    "extensions": ["vdi"]
  },
  "application/x-virtualbox-vhd": {
    "compressible": true,
    "extensions": ["vhd"]
  },
  "application/x-virtualbox-vmdk": {
    "compressible": true,
    "extensions": ["vmdk"]
  },
  "application/x-wais-source": {
    "source": "apache",
    "extensions": ["src"]
  },
  "application/x-web-app-manifest+json": {
    "compressible": true,
    "extensions": ["webapp"]
  },
  "application/x-www-form-urlencoded": {
    "source": "iana",
    "compressible": true
  },
  "application/x-x509-ca-cert": {
    "source": "apache",
    "extensions": ["der", "crt", "pem"]
  },
  "application/x-xfig": {
    "source": "apache",
    "extensions": ["fig"]
  },
  "application/x-xliff+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/x-xpinstall": {
    "source": "apache",
    "compressible": false,
    "extensions": ["xpi"]
  },
  "application/x-xz": {
    "source": "apache",
    "extensions": ["xz"]
  },
  "application/x-zmachine": {
    "source": "apache",
    "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
  },
  "application/x400-bp": {
    "source": "iana"
  },
  "application/xacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xaml+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xaml"]
  },
  "application/xcap-att+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcap-caps+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcap-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/xcap-el+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcap-error+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcap-ns+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcon-conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcon-conference-info-diff+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xenc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xenc"]
  },
  "application/xhtml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xhtml", "xht"]
  },
  "application/xhtml-voice+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/xliff+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml", "xsl", "xsd", "rng"]
  },
  "application/xml-dtd": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dtd"]
  },
  "application/xml-external-parsed-entity": {
    "source": "iana"
  },
  "application/xml-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xmpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xop+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xop"]
  },
  "application/xproc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xpl"]
  },
  "application/xslt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xslt"]
  },
  "application/xspf+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xspf"]
  },
  "application/xv+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mxml", "xhvml", "xvml", "xvm"]
  },
  "application/yang": {
    "source": "iana",
    "extensions": ["yang"]
  },
  "application/yang-data+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yin+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["yin"]
  },
  "application/zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["zip"]
  },
  "application/zlib": {
    "source": "iana"
  },
  "application/zstd": {
    "source": "iana"
  },
  "audio/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "audio/32kadpcm": {
    "source": "iana"
  },
  "audio/3gpp": {
    "source": "iana",
    "compressible": false,
    "extensions": ["3gpp"]
  },
  "audio/3gpp2": {
    "source": "iana"
  },
  "audio/aac": {
    "source": "iana"
  },
  "audio/ac3": {
    "source": "iana"
  },
  "audio/adpcm": {
    "source": "apache",
    "extensions": ["adp"]
  },
  "audio/amr": {
    "source": "iana"
  },
  "audio/amr-wb": {
    "source": "iana"
  },
  "audio/amr-wb+": {
    "source": "iana"
  },
  "audio/aptx": {
    "source": "iana"
  },
  "audio/asc": {
    "source": "iana"
  },
  "audio/atrac-advanced-lossless": {
    "source": "iana"
  },
  "audio/atrac-x": {
    "source": "iana"
  },
  "audio/atrac3": {
    "source": "iana"
  },
  "audio/basic": {
    "source": "iana",
    "compressible": false,
    "extensions": ["au", "snd"]
  },
  "audio/bv16": {
    "source": "iana"
  },
  "audio/bv32": {
    "source": "iana"
  },
  "audio/clearmode": {
    "source": "iana"
  },
  "audio/cn": {
    "source": "iana"
  },
  "audio/dat12": {
    "source": "iana"
  },
  "audio/dls": {
    "source": "iana"
  },
  "audio/dsr-es201108": {
    "source": "iana"
  },
  "audio/dsr-es202050": {
    "source": "iana"
  },
  "audio/dsr-es202211": {
    "source": "iana"
  },
  "audio/dsr-es202212": {
    "source": "iana"
  },
  "audio/dv": {
    "source": "iana"
  },
  "audio/dvi4": {
    "source": "iana"
  },
  "audio/eac3": {
    "source": "iana"
  },
  "audio/encaprtp": {
    "source": "iana"
  },
  "audio/evrc": {
    "source": "iana"
  },
  "audio/evrc-qcp": {
    "source": "iana"
  },
  "audio/evrc0": {
    "source": "iana"
  },
  "audio/evrc1": {
    "source": "iana"
  },
  "audio/evrcb": {
    "source": "iana"
  },
  "audio/evrcb0": {
    "source": "iana"
  },
  "audio/evrcb1": {
    "source": "iana"
  },
  "audio/evrcnw": {
    "source": "iana"
  },
  "audio/evrcnw0": {
    "source": "iana"
  },
  "audio/evrcnw1": {
    "source": "iana"
  },
  "audio/evrcwb": {
    "source": "iana"
  },
  "audio/evrcwb0": {
    "source": "iana"
  },
  "audio/evrcwb1": {
    "source": "iana"
  },
  "audio/evs": {
    "source": "iana"
  },
  "audio/fwdred": {
    "source": "iana"
  },
  "audio/g711-0": {
    "source": "iana"
  },
  "audio/g719": {
    "source": "iana"
  },
  "audio/g722": {
    "source": "iana"
  },
  "audio/g7221": {
    "source": "iana"
  },
  "audio/g723": {
    "source": "iana"
  },
  "audio/g726-16": {
    "source": "iana"
  },
  "audio/g726-24": {
    "source": "iana"
  },
  "audio/g726-32": {
    "source": "iana"
  },
  "audio/g726-40": {
    "source": "iana"
  },
  "audio/g728": {
    "source": "iana"
  },
  "audio/g729": {
    "source": "iana"
  },
  "audio/g7291": {
    "source": "iana"
  },
  "audio/g729d": {
    "source": "iana"
  },
  "audio/g729e": {
    "source": "iana"
  },
  "audio/gsm": {
    "source": "iana"
  },
  "audio/gsm-efr": {
    "source": "iana"
  },
  "audio/gsm-hr-08": {
    "source": "iana"
  },
  "audio/ilbc": {
    "source": "iana"
  },
  "audio/ip-mr_v2.5": {
    "source": "iana"
  },
  "audio/isac": {
    "source": "apache"
  },
  "audio/l16": {
    "source": "iana"
  },
  "audio/l20": {
    "source": "iana"
  },
  "audio/l24": {
    "source": "iana",
    "compressible": false
  },
  "audio/l8": {
    "source": "iana"
  },
  "audio/lpc": {
    "source": "iana"
  },
  "audio/melp": {
    "source": "iana"
  },
  "audio/melp1200": {
    "source": "iana"
  },
  "audio/melp2400": {
    "source": "iana"
  },
  "audio/melp600": {
    "source": "iana"
  },
  "audio/midi": {
    "source": "apache",
    "extensions": ["mid", "midi", "kar", "rmi"]
  },
  "audio/mobile-xmf": {
    "source": "iana"
  },
  "audio/mp3": {
    "compressible": false,
    "extensions": ["mp3"]
  },
  "audio/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["m4a", "mp4a"]
  },
  "audio/mp4a-latm": {
    "source": "iana"
  },
  "audio/mpa": {
    "source": "iana"
  },
  "audio/mpa-robust": {
    "source": "iana"
  },
  "audio/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
  },
  "audio/mpeg4-generic": {
    "source": "iana"
  },
  "audio/musepack": {
    "source": "apache"
  },
  "audio/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["oga", "ogg", "spx"]
  },
  "audio/opus": {
    "source": "iana"
  },
  "audio/parityfec": {
    "source": "iana"
  },
  "audio/pcma": {
    "source": "iana"
  },
  "audio/pcma-wb": {
    "source": "iana"
  },
  "audio/pcmu": {
    "source": "iana"
  },
  "audio/pcmu-wb": {
    "source": "iana"
  },
  "audio/prs.sid": {
    "source": "iana"
  },
  "audio/qcelp": {
    "source": "iana"
  },
  "audio/raptorfec": {
    "source": "iana"
  },
  "audio/red": {
    "source": "iana"
  },
  "audio/rtp-enc-aescm128": {
    "source": "iana"
  },
  "audio/rtp-midi": {
    "source": "iana"
  },
  "audio/rtploopback": {
    "source": "iana"
  },
  "audio/rtx": {
    "source": "iana"
  },
  "audio/s3m": {
    "source": "apache",
    "extensions": ["s3m"]
  },
  "audio/silk": {
    "source": "apache",
    "extensions": ["sil"]
  },
  "audio/smv": {
    "source": "iana"
  },
  "audio/smv-qcp": {
    "source": "iana"
  },
  "audio/smv0": {
    "source": "iana"
  },
  "audio/sp-midi": {
    "source": "iana"
  },
  "audio/speex": {
    "source": "iana"
  },
  "audio/t140c": {
    "source": "iana"
  },
  "audio/t38": {
    "source": "iana"
  },
  "audio/telephone-event": {
    "source": "iana"
  },
  "audio/tetra_acelp": {
    "source": "iana"
  },
  "audio/tone": {
    "source": "iana"
  },
  "audio/uemclip": {
    "source": "iana"
  },
  "audio/ulpfec": {
    "source": "iana"
  },
  "audio/usac": {
    "source": "iana"
  },
  "audio/vdvi": {
    "source": "iana"
  },
  "audio/vmr-wb": {
    "source": "iana"
  },
  "audio/vnd.3gpp.iufp": {
    "source": "iana"
  },
  "audio/vnd.4sb": {
    "source": "iana"
  },
  "audio/vnd.audiokoz": {
    "source": "iana"
  },
  "audio/vnd.celp": {
    "source": "iana"
  },
  "audio/vnd.cisco.nse": {
    "source": "iana"
  },
  "audio/vnd.cmles.radio-events": {
    "source": "iana"
  },
  "audio/vnd.cns.anp1": {
    "source": "iana"
  },
  "audio/vnd.cns.inf1": {
    "source": "iana"
  },
  "audio/vnd.dece.audio": {
    "source": "iana",
    "extensions": ["uva", "uvva"]
  },
  "audio/vnd.digital-winds": {
    "source": "iana",
    "extensions": ["eol"]
  },
  "audio/vnd.dlna.adts": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    "source": "iana"
  },
  "audio/vnd.dolby.mlp": {
    "source": "iana"
  },
  "audio/vnd.dolby.mps": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2x": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2z": {
    "source": "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    "source": "iana"
  },
  "audio/vnd.dra": {
    "source": "iana",
    "extensions": ["dra"]
  },
  "audio/vnd.dts": {
    "source": "iana",
    "extensions": ["dts"]
  },
  "audio/vnd.dts.hd": {
    "source": "iana",
    "extensions": ["dtshd"]
  },
  "audio/vnd.dts.uhd": {
    "source": "iana"
  },
  "audio/vnd.dvb.file": {
    "source": "iana"
  },
  "audio/vnd.everad.plj": {
    "source": "iana"
  },
  "audio/vnd.hns.audio": {
    "source": "iana"
  },
  "audio/vnd.lucent.voice": {
    "source": "iana",
    "extensions": ["lvp"]
  },
  "audio/vnd.ms-playready.media.pya": {
    "source": "iana",
    "extensions": ["pya"]
  },
  "audio/vnd.nokia.mobile-xmf": {
    "source": "iana"
  },
  "audio/vnd.nortel.vbk": {
    "source": "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    "source": "iana",
    "extensions": ["ecelp4800"]
  },
  "audio/vnd.nuera.ecelp7470": {
    "source": "iana",
    "extensions": ["ecelp7470"]
  },
  "audio/vnd.nuera.ecelp9600": {
    "source": "iana",
    "extensions": ["ecelp9600"]
  },
  "audio/vnd.octel.sbc": {
    "source": "iana"
  },
  "audio/vnd.presonus.multitrack": {
    "source": "iana"
  },
  "audio/vnd.qcelp": {
    "source": "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    "source": "iana"
  },
  "audio/vnd.rip": {
    "source": "iana",
    "extensions": ["rip"]
  },
  "audio/vnd.rn-realaudio": {
    "compressible": false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    "source": "iana"
  },
  "audio/vnd.vmx.cvsd": {
    "source": "iana"
  },
  "audio/vnd.wave": {
    "compressible": false
  },
  "audio/vorbis": {
    "source": "iana",
    "compressible": false
  },
  "audio/vorbis-config": {
    "source": "iana"
  },
  "audio/wav": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/wave": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["weba"]
  },
  "audio/x-aac": {
    "source": "apache",
    "compressible": false,
    "extensions": ["aac"]
  },
  "audio/x-aiff": {
    "source": "apache",
    "extensions": ["aif", "aiff", "aifc"]
  },
  "audio/x-caf": {
    "source": "apache",
    "compressible": false,
    "extensions": ["caf"]
  },
  "audio/x-flac": {
    "source": "apache",
    "extensions": ["flac"]
  },
  "audio/x-m4a": {
    "source": "nginx",
    "extensions": ["m4a"]
  },
  "audio/x-matroska": {
    "source": "apache",
    "extensions": ["mka"]
  },
  "audio/x-mpegurl": {
    "source": "apache",
    "extensions": ["m3u"]
  },
  "audio/x-ms-wax": {
    "source": "apache",
    "extensions": ["wax"]
  },
  "audio/x-ms-wma": {
    "source": "apache",
    "extensions": ["wma"]
  },
  "audio/x-pn-realaudio": {
    "source": "apache",
    "extensions": ["ram", "ra"]
  },
  "audio/x-pn-realaudio-plugin": {
    "source": "apache",
    "extensions": ["rmp"]
  },
  "audio/x-realaudio": {
    "source": "nginx",
    "extensions": ["ra"]
  },
  "audio/x-tta": {
    "source": "apache"
  },
  "audio/x-wav": {
    "source": "apache",
    "extensions": ["wav"]
  },
  "audio/xm": {
    "source": "apache",
    "extensions": ["xm"]
  },
  "chemical/x-cdx": {
    "source": "apache",
    "extensions": ["cdx"]
  },
  "chemical/x-cif": {
    "source": "apache",
    "extensions": ["cif"]
  },
  "chemical/x-cmdf": {
    "source": "apache",
    "extensions": ["cmdf"]
  },
  "chemical/x-cml": {
    "source": "apache",
    "extensions": ["cml"]
  },
  "chemical/x-csml": {
    "source": "apache",
    "extensions": ["csml"]
  },
  "chemical/x-pdb": {
    "source": "apache"
  },
  "chemical/x-xyz": {
    "source": "apache",
    "extensions": ["xyz"]
  },
  "font/collection": {
    "source": "iana",
    "extensions": ["ttc"]
  },
  "font/otf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["otf"]
  },
  "font/sfnt": {
    "source": "iana"
  },
  "font/ttf": {
    "source": "iana",
    "extensions": ["ttf"]
  },
  "font/woff": {
    "source": "iana",
    "extensions": ["woff"]
  },
  "font/woff2": {
    "source": "iana",
    "extensions": ["woff2"]
  },
  "image/aces": {
    "source": "iana",
    "extensions": ["exr"]
  },
  "image/apng": {
    "compressible": false,
    "extensions": ["apng"]
  },
  "image/avci": {
    "source": "iana"
  },
  "image/avcs": {
    "source": "iana"
  },
  "image/bmp": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/cgm": {
    "source": "iana",
    "extensions": ["cgm"]
  },
  "image/dicom-rle": {
    "source": "iana",
    "extensions": ["drle"]
  },
  "image/emf": {
    "source": "iana",
    "extensions": ["emf"]
  },
  "image/fits": {
    "source": "iana",
    "extensions": ["fits"]
  },
  "image/g3fax": {
    "source": "iana",
    "extensions": ["g3"]
  },
  "image/gif": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gif"]
  },
  "image/heic": {
    "source": "iana",
    "extensions": ["heic"]
  },
  "image/heic-sequence": {
    "source": "iana",
    "extensions": ["heics"]
  },
  "image/heif": {
    "source": "iana",
    "extensions": ["heif"]
  },
  "image/heif-sequence": {
    "source": "iana",
    "extensions": ["heifs"]
  },
  "image/ief": {
    "source": "iana",
    "extensions": ["ief"]
  },
  "image/jls": {
    "source": "iana",
    "extensions": ["jls"]
  },
  "image/jp2": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jp2", "jpg2"]
  },
  "image/jpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpeg", "jpg", "jpe"]
  },
  "image/jpm": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpm"]
  },
  "image/jpx": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpx", "jpf"]
  },
  "image/jxr": {
    "source": "iana",
    "extensions": ["jxr"]
  },
  "image/ktx": {
    "source": "iana",
    "extensions": ["ktx"]
  },
  "image/naplps": {
    "source": "iana"
  },
  "image/pjpeg": {
    "compressible": false
  },
  "image/png": {
    "source": "iana",
    "compressible": false,
    "extensions": ["png"]
  },
  "image/prs.btif": {
    "source": "iana",
    "extensions": ["btif"]
  },
  "image/prs.pti": {
    "source": "iana",
    "extensions": ["pti"]
  },
  "image/pwg-raster": {
    "source": "iana"
  },
  "image/sgi": {
    "source": "apache",
    "extensions": ["sgi"]
  },
  "image/svg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["svg", "svgz"]
  },
  "image/t38": {
    "source": "iana",
    "extensions": ["t38"]
  },
  "image/tiff": {
    "source": "iana",
    "compressible": false,
    "extensions": ["tif", "tiff"]
  },
  "image/tiff-fx": {
    "source": "iana",
    "extensions": ["tfx"]
  },
  "image/vnd.adobe.photoshop": {
    "source": "iana",
    "compressible": true,
    "extensions": ["psd"]
  },
  "image/vnd.airzip.accelerator.azv": {
    "source": "iana",
    "extensions": ["azv"]
  },
  "image/vnd.cns.inf2": {
    "source": "iana"
  },
  "image/vnd.dece.graphic": {
    "source": "iana",
    "extensions": ["uvi", "uvvi", "uvg", "uvvg"]
  },
  "image/vnd.djvu": {
    "source": "iana",
    "extensions": ["djvu", "djv"]
  },
  "image/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "image/vnd.dwg": {
    "source": "iana",
    "extensions": ["dwg"]
  },
  "image/vnd.dxf": {
    "source": "iana",
    "extensions": ["dxf"]
  },
  "image/vnd.fastbidsheet": {
    "source": "iana",
    "extensions": ["fbs"]
  },
  "image/vnd.fpx": {
    "source": "iana",
    "extensions": ["fpx"]
  },
  "image/vnd.fst": {
    "source": "iana",
    "extensions": ["fst"]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    "source": "iana",
    "extensions": ["mmr"]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    "source": "iana",
    "extensions": ["rlc"]
  },
  "image/vnd.globalgraphics.pgb": {
    "source": "iana"
  },
  "image/vnd.microsoft.icon": {
    "source": "iana",
    "extensions": ["ico"]
  },
  "image/vnd.mix": {
    "source": "iana"
  },
  "image/vnd.mozilla.apng": {
    "source": "iana"
  },
  "image/vnd.ms-modi": {
    "source": "iana",
    "extensions": ["mdi"]
  },
  "image/vnd.ms-photo": {
    "source": "apache",
    "extensions": ["wdp"]
  },
  "image/vnd.net-fpx": {
    "source": "iana",
    "extensions": ["npx"]
  },
  "image/vnd.radiance": {
    "source": "iana"
  },
  "image/vnd.sealed.png": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    "source": "iana"
  },
  "image/vnd.svf": {
    "source": "iana"
  },
  "image/vnd.tencent.tap": {
    "source": "iana",
    "extensions": ["tap"]
  },
  "image/vnd.valve.source.texture": {
    "source": "iana",
    "extensions": ["vtf"]
  },
  "image/vnd.wap.wbmp": {
    "source": "iana",
    "extensions": ["wbmp"]
  },
  "image/vnd.xiff": {
    "source": "iana",
    "extensions": ["xif"]
  },
  "image/vnd.zbrush.pcx": {
    "source": "iana",
    "extensions": ["pcx"]
  },
  "image/webp": {
    "source": "apache",
    "extensions": ["webp"]
  },
  "image/wmf": {
    "source": "iana",
    "extensions": ["wmf"]
  },
  "image/x-3ds": {
    "source": "apache",
    "extensions": ["3ds"]
  },
  "image/x-cmu-raster": {
    "source": "apache",
    "extensions": ["ras"]
  },
  "image/x-cmx": {
    "source": "apache",
    "extensions": ["cmx"]
  },
  "image/x-freehand": {
    "source": "apache",
    "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"]
  },
  "image/x-icon": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ico"]
  },
  "image/x-jng": {
    "source": "nginx",
    "extensions": ["jng"]
  },
  "image/x-mrsid-image": {
    "source": "apache",
    "extensions": ["sid"]
  },
  "image/x-ms-bmp": {
    "source": "nginx",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/x-pcx": {
    "source": "apache",
    "extensions": ["pcx"]
  },
  "image/x-pict": {
    "source": "apache",
    "extensions": ["pic", "pct"]
  },
  "image/x-portable-anymap": {
    "source": "apache",
    "extensions": ["pnm"]
  },
  "image/x-portable-bitmap": {
    "source": "apache",
    "extensions": ["pbm"]
  },
  "image/x-portable-graymap": {
    "source": "apache",
    "extensions": ["pgm"]
  },
  "image/x-portable-pixmap": {
    "source": "apache",
    "extensions": ["ppm"]
  },
  "image/x-rgb": {
    "source": "apache",
    "extensions": ["rgb"]
  },
  "image/x-tga": {
    "source": "apache",
    "extensions": ["tga"]
  },
  "image/x-xbitmap": {
    "source": "apache",
    "extensions": ["xbm"]
  },
  "image/x-xcf": {
    "compressible": false
  },
  "image/x-xpixmap": {
    "source": "apache",
    "extensions": ["xpm"]
  },
  "image/x-xwindowdump": {
    "source": "apache",
    "extensions": ["xwd"]
  },
  "message/cpim": {
    "source": "iana"
  },
  "message/delivery-status": {
    "source": "iana"
  },
  "message/disposition-notification": {
    "source": "iana",
    "extensions": ["disposition-notification"]
  },
  "message/external-body": {
    "source": "iana"
  },
  "message/feedback-report": {
    "source": "iana"
  },
  "message/global": {
    "source": "iana",
    "extensions": ["u8msg"]
  },
  "message/global-delivery-status": {
    "source": "iana",
    "extensions": ["u8dsn"]
  },
  "message/global-disposition-notification": {
    "source": "iana",
    "extensions": ["u8mdn"]
  },
  "message/global-headers": {
    "source": "iana",
    "extensions": ["u8hdr"]
  },
  "message/http": {
    "source": "iana",
    "compressible": false
  },
  "message/imdn+xml": {
    "source": "iana",
    "compressible": true
  },
  "message/news": {
    "source": "iana"
  },
  "message/partial": {
    "source": "iana",
    "compressible": false
  },
  "message/rfc822": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eml", "mime"]
  },
  "message/s-http": {
    "source": "iana"
  },
  "message/sip": {
    "source": "iana"
  },
  "message/sipfrag": {
    "source": "iana"
  },
  "message/tracking-status": {
    "source": "iana"
  },
  "message/vnd.si.simp": {
    "source": "iana"
  },
  "message/vnd.wfa.wsc": {
    "source": "iana",
    "extensions": ["wsc"]
  },
  "model/3mf": {
    "source": "iana",
    "extensions": ["3mf"]
  },
  "model/gltf+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gltf"]
  },
  "model/gltf-binary": {
    "source": "iana",
    "compressible": true,
    "extensions": ["glb"]
  },
  "model/iges": {
    "source": "iana",
    "compressible": false,
    "extensions": ["igs", "iges"]
  },
  "model/mesh": {
    "source": "iana",
    "compressible": false,
    "extensions": ["msh", "mesh", "silo"]
  },
  "model/stl": {
    "source": "iana",
    "extensions": ["stl"]
  },
  "model/vnd.collada+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dae"]
  },
  "model/vnd.dwf": {
    "source": "iana",
    "extensions": ["dwf"]
  },
  "model/vnd.flatland.3dml": {
    "source": "iana"
  },
  "model/vnd.gdl": {
    "source": "iana",
    "extensions": ["gdl"]
  },
  "model/vnd.gs-gdl": {
    "source": "apache"
  },
  "model/vnd.gs.gdl": {
    "source": "iana"
  },
  "model/vnd.gtw": {
    "source": "iana",
    "extensions": ["gtw"]
  },
  "model/vnd.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "model/vnd.mts": {
    "source": "iana",
    "extensions": ["mts"]
  },
  "model/vnd.opengex": {
    "source": "iana",
    "extensions": ["ogex"]
  },
  "model/vnd.parasolid.transmit.binary": {
    "source": "iana",
    "extensions": ["x_b"]
  },
  "model/vnd.parasolid.transmit.text": {
    "source": "iana",
    "extensions": ["x_t"]
  },
  "model/vnd.rosette.annotated-data-model": {
    "source": "iana"
  },
  "model/vnd.usdz+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["usdz"]
  },
  "model/vnd.valve.source.compiled-map": {
    "source": "iana",
    "extensions": ["bsp"]
  },
  "model/vnd.vtu": {
    "source": "iana",
    "extensions": ["vtu"]
  },
  "model/vrml": {
    "source": "iana",
    "compressible": false,
    "extensions": ["wrl", "vrml"]
  },
  "model/x3d+binary": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3db", "x3dbz"]
  },
  "model/x3d+fastinfoset": {
    "source": "iana",
    "extensions": ["x3db"]
  },
  "model/x3d+vrml": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3dv", "x3dvz"]
  },
  "model/x3d+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["x3d", "x3dz"]
  },
  "model/x3d-vrml": {
    "source": "iana",
    "extensions": ["x3dv"]
  },
  "multipart/alternative": {
    "source": "iana",
    "compressible": false
  },
  "multipart/appledouble": {
    "source": "iana"
  },
  "multipart/byteranges": {
    "source": "iana"
  },
  "multipart/digest": {
    "source": "iana"
  },
  "multipart/encrypted": {
    "source": "iana",
    "compressible": false
  },
  "multipart/form-data": {
    "source": "iana",
    "compressible": false
  },
  "multipart/header-set": {
    "source": "iana"
  },
  "multipart/mixed": {
    "source": "iana",
    "compressible": false
  },
  "multipart/multilingual": {
    "source": "iana"
  },
  "multipart/parallel": {
    "source": "iana"
  },
  "multipart/related": {
    "source": "iana",
    "compressible": false
  },
  "multipart/report": {
    "source": "iana"
  },
  "multipart/signed": {
    "source": "iana",
    "compressible": false
  },
  "multipart/vnd.bint.med-plus": {
    "source": "iana"
  },
  "multipart/voice-message": {
    "source": "iana"
  },
  "multipart/x-mixed-replace": {
    "source": "iana"
  },
  "text/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "text/cache-manifest": {
    "source": "iana",
    "compressible": true,
    "extensions": ["appcache", "manifest"]
  },
  "text/calendar": {
    "source": "iana",
    "extensions": ["ics", "ifb"]
  },
  "text/calender": {
    "compressible": true
  },
  "text/cmd": {
    "compressible": true
  },
  "text/coffeescript": {
    "extensions": ["coffee", "litcoffee"]
  },
  "text/css": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["css"]
  },
  "text/csv": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csv"]
  },
  "text/csv-schema": {
    "source": "iana"
  },
  "text/directory": {
    "source": "iana"
  },
  "text/dns": {
    "source": "iana"
  },
  "text/ecmascript": {
    "source": "iana"
  },
  "text/encaprtp": {
    "source": "iana"
  },
  "text/enriched": {
    "source": "iana"
  },
  "text/fwdred": {
    "source": "iana"
  },
  "text/grammar-ref-list": {
    "source": "iana"
  },
  "text/html": {
    "source": "iana",
    "compressible": true,
    "extensions": ["html", "htm", "shtml"]
  },
  "text/jade": {
    "extensions": ["jade"]
  },
  "text/javascript": {
    "source": "iana",
    "compressible": true
  },
  "text/jcr-cnd": {
    "source": "iana"
  },
  "text/jsx": {
    "compressible": true,
    "extensions": ["jsx"]
  },
  "text/less": {
    "compressible": true,
    "extensions": ["less"]
  },
  "text/markdown": {
    "source": "iana",
    "compressible": true,
    "extensions": ["markdown", "md"]
  },
  "text/mathml": {
    "source": "nginx",
    "extensions": ["mml"]
  },
  "text/mdx": {
    "compressible": true,
    "extensions": ["mdx"]
  },
  "text/mizar": {
    "source": "iana"
  },
  "text/n3": {
    "source": "iana",
    "compressible": true,
    "extensions": ["n3"]
  },
  "text/parameters": {
    "source": "iana"
  },
  "text/parityfec": {
    "source": "iana"
  },
  "text/plain": {
    "source": "iana",
    "compressible": true,
    "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
  },
  "text/provenance-notation": {
    "source": "iana"
  },
  "text/prs.fallenstein.rst": {
    "source": "iana"
  },
  "text/prs.lines.tag": {
    "source": "iana",
    "extensions": ["dsc"]
  },
  "text/prs.prop.logic": {
    "source": "iana"
  },
  "text/raptorfec": {
    "source": "iana"
  },
  "text/red": {
    "source": "iana"
  },
  "text/rfc822-headers": {
    "source": "iana"
  },
  "text/richtext": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtx"]
  },
  "text/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "text/rtp-enc-aescm128": {
    "source": "iana"
  },
  "text/rtploopback": {
    "source": "iana"
  },
  "text/rtx": {
    "source": "iana"
  },
  "text/sgml": {
    "source": "iana",
    "extensions": ["sgml", "sgm"]
  },
  "text/shex": {
    "extensions": ["shex"]
  },
  "text/slim": {
    "extensions": ["slim", "slm"]
  },
  "text/strings": {
    "source": "iana"
  },
  "text/stylus": {
    "extensions": ["stylus", "styl"]
  },
  "text/t140": {
    "source": "iana"
  },
  "text/tab-separated-values": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tsv"]
  },
  "text/troff": {
    "source": "iana",
    "extensions": ["t", "tr", "roff", "man", "me", "ms"]
  },
  "text/turtle": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["ttl"]
  },
  "text/ulpfec": {
    "source": "iana"
  },
  "text/uri-list": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uri", "uris", "urls"]
  },
  "text/vcard": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vcard"]
  },
  "text/vnd.a": {
    "source": "iana"
  },
  "text/vnd.abc": {
    "source": "iana"
  },
  "text/vnd.ascii-art": {
    "source": "iana"
  },
  "text/vnd.curl": {
    "source": "iana",
    "extensions": ["curl"]
  },
  "text/vnd.curl.dcurl": {
    "source": "apache",
    "extensions": ["dcurl"]
  },
  "text/vnd.curl.mcurl": {
    "source": "apache",
    "extensions": ["mcurl"]
  },
  "text/vnd.curl.scurl": {
    "source": "apache",
    "extensions": ["scurl"]
  },
  "text/vnd.debian.copyright": {
    "source": "iana"
  },
  "text/vnd.dmclientscript": {
    "source": "iana"
  },
  "text/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "text/vnd.esmertec.theme-descriptor": {
    "source": "iana"
  },
  "text/vnd.fly": {
    "source": "iana",
    "extensions": ["fly"]
  },
  "text/vnd.fmi.flexstor": {
    "source": "iana",
    "extensions": ["flx"]
  },
  "text/vnd.gml": {
    "source": "iana"
  },
  "text/vnd.graphviz": {
    "source": "iana",
    "extensions": ["gv"]
  },
  "text/vnd.hgl": {
    "source": "iana"
  },
  "text/vnd.in3d.3dml": {
    "source": "iana",
    "extensions": ["3dml"]
  },
  "text/vnd.in3d.spot": {
    "source": "iana",
    "extensions": ["spot"]
  },
  "text/vnd.iptc.newsml": {
    "source": "iana"
  },
  "text/vnd.iptc.nitf": {
    "source": "iana"
  },
  "text/vnd.latex-z": {
    "source": "iana"
  },
  "text/vnd.motorola.reflex": {
    "source": "iana"
  },
  "text/vnd.ms-mediapackage": {
    "source": "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    "source": "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    "source": "iana"
  },
  "text/vnd.senx.warpscript": {
    "source": "iana"
  },
  "text/vnd.si.uricatalogue": {
    "source": "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    "source": "iana",
    "extensions": ["jad"]
  },
  "text/vnd.trolltech.linguist": {
    "source": "iana"
  },
  "text/vnd.wap.si": {
    "source": "iana"
  },
  "text/vnd.wap.sl": {
    "source": "iana"
  },
  "text/vnd.wap.wml": {
    "source": "iana",
    "extensions": ["wml"]
  },
  "text/vnd.wap.wmlscript": {
    "source": "iana",
    "extensions": ["wmls"]
  },
  "text/vtt": {
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["vtt"]
  },
  "text/x-asm": {
    "source": "apache",
    "extensions": ["s", "asm"]
  },
  "text/x-c": {
    "source": "apache",
    "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
  },
  "text/x-component": {
    "source": "nginx",
    "extensions": ["htc"]
  },
  "text/x-fortran": {
    "source": "apache",
    "extensions": ["f", "for", "f77", "f90"]
  },
  "text/x-gwt-rpc": {
    "compressible": true
  },
  "text/x-handlebars-template": {
    "extensions": ["hbs"]
  },
  "text/x-java-source": {
    "source": "apache",
    "extensions": ["java"]
  },
  "text/x-jquery-tmpl": {
    "compressible": true
  },
  "text/x-lua": {
    "extensions": ["lua"]
  },
  "text/x-markdown": {
    "compressible": true,
    "extensions": ["mkd"]
  },
  "text/x-nfo": {
    "source": "apache",
    "extensions": ["nfo"]
  },
  "text/x-opml": {
    "source": "apache",
    "extensions": ["opml"]
  },
  "text/x-org": {
    "compressible": true,
    "extensions": ["org"]
  },
  "text/x-pascal": {
    "source": "apache",
    "extensions": ["p", "pas"]
  },
  "text/x-processing": {
    "compressible": true,
    "extensions": ["pde"]
  },
  "text/x-sass": {
    "extensions": ["sass"]
  },
  "text/x-scss": {
    "extensions": ["scss"]
  },
  "text/x-setext": {
    "source": "apache",
    "extensions": ["etx"]
  },
  "text/x-sfv": {
    "source": "apache",
    "extensions": ["sfv"]
  },
  "text/x-suse-ymp": {
    "compressible": true,
    "extensions": ["ymp"]
  },
  "text/x-uuencode": {
    "source": "apache",
    "extensions": ["uu"]
  },
  "text/x-vcalendar": {
    "source": "apache",
    "extensions": ["vcs"]
  },
  "text/x-vcard": {
    "source": "apache",
    "extensions": ["vcf"]
  },
  "text/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml"]
  },
  "text/xml-external-parsed-entity": {
    "source": "iana"
  },
  "text/yaml": {
    "extensions": ["yaml", "yml"]
  },
  "video/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "video/3gpp": {
    "source": "iana",
    "extensions": ["3gp", "3gpp"]
  },
  "video/3gpp-tt": {
    "source": "iana"
  },
  "video/3gpp2": {
    "source": "iana",
    "extensions": ["3g2"]
  },
  "video/bmpeg": {
    "source": "iana"
  },
  "video/bt656": {
    "source": "iana"
  },
  "video/celb": {
    "source": "iana"
  },
  "video/dv": {
    "source": "iana"
  },
  "video/encaprtp": {
    "source": "iana"
  },
  "video/h261": {
    "source": "iana",
    "extensions": ["h261"]
  },
  "video/h263": {
    "source": "iana",
    "extensions": ["h263"]
  },
  "video/h263-1998": {
    "source": "iana"
  },
  "video/h263-2000": {
    "source": "iana"
  },
  "video/h264": {
    "source": "iana",
    "extensions": ["h264"]
  },
  "video/h264-rcdo": {
    "source": "iana"
  },
  "video/h264-svc": {
    "source": "iana"
  },
  "video/h265": {
    "source": "iana"
  },
  "video/iso.segment": {
    "source": "iana"
  },
  "video/jpeg": {
    "source": "iana",
    "extensions": ["jpgv"]
  },
  "video/jpeg2000": {
    "source": "iana"
  },
  "video/jpm": {
    "source": "apache",
    "extensions": ["jpm", "jpgm"]
  },
  "video/mj2": {
    "source": "iana",
    "extensions": ["mj2", "mjp2"]
  },
  "video/mp1s": {
    "source": "iana"
  },
  "video/mp2p": {
    "source": "iana"
  },
  "video/mp2t": {
    "source": "iana",
    "extensions": ["ts"]
  },
  "video/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mp4", "mp4v", "mpg4"]
  },
  "video/mp4v-es": {
    "source": "iana"
  },
  "video/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"]
  },
  "video/mpeg4-generic": {
    "source": "iana"
  },
  "video/mpv": {
    "source": "iana"
  },
  "video/nv": {
    "source": "iana"
  },
  "video/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogv"]
  },
  "video/parityfec": {
    "source": "iana"
  },
  "video/pointer": {
    "source": "iana"
  },
  "video/quicktime": {
    "source": "iana",
    "compressible": false,
    "extensions": ["qt", "mov"]
  },
  "video/raptorfec": {
    "source": "iana"
  },
  "video/raw": {
    "source": "iana"
  },
  "video/rtp-enc-aescm128": {
    "source": "iana"
  },
  "video/rtploopback": {
    "source": "iana"
  },
  "video/rtx": {
    "source": "iana"
  },
  "video/smpte291": {
    "source": "iana"
  },
  "video/smpte292m": {
    "source": "iana"
  },
  "video/ulpfec": {
    "source": "iana"
  },
  "video/vc1": {
    "source": "iana"
  },
  "video/vc2": {
    "source": "iana"
  },
  "video/vnd.cctv": {
    "source": "iana"
  },
  "video/vnd.dece.hd": {
    "source": "iana",
    "extensions": ["uvh", "uvvh"]
  },
  "video/vnd.dece.mobile": {
    "source": "iana",
    "extensions": ["uvm", "uvvm"]
  },
  "video/vnd.dece.mp4": {
    "source": "iana"
  },
  "video/vnd.dece.pd": {
    "source": "iana",
    "extensions": ["uvp", "uvvp"]
  },
  "video/vnd.dece.sd": {
    "source": "iana",
    "extensions": ["uvs", "uvvs"]
  },
  "video/vnd.dece.video": {
    "source": "iana",
    "extensions": ["uvv", "uvvv"]
  },
  "video/vnd.directv.mpeg": {
    "source": "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dvb.file": {
    "source": "iana",
    "extensions": ["dvb"]
  },
  "video/vnd.fvt": {
    "source": "iana",
    "extensions": ["fvt"]
  },
  "video/vnd.hns.video": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    "source": "iana"
  },
  "video/vnd.motorola.video": {
    "source": "iana"
  },
  "video/vnd.motorola.videop": {
    "source": "iana"
  },
  "video/vnd.mpegurl": {
    "source": "iana",
    "extensions": ["mxu", "m4u"]
  },
  "video/vnd.ms-playready.media.pyv": {
    "source": "iana",
    "extensions": ["pyv"]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    "source": "iana"
  },
  "video/vnd.nokia.mp4vr": {
    "source": "iana"
  },
  "video/vnd.nokia.videovoip": {
    "source": "iana"
  },
  "video/vnd.objectvideo": {
    "source": "iana"
  },
  "video/vnd.radgamettools.bink": {
    "source": "iana"
  },
  "video/vnd.radgamettools.smacker": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg1": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg4": {
    "source": "iana"
  },
  "video/vnd.sealed.swf": {
    "source": "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    "source": "iana"
  },
  "video/vnd.uvvu.mp4": {
    "source": "iana",
    "extensions": ["uvu", "uvvu"]
  },
  "video/vnd.vivo": {
    "source": "iana",
    "extensions": ["viv"]
  },
  "video/vp8": {
    "source": "iana"
  },
  "video/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["webm"]
  },
  "video/x-f4v": {
    "source": "apache",
    "extensions": ["f4v"]
  },
  "video/x-fli": {
    "source": "apache",
    "extensions": ["fli"]
  },
  "video/x-flv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["flv"]
  },
  "video/x-m4v": {
    "source": "apache",
    "extensions": ["m4v"]
  },
  "video/x-matroska": {
    "source": "apache",
    "compressible": false,
    "extensions": ["mkv", "mk3d", "mks"]
  },
  "video/x-mng": {
    "source": "apache",
    "extensions": ["mng"]
  },
  "video/x-ms-asf": {
    "source": "apache",
    "extensions": ["asf", "asx"]
  },
  "video/x-ms-vob": {
    "source": "apache",
    "extensions": ["vob"]
  },
  "video/x-ms-wm": {
    "source": "apache",
    "extensions": ["wm"]
  },
  "video/x-ms-wmv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["wmv"]
  },
  "video/x-ms-wmx": {
    "source": "apache",
    "extensions": ["wmx"]
  },
  "video/x-ms-wvx": {
    "source": "apache",
    "extensions": ["wvx"]
  },
  "video/x-msvideo": {
    "source": "apache",
    "extensions": ["avi"]
  },
  "video/x-sgi-movie": {
    "source": "apache",
    "extensions": ["movie"]
  },
  "video/x-smv": {
    "source": "apache",
    "extensions": ["smv"]
  },
  "x-conference/x-cooltalk": {
    "source": "apache",
    "extensions": ["ice"]
  },
  "x-shader/x-fragment": {
    "compressible": true
  },
  "x-shader/x-vertex": {
    "compressible": true
  }
};
},{}],"node_modules/mime-db/index.js":[function(require,module,exports) {
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 */
module.exports = require('./db.json');
},{"./db.json":"node_modules/mime-db/db.json"}],"node_modules/path-browserify/index.js":[function(require,module,exports) {
var process = require("process");
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"process":"node_modules/process/browser.js"}],"node_modules/mime-types/index.js":[function(require,module,exports) {
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module dependencies.
 * @private
 */

var db = require('mime-db');

var extname = require('path').extname;
/**
 * Module variables.
 * @private
 */


var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */

exports.charset = charset;
exports.charsets = {
  lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null); // Populate the extensions/types maps

populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset(type) {
  if (!type || typeof type !== 'string') {
    return false;
  } // TODO: use media-typer


  var match = EXTRACT_TYPE_REGEXP.exec(type);
  var mime = match && db[match[1].toLowerCase()];

  if (mime && mime.charset) {
    return mime.charset;
  } // default text/* to utf-8


  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8';
  }

  return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */


function contentType(str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false;
  }

  var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;

  if (!mime) {
    return false;
  } // TODO: use content-type or other module


  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime);
    if (charset) mime += '; charset=' + charset.toLowerCase();
  }

  return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */


function extension(type) {
  if (!type || typeof type !== 'string') {
    return false;
  } // TODO: use media-typer


  var match = EXTRACT_TYPE_REGEXP.exec(type); // get extensions

  var exts = match && exports.extensions[match[1].toLowerCase()];

  if (!exts || !exts.length) {
    return false;
  }

  return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */


function lookup(path) {
  if (!path || typeof path !== 'string') {
    return false;
  } // get the extension ("ext" or ".ext" or full path)


  var extension = extname('x.' + path).toLowerCase().substr(1);

  if (!extension) {
    return false;
  }

  return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */


function populateMaps(extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana'];
  Object.keys(db).forEach(function forEachMimeType(type) {
    var mime = db[type];
    var exts = mime.extensions;

    if (!exts || !exts.length) {
      return;
    } // mime -> extensions


    extensions[type] = exts; // extension -> mime

    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i];

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source);
        var to = preference.indexOf(mime.source);

        if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
          // skip the remapping
          continue;
        }
      } // set the extension -> mime


      types[extension] = type;
    }
  });
}
},{"mime-db":"node_modules/mime-db/index.js","path":"node_modules/path-browserify/index.js"}],"node_modules/type-is/index.js":[function(require,module,exports) {
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module dependencies.
 * @private
 */

var typer = require('media-typer');

var mime = require('mime-types');
/**
 * Module exports.
 * @public
 */


module.exports = typeofrequest;
module.exports.is = typeis;
module.exports.hasBody = hasbody;
module.exports.normalize = normalize;
module.exports.match = mimeMatch;
/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */

function typeis(value, types_) {
  var i;
  var types = types_; // remove parameters and normalize

  var val = tryNormalizeType(value); // no type or invalid

  if (!val) {
    return false;
  } // support flattened arguments


  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1);

    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1];
    }
  } // no types, return the content type


  if (!types || !types.length) {
    return val;
  }

  var type;

  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize(type = types[i]), val)) {
      return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
    }
  } // no matches


  return false;
}
/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */


function hasbody(req) {
  return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
}
/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */


function typeofrequest(req, types_) {
  var types = types_; // no body

  if (!hasbody(req)) {
    return null;
  } // support flattened arguments


  if (arguments.length > 2) {
    types = new Array(arguments.length - 1);

    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1];
    }
  } // request content type


  var value = req.headers['content-type'];
  return typeis(value, types);
}
/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @private
 */


function normalize(type) {
  if (typeof type !== 'string') {
    // invalid type
    return false;
  }

  switch (type) {
    case 'urlencoded':
      return 'application/x-www-form-urlencoded';

    case 'multipart':
      return 'multipart/*';
  }

  if (type[0] === '+') {
    // "+json" -> "*/*+json" expando
    return '*/*' + type;
  }

  return type.indexOf('/') === -1 ? mime.lookup(type) : type;
}
/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @private
 */


function mimeMatch(expected, actual) {
  // invalid type
  if (expected === false) {
    return false;
  } // split types


  var actualParts = actual.split('/');
  var expectedParts = expected.split('/'); // invalid format

  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false;
  } // validate type


  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
    return false;
  } // validate suffix wildcard


  if (expectedParts[1].substr(0, 2) === '*+') {
    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
  } // validate subtype


  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
    return false;
  }

  return true;
}
/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */


function normalizeType(value) {
  // parse the type
  var type = typer.parse(value); // remove the parameters

  type.parameters = undefined; // reformat it

  return typer.format(type);
}
/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */


function tryNormalizeType(value) {
  if (!value) {
    return null;
  }

  try {
    return normalizeType(value);
  } catch (err) {
    return null;
  }
}
},{"media-typer":"node_modules/media-typer/index.js","mime-types":"node_modules/mime-types/index.js"}],"node_modules/depd/lib/browser/index.js":[function(require,module,exports) {
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module exports.
 * @public
 */

module.exports = depd;
/**
 * Create deprecate for namespace in caller.
 */

function depd(namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required');
  }

  function deprecate(message) {// no-op in browser
  }

  deprecate._file = undefined;
  deprecate._ignored = true;
  deprecate._namespace = namespace;
  deprecate._traced = false;
  deprecate._warned = Object.create(null);
  deprecate.function = wrapfunction;
  deprecate.property = wrapproperty;
  return deprecate;
}
/**
 * Return a wrapped function in a deprecation message.
 *
 * This is a no-op version of the wrapper, which does nothing but call
 * validation.
 */


function wrapfunction(fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function');
  }

  return fn;
}
/**
 * Wrap property in a deprecation message.
 *
 * This is a no-op version of the wrapper, which does nothing but call
 * validation.
 */


function wrapproperty(obj, prop, message) {
  if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('argument obj must be object');
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

  if (!descriptor) {
    throw new TypeError('must call property on owner object');
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable');
  }
}
},{}],"node_modules/setprototypeof/index.js":[function(require,module,exports) {
'use strict'
/* eslint no-proto: 0 */
module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties)

function setProtoOf (obj, proto) {
  obj.__proto__ = proto
  return obj
}

function mixinProperties (obj, proto) {
  for (var prop in proto) {
    if (!obj.hasOwnProperty(prop)) {
      obj[prop] = proto[prop]
    }
  }
  return obj
}

},{}],"node_modules/statuses/codes.json":[function(require,module,exports) {
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "(Unused)",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
},{}],"node_modules/statuses/index.js":[function(require,module,exports) {
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module dependencies.
 * @private
 */

var codes = require('./codes.json');
/**
 * Module exports.
 * @public
 */


module.exports = status; // status code to message map

status.STATUS_CODES = codes; // array of status codes

status.codes = populateStatusesMap(status, codes); // status codes for redirects

status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
}; // status codes for empty bodies

status.empty = {
  204: true,
  205: true,
  304: true
}; // status codes for when you should retry the request

status.retry = {
  502: true,
  503: true,
  504: true
};
/**
 * Populate the statuses map for given codes.
 * @private
 */

function populateStatusesMap(statuses, codes) {
  var arr = [];
  Object.keys(codes).forEach(function forEachCode(code) {
    var message = codes[code];
    var status = Number(code); // Populate properties

    statuses[status] = message;
    statuses[message] = status;
    statuses[message.toLowerCase()] = status; // Add to array

    arr.push(status);
  });
  return arr;
}
/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */


function status(code) {
  if (typeof code === 'number') {
    if (!status[code]) throw new Error('invalid status code: ' + code);
    return code;
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string');
  } // '403'


  var n = parseInt(code, 10);

  if (!isNaN(n)) {
    if (!status[n]) throw new Error('invalid status code: ' + n);
    return n;
  }

  n = status[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"');
  return n;
}
},{"./codes.json":"node_modules/statuses/codes.json"}],"node_modules/toidentifier/index.js":[function(require,module,exports) {
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */
module.exports = toIdentifier;
/**
 * Trasform the given string into a JavaScript identifier
 *
 * @param {string} str
 * @returns {string}
 * @public
 */

function toIdentifier(str) {
  return str.split(' ').map(function (token) {
    return token.slice(0, 1).toUpperCase() + token.slice(1);
  }).join('').replace(/[^ _0-9a-z]/gi, '');
}
},{}],"node_modules/http-errors/index.js":[function(require,module,exports) {
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module dependencies.
 * @private
 */

var deprecate = require('depd')('http-errors');

var setPrototypeOf = require('setprototypeof');

var statuses = require('statuses');

var inherits = require('inherits');

var toIdentifier = require('toidentifier');
/**
 * Module exports.
 * @public
 */


module.exports = createError;
module.exports.HttpError = createHttpErrorConstructor(); // Populate exports for all constructors

populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
/**
 * Get the code class of a status code.
 * @private
 */

function codeClass(status) {
  return Number(String(status).charAt(0) + '00');
}
/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */


function createError() {
  // so much arity going on ~_~
  var err;
  var msg;
  var status = 500;
  var props = {};

  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];

    if (arg instanceof Error) {
      err = arg;
      status = err.status || err.statusCode || status;
      continue;
    }

    switch (typeof arg) {
      case 'string':
        msg = arg;
        break;

      case 'number':
        status = arg;

        if (i !== 0) {
          deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)');
        }

        break;

      case 'object':
        props = arg;
        break;
    }
  }

  if (typeof status === 'number' && (status < 400 || status >= 600)) {
    deprecate('non-error status code; use only 4xx or 5xx status codes');
  }

  if (typeof status !== 'number' || !statuses[status] && (status < 400 || status >= 600)) {
    status = 500;
  } // constructor


  var HttpError = createError[status] || createError[codeClass(status)];

  if (!err) {
    // create error
    err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
    Error.captureStackTrace(err, createError);
  }

  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
    // add properties to generic error
    err.expose = status < 500;
    err.status = err.statusCode = status;
  }

  for (var key in props) {
    if (key !== 'status' && key !== 'statusCode') {
      err[key] = props[key];
    }
  }

  return err;
}
/**
 * Create HTTP error abstract base class.
 * @private
 */


function createHttpErrorConstructor() {
  function HttpError() {
    throw new TypeError('cannot construct abstract class');
  }

  inherits(HttpError, Error);
  return HttpError;
}
/**
 * Create a constructor for a client error.
 * @private
 */


function createClientErrorConstructor(HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error';

  function ClientError(message) {
    // create the error object
    var msg = message != null ? message : statuses[code];
    var err = new Error(msg); // capture a stack trace to the construction point

    Error.captureStackTrace(err, ClientError); // adjust the [[Prototype]]

    setPrototypeOf(err, ClientError.prototype); // redefine the error message

    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    }); // redefine the error name

    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    });
    return err;
  }

  inherits(ClientError, HttpError);
  nameFunc(ClientError, className);
  ClientError.prototype.status = code;
  ClientError.prototype.statusCode = code;
  ClientError.prototype.expose = true;
  return ClientError;
}
/**
 * Create a constructor for a server error.
 * @private
 */


function createServerErrorConstructor(HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error';

  function ServerError(message) {
    // create the error object
    var msg = message != null ? message : statuses[code];
    var err = new Error(msg); // capture a stack trace to the construction point

    Error.captureStackTrace(err, ServerError); // adjust the [[Prototype]]

    setPrototypeOf(err, ServerError.prototype); // redefine the error message

    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    }); // redefine the error name

    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    });
    return err;
  }

  inherits(ServerError, HttpError);
  nameFunc(ServerError, className);
  ServerError.prototype.status = code;
  ServerError.prototype.statusCode = code;
  ServerError.prototype.expose = false;
  return ServerError;
}
/**
 * Set the name of a function, if possible.
 * @private
 */


function nameFunc(func, name) {
  var desc = Object.getOwnPropertyDescriptor(func, 'name');

  if (desc && desc.configurable) {
    desc.value = name;
    Object.defineProperty(func, 'name', desc);
  }
}
/**
 * Populate the exports object with constructors for every error class.
 * @private
 */


function populateConstructorExports(exports, codes, HttpError) {
  codes.forEach(function forEachCode(code) {
    var CodeError;
    var name = toIdentifier(statuses[code]);

    switch (codeClass(code)) {
      case 400:
        CodeError = createClientErrorConstructor(HttpError, name, code);
        break;

      case 500:
        CodeError = createServerErrorConstructor(HttpError, name, code);
        break;
    }

    if (CodeError) {
      // export the constructor
      exports[code] = CodeError;
      exports[name] = CodeError;
    }
  }); // backwards-compatibility

  exports["I'mateapot"] = deprecate.function(exports.ImATeapot, '"I\'mateapot"; use "ImATeapot" instead');
}
},{"depd":"node_modules/depd/lib/browser/index.js","setprototypeof":"node_modules/setprototypeof/index.js","statuses":"node_modules/statuses/index.js","inherits":"node_modules/inherits/inherits_browser.js","toidentifier":"node_modules/toidentifier/index.js"}],"node_modules/fastify-sensible/lib/httpErrors.js":[function(require,module,exports) {
'use strict'

const createError = require('http-errors')
const statusCodes = require('http').STATUS_CODES

const statusCodesMap = Object.assign({}, statusCodes)
Object.keys(statusCodesMap).forEach(code => {
  statusCodesMap[code] = normalize(code, statusCodesMap[code])
})

function normalize (code, msg) {
  if (code === '414') return 'uriTooLong'
  if (code === '505') return 'httpVersionNotSupported'
  msg = msg.split(' ').join('').replace(/'/g, '')
  msg = msg[0].toLowerCase() + msg.slice(1)
  return msg
}

const httpErrors = {
  badRequest: function badRequest (message) {
    return new createError.BadRequest(message)
  },

  unauthorized: function unauthorized (message) {
    return new createError.Unauthorized(message)
  },

  paymentRequired: function paymentRequired (message) {
    return new createError.PaymentRequired(message)
  },

  forbidden: function forbidden (message) {
    return new createError.Forbidden(message)
  },

  notFound: function notFound (message) {
    return new createError.NotFound(message)
  },

  methodNotAllowed: function methodNotAllowed (message) {
    return new createError.MethodNotAllowed(message)
  },

  notAcceptable: function notAcceptable (message) {
    return new createError.NotAcceptable(message)
  },

  proxyAuthenticationRequired: function proxyAuthenticationRequired (message) {
    return new createError.ProxyAuthenticationRequired(message)
  },

  requestTimeout: function requestTimeout (message) {
    return new createError.RequestTimeout(message)
  },

  conflict: function conflict (message) {
    return new createError.Conflict(message)
  },

  gone: function gone (message) {
    return new createError.Gone(message)
  },

  lengthRequired: function lengthRequired (message) {
    return new createError.LengthRequired(message)
  },

  preconditionFailed: function preconditionFailed (message) {
    return new createError.PreconditionFailed(message)
  },

  payloadTooLarge: function payloadTooLarge (message) {
    return new createError.PayloadTooLarge(message)
  },

  uriTooLong: function uriTooLong (message) {
    return new createError.URITooLong(message)
  },

  unsupportedMediaType: function unsupportedMediaType (message) {
    return new createError.UnsupportedMediaType(message)
  },

  rangeNotSatisfiable: function rangeNotSatisfiable (message) {
    return new createError.RangeNotSatisfiable(message)
  },

  expectationFailed: function expectationFailed (message) {
    return new createError.ExpectationFailed(message)
  },

  imateapot: function imateapot (message) {
    return new createError.ImATeapot(message)
  },

  misdirectedRequest: function misdirectedRequest (message) {
    return new createError.MisdirectedRequest(message)
  },

  unprocessableEntity: function unprocessableEntity (message) {
    return new createError.UnprocessableEntity(message)
  },

  locked: function locked (message) {
    return new createError.Locked(message)
  },

  failedDependency: function failedDependency (message) {
    return new createError.FailedDependency(message)
  },

  unorderedCollection: function unorderedCollection (message) {
    return new createError.UnorderedCollection(message)
  },

  upgradeRequired: function upgradeRequired (message) {
    return new createError.UpgradeRequired(message)
  },

  preconditionRequired: function preconditionRequired (message) {
    return new createError.PreconditionRequired(message)
  },

  tooManyRequests: function tooManyRequests (message) {
    return new createError.TooManyRequests(message)
  },

  requestHeaderFieldsTooLarge: function requestHeaderFieldsTooLarge (message) {
    return new createError.RequestHeaderFieldsTooLarge(message)
  },

  unavailableForLegalReasons: function unavailableForLegalReasons (message) {
    return new createError.UnavailableForLegalReasons(message)
  },

  internalServerError: function internalServerError (message) {
    const error = new createError.InternalServerError(message)
    // mark error as explicit to allow custom message
    error.explicitInternalServerError = true
    return error
  },

  notImplemented: function notImplemented (message) {
    return new createError.NotImplemented(message)
  },

  badGateway: function badGateway (message) {
    return new createError.BadGateway(message)
  },

  serviceUnavailable: function serviceUnavailable (message) {
    return new createError.ServiceUnavailable(message)
  },

  gatewayTimeout: function gatewayTimeout (message) {
    return new createError.GatewayTimeout(message)
  },

  httpVersionNotSupported: function httpVersionNotSupported (message) {
    return new createError.HTTPVersionNotSupported(message)
  },

  variantAlsoNegotiates: function variantAlsoNegotiates (message) {
    return new createError.VariantAlsoNegotiates(message)
  },

  insufficientStorage: function insufficientStorage (message) {
    return new createError.InsufficientStorage(message)
  },

  loopDetected: function loopDetected (message) {
    return new createError.LoopDetected(message)
  },

  bandwidthLimitExceeded: function bandwidthLimitExceeded (message) {
    return new createError.BandwidthLimitExceeded(message)
  },

  notExtended: function notExtended (message) {
    return new createError.NotExtended(message)
  },

  networkAuthenticationRequired: function networkAuthenticationRequired (message) {
    return new createError.NetworkAuthenticationRequired(message)
  }
}

function getHttpError (code, message) {
  return httpErrors[statusCodesMap[code + '']](message)
}

module.exports = httpErrors
module.exports.getHttpError = getHttpError
module.exports.HttpError = createError.HttpError

},{"http-errors":"node_modules/http-errors/index.js","http":"node_modules/stream-http/index.js"}],"node_modules/fastify-sensible/lib/assert.js":[function(require,module,exports) {
/* eslint-disable eqeqeq */
'use strict'

const deepEqual = require('fast-deep-equal')
const getHttpError = require('./httpErrors').getHttpError

function assert (condition, code, message) {
  if (condition) return
  throw getHttpError(code, message)
}

assert.ok = assert

assert.equal = function (a, b, code, message) {
  assert(a == b, code, message)
}

assert.notEqual = function (a, b, code, message) {
  assert(a != b, code, message)
}

assert.strictEqual = function (a, b, code, message) {
  assert(a === b, code, message)
}

assert.notStrictEqual = function (a, b, code, message) {
  assert(a !== b, code, message)
}

assert.deepEqual = function (a, b, code, message) {
  assert(deepEqual(a, b), code, message)
}

assert.notDeepEqual = function (a, b, code, message) {
  assert(deepEqual(a, b) === false, code, message)
}

module.exports = assert

},{"fast-deep-equal":"node_modules/fast-deep-equal/index.js","./httpErrors":"node_modules/fastify-sensible/lib/httpErrors.js"}],"node_modules/vary/index.js":[function(require,module,exports) {
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module exports.
 */

module.exports = vary;
module.exports.append = append;
/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append(header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required');
  }

  if (!field) {
    throw new TypeError('field argument is required');
  } // get fields array


  var fields = !Array.isArray(field) ? parse(String(field)) : field; // assert on invalid field names

  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name');
    }
  } // existing, unspecified vary


  if (header === '*') {
    return header;
  } // enumerate current values


  var val = header;
  var vals = parse(header.toLowerCase()); // unspecified vary

  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*';
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase(); // append value (case-preserving)

    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ', ' + fields[i] : fields[i];
    }
  }

  return val;
}
/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */


function parse(header) {
  var end = 0;
  var list = [];
  var start = 0; // gather tokens

  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20:
        /*   */
        if (start === end) {
          start = end = i + 1;
        }

        break;

      case 0x2c:
        /* , */
        list.push(header.substring(start, end));
        start = end = i + 1;
        break;

      default:
        end = i + 1;
        break;
    }
  } // final token


  list.push(header.substring(start, end));
  return list;
}
/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */


function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required');
  } // get existing header


  var val = res.getHeader('Vary') || '';
  var header = Array.isArray(val) ? val.join(', ') : String(val); // set new header

  if (val = append(header, field)) {
    res.setHeader('Vary', val);
  }
}
},{}],"node_modules/fastify-sensible/lib/vary.js":[function(require,module,exports) {
'use strict'

const append = require('vary').append

// Same implementation of https://github.com/jshttp/vary
// but adapted to the Fastify API
function vary (field) {
  var value = this.getHeader('Vary') || ''
  var header = Array.isArray(value)
    ? value.join(', ')
    : String(value)

  // set new header
  if ((value = append(header, field))) {
    this.header('Vary', value)
  }
}

module.exports = vary
module.exports.append = append

},{"vary":"node_modules/vary/index.js"}],"node_modules/fastify-sensible/index.js":[function(require,module,exports) {
'use strict'

const fp = require('fastify-plugin')
// External utilities
const forwarded = require('forwarded')
const proxyaddr = require('proxy-addr')
const typeis = require('type-is')
// Internals Utilities
const httpErrors = require('./lib/httpErrors')
const assert = require('./lib/assert')
const vary = require('./lib/vary')

function fastifySensible (fastify, opts, next) {
  fastify.decorate('httpErrors', httpErrors)
  fastify.decorate('assert', assert)
  fastify.decorate('to', to)

  fastify.decorateRequest('forwarded', function () {
    return forwarded(this.raw)
  })

  fastify.decorateRequest('proxyaddr', function (trust) {
    return proxyaddr(this.raw, trust)
  })

  fastify.decorateRequest('is', function (types) {
    return typeis(this.raw, Array.isArray(types) ? types : [types])
  })

  fastify.decorateReply('vary', vary)

  // TODO: benchmark if this closure causes some performance drop
  Object.keys(httpErrors).forEach(httpError => {
    switch (httpError) {
      case 'HttpError':
        // skip abstract class constructor
        break
      case 'getHttpError':
        fastify.decorateReply('getHttpError', function (errorCode, message) {
          this.send(httpErrors['getHttpError'](errorCode, message))
        })
        break
      default:
        fastify.decorateReply(httpError, function (message) {
          this.send(httpErrors[httpError](message))
        })
    }
  })

  if (opts.errorHandler !== false) {
    fastify.setErrorHandler(function (error, request, reply) {
      if (reply.res.statusCode === 500 && error.explicitInternalServerError !== true) {
        request.log.error(error)
        reply.send(new Error('Something went wrong'))
      } else {
        reply.send(error)
      }
    })
  }

  function to (promise) {
    return promise.then(data => [null, data], err => [err, undefined])
  }

  next()
}

module.exports = fp(fastifySensible, {
  name: 'fastify-sensible',
  fastify: '2.x'
})

},{"fastify-plugin":"node_modules/fastify-plugin/index.js","forwarded":"node_modules/forwarded/index.js","proxy-addr":"node_modules/proxy-addr/index.js","type-is":"node_modules/type-is/index.js","./lib/httpErrors":"node_modules/fastify-sensible/lib/httpErrors.js","./lib/assert":"node_modules/fastify-sensible/lib/assert.js","./lib/vary":"node_modules/fastify-sensible/lib/vary.js"}],"node_modules/fastify-cors/index.js":[function(require,module,exports) {
'use strict'

const fp = require('fastify-plugin')
const append = require('vary').append

function fastifyCors (fastify, opts, next) {
  const {
    origin,
    credentials,
    exposedHeaders,
    allowedHeaders,
    methods,
    maxAge,
    preflightContinue,
    optionsSuccessStatus,
    preflight
  } = Object.assign({
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204,
    credentials: false,
    exposedHeaders: null,
    allowedHeaders: null,
    maxAge: null,
    preflight: true
  }, opts)

  const isOriginFalsy = !origin
  const isOriginString = typeof origin === 'string'
  const isOriginFunction = typeof origin === 'function'

  if (preflight === true) {
    fastify.options('*', (req, reply) => reply.send())
  }
  fastify.addHook('onRequest', onRequest)
  function onRequest (req, reply, next) {
    if (isOriginFalsy) return next()

    configureOrigin(req, reply, (err, origin) => {
      if (err !== null) return next(err)
      if (origin === false) return next()

      if (credentials) {
        reply.header('Access-Control-Allow-Credentials', 'true')
      }

      if (exposedHeaders !== null) {
        reply.header(
          'Access-Control-Expose-Headers',
          Array.isArray(exposedHeaders) ? exposedHeaders.join(', ') : exposedHeaders
        )
      }

      if (req.raw.method === 'OPTIONS' && preflight === true) {
        // preflight
        reply.header(
          'Access-Control-Allow-Methods',
          Array.isArray(methods) ? methods.join(', ') : methods
        )

        if (allowedHeaders === null) {
          vary(reply, 'Access-Control-Request-Headers')
          var reqAllowedHeaders = req.headers['access-control-request-headers']
          if (reqAllowedHeaders !== undefined) {
            reply.header('Access-Control-Allow-Headers', reqAllowedHeaders)
          }
        } else {
          reply.header(
            'Access-Control-Allow-Headers',
            Array.isArray(allowedHeaders) ? allowedHeaders.join(', ') : allowedHeaders
          )
        }

        if (maxAge !== null) {
          reply.header('Access-Control-Max-Age', String(maxAge))
        }

        if (preflightContinue) {
          next()
        } else {
          // Safari (and potentially other browsers) need content-length 0,
          // for 204 or they just hang waiting for a body
          reply
            .code(optionsSuccessStatus)
            .header('Content-Length', '0')
            .send()
        }
      } else {
        next()
      }
    })
  }

  function configureOrigin (req, reply, callback) {
    var reqOrigin = req.headers.origin
    if (isOriginFunction) {
      var result = origin.call(fastify, reqOrigin, _onOrigin)
      if (result && typeof result.then === 'function') {
        result.then(res => _onOrigin(null, res), callback)
      }
    } else {
      _configureOrigin(origin)
    }

    function _onOrigin (err, origin) {
      if (err !== null || origin === false) {
        return callback(err, origin)
      }

      _configureOrigin(origin)
    }

    function _configureOrigin (origin) {
      if (!origin || origin === '*') {
        // allow any origin
        reply.header('Access-Control-Allow-Origin', '*')
      } else if (isOriginString) {
        // fixed origin
        reply.header('Access-Control-Allow-Origin', origin)
        vary(reply, 'Origin')
      } else {
        // reflect origin
        reply.header(
          'Access-Control-Allow-Origin',
          isOriginAllowed(reqOrigin, origin) ? reqOrigin : false
        )
        vary(reply, 'Origin')
      }

      callback(null, origin)
    }
  }

  function isOriginAllowed (reqOrigin, origin) {
    if (Array.isArray(origin)) {
      for (var i = 0; i < origin.length; ++i) {
        if (isOriginAllowed(reqOrigin, origin[i])) {
          return true
        }
      }
      return false
    } else if (typeof origin === 'string') {
      return reqOrigin === origin
    } else if (origin instanceof RegExp) {
      return origin.test(reqOrigin)
    } else {
      return !!origin
    }
  }

  next()
}

// https://github.com/fastify/fastify-sensible/blob/master/lib/vary.js
function vary (reply, field) {
  var value = reply.getHeader('Vary') || ''
  var header = Array.isArray(value)
    ? value.join(', ')
    : String(value)

  // set new header
  if ((value = append(header, field))) {
    reply.header('Vary', value)
  }
}

module.exports = fp(fastifyCors, {
  fastify: '>=2.x',
  name: 'fastify-cors'
})

},{"fastify-plugin":"node_modules/fastify-plugin/index.js","vary":"node_modules/vary/index.js"}],"node_modules/underscore/underscore.js":[function(require,module,exports) {
//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

},{}],"node_modules/nedb/lib/model.js":[function(require,module,exports) {
/**
 * Handle models (i.e. docs)
 * Serialization/deserialization
 * Copying
 * Querying, update
 */

var util = require('util')
  , _ = require('underscore')
  , modifierFunctions = {}
  , lastStepModifierFunctions = {}
  , comparisonFunctions = {}
  , logicalOperators = {}
  , arrayComparisonFunctions = {}
  ;


/**
 * Check a key, throw an error if the key is non valid
 * @param {String} k key
 * @param {Model} v value, needed to treat the Date edge case
 * Non-treatable edge cases here: if part of the object if of the form { $$date: number } or { $$deleted: true }
 * Its serialized-then-deserialized version it will transformed into a Date object
 * But you really need to want it to trigger such behaviour, even when warned not to use '$' at the beginning of the field names...
 */
function checkKey (k, v) {
  if (typeof k === 'number') {
    k = k.toString();
  }

  if (k[0] === '$' && !(k === '$$date' && typeof v === 'number') && !(k === '$$deleted' && v === true) && !(k === '$$indexCreated') && !(k === '$$indexRemoved')) {
    throw new Error('Field names cannot begin with the $ character');
  }

  if (k.indexOf('.') !== -1) {
    throw new Error('Field names cannot contain a .');
  }
}


/**
 * Check a DB object and throw an error if it's not valid
 * Works by applying the above checkKey function to all fields recursively
 */
function checkObject (obj) {
  if (util.isArray(obj)) {
    obj.forEach(function (o) {
      checkObject(o);
    });
  }

  if (typeof obj === 'object' && obj !== null) {
    Object.keys(obj).forEach(function (k) {
      checkKey(k, obj[k]);
      checkObject(obj[k]);
    });
  }
}


/**
 * Serialize an object to be persisted to a one-line string
 * For serialization/deserialization, we use the native JSON parser and not eval or Function
 * That gives us less freedom but data entered in the database may come from users
 * so eval and the like are not safe
 * Accepted primitive types: Number, String, Boolean, Date, null
 * Accepted secondary types: Objects, Arrays
 */
function serialize (obj) {
  var res;

  res = JSON.stringify(obj, function (k, v) {
    checkKey(k, v);

    if (v === undefined) { return undefined; }
    if (v === null) { return null; }

    // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).
    // We can't use value directly because for dates it is already string in this function (date.toJSON was already called), so we use this
    if (typeof this[k].getTime === 'function') { return { $$date: this[k].getTime() }; }

    return v;
  });

  return res;
}


/**
 * From a one-line representation of an object generate by the serialize function
 * Return the object itself
 */
function deserialize (rawData) {
  return JSON.parse(rawData, function (k, v) {
    if (k === '$$date') { return new Date(v); }
    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) { return v; }
    if (v && v.$$date) { return v.$$date; }

    return v;
  });
}


/**
 * Deep copy a DB object
 * The optional strictKeys flag (defaulting to false) indicates whether to copy everything or only fields
 * where the keys are valid, i.e. don't begin with $ and don't contain a .
 */
function deepCopy (obj, strictKeys) {
  var res;

  if ( typeof obj === 'boolean' ||
       typeof obj === 'number' ||
       typeof obj === 'string' ||
       obj === null ||
       (util.isDate(obj)) ) {
    return obj;
  }

  if (util.isArray(obj)) {
    res = [];
    obj.forEach(function (o) { res.push(deepCopy(o, strictKeys)); });
    return res;
  }

  if (typeof obj === 'object') {
    res = {};
    Object.keys(obj).forEach(function (k) {
      if (!strictKeys || (k[0] !== '$' && k.indexOf('.') === -1)) {
        res[k] = deepCopy(obj[k], strictKeys);
      }
    });
    return res;
  }

  return undefined;   // For now everything else is undefined. We should probably throw an error instead
}


/**
 * Tells if an object is a primitive type or a "real" object
 * Arrays are considered primitive
 */
function isPrimitiveType (obj) {
  return ( typeof obj === 'boolean' ||
       typeof obj === 'number' ||
       typeof obj === 'string' ||
       obj === null ||
       util.isDate(obj) ||
       util.isArray(obj));
}


/**
 * Utility functions for comparing things
 * Assumes type checking was already done (a and b already have the same type)
 * compareNSB works for numbers, strings and booleans
 */
function compareNSB (a, b) {
  if (a < b) { return -1; }
  if (a > b) { return 1; }
  return 0;
}

function compareArrays (a, b) {
  var i, comp;

  for (i = 0; i < Math.min(a.length, b.length); i += 1) {
    comp = compareThings(a[i], b[i]);

    if (comp !== 0) { return comp; }
  }

  // Common section was identical, longest one wins
  return compareNSB(a.length, b.length);
}


/**
 * Compare { things U undefined }
 * Things are defined as any native types (string, number, boolean, null, date) and objects
 * We need to compare with undefined as it will be used in indexes
 * In the case of objects and arrays, we deep-compare
 * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects
 * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)
 *
 * @param {Function} _compareStrings String comparing function, returning -1, 0 or 1, overriding default string comparison (useful for languages with accented letters)
 */
function compareThings (a, b, _compareStrings) {
  var aKeys, bKeys, comp, i
    , compareStrings = _compareStrings || compareNSB;

  // undefined
  if (a === undefined) { return b === undefined ? 0 : -1; }
  if (b === undefined) { return a === undefined ? 0 : 1; }

  // null
  if (a === null) { return b === null ? 0 : -1; }
  if (b === null) { return a === null ? 0 : 1; }

  // Numbers
  if (typeof a === 'number') { return typeof b === 'number' ? compareNSB(a, b) : -1; }
  if (typeof b === 'number') { return typeof a === 'number' ? compareNSB(a, b) : 1; }

  // Strings
  if (typeof a === 'string') { return typeof b === 'string' ? compareStrings(a, b) : -1; }
  if (typeof b === 'string') { return typeof a === 'string' ? compareStrings(a, b) : 1; }

  // Booleans
  if (typeof a === 'boolean') { return typeof b === 'boolean' ? compareNSB(a, b) : -1; }
  if (typeof b === 'boolean') { return typeof a === 'boolean' ? compareNSB(a, b) : 1; }

  // Dates
  if (util.isDate(a)) { return util.isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1; }
  if (util.isDate(b)) { return util.isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1; }

  // Arrays (first element is most significant and so on)
  if (util.isArray(a)) { return util.isArray(b) ? compareArrays(a, b) : -1; }
  if (util.isArray(b)) { return util.isArray(a) ? compareArrays(a, b) : 1; }

  // Objects
  aKeys = Object.keys(a).sort();
  bKeys = Object.keys(b).sort();

  for (i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {
    comp = compareThings(a[aKeys[i]], b[bKeys[i]]);

    if (comp !== 0) { return comp; }
  }

  return compareNSB(aKeys.length, bKeys.length);
}



// ==============================================================
// Updating documents
// ==============================================================

/**
 * The signature of modifier functions is as follows
 * Their structure is always the same: recursively follow the dot notation while creating
 * the nested documents if needed, then apply the "last step modifier"
 * @param {Object} obj The model to modify
 * @param {String} field Can contain dots, in that case that means we will set a subfield recursively
 * @param {Model} value
 */

/**
 * Set a field to a new value
 */
lastStepModifierFunctions.$set = function (obj, field, value) {
  obj[field] = value;
};


/**
 * Unset a field
 */
lastStepModifierFunctions.$unset = function (obj, field, value) {
  delete obj[field];
};


/**
 * Push an element to the end of an array field
 * Optional modifier $each instead of value to push several values
 * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/
 * Différeence with MongoDB: if $slice is specified and not $each, we act as if value is an empty array
 */
lastStepModifierFunctions.$push = function (obj, field, value) {
  // Create the array if it doesn't exist
  if (!obj.hasOwnProperty(field)) { obj[field] = []; }

  if (!util.isArray(obj[field])) { throw new Error("Can't $push an element on non-array values"); }

  if (value !== null && typeof value === 'object' && value.$slice && value.$each === undefined) {
    value.$each = [];
  }

  if (value !== null && typeof value === 'object' && value.$each) {
    if (Object.keys(value).length >= 3 || (Object.keys(value).length === 2 && value.$slice === undefined)) { throw new Error("Can only use $slice in cunjunction with $each when $push to array"); }
    if (!util.isArray(value.$each)) { throw new Error("$each requires an array value"); }

    value.$each.forEach(function (v) {
      obj[field].push(v);
    });

    if (value.$slice === undefined || typeof value.$slice !== 'number') { return; }

    if (value.$slice === 0) {
      obj[field] = [];
    } else {
      var start, end, n = obj[field].length;
      if (value.$slice < 0) {
        start = Math.max(0, n + value.$slice);
        end = n;
      } else if (value.$slice > 0) {
        start = 0;
        end = Math.min(n, value.$slice);
      }
      obj[field] = obj[field].slice(start, end);
    }
  } else {
    obj[field].push(value);
  }
};


/**
 * Add an element to an array field only if it is not already in it
 * No modification if the element is already in the array
 * Note that it doesn't check whether the original array contains duplicates
 */
lastStepModifierFunctions.$addToSet = function (obj, field, value) {
  var addToSet = true;

  // Create the array if it doesn't exist
  if (!obj.hasOwnProperty(field)) { obj[field] = []; }

  if (!util.isArray(obj[field])) { throw new Error("Can't $addToSet an element on non-array values"); }

  if (value !== null && typeof value === 'object' && value.$each) {
    if (Object.keys(value).length > 1) { throw new Error("Can't use another field in conjunction with $each"); }
    if (!util.isArray(value.$each)) { throw new Error("$each requires an array value"); }

    value.$each.forEach(function (v) {
      lastStepModifierFunctions.$addToSet(obj, field, v);
    });
  } else {
    obj[field].forEach(function (v) {
      if (compareThings(v, value) === 0) { addToSet = false; }
    });
    if (addToSet) { obj[field].push(value); }
  }
};


/**
 * Remove the first or last element of an array
 */
lastStepModifierFunctions.$pop = function (obj, field, value) {
  if (!util.isArray(obj[field])) { throw new Error("Can't $pop an element from non-array values"); }
  if (typeof value !== 'number') { throw new Error(value + " isn't an integer, can't use it with $pop"); }
  if (value === 0) { return; }

  if (value > 0) {
    obj[field] = obj[field].slice(0, obj[field].length - 1);
  } else {
    obj[field] = obj[field].slice(1);
  }
};


/**
 * Removes all instances of a value from an existing array
 */
lastStepModifierFunctions.$pull = function (obj, field, value) {
  var arr, i;

  if (!util.isArray(obj[field])) { throw new Error("Can't $pull an element from non-array values"); }

  arr = obj[field];
  for (i = arr.length - 1; i >= 0; i -= 1) {
    if (match(arr[i], value)) {
      arr.splice(i, 1);
    }
  }
};


/**
 * Increment a numeric field's value
 */
lastStepModifierFunctions.$inc = function (obj, field, value) {
  if (typeof value !== 'number') { throw new Error(value + " must be a number"); }

  if (typeof obj[field] !== 'number') {
    if (!_.has(obj, field)) {
      obj[field] = value;
    } else {
      throw new Error("Don't use the $inc modifier on non-number fields");
    }
  } else {
    obj[field] += value;
  }
};

/**
 * Updates the value of the field, only if specified field is greater than the current value of the field
 */
lastStepModifierFunctions.$max = function (obj, field, value) {
  if (typeof obj[field] === 'undefined') {
    obj[field] = value;
  } else if (value > obj[field]) {
    obj[field] = value;
  }
};

/**
 * Updates the value of the field, only if specified field is smaller than the current value of the field
 */
lastStepModifierFunctions.$min = function (obj, field, value) {
  if (typeof obj[field] === 'undefined') { 
    obj[field] = value;
  } else if (value < obj[field]) {
    obj[field] = value;
  }
};

// Given its name, create the complete modifier function
function createModifierFunction (modifier) {
  return function (obj, field, value) {
    var fieldParts = typeof field === 'string' ? field.split('.') : field;

    if (fieldParts.length === 1) {
      lastStepModifierFunctions[modifier](obj, field, value);
    } else {
      if (obj[fieldParts[0]] === undefined) {
        if (modifier === '$unset') { return; }   // Bad looking specific fix, needs to be generalized modifiers that behave like $unset are implemented
        obj[fieldParts[0]] = {};
      }
      modifierFunctions[modifier](obj[fieldParts[0]], fieldParts.slice(1), value);
    }
  };
}

// Actually create all modifier functions
Object.keys(lastStepModifierFunctions).forEach(function (modifier) {
  modifierFunctions[modifier] = createModifierFunction(modifier);
});


/**
 * Modify a DB object according to an update query
 */
function modify (obj, updateQuery) {
  var keys = Object.keys(updateQuery)
    , firstChars = _.map(keys, function (item) { return item[0]; })
    , dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; })
    , newDoc, modifiers
    ;

  if (keys.indexOf('_id') !== -1 && updateQuery._id !== obj._id) { throw new Error("You cannot change a document's _id"); }

  if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {
    throw new Error("You cannot mix modifiers and normal fields");
  }

  if (dollarFirstChars.length === 0) {
    // Simply replace the object with the update query contents
    newDoc = deepCopy(updateQuery);
    newDoc._id = obj._id;
  } else {
    // Apply modifiers
    modifiers = _.uniq(keys);
    newDoc = deepCopy(obj);
    modifiers.forEach(function (m) {
      var keys;

      if (!modifierFunctions[m]) { throw new Error("Unknown modifier " + m); }

      // Can't rely on Object.keys throwing on non objects since ES6
      // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it
      if (typeof updateQuery[m] !== 'object') {
        throw new Error("Modifier " + m + "'s argument must be an object");
      }

      keys = Object.keys(updateQuery[m]);
      keys.forEach(function (k) {
        modifierFunctions[m](newDoc, k, updateQuery[m][k]);
      });
    });
  }

  // Check result is valid and return it
  checkObject(newDoc);

  if (obj._id !== newDoc._id) { throw new Error("You can't change a document's _id"); }
  return newDoc;
};


// ==============================================================
// Finding documents
// ==============================================================

/**
 * Get a value from object with dot notation
 * @param {Object} obj
 * @param {String} field
 */
function getDotValue (obj, field) {
  var fieldParts = typeof field === 'string' ? field.split('.') : field
    , i, objs;

  if (!obj) { return undefined; }   // field cannot be empty so that means we should return undefined so that nothing can match

  if (fieldParts.length === 0) { return obj; }

  if (fieldParts.length === 1) { return obj[fieldParts[0]]; }

  if (util.isArray(obj[fieldParts[0]])) {
    // If the next field is an integer, return only this item of the array
    i = parseInt(fieldParts[1], 10);
    if (typeof i === 'number' && !isNaN(i)) {
      return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2))
    }

    // Return the array of values
    objs = new Array();
    for (i = 0; i < obj[fieldParts[0]].length; i += 1) {
       objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));
    }
    return objs;
  } else {
    return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));
  }
}


/**
 * Check whether 'things' are equal
 * Things are defined as any native types (string, number, boolean, null, date) and objects
 * In the case of object, we check deep equality
 * Returns true if they are, false otherwise
 */
function areThingsEqual (a, b) {
  var aKeys , bKeys , i;

  // Strings, booleans, numbers, null
  if (a === null || typeof a === 'string' || typeof a === 'boolean' || typeof a === 'number' ||
      b === null || typeof b === 'string' || typeof b === 'boolean' || typeof b === 'number') { return a === b; }

  // Dates
  if (util.isDate(a) || util.isDate(b)) { return util.isDate(a) && util.isDate(b) && a.getTime() === b.getTime(); }

  // Arrays (no match since arrays are used as a $in)
  // undefined (no match since they mean field doesn't exist and can't be serialized)
  if ((!(util.isArray(a) && util.isArray(b)) && (util.isArray(a) || util.isArray(b))) || a === undefined || b === undefined) { return false; }

  // General objects (check for deep equality)
  // a and b should be objects at this point
  try {
    aKeys = Object.keys(a);
    bKeys = Object.keys(b);
  } catch (e) {
    return false;
  }

  if (aKeys.length !== bKeys.length) { return false; }
  for (i = 0; i < aKeys.length; i += 1) {
    if (bKeys.indexOf(aKeys[i]) === -1) { return false; }
    if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) { return false; }
  }
  return true;
}


/**
 * Check that two values are comparable
 */
function areComparable (a, b) {
  if (typeof a !== 'string' && typeof a !== 'number' && !util.isDate(a) &&
      typeof b !== 'string' && typeof b !== 'number' && !util.isDate(b)) {
    return false;
  }

  if (typeof a !== typeof b) { return false; }

  return true;
}


/**
 * Arithmetic and comparison operators
 * @param {Native value} a Value in the object
 * @param {Native value} b Value in the query
 */
comparisonFunctions.$lt = function (a, b) {
  return areComparable(a, b) && a < b;
};

comparisonFunctions.$lte = function (a, b) {
  return areComparable(a, b) && a <= b;
};

comparisonFunctions.$gt = function (a, b) {
  return areComparable(a, b) && a > b;
};

comparisonFunctions.$gte = function (a, b) {
  return areComparable(a, b) && a >= b;
};

comparisonFunctions.$ne = function (a, b) {
  if (a === undefined) { return true; }
  return !areThingsEqual(a, b);
};

comparisonFunctions.$in = function (a, b) {
  var i;

  if (!util.isArray(b)) { throw new Error("$in operator called with a non-array"); }

  for (i = 0; i < b.length; i += 1) {
    if (areThingsEqual(a, b[i])) { return true; }
  }

  return false;
};

comparisonFunctions.$nin = function (a, b) {
  if (!util.isArray(b)) { throw new Error("$nin operator called with a non-array"); }

  return !comparisonFunctions.$in(a, b);
};

comparisonFunctions.$regex = function (a, b) {
  if (!util.isRegExp(b)) { throw new Error("$regex operator called with non regular expression"); }

  if (typeof a !== 'string') {
    return false
  } else {
    return b.test(a);
  }
};

comparisonFunctions.$exists = function (value, exists) {
  if (exists || exists === '') {   // This will be true for all values of exists except false, null, undefined and 0
    exists = true;                 // That's strange behaviour (we should only use true/false) but that's the way Mongo does it...
  } else {
    exists = false;
  }

  if (value === undefined) {
    return !exists
  } else {
    return exists;
  }
};

// Specific to arrays
comparisonFunctions.$size = function (obj, value) {
    if (!util.isArray(obj)) { return false; }
    if (value % 1 !== 0) { throw new Error("$size operator called without an integer"); }

    return (obj.length == value);
};
comparisonFunctions.$elemMatch = function (obj, value) {
  if (!util.isArray(obj)) { return false; }
  var i = obj.length;
  var result = false;   // Initialize result
  while (i--) {
    if (match(obj[i], value)) {   // If match for array element, return true
      result = true;
      break;
    }
  }
  return result;
};
arrayComparisonFunctions.$size = true;
arrayComparisonFunctions.$elemMatch = true;


/**
 * Match any of the subqueries
 * @param {Model} obj
 * @param {Array of Queries} query
 */
logicalOperators.$or = function (obj, query) {
  var i;

  if (!util.isArray(query)) { throw new Error("$or operator used without an array"); }

  for (i = 0; i < query.length; i += 1) {
    if (match(obj, query[i])) { return true; }
  }

  return false;
};


/**
 * Match all of the subqueries
 * @param {Model} obj
 * @param {Array of Queries} query
 */
logicalOperators.$and = function (obj, query) {
  var i;

  if (!util.isArray(query)) { throw new Error("$and operator used without an array"); }

  for (i = 0; i < query.length; i += 1) {
    if (!match(obj, query[i])) { return false; }
  }

  return true;
};


/**
 * Inverted match of the query
 * @param {Model} obj
 * @param {Query} query
 */
logicalOperators.$not = function (obj, query) {
  return !match(obj, query);
};


/**
 * Use a function to match
 * @param {Model} obj
 * @param {Query} query
 */
logicalOperators.$where = function (obj, fn) {
  var result;

  if (!_.isFunction(fn)) { throw new Error("$where operator used without a function"); }

  result = fn.call(obj);
  if (!_.isBoolean(result)) { throw new Error("$where function must return boolean"); }

  return result;
};


/**
 * Tell if a given document matches a query
 * @param {Object} obj Document to check
 * @param {Object} query
 */
function match (obj, query) {
  var queryKeys, queryKey, queryValue, i;

  // Primitive query against a primitive type
  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later
  // But I don't have time for a cleaner implementation now
  if (isPrimitiveType(obj) || isPrimitiveType(query)) {
    return matchQueryPart({ needAKey: obj }, 'needAKey', query);
  }

  // Normal query
  queryKeys = Object.keys(query);
  for (i = 0; i < queryKeys.length; i += 1) {
    queryKey = queryKeys[i];
    queryValue = query[queryKey];

    if (queryKey[0] === '$') {
      if (!logicalOperators[queryKey]) { throw new Error("Unknown logical operator " + queryKey); }
      if (!logicalOperators[queryKey](obj, queryValue)) { return false; }
    } else {
      if (!matchQueryPart(obj, queryKey, queryValue)) { return false; }
    }
  }

  return true;
};


/**
 * Match an object against a specific { key: value } part of a query
 * if the treatObjAsValue flag is set, don't try to match every part separately, but the array as a whole
 */
function matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {
  var objValue = getDotValue(obj, queryKey)
    , i, keys, firstChars, dollarFirstChars;

  // Check if the value is an array if we don't force a treatment as value
  if (util.isArray(objValue) && !treatObjAsValue) {
    // If the queryValue is an array, try to perform an exact match
    if (util.isArray(queryValue)) {
      return matchQueryPart(obj, queryKey, queryValue, true);
    }

    // Check if we are using an array-specific comparison function
    if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {
      keys = Object.keys(queryValue);
      for (i = 0; i < keys.length; i += 1) {
        if (arrayComparisonFunctions[keys[i]]) { return matchQueryPart(obj, queryKey, queryValue, true); }
      }
    }

    // If not, treat it as an array of { obj, query } where there needs to be at least one match
    for (i = 0; i < objValue.length; i += 1) {
      if (matchQueryPart({ k: objValue[i] }, 'k', queryValue)) { return true; }   // k here could be any string
    }
    return false;
  }

  // queryValue is an actual object. Determine whether it contains comparison operators
  // or only normal fields. Mixed objects are not allowed
  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue) && !util.isArray(queryValue)) {
    keys = Object.keys(queryValue);
    firstChars = _.map(keys, function (item) { return item[0]; });
    dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; });

    if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {
      throw new Error("You cannot mix operators and normal fields");
    }

    // queryValue is an object of this form: { $comparisonOperator1: value1, ... }
    if (dollarFirstChars.length > 0) {
      for (i = 0; i < keys.length; i += 1) {
        if (!comparisonFunctions[keys[i]]) { throw new Error("Unknown comparison function " + keys[i]); }

        if (!comparisonFunctions[keys[i]](objValue, queryValue[keys[i]])) { return false; }
      }
      return true;
    }
  }

  // Using regular expressions with basic querying
  if (util.isRegExp(queryValue)) { return comparisonFunctions.$regex(objValue, queryValue); }

  // queryValue is either a native value or a normal object
  // Basic matching is possible
  if (!areThingsEqual(objValue, queryValue)) { return false; }

  return true;
}


// Interface
module.exports.serialize = serialize;
module.exports.deserialize = deserialize;
module.exports.deepCopy = deepCopy;
module.exports.checkObject = checkObject;
module.exports.isPrimitiveType = isPrimitiveType;
module.exports.modify = modify;
module.exports.getDotValue = getDotValue;
module.exports.match = match;
module.exports.areThingsEqual = areThingsEqual;
module.exports.compareThings = compareThings;

},{"util":"node_modules/util/util.js","underscore":"node_modules/underscore/underscore.js"}],"node_modules/nedb/lib/cursor.js":[function(require,module,exports) {
/**
 * Manage access to data, be it to find, update or remove it
 */
var model = require('./model')
  , _ = require('underscore')
  ;



/**
 * Create a new cursor for this collection
 * @param {Datastore} db - The datastore this cursor is bound to
 * @param {Query} query - The query this cursor will operate on
 * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove
 */
function Cursor (db, query, execFn) {
  this.db = db;
  this.query = query || {};
  if (execFn) { this.execFn = execFn; }
}


/**
 * Set a limit to the number of results
 */
Cursor.prototype.limit = function(limit) {
  this._limit = limit;
  return this;
};


/**
 * Skip a the number of results
 */
Cursor.prototype.skip = function(skip) {
  this._skip = skip;
  return this;
};


/**
 * Sort results of the query
 * @param {SortQuery} sortQuery - SortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending
 */
Cursor.prototype.sort = function(sortQuery) {
  this._sort = sortQuery;
  return this;
};


/**
 * Add the use of a projection
 * @param {Object} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2
 *                              { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits
 */
Cursor.prototype.projection = function(projection) {
  this._projection = projection;
  return this;
};


/**
 * Apply the projection
 */
Cursor.prototype.project = function (candidates) {
  var res = [], self = this
    , keepId, action, keys
    ;

  if (this._projection === undefined || Object.keys(this._projection).length === 0) {
    return candidates;
  }

  keepId = this._projection._id === 0 ? false : true;
  this._projection = _.omit(this._projection, '_id');

  // Check for consistency
  keys = Object.keys(this._projection);
  keys.forEach(function (k) {
    if (action !== undefined && self._projection[k] !== action) { throw new Error("Can't both keep and omit fields except for _id"); }
    action = self._projection[k];
  });

  // Do the actual projection
  candidates.forEach(function (candidate) {
    var toPush;
    if (action === 1) {   // pick-type projection
      toPush = { $set: {} };
      keys.forEach(function (k) {
        toPush.$set[k] = model.getDotValue(candidate, k);
        if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
      });
      toPush = model.modify({}, toPush);
    } else {   // omit-type projection
      toPush = { $unset: {} };
      keys.forEach(function (k) { toPush.$unset[k] = true });
      toPush = model.modify(candidate, toPush);
    }
    if (keepId) {
      toPush._id = candidate._id;
    } else {
      delete toPush._id;
    }
    res.push(toPush);
  });

  return res;
};


/**
 * Get all matching elements
 * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne
 * This is an internal function, use exec which uses the executor
 *
 * @param {Function} callback - Signature: err, results
 */
Cursor.prototype._exec = function(_callback) {
  var res = [], added = 0, skipped = 0, self = this
    , error = null
    , i, keys, key
    ;

  function callback (error, res) {
    if (self.execFn) {
      return self.execFn(error, res, _callback);
    } else {
      return _callback(error, res);
    }
  }

  this.db.getCandidates(this.query, function (err, candidates) {
    if (err) { return callback(err); }

    try {
      for (i = 0; i < candidates.length; i += 1) {
        if (model.match(candidates[i], self.query)) {
          // If a sort is defined, wait for the results to be sorted before applying limit and skip
          if (!self._sort) {
            if (self._skip && self._skip > skipped) {
              skipped += 1;
            } else {
              res.push(candidates[i]);
              added += 1;
              if (self._limit && self._limit <= added) { break; }
            }
          } else {
            res.push(candidates[i]);
          }
        }
      }
    } catch (err) {
      return callback(err);
    }

    // Apply all sorts
    if (self._sort) {
      keys = Object.keys(self._sort);

      // Sorting
      var criteria = [];
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        criteria.push({ key: key, direction: self._sort[key] });
      }
      res.sort(function(a, b) {
        var criterion, compare, i;
        for (i = 0; i < criteria.length; i++) {
          criterion = criteria[i];
          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);
          if (compare !== 0) {
            return compare;
          }
        }
        return 0;
      });

      // Applying limit and skip
      var limit = self._limit || res.length
        , skip = self._skip || 0;

      res = res.slice(skip, skip + limit);
    }

    // Apply projection
    try {
      res = self.project(res);
    } catch (e) {
      error = e;
      res = undefined;
    }

    return callback(error, res);
  });
};

Cursor.prototype.exec = function () {
  this.db.executor.push({ this: this, fn: this._exec, arguments: arguments });
};



// Interface
module.exports = Cursor;

},{"./model":"node_modules/nedb/lib/model.js","underscore":"node_modules/underscore/underscore.js"}],"node_modules/nedb-promises/src/Cursor.js":[function(require,module,exports) {
const
	OriginalCursor = require('nedb/lib/cursor')

/**
 * @class
 */
class Cursor {
	constructor(original, prerequisite, callback) {
		if ( ! (original instanceof OriginalCursor)) {
			throw new TypeError(`Unexpected ${typeof original}, expected: Cursor (nedb/lib/cursor)`)
		}

		if ( ! (prerequisite instanceof Promise)) {
			prerequisite = Promise.resolve()
		}

		Object.defineProperties(this, {
			__original: {
				configurable: false,
				enumerable: false,
				writable: false,
				value: original
			},

			__prerequisite: {
				configurable: false,
				enumerable: false,
				writable: false,
				value: prerequisite
			},

			__callback: {
				configurable: false,
				enumerable: false,
				writable: false,
				value: callback
			}
		})
	}

	sort() {
		this.__original.sort.apply(this.__original, arguments)
		return this
	}

	skip() {
		this.__original.skip.apply(this.__original, arguments)
		return this
	}

	limit() {
		this.__original.limit.apply(this.__original, arguments)
		return this
	}

	/**
	 * Execute the cursor.
	 *
	 * You can use the same cursor methods
	 * that you could with the original module:
	 *
	 * https://github.com/louischatriot/nedb#sorting-and-paginating
	 *
	 * Since the Cursor has a `then` and a `catch` method
	 * JavaScript identifies it as a thenable object
	 * thus you can await it in async functions.
	 *
	 * @example
	 * // in an async function
	 * await datastore.find(...)
	 * 	.sort(...)
	 * 	.limit(...)
	 *
	 * @example
	 * // the previous is the same as:
	 * await datastore.find(...)
	 * 	.sort(...)
	 * 	.limit(...)
	 * 	.exec()
	 * 
	 * @return {Promise.<Object[]>}
	 */
	exec() {
		return this.__prerequisite.then(() => {
			return new Promise((resolve, reject) => {
				this.__original.exec((error, result) => {
					if ('function' === typeof this.__callback) {
						this.__callback(error, result)
					}

					return error
						? reject(error)
						: resolve(result)
				})
			})
		})
	}

	/**
	 * Execute the cursor and set promise callbacks.
	 * 
	 * For more information visit:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then
	 * 
	 * @param  {Function} fulfilled
	 * @param  {Function} [rejected]
	 * @return {Promise}
	 */
	then(fulfilled, rejected) {
		return this.exec().then(fulfilled, rejected)
	}

	/**
	 * Execute the cursor and set promise error callback.
	 *
	 * For more information visit:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch
	 * 
	 * @param  {Function} rejected
	 * @return {Promise}
	 */
	catch(rejected) {
		return this.exec().catch(rejected)
	}
}

module.exports = Cursor

},{"nedb/lib/cursor":"node_modules/nedb/lib/cursor.js"}],"node_modules/nedb/browser-version/browser-specific/lib/customUtils.js":[function(require,module,exports) {
/**
 * Specific customUtils for the browser, where we don't have access to the Crypto and Buffer modules
 */

/**
 * Taken from the crypto-browserify module
 * https://github.com/dominictarr/crypto-browserify
 * NOTE: Math.random() does not guarantee "cryptographic quality" but we actually don't need it
 */
function randomBytes (size) {
  var bytes = new Array(size);
  var r;

  for (var i = 0, r; i < size; i++) {
    if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
  }

  return bytes;
}


/**
 * Taken from the base64-js module
 * https://github.com/beatgammit/base64-js/
 */
function byteArrayToBase64 (uint8) {
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    , extraBytes = uint8.length % 3   // if we have 1 byte left, pad 2 bytes
    , output = ""
    , temp, length, i;

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  };

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output += tripletToBase64(temp);
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  switch (extraBytes) {
    case 1:
      temp = uint8[uint8.length - 1];
      output += lookup[temp >> 2];
      output += lookup[(temp << 4) & 0x3F];
      output += '==';
      break;
    case 2:
      temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
      output += lookup[temp >> 10];
      output += lookup[(temp >> 4) & 0x3F];
      output += lookup[(temp << 2) & 0x3F];
      output += '=';
      break;
  }

  return output;
}


/**
 * Return a random alphanumerical string of length len
 * There is a very small probability (less than 1/1,000,000) for the length to be less than len
 * (il the base64 conversion yields too many pluses and slashes) but
 * that's not an issue here
 * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)
 * See http://en.wikipedia.org/wiki/Birthday_problem
 */
function uid (len) {
  return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\/]/g, '').slice(0, len);
}



module.exports.uid = uid;

},{}],"node_modules/async/lib/async.js":[function(require,module,exports) {
var process = require("process");
var define;
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

},{"process":"node_modules/process/browser.js"}],"node_modules/nedb/lib/executor.js":[function(require,module,exports) {
var process = require("process");
/**
 * Responsible for sequentially executing actions on the database
 */

var async = require('async')
  ;

function Executor () {
  this.buffer = [];
  this.ready = false;

  // This queue will execute all commands, one-by-one in order
  this.queue = async.queue(function (task, cb) {
    var newArguments = [];

    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array
    for (var i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
    var lastArg = task.arguments[task.arguments.length - 1];

    // Always tell the queue task is complete. Execute callback if any was given.
    if (typeof lastArg === 'function') {
      // Callback was supplied
      newArguments[newArguments.length - 1] = function () {
        if (typeof setImmediate === 'function') {
           setImmediate(cb);
        } else {
          process.nextTick(cb);
        }
        lastArg.apply(null, arguments);
      };
    } else if (!lastArg && task.arguments.length !== 0) {
      // false/undefined/null supplied as callbback
      newArguments[newArguments.length - 1] = function () { cb(); };
    } else {
      // Nothing supplied as callback
      newArguments.push(function () { cb(); });
    }


    task.fn.apply(task.this, newArguments);
  }, 1);
}


/**
 * If executor is ready, queue task (and process it immediately if executor was idle)
 * If not, buffer task for later processing
 * @param {Object} task
 *                 task.this - Object to use as this
 *                 task.fn - Function to execute
 *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)
 *                                                                 and the last argument cannot be false/undefined/null
 * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready
 */
Executor.prototype.push = function (task, forceQueuing) {
  if (this.ready || forceQueuing) {
    this.queue.push(task);
  } else {
    this.buffer.push(task);
  }
};


/**
 * Queue all tasks in buffer (in the same order they came in)
 * Automatically sets executor as ready
 */
Executor.prototype.processBuffer = function () {
  var i;
  this.ready = true;
  for (i = 0; i < this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }
  this.buffer = [];
};



// Interface
module.exports = Executor;

},{"async":"node_modules/async/lib/async.js","process":"node_modules/process/browser.js"}],"node_modules/binary-search-tree/lib/customUtils.js":[function(require,module,exports) {
/**
 * Return an array with the numbers from 0 to n-1, in a random order
 */
function getRandomArray (n) {
  var res, next;

  if (n === 0) { return []; }
  if (n === 1) { return [0]; }

  res = getRandomArray(n - 1);
  next = Math.floor(Math.random() * n);
  res.splice(next, 0, n - 1);   // Add n-1 at a random position in the array

  return res;
};
module.exports.getRandomArray = getRandomArray;


/*
 * Default compareKeys function will work for numbers, strings and dates
 */
function defaultCompareKeysFunction (a, b) {
  if (a < b) { return -1; }
  if (a > b) { return 1; }
  if (a === b) { return 0; }

  var err = new Error("Couldn't compare elements");
  err.a = a;
  err.b = b;
  throw err;
}
module.exports.defaultCompareKeysFunction = defaultCompareKeysFunction;


/**
 * Check whether two values are equal (used in non-unique deletion)
 */
function defaultCheckValueEquality (a, b) {
  return a === b;
}
module.exports.defaultCheckValueEquality = defaultCheckValueEquality;

},{}],"node_modules/binary-search-tree/lib/bst.js":[function(require,module,exports) {
/**
 * Simple binary search tree
 */
var customUtils = require('./customUtils');


/**
 * Constructor
 * @param {Object} options Optional
 * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
 * @param {Key}      options.key Initialize this BST's key with key
 * @param {Value}    options.value Initialize this BST's data with [value]
 * @param {Function} options.compareKeys Initialize this BST's compareKeys
 */
function BinarySearchTree (options) {
  options = options || {};

  this.left = null;
  this.right = null;
  this.parent = options.parent !== undefined ? options.parent : null;
  if (options.hasOwnProperty('key')) { this.key = options.key; }
  this.data = options.hasOwnProperty('value') ? [options.value] : [];
  this.unique = options.unique || false;

  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;
  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;
}


// ================================
// Methods used to test the tree
// ================================


/**
 * Get the descendant with max key
 */
BinarySearchTree.prototype.getMaxKeyDescendant = function () {
  if (this.right) {
    return this.right.getMaxKeyDescendant();
  } else {
    return this;
  }
};


/**
 * Get the maximum key
 */
BinarySearchTree.prototype.getMaxKey = function () {
  return this.getMaxKeyDescendant().key;
};


/**
 * Get the descendant with min key
 */
BinarySearchTree.prototype.getMinKeyDescendant = function () {
  if (this.left) {
    return this.left.getMinKeyDescendant()
  } else {
    return this;
  }
};


/**
 * Get the minimum key
 */
BinarySearchTree.prototype.getMinKey = function () {
  return this.getMinKeyDescendant().key;
};


/**
 * Check that all nodes (incl. leaves) fullfil condition given by fn
 * test is a function passed every (key, data) and which throws if the condition is not met
 */
BinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {
  if (!this.hasOwnProperty('key')) { return; }

  test(this.key, this.data);
  if (this.left) { this.left.checkAllNodesFullfillCondition(test); }
  if (this.right) { this.right.checkAllNodesFullfillCondition(test); }
};


/**
 * Check that the core BST properties on node ordering are verified
 * Throw if they aren't
 */
BinarySearchTree.prototype.checkNodeOrdering = function () {
  var self = this;

  if (!this.hasOwnProperty('key')) { return; }

  if (this.left) {
    this.left.checkAllNodesFullfillCondition(function (k) {
      if (self.compareKeys(k, self.key) >= 0) {
        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');
      }
    });
    this.left.checkNodeOrdering();
  }

  if (this.right) {
    this.right.checkAllNodesFullfillCondition(function (k) {
      if (self.compareKeys(k, self.key) <= 0) {
        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');
      }
    });
    this.right.checkNodeOrdering();
  }
};


/**
 * Check that all pointers are coherent in this tree
 */
BinarySearchTree.prototype.checkInternalPointers = function () {
  if (this.left) {
    if (this.left.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }
    this.left.checkInternalPointers();
  }

  if (this.right) {
    if (this.right.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }
    this.right.checkInternalPointers();
  }
};


/**
 * Check that a tree is a BST as defined here (node ordering and pointer references)
 */
BinarySearchTree.prototype.checkIsBST = function () {
  this.checkNodeOrdering();
  this.checkInternalPointers();
  if (this.parent) { throw new Error("The root shouldn't have a parent"); }
};


/**
 * Get number of keys inserted
 */
BinarySearchTree.prototype.getNumberOfKeys = function () {
  var res;

  if (!this.hasOwnProperty('key')) { return 0; }

  res = 1;
  if (this.left) { res += this.left.getNumberOfKeys(); }
  if (this.right) { res += this.right.getNumberOfKeys(); }

  return res;
};



// ============================================
// Methods used to actually work on the tree
// ============================================

/**
 * Create a BST similar (i.e. same options except for key and value) to the current one
 * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)
 * @param {Object} options see constructor
 */
BinarySearchTree.prototype.createSimilar = function (options) {
  options = options || {};
  options.unique = this.unique;
  options.compareKeys = this.compareKeys;
  options.checkValueEquality = this.checkValueEquality;

  return new this.constructor(options);
};


/**
 * Create the left child of this BST and return it
 */
BinarySearchTree.prototype.createLeftChild = function (options) {
  var leftChild = this.createSimilar(options);
  leftChild.parent = this;
  this.left = leftChild;

  return leftChild;
};


/**
 * Create the right child of this BST and return it
 */
BinarySearchTree.prototype.createRightChild = function (options) {
  var rightChild = this.createSimilar(options);
  rightChild.parent = this;
  this.right = rightChild;

  return rightChild;
};


/**
 * Insert a new element
 */
BinarySearchTree.prototype.insert = function (key, value) {
  // Empty tree, insert as root
  if (!this.hasOwnProperty('key')) {
    this.key = key;
    this.data.push(value);
    return;
  }

  // Same key as root
  if (this.compareKeys(this.key, key) === 0) {
    if (this.unique) {
      var err = new Error("Can't insert key " + key + ", it violates the unique constraint");
      err.key = key;
      err.errorType = 'uniqueViolated';
      throw err;
    } else {
      this.data.push(value);
    }
    return;
  }

  if (this.compareKeys(key, this.key) < 0) {
    // Insert in left subtree
    if (this.left) {
      this.left.insert(key, value);
    } else {
      this.createLeftChild({ key: key, value: value });
    }
  } else {
    // Insert in right subtree
    if (this.right) {
      this.right.insert(key, value);
    } else {
      this.createRightChild({ key: key, value: value });
    }
  }
};


/**
 * Search for all data corresponding to a key
 */
BinarySearchTree.prototype.search = function (key) {
  if (!this.hasOwnProperty('key')) { return []; }

  if (this.compareKeys(this.key, key) === 0) { return this.data; }

  if (this.compareKeys(key, this.key) < 0) {
    if (this.left) {
      return this.left.search(key);
    } else {
      return [];
    }
  } else {
    if (this.right) {
      return this.right.search(key);
    } else {
      return [];
    }
  }
};


/**
 * Return a function that tells whether a given key matches a lower bound
 */
BinarySearchTree.prototype.getLowerBoundMatcher = function (query) {
  var self = this;

  // No lower bound
  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {
    return function () { return true; };
  }

  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {
    if (self.compareKeys(query.$gte, query.$gt) === 0) {
      return function (key) { return self.compareKeys(key, query.$gt) > 0; };
    }

    if (self.compareKeys(query.$gte, query.$gt) > 0) {
      return function (key) { return self.compareKeys(key, query.$gte) >= 0; };
    } else {
      return function (key) { return self.compareKeys(key, query.$gt) > 0; };
    }
  }

  if (query.hasOwnProperty('$gt')) {
    return function (key) { return self.compareKeys(key, query.$gt) > 0; };
  } else {
    return function (key) { return self.compareKeys(key, query.$gte) >= 0; };
  }
};


/**
 * Return a function that tells whether a given key matches an upper bound
 */
BinarySearchTree.prototype.getUpperBoundMatcher = function (query) {
  var self = this;

  // No lower bound
  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {
    return function () { return true; };
  }

  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {
    if (self.compareKeys(query.$lte, query.$lt) === 0) {
      return function (key) { return self.compareKeys(key, query.$lt) < 0; };
    }

    if (self.compareKeys(query.$lte, query.$lt) < 0) {
      return function (key) { return self.compareKeys(key, query.$lte) <= 0; };
    } else {
      return function (key) { return self.compareKeys(key, query.$lt) < 0; };
    }
  }

  if (query.hasOwnProperty('$lt')) {
    return function (key) { return self.compareKeys(key, query.$lt) < 0; };
  } else {
    return function (key) { return self.compareKeys(key, query.$lte) <= 0; };
  }
};


// Append all elements in toAppend to array
function append (array, toAppend) {
  var i;

  for (i = 0; i < toAppend.length; i += 1) {
    array.push(toAppend[i]);
  }
}


/**
 * Get all data for a key between bounds
 * Return it in key order
 * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)
 * @param {Functions} lbm/ubm matching functions calculated at the first recursive step
 */
BinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {
  var res = [];

  if (!this.hasOwnProperty('key')) { return []; }   // Empty tree

  lbm = lbm || this.getLowerBoundMatcher(query);
  ubm = ubm || this.getUpperBoundMatcher(query);

  if (lbm(this.key) && this.left) { append(res, this.left.betweenBounds(query, lbm, ubm)); }
  if (lbm(this.key) && ubm(this.key)) { append(res, this.data); }
  if (ubm(this.key) && this.right) { append(res, this.right.betweenBounds(query, lbm, ubm)); }

  return res;
};


/**
 * Delete the current node if it is a leaf
 * Return true if it was deleted
 */
BinarySearchTree.prototype.deleteIfLeaf = function () {
  if (this.left || this.right) { return false; }

  // The leaf is itself a root
  if (!this.parent) {
    delete this.key;
    this.data = [];
    return true;
  }

  if (this.parent.left === this) {
    this.parent.left = null;
  } else {
    this.parent.right = null;
  }

  return true;
};


/**
 * Delete the current node if it has only one child
 * Return true if it was deleted
 */
BinarySearchTree.prototype.deleteIfOnlyOneChild = function () {
  var child;

  if (this.left && !this.right) { child = this.left; }
  if (!this.left && this.right) { child = this.right; }
  if (!child) { return false; }

  // Root
  if (!this.parent) {
    this.key = child.key;
    this.data = child.data;

    this.left = null;
    if (child.left) {
      this.left = child.left;
      child.left.parent = this;
    }

    this.right = null;
    if (child.right) {
      this.right = child.right;
      child.right.parent = this;
    }

    return true;
  }

  if (this.parent.left === this) {
    this.parent.left = child;
    child.parent = this.parent;
  } else {
    this.parent.right = child;
    child.parent = this.parent;
  }

  return true;
};


/**
 * Delete a key or just a value
 * @param {Key} key
 * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted
 */
BinarySearchTree.prototype.delete = function (key, value) {
  var newData = [], replaceWith
    , self = this
    ;

  if (!this.hasOwnProperty('key')) { return; }

  if (this.compareKeys(key, this.key) < 0) {
    if (this.left) { this.left.delete(key, value); }
    return;
  }

  if (this.compareKeys(key, this.key) > 0) {
    if (this.right) { this.right.delete(key, value); }
    return;
  }

  if (!this.compareKeys(key, this.key) === 0) { return; }

  // Delete only a value
  if (this.data.length > 1 && value !== undefined) {
    this.data.forEach(function (d) {
      if (!self.checkValueEquality(d, value)) { newData.push(d); }
    });
    self.data = newData;
    return;
  }

  // Delete the whole node
  if (this.deleteIfLeaf()) {
    return;
  }
  if (this.deleteIfOnlyOneChild()) {
    return;
  }

  // We are in the case where the node to delete has two children
  if (Math.random() >= 0.5) {   // Randomize replacement to avoid unbalancing the tree too much
    // Use the in-order predecessor
    replaceWith = this.left.getMaxKeyDescendant();

    this.key = replaceWith.key;
    this.data = replaceWith.data;

    if (this === replaceWith.parent) {   // Special case
      this.left = replaceWith.left;
      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }
    } else {
      replaceWith.parent.right = replaceWith.left;
      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }
    }
  } else {
    // Use the in-order successor
    replaceWith = this.right.getMinKeyDescendant();

    this.key = replaceWith.key;
    this.data = replaceWith.data;

    if (this === replaceWith.parent) {   // Special case
      this.right = replaceWith.right;
      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }
    } else {
      replaceWith.parent.left = replaceWith.right;
      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }
    }
  }
};


/**
 * Execute a function on every node of the tree, in key order
 * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data
 */
BinarySearchTree.prototype.executeOnEveryNode = function (fn) {
  if (this.left) { this.left.executeOnEveryNode(fn); }
  fn(this);
  if (this.right) { this.right.executeOnEveryNode(fn); }
};


/**
 * Pretty print a tree
 * @param {Boolean} printData To print the nodes' data along with the key
 */
BinarySearchTree.prototype.prettyPrint = function (printData, spacing) {
  spacing = spacing || "";

  console.log(spacing + "* " + this.key);
  if (printData) { console.log(spacing + "* " + this.data); }

  if (!this.left && !this.right) { return; }

  if (this.left) {
    this.left.prettyPrint(printData, spacing + "  ");
  } else {
    console.log(spacing + "  *");
  }
  if (this.right) {
    this.right.prettyPrint(printData, spacing + "  ");
  } else {
    console.log(spacing + "  *");
  }
};




// Interface
module.exports = BinarySearchTree;

},{"./customUtils":"node_modules/binary-search-tree/lib/customUtils.js"}],"node_modules/binary-search-tree/lib/avltree.js":[function(require,module,exports) {
/**
 * Self-balancing binary search tree using the AVL implementation
 */
var BinarySearchTree = require('./bst')
  , customUtils = require('./customUtils')
  , util = require('util')
  , _ = require('underscore')
  ;


/**
 * Constructor
 * We can't use a direct pointer to the root node (as in the simple binary search tree)
 * as the root will change during tree rotations
 * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
 * @param {Function} options.compareKeys Initialize this BST's compareKeys
 */
function AVLTree (options) {
  this.tree = new _AVLTree(options);
}


/**
 * Constructor of the internal AVLTree
 * @param {Object} options Optional
 * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
 * @param {Key}      options.key Initialize this BST's key with key
 * @param {Value}    options.value Initialize this BST's data with [value]
 * @param {Function} options.compareKeys Initialize this BST's compareKeys
 */
function _AVLTree (options) {
  options = options || {};

  this.left = null;
  this.right = null;
  this.parent = options.parent !== undefined ? options.parent : null;
  if (options.hasOwnProperty('key')) { this.key = options.key; }
  this.data = options.hasOwnProperty('value') ? [options.value] : [];
  this.unique = options.unique || false;

  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;
  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;
}


/**
 * Inherit basic functions from the basic binary search tree
 */
util.inherits(_AVLTree, BinarySearchTree);

/**
 * Keep a pointer to the internal tree constructor for testing purposes
 */
AVLTree._AVLTree = _AVLTree;


/**
 * Check the recorded height is correct for every node
 * Throws if one height doesn't match
 */
_AVLTree.prototype.checkHeightCorrect = function () {
  var leftH, rightH;

  if (!this.hasOwnProperty('key')) { return; }   // Empty tree

  if (this.left && this.left.height === undefined) { throw new Error("Undefined height for node " + this.left.key); }
  if (this.right && this.right.height === undefined) { throw new Error("Undefined height for node " + this.right.key); }
  if (this.height === undefined) { throw new Error("Undefined height for node " + this.key); }

  leftH = this.left ? this.left.height : 0;
  rightH = this.right ? this.right.height : 0;

  if (this.height !== 1 + Math.max(leftH, rightH)) { throw new Error("Height constraint failed for node " + this.key); }
  if (this.left) { this.left.checkHeightCorrect(); }
  if (this.right) { this.right.checkHeightCorrect(); }
};


/**
 * Return the balance factor
 */
_AVLTree.prototype.balanceFactor = function () {
  var leftH = this.left ? this.left.height : 0
    , rightH = this.right ? this.right.height : 0
    ;
  return leftH - rightH;
};


/**
 * Check that the balance factors are all between -1 and 1
 */
_AVLTree.prototype.checkBalanceFactors = function () {
  if (Math.abs(this.balanceFactor()) > 1) { throw new Error('Tree is unbalanced at node ' + this.key); }

  if (this.left) { this.left.checkBalanceFactors(); }
  if (this.right) { this.right.checkBalanceFactors(); }
};


/**
 * When checking if the BST conditions are met, also check that the heights are correct
 * and the tree is balanced
 */
_AVLTree.prototype.checkIsAVLT = function () {
  _AVLTree.super_.prototype.checkIsBST.call(this);
  this.checkHeightCorrect();
  this.checkBalanceFactors();
};
AVLTree.prototype.checkIsAVLT = function () { this.tree.checkIsAVLT(); };


/**
 * Perform a right rotation of the tree if possible
 * and return the root of the resulting tree
 * The resulting tree's nodes' heights are also updated
 */
_AVLTree.prototype.rightRotation = function () {
  var q = this
    , p = this.left
    , b
    , ah, bh, ch;

  if (!p) { return this; }   // No change

  b = p.right;

  // Alter tree structure
  if (q.parent) {
    p.parent = q.parent;
    if (q.parent.left === q) { q.parent.left = p; } else { q.parent.right = p; }
  } else {
    p.parent = null;
  }
  p.right = q;
  q.parent = p;
  q.left = b;
  if (b) { b.parent = q; }

  // Update heights
  ah = p.left ? p.left.height : 0;
  bh = b ? b.height : 0;
  ch = q.right ? q.right.height : 0;
  q.height = Math.max(bh, ch) + 1;
  p.height = Math.max(ah, q.height) + 1;

  return p;
};


/**
 * Perform a left rotation of the tree if possible
 * and return the root of the resulting tree
 * The resulting tree's nodes' heights are also updated
 */
_AVLTree.prototype.leftRotation = function () {
  var p = this
    , q = this.right
    , b
    , ah, bh, ch;

  if (!q) { return this; }   // No change

  b = q.left;

  // Alter tree structure
  if (p.parent) {
    q.parent = p.parent;
    if (p.parent.left === p) { p.parent.left = q; } else { p.parent.right = q; }
  } else {
    q.parent = null;
  }
  q.left = p;
  p.parent = q;
  p.right = b;
  if (b) { b.parent = p; }

  // Update heights
  ah = p.left ? p.left.height : 0;
  bh = b ? b.height : 0;
  ch = q.right ? q.right.height : 0;
  p.height = Math.max(ah, bh) + 1;
  q.height = Math.max(ch, p.height) + 1;

  return q;
};


/**
 * Modify the tree if its right subtree is too small compared to the left
 * Return the new root if any
 */
_AVLTree.prototype.rightTooSmall = function () {
  if (this.balanceFactor() <= 1) { return this; }   // Right is not too small, don't change

  if (this.left.balanceFactor() < 0) {
    this.left.leftRotation();
  }

  return this.rightRotation();
};


/**
 * Modify the tree if its left subtree is too small compared to the right
 * Return the new root if any
 */
_AVLTree.prototype.leftTooSmall = function () {
  if (this.balanceFactor() >= -1) { return this; }   // Left is not too small, don't change

  if (this.right.balanceFactor() > 0) {
    this.right.rightRotation();
  }

  return this.leftRotation();
};


/**
 * Rebalance the tree along the given path. The path is given reversed (as he was calculated
 * in the insert and delete functions).
 * Returns the new root of the tree
 * Of course, the first element of the path must be the root of the tree
 */
_AVLTree.prototype.rebalanceAlongPath = function (path) {
  var newRoot = this
    , rotated
    , i;

  if (!this.hasOwnProperty('key')) { delete this.height; return this; }   // Empty tree

  // Rebalance the tree and update all heights
  for (i = path.length - 1; i >= 0; i -= 1) {
    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);

    if (path[i].balanceFactor() > 1) {
      rotated = path[i].rightTooSmall();
      if (i === 0) { newRoot = rotated; }
    }

    if (path[i].balanceFactor() < -1) {
      rotated = path[i].leftTooSmall();
      if (i === 0) { newRoot = rotated; }
    }
  }

  return newRoot;
};


/**
 * Insert a key, value pair in the tree while maintaining the AVL tree height constraint
 * Return a pointer to the root node, which may have changed
 */
_AVLTree.prototype.insert = function (key, value) {
  var insertPath = []
    , currentNode = this
    ;

  // Empty tree, insert as root
  if (!this.hasOwnProperty('key')) {
    this.key = key;
    this.data.push(value);
    this.height = 1;
    return this;
  }

  // Insert new leaf at the right place
  while (true) {
    // Same key: no change in the tree structure
    if (currentNode.compareKeys(currentNode.key, key) === 0) {
      if (currentNode.unique) {
        var err = new Error("Can't insert key " + key + ", it violates the unique constraint");
        err.key = key;
        err.errorType = 'uniqueViolated';
        throw err;
      } else {
        currentNode.data.push(value);
      }
      return this;
    }

    insertPath.push(currentNode);

    if (currentNode.compareKeys(key, currentNode.key) < 0) {
      if (!currentNode.left) {
        insertPath.push(currentNode.createLeftChild({ key: key, value: value }));
        break;
      } else {
        currentNode = currentNode.left;
      }
    } else {
      if (!currentNode.right) {
        insertPath.push(currentNode.createRightChild({ key: key, value: value }));
        break;
      } else {
        currentNode = currentNode.right;
      }
    }
  }

  return this.rebalanceAlongPath(insertPath);
};

// Insert in the internal tree, update the pointer to the root if needed
AVLTree.prototype.insert = function (key, value) {
  var newTree = this.tree.insert(key, value);

  // If newTree is undefined, that means its structure was not modified
  if (newTree) { this.tree = newTree; }
};


/**
 * Delete a key or just a value and return the new root of the tree
 * @param {Key} key
 * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted
 */
_AVLTree.prototype.delete = function (key, value) {
  var newData = [], replaceWith
    , self = this
    , currentNode = this
    , deletePath = []
    ;

  if (!this.hasOwnProperty('key')) { return this; }   // Empty tree

  // Either no match is found and the function will return from within the loop
  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop
  while (true) {
    if (currentNode.compareKeys(key, currentNode.key) === 0) { break; }

    deletePath.push(currentNode);

    if (currentNode.compareKeys(key, currentNode.key) < 0) {
      if (currentNode.left) {
        currentNode = currentNode.left;
      } else {
        return this;   // Key not found, no modification
      }
    } else {
      // currentNode.compareKeys(key, currentNode.key) is > 0
      if (currentNode.right) {
        currentNode = currentNode.right;
      } else {
        return this;   // Key not found, no modification
      }
    }
  }

  // Delete only a value (no tree modification)
  if (currentNode.data.length > 1 && value) {
    currentNode.data.forEach(function (d) {
      if (!currentNode.checkValueEquality(d, value)) { newData.push(d); }
    });
    currentNode.data = newData;
    return this;
  }

  // Delete a whole node

  // Leaf
  if (!currentNode.left && !currentNode.right) {
    if (currentNode === this) {   // This leaf is also the root
      delete currentNode.key;
      currentNode.data = [];
      delete currentNode.height;
      return this;
    } else {
      if (currentNode.parent.left === currentNode) {
        currentNode.parent.left = null;
      } else {
        currentNode.parent.right = null;
      }
      return this.rebalanceAlongPath(deletePath);
    }
  }


  // Node with only one child
  if (!currentNode.left || !currentNode.right) {
    replaceWith = currentNode.left ? currentNode.left : currentNode.right;

    if (currentNode === this) {   // This node is also the root
      replaceWith.parent = null;
      return replaceWith;   // height of replaceWith is necessarily 1 because the tree was balanced before deletion
    } else {
      if (currentNode.parent.left === currentNode) {
        currentNode.parent.left = replaceWith;
        replaceWith.parent = currentNode.parent;
      } else {
        currentNode.parent.right = replaceWith;
        replaceWith.parent = currentNode.parent;
      }

      return this.rebalanceAlongPath(deletePath);
    }
  }


  // Node with two children
  // Use the in-order predecessor (no need to randomize since we actively rebalance)
  deletePath.push(currentNode);
  replaceWith = currentNode.left;

  // Special case: the in-order predecessor is right below the node to delete
  if (!replaceWith.right) {
    currentNode.key = replaceWith.key;
    currentNode.data = replaceWith.data;
    currentNode.left = replaceWith.left;
    if (replaceWith.left) { replaceWith.left.parent = currentNode; }
    return this.rebalanceAlongPath(deletePath);
  }

  // After this loop, replaceWith is the right-most leaf in the left subtree
  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)
  while (true) {
    if (replaceWith.right) {
      deletePath.push(replaceWith);
      replaceWith = replaceWith.right;
    } else {
      break;
    }
  }

  currentNode.key = replaceWith.key;
  currentNode.data = replaceWith.data;

  replaceWith.parent.right = replaceWith.left;
  if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }

  return this.rebalanceAlongPath(deletePath);
};

// Delete a value
AVLTree.prototype.delete = function (key, value) {
  var newTree = this.tree.delete(key, value);

  // If newTree is undefined, that means its structure was not modified
  if (newTree) { this.tree = newTree; }
};


/**
 * Other functions we want to use on an AVLTree as if it were the internal _AVLTree
 */
['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {
  AVLTree.prototype[fn] = function () {
    return this.tree[fn].apply(this.tree, arguments);
  };
});


// Interface
module.exports = AVLTree;

},{"./bst":"node_modules/binary-search-tree/lib/bst.js","./customUtils":"node_modules/binary-search-tree/lib/customUtils.js","util":"node_modules/util/util.js","underscore":"node_modules/underscore/underscore.js"}],"node_modules/binary-search-tree/index.js":[function(require,module,exports) {
module.exports.BinarySearchTree = require('./lib/bst');
module.exports.AVLTree = require('./lib/avltree');

},{"./lib/bst":"node_modules/binary-search-tree/lib/bst.js","./lib/avltree":"node_modules/binary-search-tree/lib/avltree.js"}],"node_modules/nedb/lib/indexes.js":[function(require,module,exports) {
var BinarySearchTree = require('binary-search-tree').AVLTree
  , model = require('./model')
  , _ = require('underscore')
  , util = require('util')
  ;

/**
 * Two indexed pointers are equal iif they point to the same place
 */
function checkValueEquality (a, b) {
  return a === b;
}

/**
 * Type-aware projection
 */
function projectForUnique (elt) {
  if (elt === null) { return '$null'; }
  if (typeof elt === 'string') { return '$string' + elt; }
  if (typeof elt === 'boolean') { return '$boolean' + elt; }
  if (typeof elt === 'number') { return '$number' + elt; }
  if (util.isArray(elt)) { return '$date' + elt.getTime(); }

  return elt;   // Arrays and objects, will check for pointer equality
}


/**
 * Create a new index
 * All methods on an index guarantee that either the whole operation was successful and the index changed
 * or the operation was unsuccessful and an error is thrown while the index is unchanged
 * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)
 * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)
 * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)
 */
function Index (options) {
  this.fieldName = options.fieldName;
  this.unique = options.unique || false;
  this.sparse = options.sparse || false;

  this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality: checkValueEquality };

  this.reset();   // No data in the beginning
}


/**
 * Reset an index
 * @param {Document or Array of documents} newData Optional, data to initialize the index with
 *                                                 If an error is thrown during insertion, the index is not modified
 */
Index.prototype.reset = function (newData) {
  this.tree = new BinarySearchTree(this.treeOptions);

  if (newData) { this.insert(newData); }
};


/**
 * Insert a new document in the index
 * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)
 * O(log(n))
 */
Index.prototype.insert = function (doc) {
  var key, self = this
    , keys, i, failingI, error
    ;

  if (util.isArray(doc)) { this.insertMultipleDocs(doc); return; }

  key = model.getDotValue(doc, this.fieldName);

  // We don't index documents that don't contain the field if the index is sparse
  if (key === undefined && this.sparse) { return; }

  if (!util.isArray(key)) {
    this.tree.insert(key, doc);
  } else {
    // If an insert fails due to a unique constraint, roll back all inserts before it
    keys = _.uniq(key, projectForUnique);

    for (i = 0; i < keys.length; i += 1) {
      try {
        this.tree.insert(keys[i], doc);
      } catch (e) {
        error = e;
        failingI = i;
        break;
      }
    }

    if (error) {
      for (i = 0; i < failingI; i += 1) {
        this.tree.delete(keys[i], doc);
      }

      throw error;
    }
  }
};


/**
 * Insert an array of documents in the index
 * If a constraint is violated, the changes should be rolled back and an error thrown
 *
 * @API private
 */
Index.prototype.insertMultipleDocs = function (docs) {
  var i, error, failingI;

  for (i = 0; i < docs.length; i += 1) {
    try {
      this.insert(docs[i]);
    } catch (e) {
      error = e;
      failingI = i;
      break;
    }
  }

  if (error) {
    for (i = 0; i < failingI; i += 1) {
      this.remove(docs[i]);
    }

    throw error;
  }
};


/**
 * Remove a document from the index
 * If an array is passed, we remove all its elements
 * The remove operation is safe with regards to the 'unique' constraint
 * O(log(n))
 */
Index.prototype.remove = function (doc) {
  var key, self = this;

  if (util.isArray(doc)) { doc.forEach(function (d) { self.remove(d); }); return; }

  key = model.getDotValue(doc, this.fieldName);

  if (key === undefined && this.sparse) { return; }

  if (!util.isArray(key)) {
    this.tree.delete(key, doc);
  } else {
    _.uniq(key, projectForUnique).forEach(function (_key) {
      self.tree.delete(_key, doc);
    });
  }
};


/**
 * Update a document in the index
 * If a constraint is violated, changes are rolled back and an error thrown
 * Naive implementation, still in O(log(n))
 */
Index.prototype.update = function (oldDoc, newDoc) {
  if (util.isArray(oldDoc)) { this.updateMultipleDocs(oldDoc); return; }

  this.remove(oldDoc);

  try {
    this.insert(newDoc);
  } catch (e) {
    this.insert(oldDoc);
    throw e;
  }
};


/**
 * Update multiple documents in the index
 * If a constraint is violated, the changes need to be rolled back
 * and an error thrown
 * @param {Array of oldDoc, newDoc pairs} pairs
 *
 * @API private
 */
Index.prototype.updateMultipleDocs = function (pairs) {
  var i, failingI, error;

  for (i = 0; i < pairs.length; i += 1) {
    this.remove(pairs[i].oldDoc);
  }

  for (i = 0; i < pairs.length; i += 1) {
    try {
      this.insert(pairs[i].newDoc);
    } catch (e) {
      error = e;
      failingI = i;
      break;
    }
  }

  // If an error was raised, roll back changes in the inverse order
  if (error) {
    for (i = 0; i < failingI; i += 1) {
      this.remove(pairs[i].newDoc);
    }

    for (i = 0; i < pairs.length; i += 1) {
      this.insert(pairs[i].oldDoc);
    }

    throw error;
  }
};


/**
 * Revert an update
 */
Index.prototype.revertUpdate = function (oldDoc, newDoc) {
  var revert = [];

  if (!util.isArray(oldDoc)) {
    this.update(newDoc, oldDoc);
  } else {
    oldDoc.forEach(function (pair) {
      revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });
    });
    this.update(revert);
  }
};


/**
 * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)
 * @param {Thing} value Value to match the key against
 * @return {Array of documents}
 */
Index.prototype.getMatching = function (value) {
  var self = this;

  if (!util.isArray(value)) {
    return self.tree.search(value);
  } else {
    var _res = {}, res = [];

    value.forEach(function (v) {
      self.getMatching(v).forEach(function (doc) {
        _res[doc._id] = doc;
      });
    });

    Object.keys(_res).forEach(function (_id) {
      res.push(_res[_id]);
    });

    return res;
  }
};


/**
 * Get all documents in index whose key is between bounds are they are defined by query
 * Documents are sorted by key
 * @param {Query} query
 * @return {Array of documents}
 */
Index.prototype.getBetweenBounds = function (query) {
  return this.tree.betweenBounds(query);
};


/**
 * Get all elements in the index
 * @return {Array of documents}
 */
Index.prototype.getAll = function () {
  var res = [];

  this.tree.executeOnEveryNode(function (node) {
    var i;

    for (i = 0; i < node.data.length; i += 1) {
      res.push(node.data[i]);
    }
  });

  return res;
};




// Interface
module.exports = Index;

},{"binary-search-tree":"node_modules/binary-search-tree/index.js","./model":"node_modules/nedb/lib/model.js","underscore":"node_modules/underscore/underscore.js","util":"node_modules/util/util.js"}],"node_modules/localforage/dist/localforage.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/*!
    localForage -- Offline Storage, Improved
    Version 1.7.3
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
'use strict';
var immediate = _dereq_(1);

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"1":1}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';
if (typeof global.Promise !== 'function') {
  global.Promise = _dereq_(2);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"2":2}],4:[function(_dereq_,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getIDB() {
    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
    try {
        if (typeof indexedDB !== 'undefined') {
            return indexedDB;
        }
        if (typeof webkitIndexedDB !== 'undefined') {
            return webkitIndexedDB;
        }
        if (typeof mozIndexedDB !== 'undefined') {
            return mozIndexedDB;
        }
        if (typeof OIndexedDB !== 'undefined') {
            return OIndexedDB;
        }
        if (typeof msIndexedDB !== 'undefined') {
            return msIndexedDB;
        }
    } catch (e) {
        return;
    }
}

var idb = getIDB();

function isIndexedDBValid() {
    try {
        // Initialize IndexedDB; fall back to vendor-prefixed versions
        // if needed.
        if (!idb) {
            return false;
        }
        // We mimic PouchDB here;
        //
        // We test for openDatabase because IE Mobile identifies itself
        // as Safari. Oh the lulz...
        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

        // Safari <10.1 does not meet our requirements for IDB support (#5572)
        // since Safari 10.1 shipped with fetch, we can use that to detect it
        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        // See: https://github.com/mozilla/localForage/issues/128
        // See: https://github.com/mozilla/localForage/issues/272
        typeof IDBKeyRange !== 'undefined';
    } catch (e) {
        return false;
    }
}

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
function createBlob(parts, properties) {
    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
    parts = parts || [];
    properties = properties || {};
    try {
        return new Blob(parts, properties);
    } catch (e) {
        if (e.name !== 'TypeError') {
            throw e;
        }
        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
    }
}

// This is CommonJS because lie is an external dependency, so Rollup
// can just ignore it.
if (typeof Promise === 'undefined') {
    // In the "nopromises" build this will just throw if you don't have
    // a global promise object, but it would throw anyway later.
    _dereq_(3);
}
var Promise$1 = Promise;

function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}

function executeTwoCallbacks(promise, callback, errorCallback) {
    if (typeof callback === 'function') {
        promise.then(callback);
    }

    if (typeof errorCallback === 'function') {
        promise["catch"](errorCallback);
    }
}

function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(key + ' used as a key, but it is not a string.');
        key = String(key);
    }

    return key;
}

function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}

// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).

var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
var supportsBlobs = void 0;
var dbContexts = {};
var toString = Object.prototype.toString;

// Transaction Modes
var READ_ONLY = 'readonly';
var READ_WRITE = 'readwrite';

// Transform a binary string to an array buffer, because otherwise
// weird stuff happens when you try to work with the binary string directly.
// It is known.
// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function _binStringToArrayBuffer(bin) {
    var length = bin.length;
    var buf = new ArrayBuffer(length);
    var arr = new Uint8Array(buf);
    for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
    }
    return buf;
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
// Code borrowed from PouchDB. See:
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
//
function _checkBlobSupportWithoutCaching(idb) {
    return new Promise$1(function (resolve) {
        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
        var blob = createBlob(['']);
        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

        txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
        };

        txn.oncomplete = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
        };
    })["catch"](function () {
        return false; // error, so assume unsupported
    });
}

function _checkBlobSupport(idb) {
    if (typeof supportsBlobs === 'boolean') {
        return Promise$1.resolve(supportsBlobs);
    }
    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
        supportsBlobs = value;
        return supportsBlobs;
    });
}

function _deferReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Create a deferred object representing the current database operation.
    var deferredOperation = {};

    deferredOperation.promise = new Promise$1(function (resolve, reject) {
        deferredOperation.resolve = resolve;
        deferredOperation.reject = reject;
    });

    // Enqueue the deferred operation.
    dbContext.deferredOperations.push(deferredOperation);

    // Chain its promise to the database readiness.
    if (!dbContext.dbReady) {
        dbContext.dbReady = deferredOperation.promise;
    } else {
        dbContext.dbReady = dbContext.dbReady.then(function () {
            return deferredOperation.promise;
        });
    }
}

function _advanceReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Resolve its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.resolve();
        return deferredOperation.promise;
    }
}

function _rejectReadiness(dbInfo, err) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Reject its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.reject(err);
        return deferredOperation.promise;
    }
}

function _getConnection(dbInfo, upgradeNeeded) {
    return new Promise$1(function (resolve, reject) {
        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

        if (dbInfo.db) {
            if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
            } else {
                return resolve(dbInfo.db);
            }
        }

        var dbArgs = [dbInfo.name];

        if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
        }

        var openreq = idb.open.apply(idb, dbArgs);

        if (upgradeNeeded) {
            openreq.onupgradeneeded = function (e) {
                var db = openreq.result;
                try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                        // Added when support for blob shims was added
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                } catch (ex) {
                    if (ex.name === 'ConstraintError') {
                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                        throw ex;
                    }
                }
            };
        }

        openreq.onerror = function (e) {
            e.preventDefault();
            reject(openreq.error);
        };

        openreq.onsuccess = function () {
            resolve(openreq.result);
            _advanceReadiness(dbInfo);
        };
    });
}

function _getOriginalConnection(dbInfo) {
    return _getConnection(dbInfo, false);
}

function _getUpgradedConnection(dbInfo) {
    return _getConnection(dbInfo, true);
}

function _isUpgradeNeeded(dbInfo, defaultVersion) {
    if (!dbInfo.db) {
        return true;
    }

    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
    var isDowngrade = dbInfo.version < dbInfo.db.version;
    var isUpgrade = dbInfo.version > dbInfo.db.version;

    if (isDowngrade) {
        // If the version is not the default one
        // then warn for impossible downgrade.
        if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
        }
        // Align the versions to prevent errors.
        dbInfo.version = dbInfo.db.version;
    }

    if (isUpgrade || isNewStore) {
        // If the store is new then increment the version (if needed).
        // This will trigger an "upgradeneeded" event which is required
        // for creating a store.
        if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
            }
        }

        return true;
    }

    return false;
}

// encode a blob for indexeddb engines that don't support blobs
function _encodeBlob(blob) {
    return new Promise$1(function (resolve, reject) {
        var reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = function (e) {
            var base64 = btoa(e.target.result || '');
            resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
            });
        };
        reader.readAsBinaryString(blob);
    });
}

// decode an encoded blob
function _decodeBlob(encodedBlob) {
    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
    return createBlob([arrayBuff], { type: encodedBlob.type });
}

// is this one of our fancy encoded blobs?
function _isEncodedBlob(value) {
    return value && value.__local_forage_encoded_blob;
}

// Specialize the default `ready()` function by making it dependent
// on the current database operations. Thus, the driver will be actually
// ready when it's been initialized (default) *and* there are no pending
// operations on the database (initiated by some other instances).
function _fullyReady(callback) {
    var self = this;

    var promise = self._initReady().then(function () {
        var dbContext = dbContexts[self._dbInfo.name];

        if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
        }
    });

    executeTwoCallbacks(promise, callback, callback);
    return promise;
}

// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
function _tryReconnect(dbInfo) {
    _deferReadiness(dbInfo);

    var dbContext = dbContexts[dbInfo.name];
    var forages = dbContext.forages;

    for (var i = 0; i < forages.length; i++) {
        var forage = forages[i];
        if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
        }
    }
    dbInfo.db = null;

    return _getOriginalConnection(dbInfo).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        // store the latest db reference
        // in case the db was upgraded
        dbInfo.db = dbContext.db = db;
        for (var i = 0; i < forages.length; i++) {
            forages[i]._dbInfo.db = db;
        }
    })["catch"](function (err) {
        _rejectReadiness(dbInfo, err);
        throw err;
    });
}

// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
function createTransaction(dbInfo, mode, callback, retries) {
    if (retries === undefined) {
        retries = 1;
    }

    try {
        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
        callback(null, tx);
    } catch (err) {
        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
            return Promise$1.resolve().then(function () {
                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    // increase the db version, to create the new ObjectStore
                    if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                    }
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
            }).then(function () {
                return _tryReconnect(dbInfo).then(function () {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                });
            })["catch"](callback);
        }

        callback(err);
    }
}

function createDbContext() {
    return {
        // Running localForages sharing a database.
        forages: [],
        // Shared database.
        db: null,
        // Database readiness (promise).
        dbReady: null,
        // Deferred operations on the database.
        deferredOperations: []
    };
}

// Open the IndexedDB database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    // Get the current context of the database;
    var dbContext = dbContexts[dbInfo.name];

    // ...or create a new context.
    if (!dbContext) {
        dbContext = createDbContext();
        // Register the new context in the global container.
        dbContexts[dbInfo.name] = dbContext;
    }

    // Register itself as a running localForage in the current context.
    dbContext.forages.push(self);

    // Replace the default `ready()` function with the specialized one.
    if (!self._initReady) {
        self._initReady = self.ready;
        self.ready = _fullyReady;
    }

    // Create an array of initialization states of the related localForages.
    var initPromises = [];

    function ignoreErrors() {
        // Don't handle errors here,
        // just makes sure related localForages aren't pending.
        return Promise$1.resolve();
    }

    for (var j = 0; j < dbContext.forages.length; j++) {
        var forage = dbContext.forages[j];
        if (forage !== self) {
            // Don't wait for itself...
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
        }
    }

    // Take a snapshot of the related localForages.
    var forages = dbContext.forages.slice(0);

    // Initialize the connection process only when
    // all the related localForages aren't pending.
    return Promise$1.all(initPromises).then(function () {
        dbInfo.db = dbContext.db;
        // Get the connection or open a new one without upgrade.
        return _getOriginalConnection(dbInfo);
    }).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        dbInfo.db = dbContext.db = db;
        self._dbInfo = dbInfo;
        // Share the final connection amongst related localForages.
        for (var k = 0; k < forages.length; k++) {
            var forage = forages[k];
            if (forage !== self) {
                // Self is already up-to-date.
                forage._dbInfo.db = dbInfo.db;
                forage._dbInfo.version = dbInfo.version;
            }
        }
    });
}

function getItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.get(key);

                    req.onsuccess = function () {
                        var value = req.result;
                        if (value === undefined) {
                            value = null;
                        }
                        if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                        }
                        resolve(value);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items stored in database.
function iterate(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (cursor) {
                            var value = cursor.value;
                            if (_isEncodedBlob(value)) {
                                value = _decodeBlob(value);
                            }
                            var result = iterator(value, cursor.key, iterationNumber++);

                            // when the iterator callback retuns any
                            // (non-`undefined`) value, then we stop
                            // the iteration immediately
                            if (result !== void 0) {
                                resolve(result);
                            } else {
                                cursor["continue"]();
                            }
                        } else {
                            resolve();
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);

    return promise;
}

function setItem(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        var dbInfo;
        self.ready().then(function () {
            dbInfo = self._dbInfo;
            if (toString.call(value) === '[object Blob]') {
                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                    if (blobSupport) {
                        return value;
                    }
                    return _encodeBlob(value);
                });
            }
            return value;
        }).then(function (value) {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);

                    // The reason we don't _save_ null is because IE 10 does
                    // not support saving the `null` type in IndexedDB. How
                    // ironic, given the bug below!
                    // See: https://github.com/mozilla/localForage/issues/161
                    if (value === null) {
                        value = undefined;
                    }

                    var req = store.put(value, key);

                    transaction.oncomplete = function () {
                        // Cast to undefined so the value passed to
                        // callback/promise is the same as what one would get out
                        // of `getItem()` later. This leads to some weirdness
                        // (setItem('foo', undefined) will return `null`), but
                        // it's not my fault localStorage is our baseline and that
                        // it's weird.
                        if (value === undefined) {
                            value = null;
                        }

                        resolve(value);
                    };
                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function removeItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    // We use a Grunt task to make this safe for IE and some
                    // versions of Android (including those used by Cordova).
                    // Normally IE won't like `.delete()` and will insist on
                    // using `['delete']()`, but we have a build step that
                    // fixes this for us now.
                    var req = store["delete"](key);
                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onerror = function () {
                        reject(req.error);
                    };

                    // The request will be also be aborted if we've exceeded our storage
                    // space.
                    transaction.onabort = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function clear(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.clear();

                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function length(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.count();

                    req.onsuccess = function () {
                        resolve(req.result);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function key(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        if (n < 0) {
            resolve(null);

            return;
        }

        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openCursor();

                    req.onsuccess = function () {
                        var cursor = req.result;
                        if (!cursor) {
                            // this means there weren't enough keys
                            resolve(null);

                            return;
                        }

                        if (n === 0) {
                            // We have the first key, return it if that's what they
                            // wanted.
                            resolve(cursor.key);
                        } else {
                            if (!advanced) {
                                // Otherwise, ask the cursor to skip ahead n
                                // records.
                                advanced = true;
                                cursor.advance(n);
                            } else {
                                // When we get here, we've got the nth key.
                                resolve(cursor.key);
                            }
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openCursor();
                    var keys = [];

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (!cursor) {
                            resolve(keys);
                            return;
                        }

                        keys.push(cursor.key);
                        cursor["continue"]();
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
            }
            return db;
        });

        if (!options.storeName) {
            promise = dbPromise.then(function (db) {
                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                }

                var dropDBPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.deleteDatabase(options.name);

                    req.onerror = req.onblocked = function (err) {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        reject(err);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        resolve(db);
                    };
                });

                return dropDBPromise.then(function (db) {
                    dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                        var _forage = forages[i];
                        _advanceReadiness(_forage._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        } else {
            promise = dbPromise.then(function (db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                }

                var newVersion = db.version + 1;

                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                }

                var dropObjectPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.open(options.name, newVersion);

                    req.onerror = function (err) {
                        var db = req.result;
                        db.close();
                        reject(err);
                    };

                    req.onupgradeneeded = function () {
                        var db = req.result;
                        db.deleteObjectStore(options.storeName);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        db.close();
                        resolve(db);
                    };
                });

                return dropObjectPromise.then(function (db) {
                    dbContext.db = db;
                    for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db;
                        _advanceReadiness(_forage2._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        }
    }

    executeCallback(promise, callback);
    return promise;
}

var asyncStorage = {
    _driver: 'asyncStorage',
    _initStorage: _initStorage,
    _support: isIndexedDBValid(),
    iterate: iterate,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys,
    dropInstance: dropInstance
};

function isWebSQLValid() {
    return typeof openDatabase === 'function';
}

// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
// it to Base64, so this is how we store it to prevent very strange errors with less
// verbose ways of binary <-> string data storage.
var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var BLOB_TYPE_PREFIX = '~~local_forage_type~';
var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

var SERIALIZED_MARKER = '__lfsc__:';
var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

// OMG the serializations!
var TYPE_ARRAYBUFFER = 'arbf';
var TYPE_BLOB = 'blob';
var TYPE_INT8ARRAY = 'si08';
var TYPE_UINT8ARRAY = 'ui08';
var TYPE_UINT8CLAMPEDARRAY = 'uic8';
var TYPE_INT16ARRAY = 'si16';
var TYPE_INT32ARRAY = 'si32';
var TYPE_UINT16ARRAY = 'ur16';
var TYPE_UINT32ARRAY = 'ui32';
var TYPE_FLOAT32ARRAY = 'fl32';
var TYPE_FLOAT64ARRAY = 'fl64';
var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

var toString$1 = Object.prototype.toString;

function stringToBuffer(serializedString) {
    // Fill the string into a ArrayBuffer.
    var bufferLength = serializedString.length * 0.75;
    var len = serializedString.length;
    var i;
    var p = 0;
    var encoded1, encoded2, encoded3, encoded4;

    if (serializedString[serializedString.length - 1] === '=') {
        bufferLength--;
        if (serializedString[serializedString.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

        /*jslint bitwise: true */
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
}

// Converts a buffer to a string to store, serialized, in the backend
// storage library.
function bufferToString(buffer) {
    // base64-arraybuffer
    var bytes = new Uint8Array(buffer);
    var base64String = '';
    var i;

    for (i = 0; i < bytes.length; i += 3) {
        /*jslint bitwise: true */
        base64String += BASE_CHARS[bytes[i] >> 2];
        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64String += BASE_CHARS[bytes[i + 2] & 63];
    }

    if (bytes.length % 3 === 2) {
        base64String = base64String.substring(0, base64String.length - 1) + '=';
    } else if (bytes.length % 3 === 1) {
        base64String = base64String.substring(0, base64String.length - 2) + '==';
    }

    return base64String;
}

// Serialize a value, afterwards executing a callback (which usually
// instructs the `setItem()` callback/promise to be executed). This is how
// we store binary data with localStorage.
function serialize(value, callback) {
    var valueType = '';
    if (value) {
        valueType = toString$1.call(value);
    }

    // Cannot use `value instanceof ArrayBuffer` or such here, as these
    // checks fail when running the tests using casper.js...
    //
    // TODO: See why those tests fail and use a better solution.
    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
        // Convert binary arrays to a string and prefix the string with
        // a special marker.
        var buffer;
        var marker = SERIALIZED_MARKER;

        if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
        } else {
            buffer = value.buffer;

            if (valueType === '[object Int8Array]') {
                marker += TYPE_INT8ARRAY;
            } else if (valueType === '[object Uint8Array]') {
                marker += TYPE_UINT8ARRAY;
            } else if (valueType === '[object Uint8ClampedArray]') {
                marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === '[object Int16Array]') {
                marker += TYPE_INT16ARRAY;
            } else if (valueType === '[object Uint16Array]') {
                marker += TYPE_UINT16ARRAY;
            } else if (valueType === '[object Int32Array]') {
                marker += TYPE_INT32ARRAY;
            } else if (valueType === '[object Uint32Array]') {
                marker += TYPE_UINT32ARRAY;
            } else if (valueType === '[object Float32Array]') {
                marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === '[object Float64Array]') {
                marker += TYPE_FLOAT64ARRAY;
            } else {
                callback(new Error('Failed to get type for BinaryArray'));
            }
        }

        callback(marker + bufferToString(buffer));
    } else if (valueType === '[object Blob]') {
        // Conver the blob to a binaryArray and then to a string.
        var fileReader = new FileReader();

        fileReader.onload = function () {
            // Backwards-compatible prefix for the blob type.
            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
        };

        fileReader.readAsArrayBuffer(value);
    } else {
        try {
            callback(JSON.stringify(value));
        } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);

            callback(null, e);
        }
    }
}

// Deserialize data we've inserted into a value column/field. We place
// special markers into our strings to mark them as encoded; this isn't
// as nice as a meta field, but it's the only sane thing we can do whilst
// keeping localStorage support intact.
//
// Oftentimes this will just deserialize JSON content, but if we have a
// special marker (SERIALIZED_MARKER, defined above), we will extract
// some kind of arraybuffer/binary data/typed array out of the string.
function deserialize(value) {
    // If we haven't marked this string as being specially serialized (i.e.
    // something other than serialized JSON), we can just return it and be
    // done with it.
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
        return JSON.parse(value);
    }

    // The following code deals with deserializing some kind of Blob or
    // TypedArray. First we separate out the type of data we're dealing
    // with from the data itself.
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

    var blobType;
    // Backwards-compatible blob type serialization strategy.
    // DBs created with older versions of localForage will simply not have the blob type.
    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
        blobType = matcher[1];
        serializedString = serializedString.substring(matcher[0].length);
    }
    var buffer = stringToBuffer(serializedString);

    // Return the right type based on the code/type set during
    // serialization.
    switch (type) {
        case TYPE_ARRAYBUFFER:
            return buffer;
        case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
        case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
        case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
        case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
        case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
        case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
        case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
        case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
        case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
        case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
        default:
            throw new Error('Unkown type: ' + type);
    }
}

var localforageSerializer = {
    serialize: serialize,
    deserialize: deserialize,
    stringToBuffer: stringToBuffer,
    bufferToString: bufferToString
};

/*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function createDbTable(t, dbInfo, callback, errorCallback) {
    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
}

// Open the WebSQL database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage$1(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
        }
    }

    var dbInfoPromise = new Promise$1(function (resolve, reject) {
        // Open the database; the openDatabase API will automatically
        // create it for us if it doesn't exist.
        try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
        } catch (e) {
            return reject(e);
        }

        // Create our key/value table if it doesn't exist.
        dbInfo.db.transaction(function (t) {
            createDbTable(t, dbInfo, function () {
                self._dbInfo = dbInfo;
                resolve();
            }, function (t, error) {
                reject(error);
            });
        }, reject);
    });

    dbInfo.serializer = localforageSerializer;
    return dbInfoPromise;
}

function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
    t.executeSql(sqlStatement, args, callback, function (t, error) {
        if (error.code === error.SYNTAX_ERR) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                if (!results.rows.length) {
                    // if the table is missing (was deleted)
                    // re-create it table and retry
                    createDbTable(t, dbInfo, function () {
                        t.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                } else {
                    errorCallback(t, error);
                }
            }, errorCallback);
        } else {
            errorCallback(t, error);
        }
    }, errorCallback);
}

function getItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;

                    // Check to see if this is serialized content we need to
                    // unpack.
                    if (result) {
                        result = dbInfo.serializer.deserialize(result);
                    }

                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function iterate$1(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;

            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                    var rows = results.rows;
                    var length = rows.length;

                    for (var i = 0; i < length; i++) {
                        var item = rows.item(i);
                        var result = item.value;

                        // Check to see if this is serialized content
                        // we need to unpack.
                        if (result) {
                            result = dbInfo.serializer.deserialize(result);
                        }

                        result = iterator(result, item.key, i + 1);

                        // void(0) prevents problems with redefinition
                        // of `undefined`.
                        if (result !== void 0) {
                            resolve(result);
                            return;
                        }
                    }

                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function _setItem(key, value, callback, retriesLeft) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            // The localStorage API doesn't return undefined values in an
            // "expected" way, so undefined is always cast to null in all
            // drivers. See: https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
                value = null;
            }

            // Save the original value to pass to the callback.
            var originalValue = value;

            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                            resolve(originalValue);
                        }, function (t, error) {
                            reject(error);
                        });
                    }, function (sqlError) {
                        // The transaction failed; check
                        // to see if it's a quota error.
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                            // We reject the callback outright for now, but
                            // it's worth trying to re-run the transaction.
                            // Even if the user accepts the prompt to use
                            // more storage on Safari, this error will
                            // be called.
                            //
                            // Try to re-run the transaction.
                            if (retriesLeft > 0) {
                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                return;
                            }
                            reject(sqlError);
                        }
                    });
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function setItem$1(key, value, callback) {
    return _setItem.apply(this, [key, value, callback, 1]);
}

function removeItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Deletes every item in the table.
// TODO: Find out if this resets the AUTO_INCREMENT number.
function clear$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Does a simple `COUNT(key)` to get the number of items stored in
// localForage.
function length$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                // Ahhh, SQL makes this one soooooo easy.
                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                    var result = results.rows.item(0).c;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Return the key located at key index X; essentially gets the key from a
// `WHERE id = ?`. This is the most efficient way I can think to implement
// this rarely-used (in my experience) part of the API, but it can seem
// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
// the ID of each key will change every time it's updated. Perhaps a stored
// procedure for the `setItem()` SQL would solve this problem?
// TODO: Don't change ID on `setItem()`.
function key$1(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                    var keys = [];

                    for (var i = 0; i < results.rows.length; i++) {
                        keys.push(results.rows.item(i).key);
                    }

                    resolve(keys);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// https://www.w3.org/TR/webdatabase/#databases
// > There is no way to enumerate or delete the databases available for an origin from this API.
function getAllStoreNames(db) {
    return new Promise$1(function (resolve, reject) {
        db.transaction(function (t) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                var storeNames = [];

                for (var i = 0; i < results.rows.length; i++) {
                    storeNames.push(results.rows.item(i).name);
                }

                resolve({
                    db: db,
                    storeNames: storeNames
                });
            }, function (t, error) {
                reject(error);
            });
        }, function (sqlError) {
            reject(sqlError);
        });
    });
}

function dropInstance$1(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            var db;
            if (options.name === currentConfig.name) {
                // use the db reference of the current instance
                db = self._dbInfo.db;
            } else {
                db = openDatabase(options.name, '', '', 0);
            }

            if (!options.storeName) {
                // drop all database tables
                resolve(getAllStoreNames(db));
            } else {
                resolve({
                    db: db,
                    storeNames: [options.storeName]
                });
            }
        }).then(function (operationInfo) {
            return new Promise$1(function (resolve, reject) {
                operationInfo.db.transaction(function (t) {
                    function dropTable(storeName) {
                        return new Promise$1(function (resolve, reject) {
                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    }

                    var operations = [];
                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                    }

                    Promise$1.all(operations).then(function () {
                        resolve();
                    })["catch"](function (e) {
                        reject(e);
                    });
                }, function (sqlError) {
                    reject(sqlError);
                });
            });
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var webSQLStorage = {
    _driver: 'webSQLStorage',
    _initStorage: _initStorage$1,
    _support: isWebSQLValid(),
    iterate: iterate$1,
    getItem: getItem$1,
    setItem: setItem$1,
    removeItem: removeItem$1,
    clear: clear$1,
    length: length$1,
    key: key$1,
    keys: keys$1,
    dropInstance: dropInstance$1
};

function isLocalStorageValid() {
    try {
        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
        // in IE8 typeof localStorage.setItem === 'object'
        !!localStorage.setItem;
    } catch (e) {
        return false;
    }
}

function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + '/';

    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + '/';
    }
    return keyPrefix;
}

// Check if localStorage throws when saving an item
function checkIfLocalStorageThrows() {
    var localStorageTestKey = '_localforage_support_test';

    try {
        localStorage.setItem(localStorageTestKey, true);
        localStorage.removeItem(localStorageTestKey);

        return false;
    } catch (e) {
        return true;
    }
}

// Check if localStorage is usable and allows to save an item
// This method checks if localStorage is usable in Safari Private Browsing
// mode, or in any other case where the available quota for localStorage
// is 0 and there wasn't any saved items yet.
function _isLocalStorageUsable() {
    return !checkIfLocalStorageThrows() || localStorage.length > 0;
}

// Config the localStorage backend, using options set in the config.
function _initStorage$2(options) {
    var self = this;
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

    if (!_isLocalStorageUsable()) {
        return Promise$1.reject();
    }

    self._dbInfo = dbInfo;
    dbInfo.serializer = localforageSerializer;

    return Promise$1.resolve();
}

// Remove all keys from the datastore, effectively destroying all data in
// the app's key/value store!
function clear$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var keyPrefix = self._dbInfo.keyPrefix;

        for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key);
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Retrieve an item from the store. Unlike the original async_storage
// library in Gaia, we don't modify return values at all. If a key's value
// is `undefined`, we pass that value to the callback function.
function getItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result = localStorage.getItem(dbInfo.keyPrefix + key);

        // If a result was found, parse it from the serialized
        // string into a JS object. If result isn't truthy, the key
        // is likely undefined and we'll pass it straight to the
        // callback.
        if (result) {
            result = dbInfo.serializer.deserialize(result);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items in the store.
function iterate$2(iterator, callback) {
    var self = this;

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var keyPrefix = dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length = localStorage.length;

        // We use a dedicated iterator instead of the `i` variable below
        // so other keys we fetch in localStorage aren't counted in
        // the `iterationNumber` argument passed to the `iterate()`
        // callback.
        //
        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
        var iterationNumber = 1;

        for (var i = 0; i < length; i++) {
            var key = localStorage.key(i);
            if (key.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = localStorage.getItem(key);

            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.
            if (value) {
                value = dbInfo.serializer.deserialize(value);
            }

            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

            if (value !== void 0) {
                return value;
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Same as localStorage's key() method, except takes a callback.
function key$2(n, callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result;
        try {
            result = localStorage.key(n);
        } catch (error) {
            result = null;
        }

        // Remove the prefix from the key, if a key is found.
        if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var length = localStorage.length;
        var keys = [];

        for (var i = 0; i < length; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
        }

        return keys;
    });

    executeCallback(promise, callback);
    return promise;
}

// Supply the number of keys in the datastore to the callback function.
function length$2(callback) {
    var self = this;
    var promise = self.keys().then(function (keys) {
        return keys.length;
    });

    executeCallback(promise, callback);
    return promise;
}

// Remove an item from the store, nice and simple.
function removeItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        localStorage.removeItem(dbInfo.keyPrefix + key);
    });

    executeCallback(promise, callback);
    return promise;
}

// Set a key's value and run an optional callback once the value is set.
// Unlike Gaia's implementation, the callback function is passed the value,
// in case you want to operate on that value only after you're sure it
// saved, or something like that.
function setItem$2(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        // Convert undefined values to null.
        // https://github.com/mozilla/localForage/pull/42
        if (value === undefined) {
            value = null;
        }

        // Save the original value to pass to the callback.
        var originalValue = value;

        return new Promise$1(function (resolve, reject) {
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    try {
                        localStorage.setItem(dbInfo.keyPrefix + key, value);
                        resolve(originalValue);
                    } catch (e) {
                        // localStorage capacity exceeded.
                        // TODO: Make this a specific error/event.
                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance$2(options, callback) {
    callback = getCallback.apply(this, arguments);

    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + '/');
            } else {
                resolve(_getKeyPrefix(options, self._defaultConfig));
            }
        }).then(function (keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);

                if (key.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var localStorageWrapper = {
    _driver: 'localStorageWrapper',
    _initStorage: _initStorage$2,
    _support: isLocalStorageValid(),
    iterate: iterate$2,
    getItem: getItem$2,
    setItem: setItem$2,
    removeItem: removeItem$2,
    clear: clear$2,
    length: length$2,
    key: key$2,
    keys: keys$2,
    dropInstance: dropInstance$2
};

var sameValue = function sameValue(x, y) {
    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
};

var includes = function includes(array, searchElement) {
    var len = array.length;
    var i = 0;
    while (i < len) {
        if (sameValue(array[i], searchElement)) {
            return true;
        }
        i++;
    }

    return false;
};

var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
};

// Drivers are stored here when `defineDriver()` is called.
// They are shared across all instances of localForage.
var DefinedDrivers = {};

var DriverSupport = {};

var DefaultDrivers = {
    INDEXEDDB: asyncStorage,
    WEBSQL: webSQLStorage,
    LOCALSTORAGE: localStorageWrapper
};

var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

var OptionalDriverMethods = ['dropInstance'];

var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

var DefaultConfig = {
    description: '',
    driver: DefaultDriverOrder.slice(),
    name: 'localforage',
    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
    // we can use without a prompt.
    size: 4980736,
    storeName: 'keyvaluepairs',
    version: 1.0
};

function callWhenReady(localForageInstance, libraryMethod) {
    localForageInstance[libraryMethod] = function () {
        var _args = arguments;
        return localForageInstance.ready().then(function () {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
        });
    };
}

function extend() {
    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];

        if (arg) {
            for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                    if (isArray(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                    } else {
                        arguments[0][_key] = arg[_key];
                    }
                }
            }
        }
    }

    return arguments[0];
}

var LocalForage = function () {
    function LocalForage(options) {
        _classCallCheck(this, LocalForage);

        for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;

                if (!DefinedDrivers[driverName]) {
                    // we don't need to wait for the promise,
                    // since the default drivers can be defined
                    // in a blocking manner
                    this.defineDriver(driver);
                }
            }
        }

        this._defaultConfig = extend({}, DefaultConfig);
        this._config = extend({}, this._defaultConfig, options);
        this._driverSet = null;
        this._initDriver = null;
        this._ready = false;
        this._dbInfo = null;

        this._wrapLibraryMethodsWithReady();
        this.setDriver(this._config.driver)["catch"](function () {});
    }

    // Set any config values for localForage; can be called anytime before
    // the first API call (e.g. `getItem`, `setItem`).
    // We loop through options so we don't overwrite existing config
    // values.


    LocalForage.prototype.config = function config(options) {
        // If the options argument is an object, we use it to set values.
        // Otherwise, we return either a specified config value or all
        // config values.
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
                return new Error("Can't call config() after localforage " + 'has been used.');
            }

            for (var i in options) {
                if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                }

                if (i === 'version' && typeof options[i] !== 'number') {
                    return new Error('Database version must be a number.');
                }

                this._config[i] = options[i];
            }

            // after all config options are set and
            // the driver option is used, try setting it
            if ('driver' in options && options.driver) {
                return this.setDriver(this._config.driver);
            }

            return true;
        } else if (typeof options === 'string') {
            return this._config[options];
        } else {
            return this._config;
        }
    };

    // Used to define a custom driver, shared across all instances of
    // localForage.


    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
        var promise = new Promise$1(function (resolve, reject) {
            try {
                var driverName = driverObject._driver;
                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                // A driver name should be defined and not overlap with the
                // library-defined, default drivers.
                if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                }

                var driverMethods = LibraryMethods.concat('_initStorage');
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                    var driverMethodName = driverMethods[i];

                    // when the property is there,
                    // it should be a method even when optional
                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                        reject(complianceError);
                        return;
                    }
                }

                var configureMissingMethods = function configureMissingMethods() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                        return function () {
                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                            var promise = Promise$1.reject(error);
                            executeCallback(promise, arguments[arguments.length - 1]);
                            return promise;
                        };
                    };

                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                    }
                };

                configureMissingMethods();

                var setDriverSupport = function setDriverSupport(support) {
                    if (DefinedDrivers[driverName]) {
                        console.info('Redefining LocalForage driver: ' + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    // don't use a then, so that we can define
                    // drivers that have simple _support methods
                    // in a blocking manner
                    resolve();
                };

                if ('_support' in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                        driverObject._support().then(setDriverSupport, reject);
                    } else {
                        setDriverSupport(!!driverObject._support);
                    }
                } else {
                    setDriverSupport(true);
                }
            } catch (e) {
                reject(e);
            }
        });

        executeTwoCallbacks(promise, callback, errorCallback);
        return promise;
    };

    LocalForage.prototype.driver = function driver() {
        return this._driver || null;
    };

    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
        return getDriverPromise;
    };

    LocalForage.prototype.getSerializer = function getSerializer(callback) {
        var serializerPromise = Promise$1.resolve(localforageSerializer);
        executeTwoCallbacks(serializerPromise, callback);
        return serializerPromise;
    };

    LocalForage.prototype.ready = function ready(callback) {
        var self = this;

        var promise = self._driverSet.then(function () {
            if (self._ready === null) {
                self._ready = self._initDriver();
            }

            return self._ready;
        });

        executeTwoCallbacks(promise, callback, callback);
        return promise;
    };

    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
        var self = this;

        if (!isArray(drivers)) {
            drivers = [drivers];
        }

        var supportedDrivers = this._getSupportedDrivers(drivers);

        function setDriverToConfig() {
            self._config.driver = self.driver();
        }

        function extendSelfWithDriver(driver) {
            self._extend(driver);
            setDriverToConfig();

            self._ready = self._initStorage(self._config);
            return self._ready;
        }

        function initDriver(supportedDrivers) {
            return function () {
                var currentDriverIndex = 0;

                function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers.length) {
                        var driverName = supportedDrivers[currentDriverIndex];
                        currentDriverIndex++;

                        self._dbInfo = null;
                        self._ready = null;

                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }

                    setDriverToConfig();
                    var error = new Error('No available storage method found.');
                    self._driverSet = Promise$1.reject(error);
                    return self._driverSet;
                }

                return driverPromiseLoop();
            };
        }

        // There might be a driver initialization in progress
        // so wait for it to finish in order to avoid a possible
        // race condition to set _dbInfo
        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
            return Promise$1.resolve();
        }) : Promise$1.resolve();

        this._driverSet = oldDriverSetDone.then(function () {
            var driverName = supportedDrivers[0];
            self._dbInfo = null;
            self._ready = null;

            return self.getDriver(driverName).then(function (driver) {
                self._driver = driver._driver;
                setDriverToConfig();
                self._wrapLibraryMethodsWithReady();
                self._initDriver = initDriver(supportedDrivers);
            });
        })["catch"](function () {
            setDriverToConfig();
            var error = new Error('No available storage method found.');
            self._driverSet = Promise$1.reject(error);
            return self._driverSet;
        });

        executeTwoCallbacks(this._driverSet, callback, errorCallback);
        return this._driverSet;
    };

    LocalForage.prototype.supports = function supports(driverName) {
        return !!DriverSupport[driverName];
    };

    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
        extend(this, libraryMethodsAndProperties);
    };

    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
        var supportedDrivers = [];
        for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
            }
        }
        return supportedDrivers;
    };

    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
        // Add a stub for each driver API method that delays the call to the
        // corresponding driver method until localForage is ready. These stubs
        // will be replaced by the driver methods as soon as the driver is
        // loaded, so there is no performance impact.
        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
        }
    };

    LocalForage.prototype.createInstance = function createInstance(options) {
        return new LocalForage(options);
    };

    return LocalForage;
}();

// The actual localForage object that we expose as a module or via a
// global. It's extended by pulling in one of our other libraries.


var localforage_js = new LocalForage();

module.exports = localforage_js;

},{"3":3}]},{},[4])(4)
});

},{}],"node_modules/nedb/browser-version/browser-specific/lib/storage.js":[function(require,module,exports) {
/**
 * Way data is stored for this database
 * For a Node.js/Node Webkit database it's the file system
 * For a browser-side database it's localforage, which uses the best backend available (IndexedDB then WebSQL then localStorage)
 *
 * This version is the browser version
 */

var localforage = require('localforage')

// Configure localforage to display NeDB name for now. Would be a good idea to let user use his own app name
localforage.config({
  name: 'NeDB'
, storeName: 'nedbdata'
});


function exists (filename, callback) {
  localforage.getItem(filename, function (err, value) {
    if (value !== null) {   // Even if value is undefined, localforage returns null
      return callback(true);
    } else {
      return callback(false);
    }
  });
}


function rename (filename, newFilename, callback) {
  localforage.getItem(filename, function (err, value) {
    if (value === null) {
      localforage.removeItem(newFilename, function () { return callback(); });
    } else {
      localforage.setItem(newFilename, value, function () {
        localforage.removeItem(filename, function () { return callback(); });
      });
    }
  });
}


function writeFile (filename, contents, options, callback) {
  // Options do not matter in browser setup
  if (typeof options === 'function') { callback = options; }
  localforage.setItem(filename, contents, function () { return callback(); });
}


function appendFile (filename, toAppend, options, callback) {
  // Options do not matter in browser setup
  if (typeof options === 'function') { callback = options; }

  localforage.getItem(filename, function (err, contents) {
    contents = contents || '';
    contents += toAppend;
    localforage.setItem(filename, contents, function () { return callback(); });
  });
}


function readFile (filename, options, callback) {
  // Options do not matter in browser setup
  if (typeof options === 'function') { callback = options; }
  localforage.getItem(filename, function (err, contents) { return callback(null, contents || ''); });
}


function unlink (filename, callback) {
  localforage.removeItem(filename, function () { return callback(); });
}


// Nothing to do, no directories will be used on the browser
function mkdirp (dir, callback) {
  return callback();
}


// Nothing to do, no data corruption possible in the brower
function ensureDatafileIntegrity (filename, callback) {
  return callback(null);
}


// Interface
module.exports.exists = exists;
module.exports.rename = rename;
module.exports.writeFile = writeFile;
module.exports.crashSafeWriteFile = writeFile;   // No need for a crash safe function in the browser
module.exports.appendFile = appendFile;
module.exports.readFile = readFile;
module.exports.unlink = unlink;
module.exports.mkdirp = mkdirp;
module.exports.ensureDatafileIntegrity = ensureDatafileIntegrity;


},{"localforage":"node_modules/localforage/dist/localforage.js"}],"node_modules/nedb/lib/persistence.js":[function(require,module,exports) {
var process = require("process");
/**
 * Handle every persistence-related task
 * The interface Datastore expects to be implemented is
 * * Persistence.loadDatabase(callback) and callback has signature err
 * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err
 */
var storage = require('./storage'),
    path = require('path'),
    model = require('./model'),
    async = require('async'),
    customUtils = require('./customUtils'),
    Index = require('./indexes');
/**
 * Create a new Persistence object for database options.db
 * @param {Datastore} options.db
 * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where
 *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)
 */


function Persistence(options) {
  var i, j, randomString;
  this.db = options.db;
  this.inMemoryOnly = this.db.inMemoryOnly;
  this.filename = this.db.filename;
  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;

  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {
    throw new Error("The datafile name can't end with a ~, which is reserved for crash safe backup files");
  } // After serialization and before deserialization hooks with some basic sanity checks


  if (options.afterSerialization && !options.beforeDeserialization) {
    throw new Error("Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss");
  }

  if (!options.afterSerialization && options.beforeDeserialization) {
    throw new Error("Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss");
  }

  this.afterSerialization = options.afterSerialization || function (s) {
    return s;
  };

  this.beforeDeserialization = options.beforeDeserialization || function (s) {
    return s;
  };

  for (i = 1; i < 30; i += 1) {
    for (j = 0; j < 10; j += 1) {
      randomString = customUtils.uid(i);

      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {
        throw new Error("beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss");
      }
    }
  } // For NW apps, store data in the same directory where NW stores application data


  if (this.filename && options.nodeWebkitAppName) {
    console.log("==================================================================");
    console.log("WARNING: The nodeWebkitAppName option is deprecated");
    console.log("To get the path to the directory where Node Webkit stores the data");
    console.log("for your app, use the internal nw.gui module like this");
    console.log("require('nw.gui').App.dataPath");
    console.log("See https://github.com/rogerwang/node-webkit/issues/500");
    console.log("==================================================================");
    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);
  }
}

;
/**
 * Check if a directory exists and create it on the fly if it is not the case
 * cb is optional, signature: err
 */

Persistence.ensureDirectoryExists = function (dir, cb) {
  var callback = cb || function () {};

  storage.mkdirp(dir, function (err) {
    return callback(err);
  });
};
/**
 * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores
 * data for this application. Probably the best place to store data
 */


Persistence.getNWAppFilename = function (appName, relativeFilename) {
  var home;

  switch (process.platform) {
    case 'win32':
    case 'win64':
      home = undefined || undefined;

      if (!home) {
        throw new Error("Couldn't find the base application data folder");
      }

      home = path.join(home, appName);
      break;

    case 'darwin':
      home = "/home/lennon";

      if (!home) {
        throw new Error("Couldn't find the base application data directory");
      }

      home = path.join(home, 'Library', 'Application Support', appName);
      break;

    case 'linux':
      home = "/home/lennon";

      if (!home) {
        throw new Error("Couldn't find the base application data directory");
      }

      home = path.join(home, '.config', appName);
      break;

    default:
      throw new Error("Can't use the Node Webkit relative path for platform " + process.platform);
      break;
  }

  return path.join(home, 'nedb-data', relativeFilename);
};
/**
 * Persist cached database
 * This serves as a compaction function since the cache always contains only the number of documents in the collection
 * while the data file is append-only so it may grow larger
 * @param {Function} cb Optional callback, signature: err
 */


Persistence.prototype.persistCachedDatabase = function (cb) {
  var callback = cb || function () {},
      toPersist = '',
      self = this;

  if (this.inMemoryOnly) {
    return callback(null);
  }

  this.db.getAllData().forEach(function (doc) {
    toPersist += self.afterSerialization(model.serialize(doc)) + '\n';
  });
  Object.keys(this.db.indexes).forEach(function (fieldName) {
    if (fieldName != "_id") {
      // The special _id index is managed by datastore.js, the others need to be persisted
      toPersist += self.afterSerialization(model.serialize({
        $$indexCreated: {
          fieldName: fieldName,
          unique: self.db.indexes[fieldName].unique,
          sparse: self.db.indexes[fieldName].sparse
        }
      })) + '\n';
    }
  });
  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {
    if (err) {
      return callback(err);
    }

    self.db.emit('compaction.done');
    return callback(null);
  });
};
/**
 * Queue a rewrite of the datafile
 */


Persistence.prototype.compactDatafile = function () {
  this.db.executor.push({
    this: this,
    fn: this.persistCachedDatabase,
    arguments: []
  });
};
/**
 * Set automatic compaction every interval ms
 * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds
 */


Persistence.prototype.setAutocompactionInterval = function (interval) {
  var self = this,
      minInterval = 5000,
      realInterval = Math.max(interval || 0, minInterval);
  this.stopAutocompaction();
  this.autocompactionIntervalId = setInterval(function () {
    self.compactDatafile();
  }, realInterval);
};
/**
 * Stop autocompaction (do nothing if autocompaction was not running)
 */


Persistence.prototype.stopAutocompaction = function () {
  if (this.autocompactionIntervalId) {
    clearInterval(this.autocompactionIntervalId);
  }
};
/**
 * Persist new state for the given newDocs (can be insertion, update or removal)
 * Use an append-only format
 * @param {Array} newDocs Can be empty if no doc was updated/removed
 * @param {Function} cb Optional, signature: err
 */


Persistence.prototype.persistNewState = function (newDocs, cb) {
  var self = this,
      toPersist = '',
      callback = cb || function () {}; // In-memory only datastore


  if (self.inMemoryOnly) {
    return callback(null);
  }

  newDocs.forEach(function (doc) {
    toPersist += self.afterSerialization(model.serialize(doc)) + '\n';
  });

  if (toPersist.length === 0) {
    return callback(null);
  }

  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {
    return callback(err);
  });
};
/**
 * From a database's raw data, return the corresponding
 * machine understandable collection
 */


Persistence.prototype.treatRawData = function (rawData) {
  var data = rawData.split('\n'),
      dataById = {},
      tdata = [],
      i,
      indexes = {},
      corruptItems = -1 // Last line of every data file is usually blank so not really corrupt
  ;

  for (i = 0; i < data.length; i += 1) {
    var doc;

    try {
      doc = model.deserialize(this.beforeDeserialization(data[i]));

      if (doc._id) {
        if (doc.$$deleted === true) {
          delete dataById[doc._id];
        } else {
          dataById[doc._id] = doc;
        }
      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {
        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
      } else if (typeof doc.$$indexRemoved === "string") {
        delete indexes[doc.$$indexRemoved];
      }
    } catch (e) {
      corruptItems += 1;
    }
  } // A bit lenient on corruption


  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {
    throw new Error("More than " + Math.floor(100 * this.corruptAlertThreshold) + "% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss");
  }

  Object.keys(dataById).forEach(function (k) {
    tdata.push(dataById[k]);
  });
  return {
    data: tdata,
    indexes: indexes
  };
};
/**
 * Load the database
 * 1) Create all indexes
 * 2) Insert all data
 * 3) Compact the database
 * This means pulling data out of the data file or creating it if it doesn't exist
 * Also, all data is persisted right away, which has the effect of compacting the database file
 * This operation is very quick at startup for a big collection (60ms for ~10k docs)
 * @param {Function} cb Optional callback, signature: err
 */


Persistence.prototype.loadDatabase = function (cb) {
  var callback = cb || function () {},
      self = this;

  self.db.resetIndexes(); // In-memory only datastore

  if (self.inMemoryOnly) {
    return callback(null);
  }

  async.waterfall([function (cb) {
    Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
      storage.ensureDatafileIntegrity(self.filename, function (err) {
        storage.readFile(self.filename, 'utf8', function (err, rawData) {
          if (err) {
            return cb(err);
          }

          try {
            var treatedData = self.treatRawData(rawData);
          } catch (e) {
            return cb(e);
          } // Recreate all indexes in the datafile


          Object.keys(treatedData.indexes).forEach(function (key) {
            self.db.indexes[key] = new Index(treatedData.indexes[key]);
          }); // Fill cached database (i.e. all indexes) with data

          try {
            self.db.resetIndexes(treatedData.data);
          } catch (e) {
            self.db.resetIndexes(); // Rollback any index which didn't fail

            return cb(e);
          }

          self.db.persistence.persistCachedDatabase(cb);
        });
      });
    });
  }], function (err) {
    if (err) {
      return callback(err);
    }

    self.db.executor.processBuffer();
    return callback(null);
  });
}; // Interface


module.exports = Persistence;
},{"./storage":"node_modules/nedb/browser-version/browser-specific/lib/storage.js","path":"node_modules/path-browserify/index.js","./model":"node_modules/nedb/lib/model.js","async":"node_modules/async/lib/async.js","./customUtils":"node_modules/nedb/browser-version/browser-specific/lib/customUtils.js","./indexes":"node_modules/nedb/lib/indexes.js","process":"node_modules/process/browser.js"}],"node_modules/nedb/lib/datastore.js":[function(require,module,exports) {
var customUtils = require('./customUtils')
  , model = require('./model')
  , async = require('async')
  , Executor = require('./executor')
  , Index = require('./indexes')
  , util = require('util')
  , _ = require('underscore')
  , Persistence = require('./persistence')
  , Cursor = require('./cursor')
  ;


/**
 * Create a new collection
 * @param {String} options.filename Optional, datastore will be in-memory only if not provided
 * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)
 * @param {Boolean} options.inMemoryOnly Optional, defaults to false
 * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where
 *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)
 * @param {Boolean} options.autoload Optional, defaults to false
 * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown
 * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks
 * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt
 * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting
 *
 * Event Emitter - Events
 * * compaction.done - Fired whenever a compaction operation was finished
 */
function Datastore (options) {
  var filename;

  // Retrocompatibility with v0.6 and before
  if (typeof options === 'string') {
    filename = options;
    this.inMemoryOnly = false;   // Default
  } else {
    options = options || {};
    filename = options.filename;
    this.inMemoryOnly = options.inMemoryOnly || false;
    this.autoload = options.autoload || false;
    this.timestampData = options.timestampData || false;
  }

  // Determine whether in memory or persistent
  if (!filename || typeof filename !== 'string' || filename.length === 0) {
    this.filename = null;
    this.inMemoryOnly = true;
  } else {
    this.filename = filename;
  }

  // String comparison function
  this.compareStrings = options.compareStrings;

  // Persistence handling
  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName
                                      , afterSerialization: options.afterSerialization
                                      , beforeDeserialization: options.beforeDeserialization
                                      , corruptAlertThreshold: options.corruptAlertThreshold
                                      });

  // This new executor is ready if we don't use persistence
  // If we do, it will only be ready once loadDatabase is called
  this.executor = new Executor();
  if (this.inMemoryOnly) { this.executor.ready = true; }

  // Indexed by field name, dot notation can be used
  // _id is always indexed and since _ids are generated randomly the underlying
  // binary is always well-balanced
  this.indexes = {};
  this.indexes._id = new Index({ fieldName: '_id', unique: true });
  this.ttlIndexes = {};

  // Queue a load of the database right away and call the onload handler
  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception
  if (this.autoload) { this.loadDatabase(options.onload || function (err) {
    if (err) { throw err; }
  }); }
}

util.inherits(Datastore, require('events').EventEmitter);


/**
 * Load the database from the datafile, and trigger the execution of buffered commands if any
 */
Datastore.prototype.loadDatabase = function () {
  this.executor.push({ this: this.persistence, fn: this.persistence.loadDatabase, arguments: arguments }, true);
};


/**
 * Get an array of all the data in the database
 */
Datastore.prototype.getAllData = function () {
  return this.indexes._id.getAll();
};


/**
 * Reset all currently defined indexes
 */
Datastore.prototype.resetIndexes = function (newData) {
  var self = this;

  Object.keys(this.indexes).forEach(function (i) {
    self.indexes[i].reset(newData);
  });
};


/**
 * Ensure an index is kept for this field. Same parameters as lib/indexes
 * For now this function is synchronous, we need to test how much time it takes
 * We use an async API for consistency with the rest of the code
 * @param {String} options.fieldName
 * @param {Boolean} options.unique
 * @param {Boolean} options.sparse
 * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)
 * @param {Function} cb Optional callback, signature: err
 */
Datastore.prototype.ensureIndex = function (options, cb) {
  var err
    , callback = cb || function () {};

  options = options || {};

  if (!options.fieldName) {
    err = new Error("Cannot create an index without a fieldName");
    err.missingFieldName = true;
    return callback(err);
  }
  if (this.indexes[options.fieldName]) { return callback(null); }

  this.indexes[options.fieldName] = new Index(options);
  if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here

  try {
    this.indexes[options.fieldName].insert(this.getAllData());
  } catch (e) {
    delete this.indexes[options.fieldName];
    return callback(e);
  }

  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function
  this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {
    if (err) { return callback(err); }
    return callback(null);
  });
};


/**
 * Remove an index
 * @param {String} fieldName
 * @param {Function} cb Optional callback, signature: err
 */
Datastore.prototype.removeIndex = function (fieldName, cb) {
  var callback = cb || function () {};

  delete this.indexes[fieldName];

  this.persistence.persistNewState([{ $$indexRemoved: fieldName }], function (err) {
    if (err) { return callback(err); }
    return callback(null);
  });
};


/**
 * Add one or several document(s) to all indexes
 */
Datastore.prototype.addToIndexes = function (doc) {
  var i, failingIndex, error
    , keys = Object.keys(this.indexes)
    ;

  for (i = 0; i < keys.length; i += 1) {
    try {
      this.indexes[keys[i]].insert(doc);
    } catch (e) {
      failingIndex = i;
      error = e;
      break;
    }
  }

  // If an error happened, we need to rollback the insert on all other indexes
  if (error) {
    for (i = 0; i < failingIndex; i += 1) {
      this.indexes[keys[i]].remove(doc);
    }

    throw error;
  }
};


/**
 * Remove one or several document(s) from all indexes
 */
Datastore.prototype.removeFromIndexes = function (doc) {
  var self = this;

  Object.keys(this.indexes).forEach(function (i) {
    self.indexes[i].remove(doc);
  });
};


/**
 * Update one or several documents in all indexes
 * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs
 * If one update violates a constraint, all changes are rolled back
 */
Datastore.prototype.updateIndexes = function (oldDoc, newDoc) {
  var i, failingIndex, error
    , keys = Object.keys(this.indexes)
    ;

  for (i = 0; i < keys.length; i += 1) {
    try {
      this.indexes[keys[i]].update(oldDoc, newDoc);
    } catch (e) {
      failingIndex = i;
      error = e;
      break;
    }
  }

  // If an error happened, we need to rollback the update on all other indexes
  if (error) {
    for (i = 0; i < failingIndex; i += 1) {
      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);
    }

    throw error;
  }
};


/**
 * Return the list of candidates for a given query
 * Crude implementation for now, we return the candidates given by the first usable index if any
 * We try the following query types, in this order: basic match, $in match, comparison match
 * One way to make it better would be to enable the use of multiple indexes if the first usable index
 * returns too much data. I may do it in the future.
 *
 * Returned candidates will be scanned to find and remove all expired documents
 *
 * @param {Query} query
 * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations
 * @param {Function} callback Signature err, docs
 */
Datastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {
  var indexNames = Object.keys(this.indexes)
    , self = this
    , usableQueryKeys;

  if (typeof dontExpireStaleDocs === 'function') {
    callback = dontExpireStaleDocs;
    dontExpireStaleDocs = false;
  }

  async.waterfall([
  // STEP 1: get candidates list by checking indexes from most to least frequent usecase
  function (cb) {
    // For a basic match
    usableQueryKeys = [];
    Object.keys(query).forEach(function (k) {
      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {
        usableQueryKeys.push(k);
      }
    });
    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
    if (usableQueryKeys.length > 0) {
      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));
    }

    // For a $in match
    usableQueryKeys = [];
    Object.keys(query).forEach(function (k) {
      if (query[k] && query[k].hasOwnProperty('$in')) {
        usableQueryKeys.push(k);
      }
    });
    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
    if (usableQueryKeys.length > 0) {
      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));
    }

    // For a comparison match
    usableQueryKeys = [];
    Object.keys(query).forEach(function (k) {
      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {
        usableQueryKeys.push(k);
      }
    });
    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
    if (usableQueryKeys.length > 0) {
      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));
    }

    // By default, return all the DB data
    return cb(null, self.getAllData());
  }
  // STEP 2: remove all expired documents
  , function (docs) {
    if (dontExpireStaleDocs) { return callback(null, docs); }

    var expiredDocsIds = [], validDocs = [], ttlIndexesFieldNames = Object.keys(self.ttlIndexes);

    docs.forEach(function (doc) {
      var valid = true;
      ttlIndexesFieldNames.forEach(function (i) {
        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {
          valid = false;
        }
      });
      if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }
    });

    async.eachSeries(expiredDocsIds, function (_id, cb) {
      self._remove({ _id: _id }, {}, function (err) {
        if (err) { return callback(err); }
        return cb();
      });
    }, function (err) {
      return callback(null, validDocs);
    });
  }]);
};


/**
 * Insert a new document
 * @param {Function} cb Optional callback, signature: err, insertedDoc
 *
 * @api private Use Datastore.insert which has the same signature
 */
Datastore.prototype._insert = function (newDoc, cb) {
  var callback = cb || function () {}
    , preparedDoc
    ;

  try {
    preparedDoc = this.prepareDocumentForInsertion(newDoc)
    this._insertInCache(preparedDoc);
  } catch (e) {
    return callback(e);
  }

  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {
    if (err) { return callback(err); }
    return callback(null, model.deepCopy(preparedDoc));
  });
};

/**
 * Create a new _id that's not already in use
 */
Datastore.prototype.createNewId = function () {
  var tentativeId = customUtils.uid(16);
  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)
  if (this.indexes._id.getMatching(tentativeId).length > 0) {
    tentativeId = this.createNewId();
  }
  return tentativeId;
};

/**
 * Prepare a document (or array of documents) to be inserted in a database
 * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input
 * @api private
 */
Datastore.prototype.prepareDocumentForInsertion = function (newDoc) {
  var preparedDoc, self = this;

  if (util.isArray(newDoc)) {
    preparedDoc = [];
    newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });
  } else {
    preparedDoc = model.deepCopy(newDoc);
    if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }
    var now = new Date();
    if (this.timestampData && preparedDoc.createdAt === undefined) { preparedDoc.createdAt = now; }
    if (this.timestampData && preparedDoc.updatedAt === undefined) { preparedDoc.updatedAt = now; }
    model.checkObject(preparedDoc);
  }

  return preparedDoc;
};

/**
 * If newDoc is an array of documents, this will insert all documents in the cache
 * @api private
 */
Datastore.prototype._insertInCache = function (preparedDoc) {
  if (util.isArray(preparedDoc)) {
    this._insertMultipleDocsInCache(preparedDoc);
  } else {
    this.addToIndexes(preparedDoc);
  }
};

/**
 * If one insertion fails (e.g. because of a unique constraint), roll back all previous
 * inserts and throws the error
 * @api private
 */
Datastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {
  var i, failingI, error;

  for (i = 0; i < preparedDocs.length; i += 1) {
    try {
      this.addToIndexes(preparedDocs[i]);
    } catch (e) {
      error = e;
      failingI = i;
      break;
    }
  }

  if (error) {
    for (i = 0; i < failingI; i += 1) {
      this.removeFromIndexes(preparedDocs[i]);
    }

    throw error;
  }
};

Datastore.prototype.insert = function () {
  this.executor.push({ this: this, fn: this._insert, arguments: arguments });
};


/**
 * Count all documents matching the query
 * @param {Object} query MongoDB-style query
 */
Datastore.prototype.count = function(query, callback) {
  var cursor = new Cursor(this, query, function(err, docs, callback) {
    if (err) { return callback(err); }
    return callback(null, docs.length);
  });

  if (typeof callback === 'function') {
    cursor.exec(callback);
  } else {
    return cursor;
  }
};


/**
 * Find all documents matching the query
 * If no callback is passed, we return the cursor so that user can limit, skip and finally exec
 * @param {Object} query MongoDB-style query
 * @param {Object} projection MongoDB-style projection
 */
Datastore.prototype.find = function (query, projection, callback) {
  switch (arguments.length) {
    case 1:
      projection = {};
      // callback is undefined, will return a cursor
      break;
    case 2:
      if (typeof projection === 'function') {
        callback = projection;
        projection = {};
      }   // If not assume projection is an object and callback undefined
      break;
  }

  var cursor = new Cursor(this, query, function(err, docs, callback) {
    var res = [], i;

    if (err) { return callback(err); }

    for (i = 0; i < docs.length; i += 1) {
      res.push(model.deepCopy(docs[i]));
    }
    return callback(null, res);
  });

  cursor.projection(projection);
  if (typeof callback === 'function') {
    cursor.exec(callback);
  } else {
    return cursor;
  }
};


/**
 * Find one document matching the query
 * @param {Object} query MongoDB-style query
 * @param {Object} projection MongoDB-style projection
 */
Datastore.prototype.findOne = function (query, projection, callback) {
  switch (arguments.length) {
    case 1:
      projection = {};
      // callback is undefined, will return a cursor
      break;
    case 2:
      if (typeof projection === 'function') {
        callback = projection;
        projection = {};
      }   // If not assume projection is an object and callback undefined
      break;
  }

  var cursor = new Cursor(this, query, function(err, docs, callback) {
    if (err) { return callback(err); }
    if (docs.length === 1) {
      return callback(null, model.deepCopy(docs[0]));
    } else {
      return callback(null, null);
    }
  });

  cursor.projection(projection).limit(1);
  if (typeof callback === 'function') {
    cursor.exec(callback);
  } else {
    return cursor;
  }
};


/**
 * Update all docs matching query
 * @param {Object} query
 * @param {Object} updateQuery
 * @param {Object} options Optional options
 *                 options.multi If true, can update multiple documents (defaults to false)
 *                 options.upsert If true, document is inserted if the query doesn't match anything
 *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)
 * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)
 *                      If update was an upsert, upsert flag is set to true
 *                      affectedDocuments can be one of the following:
 *                        * For an upsert, the upserted document
 *                        * For an update with returnUpdatedDocs option false, null
 *                        * For an update with returnUpdatedDocs true and multi false, the updated document
 *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents
 *
 * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,
 *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert
 *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of
 *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the
 *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on
 *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.
 *
 * @api private Use Datastore.update which has the same signature
 */
Datastore.prototype._update = function (query, updateQuery, options, cb) {
  var callback
    , self = this
    , numReplaced = 0
    , multi, upsert
    , i
    ;

  if (typeof options === 'function') { cb = options; options = {}; }
  callback = cb || function () {};
  multi = options.multi !== undefined ? options.multi : false;
  upsert = options.upsert !== undefined ? options.upsert : false;

  async.waterfall([
  function (cb) {   // If upsert option is set, check whether we need to insert the doc
    if (!upsert) { return cb(); }

    // Need to use an internal function not tied to the executor to avoid deadlock
    var cursor = new Cursor(self, query);
    cursor.limit(1)._exec(function (err, docs) {
      if (err) { return callback(err); }
      if (docs.length === 1) {
        return cb();
      } else {
        var toBeInserted;

        try {
          model.checkObject(updateQuery);
          // updateQuery is a simple object with no modifier, use it as the document to insert
          toBeInserted = updateQuery;
        } catch (e) {
          // updateQuery contains modifiers, use the find query as the base,
          // strip it from all operators and update it according to updateQuery
          try {
            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);
          } catch (err) {
            return callback(err);
          }
        }

        return self._insert(toBeInserted, function (err, newDoc) {
          if (err) { return callback(err); }
          return callback(null, 1, newDoc, true);
        });
      }
    });
  }
  , function () {   // Perform the update
    var modifiedDoc , modifications = [], createdAt;

    self.getCandidates(query, function (err, candidates) {
      if (err) { return callback(err); }

      // Preparing update (if an error is thrown here neither the datafile nor
      // the in-memory indexes are affected)
      try {
        for (i = 0; i < candidates.length; i += 1) {
          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {
            numReplaced += 1;
            if (self.timestampData) { createdAt = candidates[i].createdAt; }
            modifiedDoc = model.modify(candidates[i], updateQuery);
            if (self.timestampData) {
              modifiedDoc.createdAt = createdAt;
              modifiedDoc.updatedAt = new Date();
            }
            modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });
          }
        }
      } catch (err) {
        return callback(err);
      }

      // Change the docs in memory
      try {
        self.updateIndexes(modifications);
      } catch (err) {
        return callback(err);
      }

      // Update the datafile
      var updatedDocs = _.pluck(modifications, 'newDoc');
      self.persistence.persistNewState(updatedDocs, function (err) {
        if (err) { return callback(err); }
        if (!options.returnUpdatedDocs) {
          return callback(null, numReplaced);
        } else {
          var updatedDocsDC = [];
          updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });
          if (! multi) { updatedDocsDC = updatedDocsDC[0]; }
          return callback(null, numReplaced, updatedDocsDC);
        }
      });
    });
  }]);
};

Datastore.prototype.update = function () {
  this.executor.push({ this: this, fn: this._update, arguments: arguments });
};


/**
 * Remove all docs matching the query
 * For now very naive implementation (similar to update)
 * @param {Object} query
 * @param {Object} options Optional options
 *                 options.multi If true, can update multiple documents (defaults to false)
 * @param {Function} cb Optional callback, signature: err, numRemoved
 *
 * @api private Use Datastore.remove which has the same signature
 */
Datastore.prototype._remove = function (query, options, cb) {
  var callback
    , self = this, numRemoved = 0, removedDocs = [], multi
    ;

  if (typeof options === 'function') { cb = options; options = {}; }
  callback = cb || function () {};
  multi = options.multi !== undefined ? options.multi : false;

  this.getCandidates(query, true, function (err, candidates) {
    if (err) { return callback(err); }

    try {
      candidates.forEach(function (d) {
        if (model.match(d, query) && (multi || numRemoved === 0)) {
          numRemoved += 1;
          removedDocs.push({ $$deleted: true, _id: d._id });
          self.removeFromIndexes(d);
        }
      });
    } catch (err) { return callback(err); }

    self.persistence.persistNewState(removedDocs, function (err) {
      if (err) { return callback(err); }
      return callback(null, numRemoved);
    });
  });
};

Datastore.prototype.remove = function () {
  this.executor.push({ this: this, fn: this._remove, arguments: arguments });
};



module.exports = Datastore;

},{"./customUtils":"node_modules/nedb/browser-version/browser-specific/lib/customUtils.js","./model":"node_modules/nedb/lib/model.js","async":"node_modules/async/lib/async.js","./executor":"node_modules/nedb/lib/executor.js","./indexes":"node_modules/nedb/lib/indexes.js","util":"node_modules/util/util.js","underscore":"node_modules/underscore/underscore.js","./persistence":"node_modules/nedb/lib/persistence.js","./cursor":"node_modules/nedb/lib/cursor.js","events":"node_modules/events/events.js"}],"node_modules/nedb/index.js":[function(require,module,exports) {
var Datastore = require('./lib/datastore');

module.exports = Datastore;

},{"./lib/datastore":"node_modules/nedb/lib/datastore.js"}],"node_modules/nedb-promises/src/Datastore.js":[function(require,module,exports) {
const
	Cursor = require('./Cursor'),
	EventEmitter = require('events'),
	OriginalDatastore = require('nedb')

/**
 * @summary
 * As of v2.0.0 the Datastore class extends node's built 
 * in EventEmitter class and implements each method as an event
 * plus additional error events.
 *
 * All event callbacks will be passed the same type of values,
 * the first being the datastore, then the operation result (if there is any)
 * and then the arguments of the called method. (Check out the first example!)
 *
 * All events have a matching error event that goes by the name of `${method}Error`,
 * for example `findError` or `loadError`. The callbacks of these events will receive
 * the same parameters as the normal event handlers except that instead of the 
 * operation result there will be an operation error. (Check out the second example!)
 *
 * A generic `__error__` event is also available. This event will be emitted at any of
 * the above error events. The callbacks of this event will receive the same parameters
 * as the specific error event handlers except that there will be one more parameter 
 * passed between the datastore and the error object, that being the name of the method
 * that failed. (Check out the third example!)
 *
 * @example
 * let datastore = Datastore.create()
 * datastore.on('update', (datastore, result, query, update, options) => {
 * })
 * datastore.on('load', (datastore) => {
 *     // this event doesn't have a result
 * })
 * datastore.on('ensureIndex', (datastore, options) => {
 *     // this event doesn't have a result
 *     // but it has the options argument which will be passed to the
 *     // event handlers
 * })
 *
 * @example
 * let datastore = Datastore.create()
 * datastore.on('updateError', (datastore, error, query, update, options) => {
 * })
 * datastore.on('loadError', (datastore, error) => {
 * })
 * datastore.on('ensureIndexError', (datastore, error, options) => {
 * })
 *
 * @example
 * let datastore = Datastore.create()
 * datastore.on('__error__', (datastore, event, error, ...args) => {
 *     // for example
 *     // datastore, 'find', error, [{ foo: 'bar' }, {}]
 * })
 * 
 * @class
 */
class Datastore extends EventEmitter {
	/**
	 * Datastore constructor...
	 *
	 * You should use `Datastore.create(...)` instead
	 * of `new Datastore(...)`. With that you can access
	 * the original datastore's properties such as `datastore.persistance`.
	 *
	 * Create a Datastore instance.
	 * 
	 * Note that the datastore will be created
	 * relative to `process.cwd()`
	 * (unless an absolute path was passed).
	 * 
	 * It's basically the same as the original:
	 * https://github.com/louischatriot/nedb#creatingloading-a-database
	 * 
	 * @param  {Object} [options]
	 * @return {static}
	 */
	constructor(options) {
		super()

		Object.defineProperties(this, {
			__loaded: {
				enumerable: false,
				writable: true,
				value: null
			},

			__original: {
				configurable: true,
				enumerable: false,
				writable: false,
				value: new OriginalDatastore(options)
			}
		})
	}

	/**
	 * Load the datastore.
	 * @return {Promise.<undefined>}
	 */
	load() {
		if ( ! (this.__loaded instanceof Promise)) {
			this.__loaded = new Promise((resolve, reject) => {
				this.__original.loadDatabase((error) => {
					if (error) {
						this.emit('loadError', this, error)
						this.emit('__error__', this, 'load', error)
						reject(error)
					} else {
						this.emit('load', this)
						resolve()
					}
				})
			})
		}

		return this.__loaded
	}

	/**
	 * Find documents that match a query.
	 *
	 * It's basically the same as the original:
	 * https://github.com/louischatriot/nedb#finding-documents
	 *
	 * There are differences minor in how the cursor works though.
	 *
	 * @example
	 * datastore.find({ ... }).sort({ ... }).exec().then(...)
	 *
	 * @example
	 * datastore.find({ ... }).sort({ ... }).then(...)
	 *
	 * @example
	 * // in an async function
	 * await datastore.find({ ... }).sort({ ... })
	 * 
	 * @param  {Object} [query]
	 * @param  {Object} [projection]
	 * @return {Cursor}
	 */
	find(query = {}, projection) {
		if (typeof projection === 'function') {
			projection = {}
		}

		return new Cursor(
			this.__original.find(query, projection),
			this.load(),
			(error, result) => {
				if (error) {
					this.emit('findError', this, error, query, projection)
					this.emit('__error__', this, 'find', error, query, projection)
				} else {
					this.emit('find', this, result, query, projection)
				}
			}
		)
	}

	/**
	 * Find a document that matches a query.
	 *
	 * It's basically the same as the original:
	 * https://github.com/louischatriot/nedb#finding-documents
	 *
	 * @example
	 * datastore.findOne({ ... }).then(...)
	 *
	 * @example
	 * // in an async function
	 * await datastore.findOne({ ... }).sort({ ... })
	 * 
	 * @param  {Object} [query]
	 * @param  {Object} [projection]
	 * @return {Cursor}
	 */
	findOne(query = {}, projection) {
		if (typeof projection === 'function') {
			projection = {}
		}

		return new Cursor(
			this.__original.findOne(query, projection),
			this.load(),
			(error, result) => {
				if (error) {
					this.emit('findOneError', this, error, query, projection)
					this.emit('__error__', this, 'findOne', error, query, projection)
				} else {
					this.emit('findOne', this, result, query, projection)
				}
			}
		)
	}

	/**
	 * Insert a document or documents.
	 *
	 * It's basically the same as the original:
	 * https://github.com/louischatriot/nedb#inserting-documents
	 * 
	 * @param  {Object|Object[]} docs
	 * @return {Promise.<Object|Object[]>}
	 */
	insert(docs) {
		return this.load().then(() => {
			return new Promise((resolve, reject) => {
				this.__original.insert(docs, (error, result) => {
					if (error) {
						this.emit('insertError', this, error, docs)
						this.emit('__error__', this, 'insert', error, docs)
						reject(error)
					} else {
						this.emit('insert', this, result, docs)
						resolve(result)
					}
				})
			})
		})
	}

	/**
	 * Update documents that match a query.
	 *
	 * It's basically the same as the original:
	 * https://github.com/louischatriot/nedb#updating-documents
	 *
	 * If you set `options.returnUpdatedDocs`,
	 * the returned promise will resolve with
	 * an object (if `options.multi` is `false`) or
	 * with an array of objects.
	 * 
	 * @param  {Object} query
	 * @param  {Object} update
	 * @param  {Object} [options]
	 * @return {Promise.<number|Object|Object[]>}
	 */
	update(query, update, options = {}) {
		return this.load().then(() => {
			return new Promise((resolve, reject) => {
				this.__original.update(
					query,
					update,
					options,
					(error, numAffected, affectedDocuments, upsert) => {
						if (error) {
							this.emit('updateError', this, error, query, update, options)
							this.emit('__error__', this, 'update', error, query, update, options)
							reject(error)
						} else {
							let result = options.returnUpdatedDocs
								? affectedDocuments
								: numAffected
							this.emit('update', this, result, query, update, options)
							resolve(result)
						}
					}
				)
			})
		})
	}

	/**
	 * Remove documents that match a query.
	 *
	 * It's basically the same as the original:
	 * https://github.com/louischatriot/nedb#removing-documents
	 * 
	 * @param  {Object} [query]
	 * @param  {Object} [options]
	 * @return {Promise.<number>}
	 */
	remove(query = {}, options = {}) {
		return this.load().then(() => {
			return new Promise((resolve, reject) => {
				this.__original.remove(
					query,
					options,
					(error, result) => {
						if (error) {
							this.emit('removeError', this, error, query, options)
							this.emit('__error__', this, 'remove', error, query, options)
							reject(error)
						} else {
							this.emit('remove', this, result, query, options)
							resolve(result)
						}
					}
				)
			})
		})
	}

	/**
	 * Count documents that match a query.
	 *
	 * It's basically the same as the original:
	 * https://github.com/louischatriot/nedb#counting-documents
	 *
	 * @example
	 * datastore.count({ ... }).limit(...).then(...)
	 *
	 * @example
	 * // in an async function
	 * await datastore.count({ ... })
	 * // or
	 * await datastore.count({ ... }).sort(...).limit(...)
	 * 
	 * @param  {Object} [query]
	 * @return {Cursor}
	 */
	count(query = {}) {
		return new Cursor(
			this.__original.count(query),
			this.load(),
			(error, result) => {
				if (error) {
					this.emit('countError', this, error, query)
					this.emit('__error__', this, 'count', error, query)
				} else {
					this.emit('count', this, result, query)
				}
			}
		)
	}

	/**
	 * https://github.com/louischatriot/nedb#indexing
	 * 
	 * @param  {Object} options
	 * @return {Promise.<undefined>}
	 */
	ensureIndex(options) {
		return new Promise((resolve, reject) => {
			this.__original.ensureIndex(options, (error) => {
				if (error) {
					this.emit('ensureIndexError', this, error, options)
					this.emit('__error__', this, 'ensureIndex', error, options)
					reject(error)
				} else {
					this.emit('ensureIndex', this, options)
					resolve()
				}
			})
		})
	}

	/**
	 * https://github.com/louischatriot/nedb#indexing
	 * 
	 * @param  {string} field
	 * @return {Promise.<undefined>}
	 */
	removeIndex(field) {
		return new Promise((resolve, reject) => {
			this.__original.removeIndex(field, (error) => {
				if (error) {
					this.emit('removeIndexError', this, error, field)
					this.emit('__error__', this, 'removeIndex', error, field)
					reject(error)
				} else {
					this.emit('removeIndex', this, field)
					resolve()
				}
			})
		})
	}

	/**
	 * Create a database instance.
	 *
	 * Use this over `new Datastore(...)` to access
	 * original nedb datastore properties, such as
	 * `datastore.persistance`.
	 *
	 * Note that the datastore will be created
	 * relative to `process.cwd()`
	 * (unless an absolute path was passed).
	 *
	 * For more information visit:
	 * https://github.com/louischatriot/nedb#creatingloading-a-database
	 * 
	 * @param  {string|Object} options
	 * @return {Proxy.<static>}
	 */
	static create(options) {
		return new Proxy(new this(options), {
			get(target, key) {
                return target[key]
                    ? target[key]
                    : target.__original[key]
			},

			set(target, key, value) {
                return target.__original.hasOwnProperty(key)
                    ? (target.__original[key] = value)
                    : (target[key] = value)
			}
		})
	}
}

module.exports = Datastore

},{"./Cursor":"node_modules/nedb-promises/src/Cursor.js","events":"node_modules/events/events.js","nedb":"node_modules/nedb/index.js"}],"node_modules/nedb-promises/index.js":[function(require,module,exports) {
module.exports = require('./src/Datastore')

},{"./src/Datastore":"node_modules/nedb-promises/src/Datastore.js"}],"node_modules/prelude-ts/dist/src/Value.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var util = require("util");
/**
 * @hidden
 */
// @ts-ignore -- see https://github.com/DefinitelyTyped/DefinitelyTyped/issues/30241
exports.inspect = util.inspect.custom;
//# sourceMappingURL=Value.js.map
},{"util":"node_modules/util/util.js"}],"node_modules/prelude-ts/dist/src/Comparison.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var Option_1 = require("./Option");
/**
 * Type guard for HasEquals: find out for a type with
 * semantic equality, whether you should call .equals
 * or ===
 */
function hasEquals(v) {
    // there is a reason why we check only for equals, not for hashCode.
    // we want to decide which codepath to take: === or equals/hashcode.
    // if there is a equals function then we don't want ===, regardless of
    // whether there is a hashCode method or not. If there is a equals
    // and not hashCode, we want to go on the equals/hashCode codepath,
    // which will blow a little later at runtime if the hashCode is missing.
    return (v.equals !== undefined);
}
exports.hasEquals = hasEquals;
/**
 * Helper function for your objects so you can compute
 * a hashcode. You can pass to this function all the fields
 * of your object that should be taken into account for the
 * hash, and the function will return a reasonable hash code.
 *
 * @param fields the fields of your object to take
 *        into account for the hashcode
 */
function fieldsHashCode() {
    var fields = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fields[_i] = arguments[_i];
    }
    // https://stackoverflow.com/a/113600/516188
    // https://stackoverflow.com/a/18066516/516188
    var result = 1;
    for (var _a = 0, fields_1 = fields; _a < fields_1.length; _a++) {
        var value = fields_1[_a];
        result = 37 * result + getHashCode(value);
    }
    return result;
}
exports.fieldsHashCode = fieldsHashCode;
/**
 * Helper function to compute a reasonable hashcode for strings.
 */
function stringHashCode(str) {
    // https://stackoverflow.com/a/7616484/516188
    var hash = 0, i, chr;
    if (str.length === 0)
        return hash;
    for (i = 0; i < str.length; i++) {
        chr = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}
exports.stringHashCode = stringHashCode;
/**
 * Equality function which tries semantic equality (using .equals())
 * if possible, degrades to === if not available, and is also null-safe.
 */
function areEqual(obj, obj2) {
    if (obj === null != obj2 === null) {
        return false;
    }
    if (obj === null || obj2 === null) {
        return true;
    }
    if (hasEquals(obj)) {
        return obj.equals(obj2);
    }
    return obj === obj2;
}
exports.areEqual = areEqual;
/**
 * Hashing function which tries to call hashCode()
 * and uses the object itself for numbers, then degrades
 * for stringHashCode of the string representation if
 * not available.
 */
function getHashCode(obj) {
    if (!obj) {
        return 0;
    }
    if (hasEquals(obj)) {
        return obj.hashCode();
    }
    if (typeof obj === 'number') {
        // this is the hashcode implementation for numbers from immutablejs
        if (obj !== obj || obj === Infinity) {
            return 0;
        }
        var h = obj | 0;
        if (h !== obj) {
            h ^= obj * 0xffffffff;
        }
        while (obj > 0xffffffff) {
            obj /= 0xffffffff;
            h ^= obj;
        }
        return smi(h);
    }
    var val = obj + "";
    return val.length > STRING_HASH_CACHE_MIN_STRLEN ?
        cachedHashString(val) :
        stringHashCode(val);
}
exports.getHashCode = getHashCode;
function cachedHashString(string) {
    var hashed = stringHashCache[string];
    if (hashed === undefined) {
        hashed = stringHashCode(string);
        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
            STRING_HASH_CACHE_SIZE = 0;
            stringHashCache = {};
        }
        STRING_HASH_CACHE_SIZE++;
        stringHashCache[string] = hashed;
    }
    return hashed;
}
// v8 has an optimization for storing 31-bit signed numbers.
// Values which have either 00 or 11 as the high order bits qualify.
// This function drops the highest order bit in a signed number, maintaining
// the sign bit. (taken from immutablejs)
function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
/**
 * @hidden
 */
function hasTrueEquality(val) {
    if (!val) {
        return Option_1.Option.none();
    }
    if (val.equals) {
        return Option_1.Option.of(true);
    }
    switch (val.constructor) {
        case String:
        case Number:
        case Boolean:
            return Option_1.Option.of(true);
    }
    return Option_1.Option.of(false);
}
exports.hasTrueEquality = hasTrueEquality;
;
/**
 * Typescript doesn't infer typeguards for lambdas; it only sees
 * predicates. This type allows you to cast a predicate to a type
 * guard in a handy manner.
 *
 * It comes in handy for discriminated unions with a 'kind' discriminator,
 * for instance:
 *
 * `.filter(typeGuard(p => p.kind === "in_board", {} as InBoard))`
 *
 * Normally you'd have to give both type parameters, but you can use
 * the type witness parameter as shown in that example to skip
 * the first type parameter.
 *
 * Also see [[typeGuard]], [[instanceOf]] and [[typeOf]].
 */
function typeGuard(predicate, typeWitness) {
    return predicate;
}
exports.typeGuard = typeGuard;
/**
 * Curried function returning a type guard telling us if a value
 * is of a specific instance.
 * Can be used when filtering to filter for the type and at the
 * same time change the type of the generics on the container.
 *
 *     Vector.of<any>("bad", new Date('04 Dec 1995 00:12:00 GMT')).filter(instanceOf(Date))
 *     => Vector.of<Date>(new Date('04 Dec 1995 00:12:00 GMT'))
 *
 *     Option.of<any>("test").filter(instanceOf(Date))
 *     => Option.none<Date>()
 *
 *     Option.of<any>(new Date('04 Dec 1995 00:12:00 GMT')).filter(instanceOf(Date))
 *     => Option.of<Date>(new Date('04 Dec 1995 00:12:00 GMT'))
 *
 * Also see [[typeGuard]] and [[typeOf]].
 */
function instanceOf(ctor) {
    // https://github.com/Microsoft/TypeScript/issues/5101#issuecomment-145693151
    return (function (x) { return x instanceof ctor; });
}
exports.instanceOf = instanceOf;
function typeOf(typ) {
    return (function (x) { return typeof x === typ; });
}
exports.typeOf = typeOf;
//# sourceMappingURL=Comparison.js.map
},{"./Option":"node_modules/prelude-ts/dist/src/Option.js"}],"node_modules/prelude-ts/dist/src/Contract.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var Comparison_1 = require("./Comparison");
var SeqHelpers_1 = require("./SeqHelpers");
var preludeTsContractViolationCb = function (msg) { throw msg; };
/**
 * Some programmatic errors are only detectable at runtime
 * (for instance trying to setup a <code>HashSet</code> of <code>Option&lt;number[]&gt;</code>: you
 * can't reliably compare a <code>number[]</code> therefore you can't compare
 * an <code>Option&lt;number[]&gt;</code>.. but we can't detect this error at compile-time
 * in typescript). So when we detect them at runtime, prelude-ts throws
 * an exception by default.
 * This function allows you to change that default action
 * (for instance, you could display an error message in the console,
 * or log the error)
 *
 * You can reproduce the issue easily by running for instance:
 *
 *  HashSet.of(Option.of([1]))
 *  => throws
 */
function setContractViolationAction(action) {
    preludeTsContractViolationCb = action;
}
exports.setContractViolationAction = setContractViolationAction;
/**
 * @hidden
 */
function reportContractViolation(msg) {
    preludeTsContractViolationCb(msg);
}
exports.reportContractViolation = reportContractViolation;
/**
 * @hidden
 */
function contractTrueEquality(context) {
    var vals = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        vals[_i - 1] = arguments[_i];
    }
    for (var _a = 0, vals_1 = vals; _a < vals_1.length; _a++) {
        var val = vals_1[_a];
        if (val) {
            if (val.hasTrueEquality && (!val.hasTrueEquality())) {
                reportContractViolation(context + ": element doesn't support true equality: " + SeqHelpers_1.toStringHelper(val));
            }
            if (!Comparison_1.hasTrueEquality(val).getOrThrow()) {
                reportContractViolation(context + ": element doesn't support equality: " + SeqHelpers_1.toStringHelper(val));
            }
            // the first element i find is looking good, aborting
            return;
        }
    }
}
exports.contractTrueEquality = contractTrueEquality;
//# sourceMappingURL=Contract.js.map
},{"./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js"}],"node_modules/prelude-ts/dist/src/ISet.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
/**
 * @hidden
 */
function isSortOnSpec(sortSpec) {
    return sortSpec.sortOn !== undefined;
}
exports.isSortOnSpec = isSortOnSpec;
//# sourceMappingURL=ISet.js.map
},{}],"node_modules/prelude-ts/dist/src/LinkedList.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
/**
 * A sequence of values, organized in-memory as a strict linked list.
 * Each element has an head (value) and a tail (the rest of the list).
 *
 * The code is organized through the class [[EmptyLinkedList]] (empty list
 * or tail), the class [[ConsLinkedList]] (list value and pointer to next),
 * and the type alias [[LinkedList]] (empty or cons).
 *
 * Finally, "static" functions on Option are arranged in the class
 * [[LinkedListStatic]] and are accessed through the global constant LinkedList.
 *
 * Random access is expensive, appending is expensive, prepend or getting
 * the tail of the list is very cheap.
 * If you often need random access you should rather use [[Vector]].
 * Avoid appending at the end of the list in a loop, prefer prepending and
 * then reversing the list.
 *
 * Examples:
 *
 *     LinkedList.of(1,2,3);
 *     LinkedList.of(1,2,3).map(x => x*2).last();
 */
var Option_1 = require("./Option");
var Vector_1 = require("./Vector");
var Comparison_1 = require("./Comparison");
var Contract_1 = require("./Contract");
var Value_1 = require("./Value");
var HashMap_1 = require("./HashMap");
var HashSet_1 = require("./HashSet");
var SeqHelpers = require("./SeqHelpers");
/**
 * Holds the "static methods" for [[LinkedList]]
 */
var LinkedListStatic = /** @class */ (function () {
    function LinkedListStatic() {
    }
    /**
     * The empty stream
     */
    LinkedListStatic.prototype.empty = function () {
        return emptyLinkedList;
    };
    LinkedListStatic.prototype.of = function () {
        var elts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elts[_i] = arguments[_i];
        }
        return exports.LinkedList.ofIterable(elts);
    };
    /**
     * Build a stream from any iterable, which means also
     * an array for instance.
     * @param T the item type
     */
    LinkedListStatic.prototype.ofIterable = function (elts) {
        var iterator = elts[Symbol.iterator]();
        var curItem = iterator.next();
        var result = emptyLinkedList;
        while (!curItem.done) {
            result = new ConsLinkedList(curItem.value, result);
            curItem = iterator.next();
        }
        return result.reverse();
    };
    /**
     * Curried type guard for LinkedList.
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(LinkedList.of(1), LinkedList.empty<number>())
     *         .filter(LinkedList.isEmpty)
     *     => Vector.of(LinkedList.empty<number>())
     */
    LinkedListStatic.prototype.isEmpty = function (l) {
        return l.isEmpty();
    };
    /**
     * Curried type guard for LinkedList.
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Stream.of(1), Stream.empty<number>())
     *         .filter(Stream.isNotEmpty)
     *         .map(s => s.head().get()+1)
     *     => Vector.of(2)
     */
    LinkedListStatic.prototype.isNotEmpty = function (l) {
        return !l.isEmpty();
    };
    /**
     * Dual to the foldRight function. Build a collection from a seed.
     * Takes a starting element and a function.
     * It applies the function on the starting element; if the
     * function returns None, it stops building the list, if it
     * returns Some of a pair, it adds the first element to the result
     * and takes the second element as a seed to keep going.
     *
     *     LinkedList.unfoldRight(
     *          10, x=>Option.of(x)
     *              .filter(x => x!==0)
     *              .map<[number,number]>(x => [x,x-1]))
     *     => LinkedList.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
     */
    LinkedListStatic.prototype.unfoldRight = function (seed, fn) {
        var nextVal = fn(seed);
        var result = emptyLinkedList;
        while (!nextVal.isNone()) {
            result = new ConsLinkedList(nextVal.get()[0], result);
            nextVal = fn(nextVal.get()[1]);
        }
        return result.reverse();
    };
    /**
     * Combine any number of iterables you give in as
     * parameters to produce a new collection which combines all,
     * in tuples. For instance:
     *
     *     LinkedList.zip(LinkedList.of(1,2,3), ["a","b","c"], Vector.of(8,9,10))
     *     => LinkedList.of([1,"a",8], [2,"b",9], [3,"c",10])
     *
     * The result collection will have the length of the shorter
     * of the input iterables. Extra elements will be discarded.
     *
     * Also see the non-static version [[ConsLinkedList.zip]], which only combines two
     * collections.
     * @param A A is the type of the tuple that'll be generated
     *          (`[number,string,number]` for the code sample)
     */
    LinkedListStatic.prototype.zip = function () {
        var iterables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            iterables[_i] = arguments[_i];
        }
        var r = exports.LinkedList.empty();
        var iterators = iterables.map(function (i) { return i[Symbol.iterator](); });
        var items = iterators.map(function (i) { return i.next(); });
        while (!items.some(function (item) { return item.done; })) {
            r = r.prepend(items.map(function (item) { return item.value; }));
            items = iterators.map(function (i) { return i.next(); });
        }
        return r.reverse();
    };
    return LinkedListStatic;
}());
exports.LinkedListStatic = LinkedListStatic;
/**
 * The LinkedList constant allows to call the LinkedList "static" methods
 */
exports.LinkedList = new LinkedListStatic();
/**
 * EmptyLinkedList is the empty linked list; every non-empty
 * linked list also has a pointer to an empty linked list
 * after its last element.
 * "static methods" available through [[LinkedListStatic]]
 * @param T the item type
 */
var EmptyLinkedList = /** @class */ (function () {
    function EmptyLinkedList() {
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * @hidden
     */
    EmptyLinkedList.prototype.hasTrueEquality = function () {
        return SeqHelpers.seqHasTrueEquality(this);
    };
    /**
     * Implementation of the Iterator interface.
     */
    EmptyLinkedList.prototype[Symbol.iterator] = function () {
        return {
            next: function () {
                return {
                    done: true,
                    value: undefined
                };
            }
        };
    };
    /**
     * View this Some a as LinkedList. Useful to help typescript type
     * inference sometimes.
     */
    EmptyLinkedList.prototype.asLinkedList = function () {
        return this;
    };
    /**
     * Get the length of the collection.
     */
    EmptyLinkedList.prototype.length = function () {
        return 0;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    EmptyLinkedList.prototype.single = function () {
        return Option_1.Option.none();
    };
    /**
     * true if the collection is empty, false otherwise.
     */
    EmptyLinkedList.prototype.isEmpty = function () {
        return true;
    };
    /**
     * Get the first value of the collection, if any.
     * In this case the list is empty, so returns Option.none
     */
    EmptyLinkedList.prototype.head = function () {
        return Option_1.Option.none();
    };
    /**
     * Get all the elements in the collection but the first one.
     * If the collection is empty, return None.
     */
    EmptyLinkedList.prototype.tail = function () {
        return Option_1.Option.none();
    };
    /**
     * Get the last value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    EmptyLinkedList.prototype.last = function () {
        return Option_1.Option.none();
    };
    /**
     * Retrieve the element at index idx.
     * Returns an option because the collection may
     * contain less elements than the index.
     *
     * Careful this is going to have poor performance
     * on LinkedList, which is not a good data structure
     * for random access!
     */
    EmptyLinkedList.prototype.get = function (idx) {
        return Option_1.Option.none();
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     */
    EmptyLinkedList.prototype.find = function (predicate) {
        return Option_1.Option.none();
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    EmptyLinkedList.prototype.contains = function (v) {
        return false;
    };
    /**
     * Return a new stream keeping only the first n elements
     * from this stream.
     */
    EmptyLinkedList.prototype.take = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate.
     */
    EmptyLinkedList.prototype.takeWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate,
     * but starting from the end of the collection.
     *
     *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)
     *     => LinkedList.of(3,4)
     */
    EmptyLinkedList.prototype.takeRightWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with the first
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    EmptyLinkedList.prototype.drop = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the first elements
     * until one element fails the predicate. All elements
     * after that point are retained.
     */
    EmptyLinkedList.prototype.dropWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with the last
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    EmptyLinkedList.prototype.dropRight = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the last elements
     * until one element fails the predicate. All elements
     * before that point are retained.
     */
    EmptyLinkedList.prototype.dropRightWhile = function (predicate) {
        return this;
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    EmptyLinkedList.prototype.fold = function (zero, fn) {
        return zero;
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldLeft("!", (xs,x) => x+xs);
     *     => "cba!"
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    EmptyLinkedList.prototype.foldLeft = function (zero, fn) {
        return zero;
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldRight("!", (x,xs) => xs+x);
     *     => "!cba"
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    EmptyLinkedList.prototype.foldRight = function (zero, fn) {
        return zero;
    };
    /**
     * Combine this collection with the collection you give in
     * parameter to produce a new collection which combines both,
     * in pairs. For instance:
     *
     *     Vector.of(1,2,3).zip(["a","b","c"])
     *     => Vector.of([1,"a"], [2,"b"], [3,"c"])
     *
     * The result collection will have the length of the shorter
     * of both collections. Extra elements will be discarded.
     *
     * Also see [[LinkedListStatic.zip]] (static version which can more than two
     * iterables)
     */
    EmptyLinkedList.prototype.zip = function (other) {
        return emptyLinkedList;
    };
    /**
     * Combine this collection with the index of the elements
     * in it. Handy if you need the index when you map on
     * the collection for instance:
     *
     *     LinkedList.of("a","b").zipWithIndex().map(([v,idx]) => v+idx);
     *     => LinkedList.of("a0", "b1")
     */
    EmptyLinkedList.prototype.zipWithIndex = function () {
        return this;
    };
    /**
     * Reverse the collection. For instance:
     *
     *     LinkedList.of(1,2,3).reverse();
     *     => LinkedList.of(3,2,1)
     */
    EmptyLinkedList.prototype.reverse = function () {
        return this;
    };
    /**
     * Takes a predicate; returns a pair of collections.
     * The first one is the longest prefix of this collection
     * which satisfies the predicate, and the second collection
     * is the remainder of the collection.
     *
     *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)
     *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]
     */
    EmptyLinkedList.prototype.span = function (predicate) {
        return [this, this];
    };
    /**
     * Split the collection at a specific index.
     *
     *     LinkedList.of(1,2,3,4,5).splitAt(3)
     *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]
     */
    EmptyLinkedList.prototype.splitAt = function (index) {
        return [this, this];
    };
    EmptyLinkedList.prototype.partition = function (predicate) {
        return [exports.LinkedList.empty(), exports.LinkedList.empty()];
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[ConsLinkedList.arrangeBy]]
     */
    EmptyLinkedList.prototype.groupBy = function (classifier) {
        return HashMap_1.HashMap.empty();
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[ConsLinkedList.groupBy]]
     */
    EmptyLinkedList.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    /**
     * Randomly reorder the elements of the collection.
     */
    EmptyLinkedList.prototype.shuffle = function () {
        return this;
    };
    /**
     * Append an element at the end of this LinkedList.
     * Warning: appending in a loop on a linked list is going
     * to be very slow!
     */
    EmptyLinkedList.prototype.append = function (v) {
        return exports.LinkedList.of(v);
    };
    /*
     * Append multiple elements at the end of this LinkedList.
     */
    EmptyLinkedList.prototype.appendAll = function (elts) {
        return exports.LinkedList.ofIterable(elts);
    };
    /**
     * Remove multiple elements from a LinkedList
     *
     *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])
     *     => LinkedList.of(1,3,3,1)
     */
    EmptyLinkedList.prototype.removeAll = function (elts) {
        return this;
    };
    /**
     * Removes the first element matching the predicate
     * (use [[Seq.filter]] to remove all elements matching a predicate)
     */
    EmptyLinkedList.prototype.removeFirst = function (predicate) {
        return this;
    };
    /**
     * Prepend an element at the beginning of the collection.
     */
    EmptyLinkedList.prototype.prepend = function (elt) {
        return new ConsLinkedList(elt, this);
    };
    /**
     * Prepend multiple elements at the beginning of the collection.
     */
    EmptyLinkedList.prototype.prependAll = function (elt) {
        return exports.LinkedList.ofIterable(elt);
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     */
    EmptyLinkedList.prototype.map = function (mapper) {
        return emptyLinkedList;
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => LinkedList.of(3, 7)
     */
    EmptyLinkedList.prototype.mapOption = function (mapper) {
        return emptyLinkedList;
    };
    /**
     * Calls the function you give for each item in the collection,
     * your function returns a collection, all the collections are
     * concatenated.
     * This is the monadic bind.
     */
    EmptyLinkedList.prototype.flatMap = function (mapper) {
        return emptyLinkedList;
    };
    /**
     * Returns true if the predicate returns true for all the
     * elements in the collection.
     */
    EmptyLinkedList.prototype.allMatch = function (predicate) {
        return true;
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    EmptyLinkedList.prototype.anyMatch = function (predicate) {
        return false;
    };
    EmptyLinkedList.prototype.filter = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with elements
     * sorted according to the comparator you give.
     *
     *     const activityOrder = ["Writer", "Actor", "Director"];
     *     LinkedList.of({name:"George", activity: "Director"}, {name:"Robert", activity: "Actor"})
     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));
     *     => LinkedList.of({"name":"Robert","activity":"Actor"}, {"name":"George","activity":"Director"})
     *
     * also see [[ConsLinkedList.sortOn]]
     */
    EmptyLinkedList.prototype.sortBy = function (compare) {
        return this;
    };
    /**
     * Give a function associating a number or a string with
     * elements from the collection, and the elements
     * are sorted according to that value.
     *
     *     LinkedList.of({a:3,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a)
     *     => LinkedList.of({a:1,b:"test"},{a:2,b:"a"},{a:3,b:"b"})
     *
     * You can also sort by multiple criteria, and request 'descending'
     * sorting:
     *
     *     LinkedList.of({a:1,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})
     *     => LinkedList.of({a:1,b:"test"},{a:1,b:"b"},{a:2,b:"a"})
     *
     * also see [[ConsLinkedList.sortBy]]
     */
    EmptyLinkedList.prototype.sortOn = function () {
        var getKeys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            getKeys[_i] = arguments[_i];
        }
        return this;
    };
    /**
     * Remove duplicate items; elements are mapped to keys, those
     * get compared.
     *
     *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)
     *     => LinkedList.of(1,2,3)
     */
    EmptyLinkedList.prototype.distinctBy = function (keyExtractor) {
        return this;
    };
    /**
     * Call a function for element in the collection.
     */
    EmptyLinkedList.prototype.forEach = function (fn) {
        return this;
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    EmptyLinkedList.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsLinkedList.minOn]]
     */
    EmptyLinkedList.prototype.minBy = function (compare) {
        return SeqHelpers.minBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     *     LinkedList.of({name:"Joe", age:12}, {name:"Paula", age:6}).minOn(x=>x.age)
     *     => Option.of({name:"Paula", age:6})
     *
     * also see [[ConsLinkedList.minBy]]
     */
    EmptyLinkedList.prototype.minOn = function (getOrderable) {
        return SeqHelpers.minOn(this, getOrderable);
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsLinkedList.maxOn]]
     */
    EmptyLinkedList.prototype.maxBy = function (compare) {
        return SeqHelpers.maxBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     *     LinkedList.of({name:"Joe", age:12}, {name:"Paula", age:6}).maxOn(x=>x.age)
     *     => Option.of({name:"Joe", age:12})
     *
     * also see [[ConsLinkedList.maxBy]]
     */
    EmptyLinkedList.prototype.maxOn = function (getOrderable) {
        return SeqHelpers.maxOn(this, getOrderable);
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     LinkedList.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    EmptyLinkedList.prototype.sumOn = function (getNumber) {
        return SeqHelpers.sumOn(this, getNumber);
    };
    /**
     * Slides a window of a specific size over the sequence.
     * Returns a lazy stream so memory use is not prohibitive.
     *
     *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)
     *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))
     */
    EmptyLinkedList.prototype.sliding = function (count) {
        return SeqHelpers.sliding(this, count);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The last element of the result is the final cumulative result.
     *
     *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)
     *     => LinkedList.of(0,1,3,6)
     */
    EmptyLinkedList.prototype.scanLeft = function (init, fn) {
        return exports.LinkedList.of(init);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The first element of the result is the final cumulative result.
     *
     *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)
     *     => LinkedList.of(6,5,3,0)
     */
    EmptyLinkedList.prototype.scanRight = function (init, fn) {
        return exports.LinkedList.of(init);
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     LinkedList.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     */
    EmptyLinkedList.prototype.mkString = function (separator) {
        return "";
    };
    /**
     * Convert to array.
     * Don't do it on an infinite stream!
     */
    EmptyLinkedList.prototype.toArray = function () {
        return [];
    };
    /**
     * Convert to vector.
     * Don't do it on an infinite stream!
     */
    EmptyLinkedList.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    /**
     * Convert this collection to a map. You give a function which
     * for each element in the collection returns a pair. The
     * key of the pair will be used as a key in the map, the value,
     * as a value in the map. If several values get the same key,
     * entries will be lost.
     *
     *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])
     *     => HashMap.of(["1",1], ["2",2], ["3",3])
     */
    EmptyLinkedList.prototype.toMap = function (converter) {
        return HashMap_1.HashMap.empty();
    };
    /**
     * Convert this collection to a set. Since the elements of the
     * Seq may not support equality, you must pass a function returning
     * a value supporting equality.
     *
     *     LinkedList.of(1,2,3,3,4).toSet(x=>x)
     *     => HashSet.of(1,2,3,4)
     */
    EmptyLinkedList.prototype.toSet = function (converter) {
        return HashSet_1.HashSet.empty();
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    EmptyLinkedList.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    EmptyLinkedList.prototype.equals = function (other) {
        if (!other) {
            return false;
        }
        return other.isEmpty();
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    EmptyLinkedList.prototype.hashCode = function () {
        return 1;
    };
    EmptyLinkedList.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[ConsLinkedList.mkString]]
     */
    EmptyLinkedList.prototype.toString = function () {
        return "LinkedList()";
    };
    return EmptyLinkedList;
}());
exports.EmptyLinkedList = EmptyLinkedList;
/**
 * ConsLinkedList holds a value and a pointer to a next element,
 * which could be [[ConsLinkedList]] or [[EmptyLinkedList]].
 * A ConsLinkedList is basically a non-empty linked list. It will
 * contain at least one element.
 * "static methods" available through [[LinkedListStatic]]
 * @param T the item type
 */
var ConsLinkedList = /** @class */ (function () {
    /**
     * @hidden
     */
    function ConsLinkedList(value, _tail) {
        this.value = value;
        this._tail = _tail;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * @hidden
     */
    ConsLinkedList.prototype.hasTrueEquality = function () {
        return SeqHelpers.seqHasTrueEquality(this);
    };
    /**
     * View this Some a as LinkedList. Useful to help typescript type
     * inference sometimes.
     */
    ConsLinkedList.prototype.asLinkedList = function () {
        return this;
    };
    /**
     * Implementation of the Iterator interface.
     */
    ConsLinkedList.prototype[Symbol.iterator] = function () {
        var item = this;
        return {
            next: function () {
                if (item.isEmpty()) {
                    return { done: true, value: undefined };
                }
                var value = item.head().get();
                item = item.tail().get();
                return { done: false, value: value };
            }
        };
    };
    /**
     * Get the length of the collection.
     */
    ConsLinkedList.prototype.length = function () {
        return this.foldLeft(0, function (n, ignored) { return n + 1; });
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    ConsLinkedList.prototype.single = function () {
        return this._tail.isEmpty() ?
            Option_1.Option.of(this.value) :
            Option_1.Option.none();
    };
    /**
     * true if the collection is empty, false otherwise.
     */
    ConsLinkedList.prototype.isEmpty = function () {
        return false;
    };
    /**
     * Get the first value of the collection, if any.
     * In this case the list is not empty, so returns Option.some
     */
    ConsLinkedList.prototype.head = function () {
        return Option_1.Option.some(this.value);
    };
    /**
     * Get all the elements in the collection but the first one.
     * If the collection is empty, return None.
     */
    ConsLinkedList.prototype.tail = function () {
        return Option_1.Option.some(this._tail);
    };
    /**
     * Get the last value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    ConsLinkedList.prototype.last = function () {
        var curItem = this;
        while (true) {
            var item = curItem.value;
            curItem = curItem._tail;
            if (curItem.isEmpty()) {
                return Option_1.Option.some(item);
            }
        }
    };
    /**
     * Retrieve the element at index idx.
     * Returns an option because the collection may
     * contain less elements than the index.
     *
     * Careful this is going to have poor performance
     * on LinkedList, which is not a good data structure
     * for random access!
     */
    ConsLinkedList.prototype.get = function (idx) {
        var curItem = this;
        var i = 0;
        while (!curItem.isEmpty()) {
            if (i === idx) {
                var item = curItem.value;
                return Option_1.Option.of(item);
            }
            curItem = curItem._tail;
            ++i;
        }
        return Option_1.Option.none();
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     */
    ConsLinkedList.prototype.find = function (predicate) {
        var curItem = this;
        while (!curItem.isEmpty()) {
            var item = curItem.value;
            if (predicate(item)) {
                return Option_1.Option.of(item);
            }
            curItem = curItem._tail;
        }
        return Option_1.Option.none();
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    ConsLinkedList.prototype.contains = function (v) {
        return this.find(function (x) { return Comparison_1.areEqual(x, v); }).isSome();
    };
    /**
     * Return a new stream keeping only the first n elements
     * from this stream.
     */
    ConsLinkedList.prototype.take = function (n) {
        var result = emptyLinkedList;
        var curItem = this;
        var i = 0;
        while (i++ < n && (!curItem.isEmpty())) {
            result = new ConsLinkedList(curItem.value, result);
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate.
     */
    ConsLinkedList.prototype.takeWhile = function (predicate) {
        var result = emptyLinkedList;
        var curItem = this;
        while ((!curItem.isEmpty()) && predicate(curItem.value)) {
            result = new ConsLinkedList(curItem.value, result);
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate,
     * but starting from the end of the collection.
     *
     *     LinkedList.of(1,2,3,4).takeRightWhile(x => x > 2)
     *     => LinkedList.of(3,4)
     */
    ConsLinkedList.prototype.takeRightWhile = function (predicate) {
        return this.reverse().takeWhile(predicate).reverse();
    };
    /**
     * Returns a new collection with the first
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    ConsLinkedList.prototype.drop = function (n) {
        var i = n;
        var curItem = this;
        while (i-- > 0 && !curItem.isEmpty()) {
            curItem = curItem._tail;
        }
        return curItem;
    };
    /**
     * Returns a new collection, discarding the first elements
     * until one element fails the predicate. All elements
     * after that point are retained.
     */
    ConsLinkedList.prototype.dropWhile = function (predicate) {
        var curItem = this;
        while (!curItem.isEmpty() && predicate(curItem.value)) {
            curItem = curItem._tail;
        }
        return curItem;
    };
    /**
     * Returns a new collection with the last
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    ConsLinkedList.prototype.dropRight = function (n) {
        // going twice through the list...
        var length = this.length();
        return this.take(length - n);
    };
    /**
     * Returns a new collection, discarding the last elements
     * until one element fails the predicate. All elements
     * before that point are retained.
     */
    ConsLinkedList.prototype.dropRightWhile = function (predicate) {
        return this.reverse().dropWhile(predicate).reverse();
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     LinkedList.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    ConsLinkedList.prototype.fold = function (zero, fn) {
        return this.foldLeft(zero, fn);
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldLeft("!", (xs,x) => x+xs);
     *     => "cba!"
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    ConsLinkedList.prototype.foldLeft = function (zero, fn) {
        var r = zero;
        var curItem = this;
        while (!curItem.isEmpty()) {
            r = fn(r, curItem.value);
            curItem = curItem._tail;
        }
        return r;
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldRight("!", (x,xs) => xs+x);
     *     => "!cba"
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    ConsLinkedList.prototype.foldRight = function (zero, fn) {
        return this.reverse().foldLeft(zero, function (xs, x) { return fn(x, xs); });
    };
    /**
     * Combine this collection with the collection you give in
     * parameter to produce a new collection which combines both,
     * in pairs. For instance:
     *
     *     Vector.of(1,2,3).zip(["a","b","c"])
     *     => Vector.of([1,"a"], [2,"b"], [3,"c"])
     *
     * The result collection will have the length of the shorter
     * of both collections. Extra elements will be discarded.
     *
     * Also see [[LinkedListStatic.zip]] (static version which can more than two
     * iterables)
     */
    ConsLinkedList.prototype.zip = function (other) {
        var otherIterator = other[Symbol.iterator]();
        var otherCurItem = otherIterator.next();
        var curItem = this;
        var result = emptyLinkedList;
        while ((!curItem.isEmpty()) && (!otherCurItem.done)) {
            result = new ConsLinkedList([curItem.value, otherCurItem.value], result);
            curItem = curItem._tail;
            otherCurItem = otherIterator.next();
        }
        return result.reverse();
    };
    /**
     * Combine this collection with the index of the elements
     * in it. Handy if you need the index when you map on
     * the collection for instance:
     *
     *     LinkedList.of("a","b").zipWithIndex().map(([v,idx]) => v+idx);
     *     => LinkedList.of("a0", "b1")
     */
    ConsLinkedList.prototype.zipWithIndex = function () {
        return SeqHelpers.zipWithIndex(this);
    };
    /**
     * Reverse the collection. For instance:
     *
     *     LinkedList.of(1,2,3).reverse();
     *     => LinkedList.of(3,2,1)
     */
    ConsLinkedList.prototype.reverse = function () {
        return this.foldLeft(emptyLinkedList, function (xs, x) { return xs.prepend(x); });
    };
    /**
     * Takes a predicate; returns a pair of collections.
     * The first one is the longest prefix of this collection
     * which satisfies the predicate, and the second collection
     * is the remainder of the collection.
     *
     *    LinkedList.of(1,2,3,4,5,6).span(x => x <3)
     *    => [LinkedList.of(1,2), LinkedList.of(3,4,5,6)]
     */
    ConsLinkedList.prototype.span = function (predicate) {
        var first = emptyLinkedList;
        var curItem = this;
        while ((!curItem.isEmpty()) && predicate(curItem.value)) {
            first = new ConsLinkedList(curItem.value, first);
            curItem = curItem._tail;
        }
        return [first.reverse(), curItem];
    };
    /**
     * Split the collection at a specific index.
     *
     *     LinkedList.of(1,2,3,4,5).splitAt(3)
     *     => [LinkedList.of(1,2,3), LinkedList.of(4,5)]
     */
    ConsLinkedList.prototype.splitAt = function (index) {
        var first = emptyLinkedList;
        var curItem = this;
        var i = 0;
        while (i++ < index && (!curItem.isEmpty())) {
            first = new ConsLinkedList(curItem.value, first);
            curItem = curItem._tail;
        }
        return [first.reverse(), curItem];
    };
    ConsLinkedList.prototype.partition = function (predicate) {
        var fst = exports.LinkedList.empty();
        var snd = exports.LinkedList.empty();
        var curItem = this;
        while (!curItem.isEmpty()) {
            if (predicate(curItem.value)) {
                fst = new ConsLinkedList(curItem.value, fst);
            }
            else {
                snd = new ConsLinkedList(curItem.value, snd);
            }
            curItem = curItem._tail;
        }
        return [fst.reverse(), snd.reverse()];
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[ConsLinkedList.arrangeBy]]
     */
    ConsLinkedList.prototype.groupBy = function (classifier) {
        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {
            return acc.putWithMerge(classifier(v), exports.LinkedList.of(v), function (v1, v2) {
                return v1.prepend(v2.single().getOrThrow());
            });
        })
            .mapValues(function (l) { return l.reverse(); });
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[ConsLinkedList.groupBy]]
     */
    ConsLinkedList.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    /**
     * Randomly reorder the elements of the collection.
     */
    ConsLinkedList.prototype.shuffle = function () {
        return exports.LinkedList.ofIterable(SeqHelpers.shuffle(this.toArray()));
    };
    /**
     * Append an element at the end of this LinkedList.
     * Warning: appending in a loop on a linked list is going
     * to be very slow!
     */
    ConsLinkedList.prototype.append = function (v) {
        return new ConsLinkedList(this.value, this._tail.append(v));
    };
    /*
     * Append multiple elements at the end of this LinkedList.
     */
    ConsLinkedList.prototype.appendAll = function (elts) {
        return exports.LinkedList.ofIterable(elts).prependAll(this);
    };
    /**
     * Remove multiple elements from a LinkedList
     *
     *     LinkedList.of(1,2,3,4,3,2,1).removeAll([2,4])
     *     => LinkedList.of(1,3,3,1)
     */
    ConsLinkedList.prototype.removeAll = function (elts) {
        return SeqHelpers.removeAll(this, elts);
    };
    /**
     * Removes the first element matching the predicate
     * (use [[Seq.filter]] to remove all elements matching a predicate)
     */
    ConsLinkedList.prototype.removeFirst = function (predicate) {
        var curItem = this;
        var result = emptyLinkedList;
        var removed = false;
        while (!curItem.isEmpty()) {
            if (predicate(curItem.value) && !removed) {
                removed = true;
            }
            else {
                result = new ConsLinkedList(curItem.value, result);
            }
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Prepend an element at the beginning of the collection.
     */
    ConsLinkedList.prototype.prepend = function (elt) {
        return new ConsLinkedList(elt, this);
    };
    /**
     * Prepend multiple elements at the beginning of the collection.
     */
    ConsLinkedList.prototype.prependAll = function (elts) {
        var leftToAdd = exports.LinkedList.ofIterable(elts).reverse();
        var result = this;
        while (!leftToAdd.isEmpty()) {
            result = new ConsLinkedList(leftToAdd.value, result);
            leftToAdd = leftToAdd._tail;
        }
        return result;
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     */
    ConsLinkedList.prototype.map = function (mapper) {
        var curItem = this;
        var result = emptyLinkedList;
        while (!curItem.isEmpty()) {
            result = new ConsLinkedList(mapper(curItem.value), result);
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     LinkedList.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => LinkedList.of(3, 7)
     */
    ConsLinkedList.prototype.mapOption = function (mapper) {
        var curItem = this;
        var result = emptyLinkedList;
        while (!curItem.isEmpty()) {
            var mapped = mapper(curItem.value);
            if (mapped.isSome()) {
                result = new ConsLinkedList(mapped.get(), result);
            }
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Calls the function you give for each item in the collection,
     * your function returns a collection, all the collections are
     * concatenated.
     * This is the monadic bind.
     */
    ConsLinkedList.prototype.flatMap = function (mapper) {
        var curItem = this;
        var result = emptyLinkedList;
        while (!curItem.isEmpty()) {
            result = result.prependAll(mapper(curItem.value).reverse());
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Returns true if the predicate returns true for all the
     * elements in the collection.
     */
    ConsLinkedList.prototype.allMatch = function (predicate) {
        return this.find(function (x) { return !predicate(x); }).isNone();
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    ConsLinkedList.prototype.anyMatch = function (predicate) {
        return this.find(predicate).isSome();
    };
    ConsLinkedList.prototype.filter = function (predicate) {
        var curItem = this;
        var result = emptyLinkedList;
        while (!curItem.isEmpty()) {
            if (predicate(curItem.value)) {
                result = new ConsLinkedList(curItem.value, result);
            }
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Returns a new collection with elements
     * sorted according to the comparator you give.
     *
     *     const activityOrder = ["Writer", "Actor", "Director"];
     *     LinkedList.of({name:"George", activity: "Director"}, {name:"Robert", activity: "Actor"})
     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));
     *     => LinkedList.of({"name":"Robert","activity":"Actor"}, {"name":"George","activity":"Director"})
     *
     * also see [[ConsLinkedList.sortOn]]
     */
    ConsLinkedList.prototype.sortBy = function (compare) {
        return exports.LinkedList.ofIterable(this.toArray().sort(compare));
    };
    /**
     * Give a function associating a number or a string with
     * elements from the collection, and the elements
     * are sorted according to that value.
     *
     *     LinkedList.of({a:3,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a)
     *     => LinkedList.of({a:1,b:"test"},{a:2,b:"a"},{a:3,b:"b"})
     *
     * You can also sort by multiple criteria, and request 'descending'
     * sorting:
     *
     *     LinkedList.of({a:1,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})
     *     => LinkedList.of({a:1,b:"test"},{a:1,b:"b"},{a:2,b:"a"})
     *
     * also see [[ConsLinkedList.sortBy]]
     */
    ConsLinkedList.prototype.sortOn = function () {
        var getKeys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            getKeys[_i] = arguments[_i];
        }
        return SeqHelpers.sortOn(this, getKeys);
    };
    /**
     * Remove duplicate items; elements are mapped to keys, those
     * get compared.
     *
     *     LinkedList.of(1,1,2,3,2,3,1).distinctBy(x => x)
     *     => LinkedList.of(1,2,3)
     */
    ConsLinkedList.prototype.distinctBy = function (keyExtractor) {
        return SeqHelpers.distinctBy(this, keyExtractor);
    };
    /**
     * Call a function for element in the collection.
     */
    ConsLinkedList.prototype.forEach = function (fn) {
        var curItem = this;
        while (!curItem.isEmpty()) {
            fn(curItem.value);
            curItem = curItem._tail;
        }
        return this;
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    ConsLinkedList.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsLinkedList.minOn]]
     */
    ConsLinkedList.prototype.minBy = function (compare) {
        return SeqHelpers.minBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     *     LinkedList.of({name:"Joe", age:12}, {name:"Paula", age:6}).minOn(x=>x.age)
     *     => Option.of({name:"Paula", age:6})
     *
     * also see [[ConsLinkedList.minBy]]
     */
    ConsLinkedList.prototype.minOn = function (getOrderable) {
        return SeqHelpers.minOn(this, getOrderable);
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     *     LinkedList.of({name:"Joe", age:12}, {name:"Paula", age:6}).maxOn(x=>x.age)
     *     => Option.of({name:"Joe", age:12})
     *
     * also see [[ConsLinkedList.maxOn]]
     */
    ConsLinkedList.prototype.maxBy = function (compare) {
        return SeqHelpers.maxBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsLinkedList.maxBy]]
     */
    ConsLinkedList.prototype.maxOn = function (getOrderable) {
        return SeqHelpers.maxOn(this, getOrderable);
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     LinkedList.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    ConsLinkedList.prototype.sumOn = function (getNumber) {
        return SeqHelpers.sumOn(this, getNumber);
    };
    /**
     * Slides a window of a specific size over the sequence.
     * Returns a lazy stream so memory use is not prohibitive.
     *
     *     LinkedList.of(1,2,3,4,5,6,7,8).sliding(3)
     *     => Stream.of(LinkedList.of(1,2,3), LinkedList.of(4,5,6), LinkedList.of(7,8))
     */
    ConsLinkedList.prototype.sliding = function (count) {
        return SeqHelpers.sliding(this, count);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     *
     *     LinkedList.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)
     *     => LinkedList.of(0,1,3,6)
     */
    ConsLinkedList.prototype.scanLeft = function (init, fn) {
        var result = exports.LinkedList.of(init);
        var curItem = this;
        var soFar = init;
        while (!curItem.isEmpty()) {
            soFar = fn(soFar, curItem.value);
            result = new ConsLinkedList(soFar, result);
            curItem = curItem._tail;
        }
        return result.reverse();
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The first element of the result is the final cumulative result.
     *
     *     LinkedList.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)
     *     => LinkedList.of(6,5,3,0)
     */
    ConsLinkedList.prototype.scanRight = function (init, fn) {
        var result = exports.LinkedList.of(init);
        var curItem = this.reverse();
        var soFar = init;
        while (!curItem.isEmpty()) {
            soFar = fn(curItem.value, soFar);
            result = new ConsLinkedList(soFar, result);
            curItem = curItem._tail;
        }
        return result;
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     LinkedList.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     */
    ConsLinkedList.prototype.mkString = function (separator) {
        var r = "";
        var curItem = this;
        var isNotFirst = false;
        while (!curItem.isEmpty()) {
            if (isNotFirst) {
                r += separator;
            }
            r += SeqHelpers.toStringHelper(curItem.value, { quoteStrings: false });
            curItem = curItem._tail;
            isNotFirst = true;
        }
        return r;
    };
    /**
     * Convert to array.
     * Don't do it on an infinite stream!
     */
    ConsLinkedList.prototype.toArray = function () {
        var r = [];
        var curItem = this;
        while (!curItem.isEmpty()) {
            r.push(curItem.value);
            curItem = curItem._tail;
        }
        return r;
    };
    /**
     * Convert to vector.
     * Don't do it on an infinite stream!
     */
    ConsLinkedList.prototype.toVector = function () {
        return Vector_1.Vector.ofIterable(this.toArray());
    };
    /**
     * Convert this collection to a map. You give a function which
     * for each element in the collection returns a pair. The
     * key of the pair will be used as a key in the map, the value,
     * as a value in the map. If several values get the same key,
     * entries will be lost.
     *
     *     LinkedList.of(1,2,3).toMap(x=>[x.toString(), x])
     *     => HashMap.of(["1",1], ["2",2], ["3",3])
     */
    ConsLinkedList.prototype.toMap = function (converter) {
        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {
            var converted = converter(cur);
            return acc.put(converted[0], converted[1]);
        });
    };
    /**
     * Convert this collection to a set. Since the elements of the
     * Seq may not support equality, you must pass a function returning
     * a value supporting equality.
     *
     *     LinkedList.of(1,2,3,3,4).toSet(x=>x)
     *     => HashSet.of(1,2,3,4)
     */
    ConsLinkedList.prototype.toSet = function (converter) {
        return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {
            return acc.add(converter(cur));
        });
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    ConsLinkedList.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    ConsLinkedList.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (!other || !other.tail) {
            return false;
        }
        Contract_1.contractTrueEquality("LinkedList.equals", this, other);
        var myVal = this;
        var hisVal = other;
        while (true) {
            if (myVal.isEmpty() !== hisVal.isEmpty()) {
                return false;
            }
            if (myVal.isEmpty()) {
                // they are both empty, end of the stream
                return true;
            }
            var myHead = myVal.value;
            var hisHead = hisVal.value;
            if ((myHead === undefined) !== (hisHead === undefined)) {
                return false;
            }
            if (myHead === undefined || hisHead === undefined) {
                // they are both undefined, the || is for TS's flow analysis
                // so he realizes none of them is undefined after this.
                continue;
            }
            if (!Comparison_1.areEqual(myHead, hisHead)) {
                return false;
            }
            myVal = myVal._tail;
            hisVal = hisVal._tail;
        }
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    ConsLinkedList.prototype.hashCode = function () {
        var hash = 1;
        var curItem = this;
        while (!curItem.isEmpty()) {
            hash = 31 * hash + Comparison_1.getHashCode(curItem.value);
            curItem = curItem._tail;
        }
        return hash;
    };
    ConsLinkedList.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[ConsLinkedList.mkString]]
     */
    ConsLinkedList.prototype.toString = function () {
        var curItem = this;
        var result = "LinkedList(";
        while (!curItem.isEmpty()) {
            result += SeqHelpers.toStringHelper(curItem.value);
            var tail = curItem._tail;
            curItem = tail;
            if (!curItem.isEmpty()) {
                result += ", ";
            }
        }
        return result + ")";
    };
    return ConsLinkedList;
}());
exports.ConsLinkedList = ConsLinkedList;
var emptyLinkedList = new EmptyLinkedList();
//# sourceMappingURL=LinkedList.js.map
},{"./Option":"node_modules/prelude-ts/dist/src/Option.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./Contract":"node_modules/prelude-ts/dist/src/Contract.js","./Value":"node_modules/prelude-ts/dist/src/Value.js","./HashMap":"node_modules/prelude-ts/dist/src/HashMap.js","./HashSet":"node_modules/prelude-ts/dist/src/HashSet.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js"}],"node_modules/hamt_plus/hamt.js":[function(require,module,exports) {
var define;
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
    @fileOverview Hash Array Mapped Trie.

    Code based on: https://github.com/exclipy/pdata
*/
var hamt = {}; // export

/* Configuration
 ******************************************************************************/
var SIZE = 5;

var BUCKET_SIZE = Math.pow(2, SIZE);

var MASK = BUCKET_SIZE - 1;

var MAX_INDEX_NODE = BUCKET_SIZE / 2;

var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

/*
 ******************************************************************************/
var nothing = {};

var constant = function constant(x) {
    return function () {
        return x;
    };
};

/**
    Get 32 bit hash of string.

    Based on:
    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
*/
var hash = hamt.hash = function (str) {
    var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);
    if (type === 'number') return str;
    if (type !== 'string') str += '';

    var hash = 0;
    for (var i = 0, len = str.length; i < len; ++i) {
        var c = str.charCodeAt(i);
        hash = (hash << 5) - hash + c | 0;
    }
    return hash;
};

/* Bit Ops
 ******************************************************************************/
/**
    Hamming weight.

    Taken from: http://jsperf.com/hamming-weight
*/
var popcount = function popcount(x) {
    x -= x >> 1 & 0x55555555;
    x = (x & 0x33333333) + (x >> 2 & 0x33333333);
    x = x + (x >> 4) & 0x0f0f0f0f;
    x += x >> 8;
    x += x >> 16;
    return x & 0x7f;
};

var hashFragment = function hashFragment(shift, h) {
    return h >>> shift & MASK;
};

var toBitmap = function toBitmap(x) {
    return 1 << x;
};

var fromBitmap = function fromBitmap(bitmap, bit) {
    return popcount(bitmap & bit - 1);
};

/* Array Ops
 ******************************************************************************/
/**
    Set a value in an array.

    @param mutate Should the input array be mutated?
    @param at Index to change.
    @param v New value
    @param arr Array.
*/
var arrayUpdate = function arrayUpdate(mutate, at, v, arr) {
    var out = arr;
    if (!mutate) {
        var len = arr.length;
        out = new Array(len);
        for (var i = 0; i < len; ++i) {
            out[i] = arr[i];
        }
    }
    out[at] = v;
    return out;
};

/**
    Remove a value from an array.

    @param mutate Should the input array be mutated?
    @param at Index to remove.
    @param arr Array.
*/
var arraySpliceOut = function arraySpliceOut(mutate, at, arr) {
    var newLen = arr.length - 1;
    var i = 0;
    var g = 0;
    var out = arr;
    if (mutate) {
        i = g = at;
    } else {
        out = new Array(newLen);
        while (i < at) {
            out[g++] = arr[i++];
        }
    }
    ++i;
    while (i <= newLen) {
        out[g++] = arr[i++];
    }if (mutate) {
        out.length = newLen;
    }
    return out;
};

/**
    Insert a value into an array.

    @param mutate Should the input array be mutated?
    @param at Index to insert at.
    @param v Value to insert,
    @param arr Array.
*/
var arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {
    var len = arr.length;
    if (mutate) {
        var _i = len;
        while (_i >= at) {
            arr[_i--] = arr[_i];
        }arr[at] = v;
        return arr;
    }
    var i = 0,
        g = 0;
    var out = new Array(len + 1);
    while (i < at) {
        out[g++] = arr[i++];
    }out[at] = v;
    while (i < len) {
        out[++g] = arr[i++];
    }return out;
};

/* Node Structures
 ******************************************************************************/
var LEAF = 1;
var COLLISION = 2;
var INDEX = 3;
var ARRAY = 4;

/**
    Empty node.
*/
var empty = {
    __hamt_isEmpty: true
};

var isEmptyNode = function isEmptyNode(x) {
    return x === empty || x && x.__hamt_isEmpty;
};

/**
    Leaf holding a value.

    @member edit Edit of the node.
    @member hash Hash of key.
    @member key Key.
    @member value Value stored.
*/
var Leaf = function Leaf(edit, hash, key, value) {
    return {
        type: LEAF,
        edit: edit,
        hash: hash,
        key: key,
        value: value,
        _modify: Leaf__modify
    };
};

/**
    Leaf holding multiple values with the same hash but different keys.

    @member edit Edit of the node.
    @member hash Hash of key.
    @member children Array of collision children node.
*/
var Collision = function Collision(edit, hash, children) {
    return {
        type: COLLISION,
        edit: edit,
        hash: hash,
        children: children,
        _modify: Collision__modify
    };
};

/**
    Internal node with a sparse set of children.

    Uses a bitmap and array to pack children.

  @member edit Edit of the node.
    @member mask Bitmap that encode the positions of children in the array.
    @member children Array of child nodes.
*/
var IndexedNode = function IndexedNode(edit, mask, children) {
    return {
        type: INDEX,
        edit: edit,
        mask: mask,
        children: children,
        _modify: IndexedNode__modify
    };
};

/**
    Internal node with many children.

    @member edit Edit of the node.
    @member size Number of children.
    @member children Array of child nodes.
*/
var ArrayNode = function ArrayNode(edit, size, children) {
    return {
        type: ARRAY,
        edit: edit,
        size: size,
        children: children,
        _modify: ArrayNode__modify
    };
};

/**
    Is `node` a leaf node?
*/
var isLeaf = function isLeaf(node) {
    return node === empty || node.type === LEAF || node.type === COLLISION;
};

/* Internal node operations.
 ******************************************************************************/
/**
    Expand an indexed node into an array node.

  @param edit Current edit.
    @param frag Index of added child.
    @param child Added child.
    @param mask Index node mask before child added.
    @param subNodes Index node children before child added.
*/
var expand = function expand(edit, frag, child, bitmap, subNodes) {
    var arr = [];
    var bit = bitmap;
    var count = 0;
    for (var i = 0; bit; ++i) {
        if (bit & 1) arr[i] = subNodes[count++];
        bit >>>= 1;
    }
    arr[frag] = child;
    return ArrayNode(edit, count + 1, arr);
};

/**
    Collapse an array node into a indexed node.

  @param edit Current edit.
    @param count Number of elements in new array.
    @param removed Index of removed element.
    @param elements Array node children before remove.
*/
var pack = function pack(edit, count, removed, elements) {
    var children = new Array(count - 1);
    var g = 0;
    var bitmap = 0;
    for (var i = 0, len = elements.length; i < len; ++i) {
        if (i !== removed) {
            var elem = elements[i];
            if (elem && !isEmptyNode(elem)) {
                children[g++] = elem;
                bitmap |= 1 << i;
            }
        }
    }
    return IndexedNode(edit, bitmap, children);
};

/**
    Merge two leaf nodes.

    @param shift Current shift.
    @param h1 Node 1 hash.
    @param n1 Node 1.
    @param h2 Node 2 hash.
    @param n2 Node 2.
*/
var mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {
    if (h1 === h2) return Collision(edit, h1, [n2, n1]);

    var subH1 = hashFragment(shift, h1);
    var subH2 = hashFragment(shift, h2);
    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);
};

/**
    Update an entry in a collision list.

    @param mutate Should mutation be used?
    @param edit Current edit.
    @param keyEq Key compare function.
    @param hash Hash of collision.
    @param list Collision list.
    @param f Update function.
    @param k Key to update.
    @param size Size ref.
*/
var updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {
    var len = list.length;
    for (var i = 0; i < len; ++i) {
        var child = list[i];
        if (keyEq(k, child.key)) {
            var value = child.value;
            var _newValue = f(value);
            if (_newValue === value) return list;

            if (_newValue === nothing) {
                --size.value;
                return arraySpliceOut(mutate, i, list);
            }
            return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);
        }
    }

    var newValue = f();
    if (newValue === nothing) return list;
    ++size.value;
    return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);
};

var canEditNode = function canEditNode(edit, node) {
    return edit === node.edit;
};

/* Editing
 ******************************************************************************/
var Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {
    if (keyEq(k, this.key)) {
        var _v = f(this.value);
        if (_v === this.value) return this;else if (_v === nothing) {
            --size.value;
            return empty;
        }
        if (canEditNode(edit, this)) {
            this.value = _v;
            return this;
        }
        return Leaf(edit, h, k, _v);
    }
    var v = f();
    if (v === nothing) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));
};

var Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {
    if (h === this.hash) {
        var canEdit = canEditNode(edit, this);
        var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);
        if (list === this.children) return this;

        return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list
    }
    var v = f();
    if (v === nothing) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));
};

var IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {
    var mask = this.mask;
    var children = this.children;
    var frag = hashFragment(shift, h);
    var bit = toBitmap(frag);
    var indx = fromBitmap(mask, bit);
    var exists = mask & bit;
    var current = exists ? children[indx] : empty;
    var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);

    if (current === child) return this;

    var canEdit = canEditNode(edit, this);
    var bitmap = mask;
    var newChildren = void 0;
    if (exists && isEmptyNode(child)) {
        // remove
        bitmap &= ~bit;
        if (!bitmap) return empty;
        if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse

        newChildren = arraySpliceOut(canEdit, indx, children);
    } else if (!exists && !isEmptyNode(child)) {
        // add
        if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);

        bitmap |= bit;
        newChildren = arraySpliceIn(canEdit, indx, child, children);
    } else {
        // modify
        newChildren = arrayUpdate(canEdit, indx, child, children);
    }

    if (canEdit) {
        this.mask = bitmap;
        this.children = newChildren;
        return this;
    }
    return IndexedNode(edit, bitmap, newChildren);
};

var ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {
    var count = this.size;
    var children = this.children;
    var frag = hashFragment(shift, h);
    var child = children[frag];
    var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);

    if (child === newChild) return this;

    var canEdit = canEditNode(edit, this);
    var newChildren = void 0;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
        // add
        ++count;
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
        // remove
        --count;
        if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);
        newChildren = arrayUpdate(canEdit, frag, empty, children);
    } else {
        // modify
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }

    if (canEdit) {
        this.size = count;
        this.children = newChildren;
        return this;
    }
    return ArrayNode(edit, count, newChildren);
};

empty._modify = function (edit, keyEq, shift, f, h, k, size) {
    var v = f();
    if (v === nothing) return empty;
    ++size.value;
    return Leaf(edit, h, k, v);
};

/*
 ******************************************************************************/
function Map(editable, edit, config, root, size) {
    this._editable = editable;
    this._edit = edit;
    this._config = config;
    this._root = root;
    this._size = size;
};

Map.prototype.setTree = function (newRoot, newSize) {
    if (this._editable) {
        this._root = newRoot;
        this._size = newSize;
        return this;
    }
    return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);
};

/* Queries
 ******************************************************************************/
/**
    Lookup the value for `key` in `map` using a custom `hash`.

    Returns the value or `alt` if none.
*/
var tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {
    var node = map._root;
    var shift = 0;
    var keyEq = map._config.keyEq;
    while (true) {
        switch (node.type) {
            case LEAF:
                {
                    return keyEq(key, node.key) ? node.value : alt;
                }
            case COLLISION:
                {
                    if (hash === node.hash) {
                        var children = node.children;
                        for (var i = 0, len = children.length; i < len; ++i) {
                            var child = children[i];
                            if (keyEq(key, child.key)) return child.value;
                        }
                    }
                    return alt;
                }
            case INDEX:
                {
                    var frag = hashFragment(shift, hash);
                    var bit = toBitmap(frag);
                    if (node.mask & bit) {
                        node = node.children[fromBitmap(node.mask, bit)];
                        shift += SIZE;
                        break;
                    }
                    return alt;
                }
            case ARRAY:
                {
                    node = node.children[hashFragment(shift, hash)];
                    if (node) {
                        shift += SIZE;
                        break;
                    }
                    return alt;
                }
            default:
                return alt;
        }
    }
};

Map.prototype.tryGetHash = function (alt, hash, key) {
    return tryGetHash(alt, hash, key, this);
};

/**
    Lookup the value for `key` in `map` using internal hash function.

    @see `tryGetHash`
*/
var tryGet = hamt.tryGet = function (alt, key, map) {
    return tryGetHash(alt, map._config.hash(key), key, map);
};

Map.prototype.tryGet = function (alt, key) {
    return tryGet(alt, key, this);
};

/**
    Lookup the value for `key` in `map` using a custom `hash`.

    Returns the value or `undefined` if none.
*/
var getHash = hamt.getHash = function (hash, key, map) {
    return tryGetHash(undefined, hash, key, map);
};

Map.prototype.getHash = function (hash, key) {
    return getHash(hash, key, this);
};

/**
    Lookup the value for `key` in `map` using internal hash function.

    @see `get`
*/
var get = hamt.get = function (key, map) {
    return tryGetHash(undefined, map._config.hash(key), key, map);
};

Map.prototype.get = function (key, alt) {
    return tryGet(alt, key, this);
};

/**
    Does an entry exist for `key` in `map`? Uses custom `hash`.
*/
var hasHash = hamt.has = function (hash, key, map) {
    return tryGetHash(nothing, hash, key, map) !== nothing;
};

Map.prototype.hasHash = function (hash, key) {
    return hasHash(hash, key, this);
};

/**
    Does an entry exist for `key` in `map`? Uses internal hash function.
*/
var has = hamt.has = function (key, map) {
    return hasHash(map._config.hash(key), key, map);
};

Map.prototype.has = function (key) {
    return has(key, this);
};

var defKeyCompare = function defKeyCompare(x, y) {
    return x === y;
};

/**
    Create an empty map.

    @param config Configuration.
*/
hamt.make = function (config) {
    return new Map(0, 0, {
        keyEq: config && config.keyEq || defKeyCompare,
        hash: config && config.hash || hash
    }, empty, 0);
};

/**
    Empty map.
*/
hamt.empty = hamt.make();

/**
    Does `map` contain any elements?
*/
var isEmpty = hamt.isEmpty = function (map) {
    return map && !!isEmptyNode(map._root);
};

Map.prototype.isEmpty = function () {
    return isEmpty(this);
};

/* Updates
 ******************************************************************************/
/**
    Alter the value stored for `key` in `map` using function `f` using
    custom hash.

    `f` is invoked with the current value for `k` if it exists,
    or no arguments if no such value exists. `modify` will always either
    update or insert a value into the map.

    Returns a map with the modified value. Does not alter `map`.
*/
var modifyHash = hamt.modifyHash = function (f, hash, key, map) {
    var size = { value: map._size };
    var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);
    return map.setTree(newRoot, size.value);
};

Map.prototype.modifyHash = function (hash, key, f) {
    return modifyHash(f, hash, key, this);
};

/**
    Alter the value stored for `key` in `map` using function `f` using
    internal hash function.

    @see `modifyHash`
*/
var modify = hamt.modify = function (f, key, map) {
    return modifyHash(f, map._config.hash(key), key, map);
};

Map.prototype.modify = function (key, f) {
    return modify(f, key, this);
};

/**
    Store `value` for `key` in `map` using custom `hash`.

    Returns a map with the modified value. Does not alter `map`.
*/
var setHash = hamt.setHash = function (hash, key, value, map) {
    return modifyHash(constant(value), hash, key, map);
};

Map.prototype.setHash = function (hash, key, value) {
    return setHash(hash, key, value, this);
};

/**
    Store `value` for `key` in `map` using internal hash function.

    @see `setHash`
*/
var set = hamt.set = function (key, value, map) {
    return setHash(map._config.hash(key), key, value, map);
};

Map.prototype.set = function (key, value) {
    return set(key, value, this);
};

/**
    Remove the entry for `key` in `map`.

    Returns a map with the value removed. Does not alter `map`.
*/
var del = constant(nothing);
var removeHash = hamt.removeHash = function (hash, key, map) {
    return modifyHash(del, hash, key, map);
};

Map.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {
    return removeHash(hash, key, this);
};

/**
    Remove the entry for `key` in `map` using internal hash function.

    @see `removeHash`
*/
var remove = hamt.remove = function (key, map) {
    return removeHash(map._config.hash(key), key, map);
};

Map.prototype.remove = Map.prototype.delete = function (key) {
    return remove(key, this);
};

/* Mutation
 ******************************************************************************/
/**
    Mark `map` as mutable.
 */
var beginMutation = hamt.beginMutation = function (map) {
    return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);
};

Map.prototype.beginMutation = function () {
    return beginMutation(this);
};

/**
    Mark `map` as immutable.
 */
var endMutation = hamt.endMutation = function (map) {
    map._editable = map._editable && map._editable - 1;
    return map;
};

Map.prototype.endMutation = function () {
    return endMutation(this);
};

/**
    Mutate `map` within the context of `f`.
    @param f
    @param map HAMT
*/
var mutate = hamt.mutate = function (f, map) {
    var transient = beginMutation(map);
    f(transient);
    return endMutation(transient);
};

Map.prototype.mutate = function (f) {
    return mutate(f, this);
};

/* Traversal
 ******************************************************************************/
/**
    Apply a continuation.
*/
var appk = function appk(k) {
    return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);
};

/**
    Recursively visit all values stored in an array of nodes lazily.
*/
var lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {
    while (i < len) {
        var child = children[i++];
        if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);
    }
    return appk(k);
};

/**
    Recursively visit all values stored in `node` lazily.
*/
var lazyVisit = function lazyVisit(node, f, k) {
    switch (node.type) {
        case LEAF:
            return {
                value: f(node),
                rest: k
            };

        case COLLISION:
        case ARRAY:
        case INDEX:
            var children = node.children;
            return lazyVisitChildren(children.length, children, 0, f, k);

        default:
            return appk(k);
    }
};

var DONE = {
    done: true
};

/**
    Javascript iterator over a map.
*/
function MapIterator(v) {
    this.v = v;
};

MapIterator.prototype.next = function () {
    if (!this.v) return DONE;
    var v0 = this.v;
    this.v = appk(v0.rest);
    return v0;
};

MapIterator.prototype[Symbol.iterator] = function () {
    return this;
};

/**
    Lazily visit each value in map with function `f`.
*/
var visit = function visit(map, f) {
    return new MapIterator(lazyVisit(map._root, f));
};

/**
    Get a Javascsript iterator of `map`.

    Iterates over `[key, value]` arrays.
*/
var buildPairs = function buildPairs(x) {
    return [x.key, x.value];
};
var entries = hamt.entries = function (map) {
    return visit(map, buildPairs);
};

Map.prototype.entries = Map.prototype[Symbol.iterator] = function () {
    return entries(this);
};

/**
    Get array of all keys in `map`.

    Order is not guaranteed.
*/
var buildKeys = function buildKeys(x) {
    return x.key;
};
var keys = hamt.keys = function (map) {
    return visit(map, buildKeys);
};

Map.prototype.keys = function () {
    return keys(this);
};

/**
    Get array of all values in `map`.

    Order is not guaranteed, duplicates are preserved.
*/
var buildValues = function buildValues(x) {
    return x.value;
};
var values = hamt.values = Map.prototype.values = function (map) {
    return visit(map, buildValues);
};

Map.prototype.values = function () {
    return values(this);
};

/* Fold
 ******************************************************************************/
/**
    Visit every entry in the map, aggregating data.

    Order of nodes is not guaranteed.

    @param f Function mapping accumulated value, value, and key to new value.
    @param z Starting value.
    @param m HAMT
*/
var fold = hamt.fold = function (f, z, m) {
    var root = m._root;
    if (root.type === LEAF) return f(z, root.value, root.key);

    var toVisit = [root.children];
    var children = void 0;
    while (children = toVisit.pop()) {
        for (var i = 0, len = children.length; i < len;) {
            var child = children[i++];
            if (child && child.type) {
                if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);
            }
        }
    }
    return z;
};

Map.prototype.fold = function (f, z) {
    return fold(f, z, this);
};

/**
    Visit every entry in the map, aggregating data.

    Order of nodes is not guaranteed.

    @param f Function invoked with value and key
    @param map HAMT
*/
var forEach = hamt.forEach = function (f, map) {
    return fold(function (_, value, key) {
        return f(value, key, map);
    }, null, map);
};

Map.prototype.forEach = function (f) {
    return forEach(f, this);
};

/* Aggregate
 ******************************************************************************/
/**
    Get the number of entries in `map`.
*/
var count = hamt.count = function (map) {
    return map._size;
};

Map.prototype.count = function () {
    return count(this);
};

Object.defineProperty(Map.prototype, 'size', {
    get: Map.prototype.count
});

/* Export
 ******************************************************************************/
if (typeof module !== 'undefined' && module.exports) {
    module.exports = hamt;
} else if (typeof define === 'function' && define.amd) {
    define('hamt', [], function () {
        return hamt;
    });
} else {
    undefined.hamt = hamt;
}
//# sourceMappingURL=hamt.js.map

},{}],"node_modules/prelude-ts/dist/src/HashSet.js":[function(require,module,exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var ISet_1 = require("./ISet");
var Vector_1 = require("./Vector");
var HashMap_1 = require("./HashMap");
var LinkedList_1 = require("./LinkedList");
var Option_1 = require("./Option");
var Comparison_1 = require("./Comparison");
var SeqHelpers = require("./SeqHelpers");
var Contract_1 = require("./Contract");
var Value_1 = require("./Value");
var hamt = require("hamt_plus");
/**
 * An unordered collection of values, where no two values
 * may be equal. A value can only be present once.
 * @param T the item type
 */
var HashSet = /** @class */ (function () {
    /**
     * @hidden
     */
    function HashSet(hamt) {
        this.hamt = hamt;
    }
    /**
     * The empty hashset.
     * @param T the item type
     */
    HashSet.empty = function () {
        return emptyHashSet;
    };
    /**
     * Build a hashset from any iterable, which means also
     * an array for instance.
     * @param T the item type
     */
    HashSet.ofIterable = function (elts) {
        return new EmptyHashSet().addAll(elts);
    };
    /**
     * Build a hashset from a series of items (any number, as parameters)
     * @param T the item type
     */
    HashSet.of = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return HashSet.ofIterable(arr);
    };
    /**
     * Curried predicate to find out whether the HashSet is empty.
     *
     *     Vector.of(HashSet.of(1), HashSet.empty<number>())
     *         .filter(HashSet.isEmpty)
     *     => Vector.of(HashSet.empty<number>())
     */
    HashSet.isEmpty = function (v) {
        return v.isEmpty();
    };
    /**
     * Curried predicate to find out whether the HashSet is empty.
     *
     *     Vector.of(HashSet.of(1), HashSet.empty<number>())
     *         .filter(HashSet.isNotEmpty)
     *     => Vector.of(HashSet.of(1))
     */
    HashSet.isNotEmpty = function (v) {
        return !v.isEmpty();
    };
    /**
     * Implementation of the Iterator interface.
     */
    HashSet.prototype[Symbol.iterator] = function () {
        return this.hamt.keys();
    };
    /**
     * Add an element to this set.
     */
    HashSet.prototype.add = function (elt) {
        return new HashSet(this.hamt.set(elt, elt));
    };
    HashSet.prototype.addAllArray = function (elts) {
        return new HashSet(this.hamt.mutate(function (h) {
            if (elts.length > 0) {
                Contract_1.contractTrueEquality("Error building a HashSet", elts[0]);
            }
            for (var _i = 0, elts_1 = elts; _i < elts_1.length; _i++) {
                var val = elts_1[_i];
                h.set(val, val);
            }
        }));
    };
    /**
     * Add multiple elements to this set.
     */
    HashSet.prototype.addAll = function (elts) {
        if (Array.isArray(elts)) {
            return this.addAllArray(elts);
        }
        return new HashSet(this.hamt.mutate(function (h) {
            var checkedEq = false;
            var iterator = elts[Symbol.iterator]();
            var curItem = iterator.next();
            if (!curItem.done && curItem.value && !checkedEq) {
                Contract_1.contractTrueEquality("Error building a HashSet", curItem.value);
                checkedEq = true;
            }
            while (!curItem.done) {
                h.set(curItem.value, curItem.value);
                curItem = iterator.next();
            }
        }));
    };
    /**
     * Returns true if the element you give is present in
     * the set, false otherwise.
     */
    HashSet.prototype.contains = function (elt) {
        return this.hamt.has(elt);
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     * The resulting set may be smaller than the source.
     */
    HashSet.prototype.map = function (mapper) {
        return this.hamt.fold(function (acc, value, key) {
            return acc.add(mapper(value));
        }, HashSet.empty());
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     HashSet.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => HashSet.of(3, 7)
     */
    HashSet.prototype.mapOption = function (mapper) {
        return this.hamt.fold(function (acc, value, key) {
            var val = mapper(value);
            return val.isSome() ? acc.add(val.get()) : acc;
        }, HashSet.empty());
    };
    /**
     * Call a function for element in the collection.
     */
    HashSet.prototype.forEach = function (fun) {
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            fun(curItem.value);
            curItem = iterator.next();
        }
        return this;
    };
    /**
     * Calls the function you give for each item in the set,
     * your function returns a set, all the sets are
     * merged.
     */
    HashSet.prototype.flatMap = function (mapper) {
        return this.foldLeft(HashSet.empty(), function (soFar, cur) { return soFar.addAll(mapper(cur)); });
    };
    HashSet.prototype.filter = function (predicate) {
        var _this = this;
        return new HashSet(hamt.make({ hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq }).mutate(function (h) {
            var iterator = _this.hamt.values();
            var curItem = iterator.next();
            while (!curItem.done) {
                if (predicate(curItem.value)) {
                    h.set(curItem.value, curItem.value);
                }
                curItem = iterator.next();
            }
        }));
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     * We name the method findAny instead of find to emphasize
     * that there is not ordering in a hashset.
     *
     *     HashSet.of(1,2,3).findAny(x => x>=3)
     *     => Option.of(3)
     *
     *     HashSet.of(1,2,3).findAny(x => x>=4)
     *     => Option.none<number>()
     */
    HashSet.prototype.findAny = function (predicate) {
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value)) {
                return Option_1.Option.of(curItem.value);
            }
            curItem = iterator.next();
        }
        return Option_1.Option.none();
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     HashSet.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    HashSet.prototype.fold = function (zero, fn) {
        return this.foldLeft(zero, fn);
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     * No guarantees for the order of items in a hashset!
     *
     * Example:
     *
     *     HashSet.of("a", "bb", "ccc").foldLeft(0, (soFar,item) => soFar+item.length);
     *     => 6
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    HashSet.prototype.foldLeft = function (zero, fn) {
        return this.hamt.fold(function (acc, v, k) {
            return fn(acc, v);
        }, zero);
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     * No guarantees for the order of items in a hashset!
     *
     * Example:
     *
     *     HashSet.of("a", "bb", "ccc").foldRight(0, (item,soFar) => soFar+item.length);
     *     => 6
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    HashSet.prototype.foldRight = function (zero, fn) {
        return this.foldLeft(zero, function (cur, soFar) { return fn(soFar, cur); });
    };
    /**
     * Converts this set to an array. Since a Set is not ordered
     * and since this method returns a JS array, it can be awkward
     * to get an array sorted in the way you'd like. So you can pass
     * an optional sorting function too.
     *
     *     HashSet.of(1,2,3).toArray().sort()
     *     => [1,2,3]
     *
     *     HashSet.of(1,2,3).toArray({sortOn:x=>x})
     *     => [1,2,3]
     *
     *     HashSet.of(1,2,3).toArray({sortBy:(x,y)=>x-y})
     *     => [1,2,3]
     *
     * You can also pass an array in sortOn, listing lambdas to
     * several fields to sort by those fields, and also {desc:lambda}
     * to sort by some fields descending.
     */
    HashSet.prototype.toArray = function (sort) {
        var _a;
        if (!sort) {
            return Array.from(this.hamt.keys());
        }
        if (ISet_1.isSortOnSpec(sort)) {
            var sortOn = sort.sortOn instanceof Array ? sort.sortOn : [sort.sortOn];
            return (_a = Vector_1.Vector.ofIterable(this.hamt.keys())).sortOn.apply(_a, sortOn).toArray();
        }
        return Array.from(this.hamt.keys()).sort(sort.sortBy);
    };
    /**
     * Converts this set to an vector
     */
    HashSet.prototype.toVector = function () {
        return Vector_1.Vector.ofIterable(this.hamt.keys());
    };
    /**
     * Converts this set to an list
     */
    HashSet.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.ofIterable(this.hamt.keys());
    };
    /**
     * Returns the number of elements in the set.
     */
    HashSet.prototype.length = function () {
        return this.hamt.size;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    HashSet.prototype.single = function () {
        return this.hamt.size === 1
            ? Option_1.Option.of(this.hamt.keys().next().value)
            : Option_1.Option.none();
    };
    /**
     * true if the set is empty, false otherwise.
     */
    HashSet.prototype.isEmpty = function () {
        return this.hamt.size === 0;
    };
    /**
     * Returns a new Set containing the difference
     * between this set and the other Set passed as parameter.
     * also see [[HashSet.intersect]]
     */
    HashSet.prototype.diff = function (elts) {
        return new HashSet(this.hamt.fold(function (acc, v, k) {
            return elts.contains(k) ? acc : acc.set(k, k);
        }, hamt.empty));
    };
    /**
     * Returns a new Set containing the intersection
     * of this set and the other Set passed as parameter
     * (the elements which are common to both sets)
     * also see [[HashSet.diff]]
     */
    HashSet.prototype.intersect = function (other) {
        return new HashSet(this.hamt.fold(function (acc, v, k) {
            return other.contains(k) ? acc.set(k, k) : acc;
        }, hamt.empty));
    };
    HashSet.prototype.isSubsetOf = function (other) {
        return this.allMatch(function (x) { return other.contains(x); });
    };
    /**
     * Returns a new set with the element you give removed
     * if it was present in the set.
     */
    HashSet.prototype.remove = function (elt) {
        return new HashSet(this.hamt.remove(elt));
    };
    /**
     * Returns a new set with all the elements of the current
     * Set, minus the elements of the iterable you give as a parameter.
     * If you call this function with a HashSet as parameter,
     * rather call 'diff', as it'll be faster.
     */
    HashSet.prototype.removeAll = function (elts) {
        return this.diff(HashSet.ofIterable(elts));
    };
    /**
     * Returns true if the predicate returns true for all the
     * elements in the collection.
     */
    HashSet.prototype.allMatch = function (predicate) {
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (!predicate(curItem.value)) {
                return false;
            }
            curItem = iterator.next();
        }
        return true;
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    HashSet.prototype.anyMatch = function (predicate) {
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value)) {
                return true;
            }
            curItem = iterator.next();
        }
        return false;
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[HashSet.arrangeBy]]
     */
    HashSet.prototype.groupBy = function (classifier) {
        var _this = this;
        // make a singleton set with the same equality as this
        var singletonHamtSet = function (v) { return hamt.make({
            hash: _this.hamt._config.hash, keyEq: _this.hamt._config.keyEq
        }).set(v, v); };
        // merge two mutable hamt sets, but I know the second has only 1 elt
        var mergeSets = function (v1, v2) {
            var k = v2.keys().next().value;
            v1.set(k, k);
            return v1;
        };
        return this.hamt.fold(
        // fold operation: combine a new value from the set with the accumulator
        function (acc, v, k) {
            return acc.putWithMerge(classifier(v), singletonHamtSet(v).beginMutation(), mergeSets);
        }, 
        // fold accumulator: the empty hashmap
        HashMap_1.HashMap.empty())
            .mapValues(function (h) { return new HashSet(h.endMutation()); });
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[HashSet.groupBy]]
     */
    HashSet.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    HashSet.prototype.partition = function (predicate) {
        var r1 = hamt.make({
            hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq
        }).beginMutation();
        var r2 = hamt.make({
            hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq
        }).beginMutation();
        var iterator = this.hamt.values();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value)) {
                r1.set(curItem.value, curItem.value);
            }
            else {
                r2.set(curItem.value, curItem.value);
            }
            curItem = iterator.next();
        }
        return [new HashSet(r1), new HashSet(r2)];
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    HashSet.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[HashSet.minOn]]
     */
    HashSet.prototype.minBy = function (compare) {
        return SeqHelpers.minBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     * also see [[HashSet.minBy]]
     */
    HashSet.prototype.minOn = function (getOrderable) {
        return SeqHelpers.minOn(this, getOrderable);
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[HashSet.maxOn]]
     */
    HashSet.prototype.maxBy = function (compare) {
        return SeqHelpers.maxBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     * also see [[HashSet.maxBy]]
     */
    HashSet.prototype.maxOn = function (getOrderable) {
        return SeqHelpers.maxOn(this, getOrderable);
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     HashSet.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    HashSet.prototype.sumOn = function (getNumber) {
        return SeqHelpers.sumOn(this, getNumber);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    HashSet.prototype.transform = function (converter) {
        return converter(this);
    };
    HashSet.prototype.toJsSet = function (keyConvert) {
        return this.foldLeft(new Set(), function (sofar, cur) { return sofar.add(keyConvert(cur)); });
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    HashSet.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        var sz = this.hamt.size;
        if (other === emptyHashSet && sz === 0) {
            // we could get that i'm not the empty map
            // but my size is zero, after some filtering and such.
            return true;
        }
        if (!other || !other.hamt) {
            return false;
        }
        if (sz !== other.hamt.size) {
            return false;
        }
        Contract_1.contractTrueEquality("HashSet.equals", this, other);
        var keys = Array.from(this.hamt.keys());
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var hisVal = other.hamt.get(k);
            if (hisVal === undefined) {
                return false;
            }
            if (!Comparison_1.areEqual(k, hisVal)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    HashSet.prototype.hashCode = function () {
        return this.hamt.fold(function (acc, value, key) {
            return Comparison_1.getHashCode(key);
        }, 0);
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[HashSet.mkString]]
     */
    HashSet.prototype.toString = function () {
        return "HashSet(" +
            this.hamt.fold(function (acc, value, key) { acc.push(SeqHelpers.toStringHelper(key)); return acc; }, []).join(", ")
            + ")";
    };
    HashSet.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     HashSet.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     *
     * (of course, order is not guaranteed)
     */
    HashSet.prototype.mkString = function (separator) {
        return this.hamt.fold(function (acc, value, key) { acc.push(SeqHelpers.toStringHelper(key, { quoteStrings: false })); return acc; }, []).join(separator);
    };
    return HashSet;
}());
exports.HashSet = HashSet;
// we need to override the empty hashmap
// because i don't know how to get the hash & keyset
// functions for the keys without a key value to get
// the functions from
var EmptyHashSet = /** @class */ (function (_super) {
    __extends(EmptyHashSet, _super);
    function EmptyHashSet() {
        return _super.call(this, {}) || this;
    }
    EmptyHashSet.prototype.add = function (elt) {
        Contract_1.contractTrueEquality("Error building a HashSet", elt);
        if (!elt) {
            // special case if we get null for the first element...
            // less optimized variant because we don't know
            // if we should use '===' or 'equals'
            return new HashSet(hamt.make({
                hash: function (v) { return Comparison_1.getHashCode(v); },
                keyEq: function (a, b) { return Comparison_1.areEqual(a, b); }
            }).set(elt, elt));
        }
        // if the element is not null, save a if later by finding
        // out right now whether we should call equals or ===
        if (Comparison_1.hasEquals(elt)) {
            return new HashSet(hamt.make({
                hash: function (v) { return v.hashCode(); },
                keyEq: function (a, b) { return a.equals(b); }
            }).set(elt, elt));
        }
        return new HashSet(hamt.make().set(elt, elt));
    };
    EmptyHashSet.prototype.addAll = function (elts) {
        var _a;
        var it = elts[Symbol.iterator]();
        var curItem = it.next();
        if (curItem.done) {
            return emptyHashSet;
        }
        return this.add(curItem.value).addAll((_a = {}, _a[Symbol.iterator] = function () { return it; }, _a));
    };
    EmptyHashSet.prototype.contains = function (elt) {
        return false;
    };
    EmptyHashSet.prototype.map = function (mapper) {
        return emptyHashSet;
    };
    EmptyHashSet.prototype.mapOption = function (mapper) {
        return emptyHashSet;
    };
    EmptyHashSet.prototype.forEach = function (fun) {
        return this;
    };
    EmptyHashSet.prototype.filter = function (predicate) {
        return this;
    };
    EmptyHashSet.prototype.findAny = function (predicate) {
        return Option_1.Option.none();
    };
    EmptyHashSet.prototype.foldLeft = function (zero, fn) {
        return zero;
    };
    EmptyHashSet.prototype.toArray = function (sort) {
        return [];
    };
    EmptyHashSet.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    EmptyHashSet.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.empty();
    };
    EmptyHashSet.prototype[Symbol.iterator] = function () {
        return { next: function () { return ({ done: true, value: undefined }); } };
    };
    EmptyHashSet.prototype.length = function () {
        return 0;
    };
    EmptyHashSet.prototype.isEmpty = function () {
        return true;
    };
    EmptyHashSet.prototype.diff = function (elts) {
        return this;
    };
    EmptyHashSet.prototype.intersect = function (other) {
        return this;
    };
    EmptyHashSet.prototype.anyMatch = function (predicate) {
        return false;
    };
    EmptyHashSet.prototype.groupBy = function (classifier) {
        return HashMap_1.HashMap.empty();
    };
    EmptyHashSet.prototype.allMatch = function (predicate) {
        return true;
    };
    EmptyHashSet.prototype.partition = function (predicate) {
        return [this, this];
    };
    EmptyHashSet.prototype.remove = function (elt) {
        return this;
    };
    EmptyHashSet.prototype.equals = function (other) {
        if (!other || !other.length) {
            return false;
        }
        return other === emptyHashSet || other.length() === 0;
    };
    EmptyHashSet.prototype.hashCode = function () {
        return 0;
    };
    EmptyHashSet.prototype.toString = function () {
        return "HashSet()";
    };
    EmptyHashSet.prototype.mkString = function (separator) {
        return "";
    };
    return EmptyHashSet;
}(HashSet));
var emptyHashSet = new EmptyHashSet();
//# sourceMappingURL=HashSet.js.map
},{"./ISet":"node_modules/prelude-ts/dist/src/ISet.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./HashMap":"node_modules/prelude-ts/dist/src/HashMap.js","./LinkedList":"node_modules/prelude-ts/dist/src/LinkedList.js","./Option":"node_modules/prelude-ts/dist/src/Option.js","./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js","./Contract":"node_modules/prelude-ts/dist/src/Contract.js","./Value":"node_modules/prelude-ts/dist/src/Value.js","hamt_plus":"node_modules/hamt_plus/hamt.js"}],"node_modules/prelude-ts/dist/src/Lazy.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var Value_1 = require("./Value");
var SeqHelpers_1 = require("./SeqHelpers");
/**
 * Represent a lazily evaluated value. You give a function which
 * will return a value; that function is only called when the value
 * is requested from Lazy, but it will be computed at most once.
 * If the value is requested again, the previously computed result
 * will be returned: Lazy is memoizing.
 */
var Lazy = /** @class */ (function () {
    function Lazy(thunk) {
        this.thunk = thunk;
    }
    /**
     * Build a Lazy from a computation returning a value.
     * The computation will be called at most once.
     */
    Lazy.of = function (thunk) {
        return new Lazy(thunk);
    };
    /**
     * Evaluate the value, cache its value, and return it, or return the
     * previously computed value.
     */
    Lazy.prototype.get = function () {
        if (this.thunk) {
            this.value = this.thunk();
            this.thunk = undefined;
        }
        return this.value;
    };
    /**
     * Returns true if the computation underlying this Lazy was already
     * performed, false otherwise.
     */
    Lazy.prototype.isEvaluated = function () {
        return this.thunk === undefined;
    };
    /**
     * Return a new lazy where the element was transformed
     * by the mapper function you give.
     */
    Lazy.prototype.map = function (mapper) {
        var _this = this;
        return new Lazy(function () { return mapper(_this.get()); });
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Lazy.prototype.toString = function () {
        return this.isEvaluated() ?
            "Lazy(" + SeqHelpers_1.toStringHelper(this.get()) + ")" :
            "Lazy(?)";
    };
    /**
     * Used by the node REPL to display values.
     * Most of the time should be the same as toString()
     */
    Lazy.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Lazy;
}());
exports.Lazy = Lazy;
//# sourceMappingURL=Lazy.js.map
},{"./Value":"node_modules/prelude-ts/dist/src/Value.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js"}],"node_modules/prelude-ts/dist/src/Stream.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
/**
 * A lazy, potentially infinite, sequence of values.
 *
 * The code is organized through the class [[EmptyStream]] (empty list
 * or tail), the class [[ConsStream]] (list value and lazy pointer to next),
 * and the type alias [[Stream]] (empty or cons).
 *
 * Finally, "static" functions on Option are arranged in the class
 * [[StreamStatic]] and are accessed through the global constant Stream.
 *
 * Use take() for instance to reduce an infinite stream to a finite one.
 *
 * Examples:
 *
 *     Stream.iterate(1, x => x*2).take(4);
 *     => Stream.of(1,2,4,8)
 *
 *     Stream.continually(Math.random).take(2);
 *     => Stream.of(0.49884723907769635, 0.3226548779864311)
 */
var Option_1 = require("./Option");
var Vector_1 = require("./Vector");
var Comparison_1 = require("./Comparison");
var Contract_1 = require("./Contract");
var Value_1 = require("./Value");
var HashMap_1 = require("./HashMap");
var HashSet_1 = require("./HashSet");
var Lazy_1 = require("./Lazy");
var LinkedList_1 = require("./LinkedList");
var SeqHelpers = require("./SeqHelpers");
/**
 * Holds the "static methods" for [[Stream]]
 */
var StreamStatic = /** @class */ (function () {
    function StreamStatic() {
    }
    /**
     * The empty stream
     */
    StreamStatic.prototype.empty = function () {
        return emptyStream;
    };
    StreamStatic.prototype.of = function () {
        var elts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elts[_i] = arguments[_i];
        }
        return exports.Stream.ofIterable(elts);
    };
    /**
     * Build a stream from any iterable, which means also
     * an array for instance.
     * @param T the item type
     */
    StreamStatic.prototype.ofIterable = function (elts) {
        // need to eagerly copy the iterable. the reason
        // is, if we would build the stream based on the iterator
        // in the iterable, Stream.tail() would do it.next().
        // but it.next() modifies the iterator (mutability),
        // and you would end up with getting two different tails
        // for the same stream if you call .tail() twice in a row
        if (Array.isArray(elts)) {
            return exports.Stream.ofArray(elts);
        }
        return exports.Stream.ofArray(Array.from(elts));
    };
    /**
     * Curried type guard for Stream.
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Stream.of(1), Stream.empty<number>())
     *         .filter(Stream.isEmpty)
     *     => Vector.of(Stream.empty<number>())
     */
    StreamStatic.prototype.isEmpty = function (s) {
        return s.isEmpty();
    };
    /**
     * Curried type guard for Stream.
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Stream.of(1), Stream.empty<number>())
     *         .filter(Stream.isNotEmpty)
     *         .map(s => s.head().get()+1)
     *     => Vector.of(2)
     */
    StreamStatic.prototype.isNotEmpty = function (s) {
        return !s.isEmpty();
    };
    /**
     * @hidden
     */
    StreamStatic.prototype.ofArray = function (elts) {
        if (elts.length === 0) {
            return emptyStream;
        }
        var head = elts[0];
        return new ConsStream(head, Lazy_1.Lazy.of(function () { return exports.Stream.ofArray(elts.slice(1)); }));
    };
    /**
     * Build an infinite stream from a seed and a transformation function.
     *
     *     Stream.iterate(1, x => x*2).take(4);
     *     => Stream.of(1,2,4,8)
     */
    StreamStatic.prototype.iterate = function (seed, fn) {
        return new ConsStream(seed, Lazy_1.Lazy.of(function () { return exports.Stream.iterate(fn(seed), fn); }));
    };
    /**
     * Build an infinite stream by calling repeatedly a function.
     *
     *     Stream.continually(() => 1).take(4);
     *     => Stream.of(1,1,1,1)
     *
     *     Stream.continually(Math.random).take(2);
     *     => Stream.of(0.49884723907769635, 0.3226548779864311)
     */
    StreamStatic.prototype.continually = function (fn) {
        return new ConsStream(fn(), Lazy_1.Lazy.of(function () { return exports.Stream.continually(fn); }));
    };
    /**
     * Dual to the foldRight function. Build a collection from a seed.
     * Takes a starting element and a function.
     * It applies the function on the starting element; if the
     * function returns None, it stops building the list, if it
     * returns Some of a pair, it adds the first element to the result
     * and takes the second element as a seed to keep going.
     *
     *     Stream.unfoldRight(
     *          10, x=>Option.of(x)
     *              .filter(x => x!==0)
     *              .map<[number,number]>(x => [x,x-1]));
     *     => Stream.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
     */
    StreamStatic.prototype.unfoldRight = function (seed, fn) {
        var nextVal = fn(seed);
        if (nextVal.isNone()) {
            return emptyStream;
        }
        return new ConsStream(nextVal.get()[0], Lazy_1.Lazy.of(function () { return exports.Stream.unfoldRight(nextVal.getOrThrow()[1], fn); }));
    };
    /**
     * Combine any number of iterables you give in as
     * parameters to produce a new collection which combines all,
     * in tuples. For instance:
     *
     *     Stream.zip(Stream.of(1,2,3), ["a","b","c"], LinkedList.of(8,9,10))
     *     => Stream.of([1,"a",8], [2,"b",9], [3,"c",10])
     *
     * The result collection will have the length of the shorter
     * of the input iterables. Extra elements will be discarded.
     *
     * Also see the non-static version [[ConsStream.zip]], which only combines two
     * collections.
     * @param A A is the type of the tuple that'll be generated
     *          (`[number,string,number]` for the code sample)
     */
    StreamStatic.prototype.zip = function () {
        var iterables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            iterables[_i] = arguments[_i];
        }
        var iterators = iterables.map(function (i) { return i[Symbol.iterator](); });
        var items = iterators.map(function (i) { return i.next(); });
        if (items.some(function (item) { return item.done; })) {
            return emptyStream;
        }
        return new ConsStream(items.map(function (item) { return item.value; }), Lazy_1.Lazy.of(function () { return exports.Stream.zip.apply(exports.Stream, iterators.map(function (i) {
            var _a;
            return (_a = {}, _a[Symbol.iterator] = function () { return i; }, _a);
        })); }));
    };
    return StreamStatic;
}());
exports.StreamStatic = StreamStatic;
/**
 * The Stream constant allows to call the Stream "static" methods
 */
exports.Stream = new StreamStatic();
/**
 * EmptyStream is the empty stream; every non-empty
 * stream also has a pointer to an empty stream
 * after its last element.
 * "static methods" available through [[StreamStatic]]
 * @param T the item type
 */
var EmptyStream = /** @class */ (function () {
    function EmptyStream() {
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Implementation of the Iterator interface.
     */
    EmptyStream.prototype[Symbol.iterator] = function () {
        return {
            next: function () {
                return {
                    done: true,
                    value: undefined
                };
            }
        };
    };
    /**
     * View this Some a as Stream. Useful to help typescript type
     * inference sometimes.
     */
    EmptyStream.prototype.asStream = function () {
        return this;
    };
    /**
     * @hidden
     */
    EmptyStream.prototype.hasTrueEquality = function () {
        return SeqHelpers.seqHasTrueEquality(this);
    };
    /**
     * Get the length of the collection.
     */
    EmptyStream.prototype.length = function () {
        return 0;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    EmptyStream.prototype.single = function () {
        return Option_1.Option.none();
    };
    /**
     * true if the collection is empty, false otherwise.
     */
    EmptyStream.prototype.isEmpty = function () {
        return true;
    };
    /**
     * Get the first value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    EmptyStream.prototype.head = function () {
        return Option_1.Option.none();
    };
    /**
     * Get all the elements in the collection but the first one.
     * If the collection is empty, return None.
     */
    EmptyStream.prototype.tail = function () {
        return Option_1.Option.none();
    };
    /**
     * Get the last value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    EmptyStream.prototype.last = function () {
        return Option_1.Option.none();
    };
    /**
     * Retrieve the element at index idx.
     * Returns an option because the collection may
     * contain less elements than the index.
     *
     * Careful this is going to have poor performance
     * on Stream, which is not a good data structure
     * for random access!
     */
    EmptyStream.prototype.get = function (idx) {
        return Option_1.Option.none();
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     */
    EmptyStream.prototype.find = function (predicate) {
        return Option_1.Option.none();
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    EmptyStream.prototype.contains = function (v) {
        return false;
    };
    /**
     * Return a new stream keeping only the first n elements
     * from this stream.
     */
    EmptyStream.prototype.take = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate.
     */
    EmptyStream.prototype.takeWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate,
     * but starting from the end of the collection.
     *
     *     Stream.of(1,2,3,4).takeRightWhile(x => x > 2)
     *     => Stream.of(3,4)
     */
    EmptyStream.prototype.takeRightWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with the first
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    EmptyStream.prototype.drop = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the first elements
     * until one element fails the predicate. All elements
     * after that point are retained.
     */
    EmptyStream.prototype.dropWhile = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with the last
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    EmptyStream.prototype.dropRight = function (n) {
        return this;
    };
    /**
     * Returns a new collection, discarding the last elements
     * until one element fails the predicate. All elements
     * before that point are retained.
     */
    EmptyStream.prototype.dropRightWhile = function (predicate) {
        return this;
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     Stream.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    EmptyStream.prototype.fold = function (zero, fn) {
        return zero;
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldLeft("!", (xs,x) => x+xs);
     *     => "cba!"
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    EmptyStream.prototype.foldLeft = function (zero, fn) {
        return zero;
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldRight("!", (x,xs) => xs+x);
     *     => "!cba"
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    EmptyStream.prototype.foldRight = function (zero, fn) {
        return zero;
    };
    /**
     * Combine this collection with the collection you give in
     * parameter to produce a new collection which combines both,
     * in pairs. For instance:
     *
     *     Stream.of(1,2,3).zip(["a","b","c"])
     *     => Stream.of([1,"a"], [2,"b"], [3,"c"])
     *
     * The result collection will have the length of the shorter
     * of both collections. Extra elements will be discarded.
     *
     * Also see [[StreamStatic.zip]] (static version which can more than two
     * iterables)
     */
    EmptyStream.prototype.zip = function (other) {
        return emptyStream;
    };
    /**
     * Combine this collection with the index of the elements
     * in it. Handy if you need the index when you map on
     * the collection for instance:
     *
     *     Stream.of("a","b").zipWithIndex().map(([v,idx]) => v+idx);
     *     => Stream.of("a0", "b1")
     */
    EmptyStream.prototype.zipWithIndex = function () {
        return SeqHelpers.zipWithIndex(this);
    };
    /**
     * Reverse the collection. For instance:
     *
     *     Stream.of(1,2,3).reverse();
     *     => Stream.of(3,2,1)
     */
    EmptyStream.prototype.reverse = function () {
        return this;
    };
    /**
     * Takes a predicate; returns a pair of collections.
     * The first one is the longest prefix of this collection
     * which satisfies the predicate, and the second collection
     * is the remainder of the collection.
     *
     *    Stream.of(1,2,3,4,5,6).span(x => x <3)
     *    => [Stream.of(1,2), Stream.of(3,4,5,6)]
     */
    EmptyStream.prototype.span = function (predicate) {
        return [this, this];
    };
    /**
     * Split the collection at a specific index.
     *
     *     Stream.of(1,2,3,4,5).splitAt(3)
     *     => [Stream.of(1,2,3), Stream.of(4,5)]
     */
    EmptyStream.prototype.splitAt = function (index) {
        return [this, this];
    };
    EmptyStream.prototype.partition = function (predicate) {
        return [exports.Stream.empty(), exports.Stream.empty()];
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[ConsStream.arrangeBy]]
     */
    EmptyStream.prototype.groupBy = function (classifier) {
        return HashMap_1.HashMap.empty();
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[ConsStream.groupBy]]
     */
    EmptyStream.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    /**
     * Randomly reorder the elements of the collection.
     */
    EmptyStream.prototype.shuffle = function () {
        return exports.Stream.ofIterable(SeqHelpers.shuffle(this.toArray()));
    };
    /**
     * Append an element at the end of this Stream.
     */
    EmptyStream.prototype.append = function (v) {
        return exports.Stream.of(v);
    };
    /*
     * Append multiple elements at the end of this Stream.
     */
    EmptyStream.prototype.appendAll = function (elts) {
        return exports.Stream.ofIterable(elts);
    };
    /**
     * Remove multiple elements from a stream
     *
     *     Stream.of(1,2,3,4,3,2,1).removeAll([2,4])
     *     => Stream.of(1,3,3,1)
     */
    EmptyStream.prototype.removeAll = function (elts) {
        return this;
    };
    /**
     * Removes the first element matching the predicate
     * (use [[ConsStream.filter]] to remove all elements matching a predicate)
     */
    EmptyStream.prototype.removeFirst = function (predicate) {
        return this;
    };
    /*
     * Append another Stream at the end of this Stream.
     *
     * There is no function taking a javascript iterator,
     * because iterators are stateful and Streams lazy.
     * If we would create two Streams working on the same iterator,
     * the streams would interact with one another.
     * It also breaks the cycle() function.
     */
    EmptyStream.prototype.appendStream = function (elts) {
        return elts;
    };
    /**
     * Prepend an element at the beginning of the collection.
     */
    EmptyStream.prototype.prepend = function (elt) {
        return exports.Stream.of(elt);
    };
    /**
     * Prepend multiple elements at the beginning of the collection.
     */
    EmptyStream.prototype.prependAll = function (elt) {
        return exports.Stream.ofIterable(elt);
    };
    /**
     * Repeat infinitely this Stream.
     * For instance:
     *
     *     Stream.of(1,2,3).cycle().take(8)
     *     => Stream.of(1,2,3,1,2,3,1,2)
     */
    EmptyStream.prototype.cycle = function () {
        return emptyStream;
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     */
    EmptyStream.prototype.map = function (mapper) {
        return emptyStream;
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     Stream.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => Stream.of(3, 7)
     */
    EmptyStream.prototype.mapOption = function (mapper) {
        return emptyStream;
    };
    /**
     * Calls the function you give for each item in the collection,
     * your function returns a collection, all the collections are
     * concatenated.
     * This is the monadic bind.
     */
    EmptyStream.prototype.flatMap = function (mapper) {
        return emptyStream;
    };
    /**
     * Returns true if the predicate returns true for all the
     * elements in the collection.
     */
    EmptyStream.prototype.allMatch = function (predicate) {
        return true;
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    EmptyStream.prototype.anyMatch = function (predicate) {
        return false;
    };
    EmptyStream.prototype.filter = function (predicate) {
        return this;
    };
    /**
     * Returns a new collection with elements
     * sorted according to the comparator you give.
     *
     *     const activityOrder = ["Writer", "Actor", "Director"];
     *     Stream.of({name:"George", activity: "Director"}, {name:"Robert", activity: "Actor"})
     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));
     *     => Stream.of({"name":"Robert","activity":"Actor"}, {"name":"George","activity":"Director"})
     *
     * also see [[ConsStream.sortOn]]
     */
    EmptyStream.prototype.sortBy = function (compare) {
        return this;
    };
    /**
     * Give a function associating a number or a string with
     * elements from the collection, and the elements
     * are sorted according to that value.
     *
     *     Stream.of({a:3,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a)
     *     => Stream.of({a:1,b:"test"},{a:2,b:"a"},{a:3,b:"b"})
     *
     * You can also sort by multiple criteria, and request 'descending'
     * sorting:
     *
     *     Stream.of({a:1,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})
     *     => Stream.of({a:1,b:"test"},{a:1,b:"b"},{a:2,b:"a"})
     *
     * also see [[ConsStream.sortBy]]
     */
    EmptyStream.prototype.sortOn = function () {
        var getKeys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            getKeys[_i] = arguments[_i];
        }
        return this;
    };
    /**
     * Remove duplicate items; elements are mapped to keys, those
     * get compared.
     *
     *     Stream.of(1,1,2,3,2,3,1).distinctBy(x => x);
     *     => Stream.of(1,2,3)
     */
    EmptyStream.prototype.distinctBy = function (keyExtractor) {
        return this;
    };
    /**
     * Call a function for element in the collection.
     */
    EmptyStream.prototype.forEach = function (fn) {
        return this;
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    EmptyStream.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsStream.minOn]]
     */
    EmptyStream.prototype.minBy = function (compare) {
        return Option_1.Option.none();
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     *     Stream.of({name:"Joe", age:12}, {name:"Paula", age:6}).minOn(x=>x.age)
     *     => Option.of({name:"Paula", age:6})
     *
     * also see [[ConsStream.minBy]]
     */
    EmptyStream.prototype.minOn = function (getOrderable) {
        return Option_1.Option.none();
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsStream.maxOn]]
     */
    EmptyStream.prototype.maxBy = function (compare) {
        return Option_1.Option.none();
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     *     Stream.of({name:"Joe", age:12}, {name:"Paula", age:6}).maxOn(x=>x.age)
     *     => Option.of({name:"Joe", age:12})
     *
     * also see [[ConsStream.maxBy]]
     */
    EmptyStream.prototype.maxOn = function (getOrderable) {
        return Option_1.Option.none();
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     Stream.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    EmptyStream.prototype.sumOn = function (getNumber) {
        return 0;
    };
    /**
     * Slides a window of a specific size over the sequence.
     * Returns a lazy stream so memory use is not prohibitive.
     *
     *     Stream.of(1,2,3,4,5,6,7,8).sliding(3)
     *     => Stream.of(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8))
     */
    EmptyStream.prototype.sliding = function (count) {
        return SeqHelpers.sliding(this, count);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     *
     *     Stream.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)
     *     => Stream.of(0,1,3,6)
     */
    EmptyStream.prototype.scanLeft = function (init, fn) {
        return new ConsStream(init, Lazy_1.Lazy.of(function () { return emptyStream; }));
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The first element of the result is the final cumulative result.
     *
     *     Stream.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)
     *     => Stream.of(6,5,3,0)
     */
    EmptyStream.prototype.scanRight = function (init, fn) {
        return new ConsStream(init, Lazy_1.Lazy.of(function () { return emptyStream; }));
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     Vector.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     */
    EmptyStream.prototype.mkString = function (separator) {
        return "";
    };
    /**
     * Convert to array.
     * Don't do it on an infinite stream!
     */
    EmptyStream.prototype.toArray = function () {
        return [];
    };
    /**
     * Convert to vector.
     * Don't do it on an infinite stream!
     */
    EmptyStream.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    /**
     * Convert this collection to a map. You give a function which
     * for each element in the collection returns a pair. The
     * key of the pair will be used as a key in the map, the value,
     * as a value in the map. If several values get the same key,
     * entries will be lost.
     *
     *     Stream.of(1,2,3).toMap(x=>[x.toString(), x])
     *     => HashMap.of(["1",1], ["2",2], ["3",3])
     */
    EmptyStream.prototype.toMap = function (converter) {
        return HashMap_1.HashMap.empty();
    };
    /**
     * Convert this collection to a set. Since the elements of the
     * Seq may not support equality, you must pass a function returning
     * a value supporting equality.
     *
     *     Stream.of(1,2,3,3,4).toSet(x=>x)
     *     => HashSet.of(1,2,3,4)
     */
    EmptyStream.prototype.toSet = function (converter) {
        return HashSet_1.HashSet.empty();
    };
    /**
     * Convert this collection to a list.
     */
    EmptyStream.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.ofIterable(this);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    EmptyStream.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    EmptyStream.prototype.equals = function (other) {
        if (!other) {
            return false;
        }
        return other.isEmpty();
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    EmptyStream.prototype.hashCode = function () {
        return 1;
    };
    EmptyStream.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[ConsStream.mkString]]
     */
    EmptyStream.prototype.toString = function () {
        return "[]";
    };
    return EmptyStream;
}());
exports.EmptyStream = EmptyStream;
/**
 * ConsStream holds a value and a lazy pointer to a next element,
 * which could be [[ConsStream]] or [[EmptyStream]].
 * A ConsStream is basically a non-empty stream. It will
 * contain at least one element.
 * "static methods" available through [[StreamStatic]]
 * @param T the item type
 */
var ConsStream = /** @class */ (function () {
    /**
     * @hidden
     */
    function ConsStream(value, _tail) {
        this.value = value;
        this._tail = _tail;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Implementation of the Iterator interface.
     */
    ConsStream.prototype[Symbol.iterator] = function () {
        var item = this;
        return {
            next: function () {
                if (item.isEmpty()) {
                    return { done: true, value: undefined };
                }
                var value = item.head().get();
                item = item.tail().get();
                return { done: false, value: value };
            }
        };
    };
    /**
     * View this Some a as Stream. Useful to help typescript type
     * inference sometimes.
     */
    ConsStream.prototype.asStream = function () {
        return this;
    };
    /**
     * @hidden
     */
    ConsStream.prototype.hasTrueEquality = function () {
        return SeqHelpers.seqHasTrueEquality(this);
    };
    /**
     * Get the length of the collection.
     */
    ConsStream.prototype.length = function () {
        return this.foldLeft(0, function (n, ignored) { return n + 1; });
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    ConsStream.prototype.single = function () {
        return this._tail.get().isEmpty() ?
            Option_1.Option.of(this.value) :
            Option_1.Option.none();
    };
    /**
     * true if the collection is empty, false otherwise.
     */
    ConsStream.prototype.isEmpty = function () {
        return false;
    };
    /**
     * Get the first value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    ConsStream.prototype.head = function () {
        return Option_1.Option.some(this.value);
    };
    /**
     * Get all the elements in the collection but the first one.
     * If the collection is empty, return None.
     */
    ConsStream.prototype.tail = function () {
        return Option_1.Option.some(this._tail.get());
    };
    /**
     * Get the last value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    ConsStream.prototype.last = function () {
        var curItem = this;
        while (true) {
            var item = curItem.value;
            curItem = curItem._tail.get();
            if (curItem.isEmpty()) {
                return Option_1.Option.some(item);
            }
        }
    };
    /**
     * Retrieve the element at index idx.
     * Returns an option because the collection may
     * contain less elements than the index.
     *
     * Careful this is going to have poor performance
     * on Stream, which is not a good data structure
     * for random access!
     */
    ConsStream.prototype.get = function (idx) {
        var curItem = this;
        var i = 0;
        while (!curItem.isEmpty()) {
            if (i === idx) {
                var item = curItem.value;
                return Option_1.Option.of(item);
            }
            curItem = curItem._tail.get();
            ++i;
        }
        return Option_1.Option.none();
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     */
    ConsStream.prototype.find = function (predicate) {
        var curItem = this;
        while (!curItem.isEmpty()) {
            var item = curItem.value;
            if (predicate(item)) {
                return Option_1.Option.of(item);
            }
            curItem = curItem._tail.get();
        }
        return Option_1.Option.none();
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    ConsStream.prototype.contains = function (v) {
        return this.find(function (x) { return Comparison_1.areEqual(x, v); }).isSome();
    };
    /**
     * Return a new stream keeping only the first n elements
     * from this stream.
     */
    ConsStream.prototype.take = function (n) {
        var _this = this;
        if (n < 1) {
            return emptyStream;
        }
        return new ConsStream(this.value, Lazy_1.Lazy.of(function () { return _this._tail.get().take(n - 1); }));
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate.
     */
    ConsStream.prototype.takeWhile = function (predicate) {
        var _this = this;
        if (!predicate(this.value)) {
            return emptyStream;
        }
        return new ConsStream(this.value, Lazy_1.Lazy.of(function () { return _this._tail.get().takeWhile(predicate); }));
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate,
     * but starting from the end of the collection.
     *
     *     Stream.of(1,2,3,4).takeRightWhile(x => x > 2)
     *     => Stream.of(3,4)
     */
    ConsStream.prototype.takeRightWhile = function (predicate) {
        return this.reverse().takeWhile(predicate).reverse();
    };
    /**
     * Returns a new collection with the first
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    ConsStream.prototype.drop = function (n) {
        var i = n;
        var curItem = this;
        while (i-- > 0 && !curItem.isEmpty()) {
            curItem = curItem._tail.get();
        }
        return curItem;
    };
    /**
     * Returns a new collection, discarding the first elements
     * until one element fails the predicate. All elements
     * after that point are retained.
     */
    ConsStream.prototype.dropWhile = function (predicate) {
        var curItem = this;
        while (!curItem.isEmpty() && predicate(curItem.value)) {
            curItem = curItem._tail.get();
        }
        return curItem;
    };
    /**
     * Returns a new collection with the last
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    ConsStream.prototype.dropRight = function (n) {
        // going twice through the list...
        var length = this.length();
        return this.take(length - n);
    };
    /**
     * Returns a new collection, discarding the last elements
     * until one element fails the predicate. All elements
     * before that point are retained.
     */
    ConsStream.prototype.dropRightWhile = function (predicate) {
        return this.reverse().dropWhile(predicate).reverse();
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     Stream.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    ConsStream.prototype.fold = function (zero, fn) {
        return this.foldLeft(zero, fn);
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldLeft("!", (xs,x) => x+xs);
     *     => "cba!"
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    ConsStream.prototype.foldLeft = function (zero, fn) {
        var r = zero;
        var curItem = this;
        while (!curItem.isEmpty()) {
            r = fn(r, curItem.value);
            curItem = curItem._tail.get();
        }
        return r;
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldRight("!", (x,xs) => xs+x);
     *     => "!cba"
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    ConsStream.prototype.foldRight = function (zero, fn) {
        return this.reverse().foldLeft(zero, function (xs, x) { return fn(x, xs); });
    };
    /**
     * Combine this collection with the collection you give in
     * parameter to produce a new collection which combines both,
     * in pairs. For instance:
     *
     *     Stream.of(1,2,3).zip(["a","b","c"])
     *     => Stream.of([1,"a"], [2,"b"], [3,"c"])
     *
     * The result collection will have the length of the shorter
     * of both collections. Extra elements will be discarded.
     *
     * Also see [[StreamStatic.zip]] (static version which can more than two
     * iterables)
     */
    ConsStream.prototype.zip = function (other) {
        var _this = this;
        var otherIterator = other[Symbol.iterator]();
        var otherCurItem = otherIterator.next();
        if (this.isEmpty() || otherCurItem.done) {
            return emptyStream;
        }
        return new ConsStream([this.value, otherCurItem.value], Lazy_1.Lazy.of(function () {
            var _a;
            return _this._tail.get().zip((_a = {}, _a[Symbol.iterator] = function () { return otherIterator; }, _a));
        }));
    };
    /**
     * Combine this collection with the index of the elements
     * in it. Handy if you need the index when you map on
     * the collection for instance:
     *
     *     Stream.of("a","b").zipWithIndex().map(([v,idx]) => v+idx);
     *     => Stream.of("a0", "b1")
     */
    ConsStream.prototype.zipWithIndex = function () {
        return SeqHelpers.zipWithIndex(this);
    };
    /**
     * Reverse the collection. For instance:
     *
     *     Stream.of(1,2,3).reverse();
     *     => Stream.of(3,2,1)
     */
    ConsStream.prototype.reverse = function () {
        return this.foldLeft(emptyStream, function (xs, x) { return xs.prepend(x); });
    };
    /**
     * Takes a predicate; returns a pair of collections.
     * The first one is the longest prefix of this collection
     * which satisfies the predicate, and the second collection
     * is the remainder of the collection.
     *
     *    Stream.of(1,2,3,4,5,6).span(x => x <3)
     *    => [Stream.of(1,2), Stream.of(3,4,5,6)]
     */
    ConsStream.prototype.span = function (predicate) {
        return [this.takeWhile(predicate), this.dropWhile(predicate)];
    };
    /**
     * Split the collection at a specific index.
     *
     *     Stream.of(1,2,3,4,5).splitAt(3)
     *     => [Stream.of(1,2,3), Stream.of(4,5)]
     */
    ConsStream.prototype.splitAt = function (index) {
        return [this.take(index), this.drop(index)];
    };
    ConsStream.prototype.partition = function (predicate) {
        // goes twice over the list, but since we want a lazy behavior...
        return [this.filter(predicate), this.filter(function (x) { return !predicate(x); })];
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[ConsStream.arrangeBy]]
     */
    ConsStream.prototype.groupBy = function (classifier) {
        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {
            return acc.putWithMerge(classifier(v), exports.Stream.of(v), function (v1, v2) { return v1.appendStream(v2); });
        });
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[ConsStream.groupBy]]
     */
    ConsStream.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    /**
     * Randomly reorder the elements of the collection.
     */
    ConsStream.prototype.shuffle = function () {
        return exports.Stream.ofIterable(SeqHelpers.shuffle(this.toArray()));
    };
    /**
     * Append an element at the end of this Stream.
     */
    ConsStream.prototype.append = function (v) {
        var tail = this._tail.get();
        return new ConsStream(this.value, Lazy_1.Lazy.of(function () { return tail.append(v); }));
    };
    /*
     * Append multiple elements at the end of this Stream.
     */
    ConsStream.prototype.appendAll = function (elts) {
        return this.appendStream(exports.Stream.ofIterable(elts));
    };
    /**
     * Remove multiple elements from a stream
     *
     *     Stream.of(1,2,3,4,3,2,1).removeAll([2,4])
     *     => Stream.of(1,3,3,1)
     */
    ConsStream.prototype.removeAll = function (elts) {
        return SeqHelpers.removeAll(this, elts);
    };
    /**
     * Removes the first element matching the predicate
     * (use [[ConsStream.filter]] to remove all elements matching a predicate)
     */
    ConsStream.prototype.removeFirst = function (predicate) {
        var tail = this._tail.get();
        return predicate(this.value) ?
            tail :
            new ConsStream(this.value, Lazy_1.Lazy.of(function () { return tail.removeFirst(predicate); }));
    };
    /*
     * Append another Stream at the end of this Stream.
     *
     * There is no function taking a javascript iterator,
     * because iterators are stateful and Streams lazy.
     * If we would create two Streams working on the same iterator,
     * the streams would interact with one another.
     * It also breaks the cycle() function.
     */
    ConsStream.prototype.appendStream = function (elts) {
        var tail = this._tail.get();
        return new ConsStream(this.value, Lazy_1.Lazy.of(function () { return tail.appendStream(elts); }));
    };
    /**
     * Prepend an element at the beginning of the collection.
     */
    ConsStream.prototype.prepend = function (elt) {
        var _this = this;
        return new ConsStream(elt, Lazy_1.Lazy.of(function () { return _this; }));
    };
    /**
     * Prepend multiple elements at the beginning of the collection.
     */
    ConsStream.prototype.prependAll = function (elts) {
        return exports.Stream.ofIterable(elts).appendAll(this);
    };
    /**
     * Repeat infinitely this Stream.
     * For instance:
     *
     *     Stream.of(1,2,3).cycle().take(8)
     *     => Stream.of(1,2,3,1,2,3,1,2)
     */
    ConsStream.prototype.cycle = function () {
        return this._cycle(this);
    };
    ConsStream.prototype._cycle = function (toRepeat) {
        var tail = this._tail.get();
        return new ConsStream(this.value, Lazy_1.Lazy.of(function () { return tail.isEmpty() ? toRepeat.cycle() : tail._cycle(toRepeat); }));
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     */
    ConsStream.prototype.map = function (mapper) {
        var _this = this;
        return new ConsStream(mapper(this.value), Lazy_1.Lazy.of(function () { return _this._tail.get().map(mapper); }));
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     Stream.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => Stream.of(3, 7)
     */
    ConsStream.prototype.mapOption = function (mapper) {
        var _this = this;
        var mapped = mapper(this.value);
        return mapped.isSome() ?
            new ConsStream(mapped.get(), Lazy_1.Lazy.of(function () { return _this._tail.get().mapOption(mapper); })) :
            this._tail.get().mapOption(mapper);
    };
    /**
     * Calls the function you give for each item in the collection,
     * your function returns a collection, all the collections are
     * concatenated.
     * This is the monadic bind.
     */
    ConsStream.prototype.flatMap = function (mapper) {
        return mapper(this.value).appendStream(this._tail.get().flatMap(mapper));
    };
    /**
     * Returns true if the predicate returns true for all the
     * elements in the collection.
     */
    ConsStream.prototype.allMatch = function (predicate) {
        return this.find(function (x) { return !predicate(x); }).isNone();
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    ConsStream.prototype.anyMatch = function (predicate) {
        return this.find(predicate).isSome();
    };
    ConsStream.prototype.filter = function (predicate) {
        var _this = this;
        return predicate(this.value) ?
            new ConsStream(this.value, Lazy_1.Lazy.of(function () { return _this._tail.get().filter(predicate); })) :
            this._tail.get().filter(predicate);
    };
    /**
     * Returns a new collection with elements
     * sorted according to the comparator you give.
     *
     *     const activityOrder = ["Writer", "Actor", "Director"];
     *     Stream.of({name:"George", activity: "Director"}, {name:"Robert", activity: "Actor"})
     *         .sortBy((p1,p2) => activityOrder.indexOf(p1.activity) - activityOrder.indexOf(p2.activity));
     *     => Stream.of({"name":"Robert","activity":"Actor"}, {"name":"George","activity":"Director"})
     *
     * also see [[ConsStream.sortOn]]
     */
    ConsStream.prototype.sortBy = function (compare) {
        return exports.Stream.ofIterable(this.toArray().sort(compare));
    };
    /**
     * Give a function associating a number or a string with
     * elements from the collection, and the elements
     * are sorted according to that value.
     *
     *     Stream.of({a:3,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a)
     *     => Stream.of({a:1,b:"test"},{a:2,b:"a"},{a:3,b:"b"})
     *
     * You can also sort by multiple criteria, and request 'descending'
     * sorting:
     *
     *     Stream.of({a:1,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})
     *     => Stream.of({a:1,b:"test"},{a:1,b:"b"},{a:2,b:"a"})
     *
     * also see [[ConsStream.sortBy]]
     */
    ConsStream.prototype.sortOn = function () {
        var getKeys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            getKeys[_i] = arguments[_i];
        }
        return SeqHelpers.sortOn(this, getKeys);
    };
    /**
     * Remove duplicate items; elements are mapped to keys, those
     * get compared.
     *
     *     Stream.of(1,1,2,3,2,3,1).distinctBy(x => x);
     *     => Stream.of(1,2,3)
     */
    ConsStream.prototype.distinctBy = function (keyExtractor) {
        return SeqHelpers.distinctBy(this, keyExtractor);
    };
    /**
     * Call a function for element in the collection.
     */
    ConsStream.prototype.forEach = function (fn) {
        var curItem = this;
        while (!curItem.isEmpty()) {
            fn(curItem.value);
            curItem = curItem._tail.get();
        }
        return this;
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    ConsStream.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsStream.minOn]]
     */
    ConsStream.prototype.minBy = function (compare) {
        return SeqHelpers.minBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     *     Stream.of({name:"Joe", age:12}, {name:"Paula", age:6}).minOn(x=>x.age)
     *     => Option.of({name:"Paula", age:6})
     *
     * also see [[ConsStream.minBy]]
     */
    ConsStream.prototype.minOn = function (getOrderable) {
        return SeqHelpers.minOn(this, getOrderable);
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[ConsStream.maxOn]]
     */
    ConsStream.prototype.maxBy = function (compare) {
        return SeqHelpers.maxBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     *     Stream.of({name:"Joe", age:12}, {name:"Paula", age:6}).maxOn(x=>x.age)
     *     => Option.of({name:"Joe", age:12})
     *
     * also see [[ConsStream.maxBy]]
     */
    ConsStream.prototype.maxOn = function (getOrderable) {
        return SeqHelpers.maxOn(this, getOrderable);
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     Stream.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    ConsStream.prototype.sumOn = function (getNumber) {
        return SeqHelpers.sumOn(this, getNumber);
    };
    /**
     * Slides a window of a specific size over the sequence.
     * Returns a lazy stream so memory use is not prohibitive.
     *
     *     Stream.of(1,2,3,4,5,6,7,8).sliding(3)
     *     => Stream.of(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8))
     */
    ConsStream.prototype.sliding = function (count) {
        return SeqHelpers.sliding(this, count);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     *
     *     Stream.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)
     *     => Stream.of(0,1,3,6)
     */
    ConsStream.prototype.scanLeft = function (init, fn) {
        var _this = this;
        return new ConsStream(init, Lazy_1.Lazy.of(function () { return _this._tail.get().scanLeft(fn(init, _this.value), fn); }));
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The first element of the result is the final cumulative result.
     *
     *     Stream.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)
     *     => Stream.of(6,5,3,0)
     */
    ConsStream.prototype.scanRight = function (init, fn) {
        // can't be lazy
        var fn2 = function (x, y) { return fn(y, x); };
        return this.reverse().scanLeft(init, fn2).reverse();
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     Vector.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     */
    ConsStream.prototype.mkString = function (separator) {
        var r = "";
        var curItem = this;
        var isNotFirst = false;
        while (!curItem.isEmpty()) {
            if (isNotFirst) {
                r += separator;
            }
            r += SeqHelpers.toStringHelper(curItem.value, { quoteStrings: false });
            curItem = curItem._tail.get();
            isNotFirst = true;
        }
        return r;
    };
    /**
     * Convert to array.
     * Don't do it on an infinite stream!
     */
    ConsStream.prototype.toArray = function () {
        var r = [];
        var curItem = this;
        while (!curItem.isEmpty()) {
            r.push(curItem.value);
            curItem = curItem._tail.get();
        }
        return r;
    };
    /**
     * Convert to vector.
     * Don't do it on an infinite stream!
     */
    ConsStream.prototype.toVector = function () {
        return Vector_1.Vector.ofIterable(this.toArray());
    };
    /**
     * Convert this collection to a map. You give a function which
     * for each element in the collection returns a pair. The
     * key of the pair will be used as a key in the map, the value,
     * as a value in the map. If several values get the same key,
     * entries will be lost.
     *
     *     Stream.of(1,2,3).toMap(x=>[x.toString(), x])
     *     => HashMap.of(["1",1], ["2",2], ["3",3])
     */
    ConsStream.prototype.toMap = function (converter) {
        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {
            var converted = converter(cur);
            return acc.put(converted[0], converted[1]);
        });
    };
    /**
     * Convert this collection to a set. Since the elements of the
     * Seq may not support equality, you must pass a function returning
     * a value supporting equality.
     *
     *     Stream.of(1,2,3,3,4).toSet(x=>x)
     *     => HashSet.of(1,2,3,4)
     */
    ConsStream.prototype.toSet = function (converter) {
        return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {
            return acc.add(converter(cur));
        });
    };
    /**
     * Convert this collection to a list.
     */
    ConsStream.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.ofIterable(this);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    ConsStream.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    ConsStream.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (!other || !other.tail) {
            return false;
        }
        Contract_1.contractTrueEquality("Stream.equals", this, other);
        var myVal = this;
        var hisVal = other;
        while (true) {
            if (myVal.isEmpty() !== hisVal.isEmpty()) {
                return false;
            }
            if (myVal.isEmpty()) {
                // they are both empty, end of the stream
                return true;
            }
            var myHead = myVal.value;
            var hisHead = hisVal.value;
            if ((myHead === undefined) !== (hisHead === undefined)) {
                return false;
            }
            if (myHead === undefined || hisHead === undefined) {
                // they are both undefined, the || is for TS's flow analysis
                // so he realizes none of them is undefined after this.
                continue;
            }
            if (!Comparison_1.areEqual(myHead, hisHead)) {
                return false;
            }
            myVal = myVal._tail.get();
            hisVal = hisVal._tail.get();
        }
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    ConsStream.prototype.hashCode = function () {
        var hash = 1;
        var curItem = this;
        while (!curItem.isEmpty()) {
            hash = 31 * hash + Comparison_1.getHashCode(curItem.value);
            curItem = curItem._tail.get();
        }
        return hash;
    };
    ConsStream.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[ConsStream.mkString]]
     */
    ConsStream.prototype.toString = function () {
        var curItem = this;
        var result = "Stream(";
        while (!curItem.isEmpty()) {
            result += SeqHelpers.toStringHelper(curItem.value);
            var tail = curItem._tail;
            if (!tail.isEvaluated()) {
                result += ", ?";
                break;
            }
            curItem = tail.get();
            if (!curItem.isEmpty()) {
                result += ", ";
            }
        }
        return result + ")";
    };
    return ConsStream;
}());
exports.ConsStream = ConsStream;
var emptyStream = new EmptyStream();
//# sourceMappingURL=Stream.js.map
},{"./Option":"node_modules/prelude-ts/dist/src/Option.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./Contract":"node_modules/prelude-ts/dist/src/Contract.js","./Value":"node_modules/prelude-ts/dist/src/Value.js","./HashMap":"node_modules/prelude-ts/dist/src/HashMap.js","./HashSet":"node_modules/prelude-ts/dist/src/HashSet.js","./Lazy":"node_modules/prelude-ts/dist/src/Lazy.js","./LinkedList":"node_modules/prelude-ts/dist/src/LinkedList.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js"}],"node_modules/prelude-ts/dist/src/SeqHelpers.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var Option_1 = require("./Option");
var Stream_1 = require("./Stream");
var Lazy_1 = require("./Lazy");
var HashSet_1 = require("./HashSet");
/**
 * @hidden
 */
function shuffle(array) {
    // https://stackoverflow.com/a/2450976/516188
    var currentIndex = array.length, temporaryValue, randomIndex;
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    return array;
}
exports.shuffle = shuffle;
/**
 * @hidden
 */
function arrangeBy(collection, getKey) {
    return Option_1.Option.of(collection.groupBy(getKey).mapValues(function (v) { return v.single(); }))
        .filter(function (map) { return !map.anyMatch(function (k, v) { return v.isNone(); }); })
        .map(function (map) { return map.mapValues(function (v) { return v.getOrThrow(); }); });
}
exports.arrangeBy = arrangeBy;
/**
 * @hidden
 */
function seqHasTrueEquality(seq) {
    return seq.find(function (x) { return x != null; }).hasTrueEquality();
}
exports.seqHasTrueEquality = seqHasTrueEquality;
/**
 * @hidden
 */
function zipWithIndex(seq) {
    return seq.zip(Stream_1.Stream.iterate(0, function (i) { return i + 1; }));
}
exports.zipWithIndex = zipWithIndex;
/**
 * @hidden
 */
function sortOn(seq, getKeys) {
    return seq.sortBy(function (x, y) {
        for (var _i = 0, getKeys_1 = getKeys; _i < getKeys_1.length; _i++) {
            var getKey = getKeys_1[_i];
            if (getKey.desc) {
                var a = getKey.desc(x);
                var b = getKey.desc(y);
                if (a === b) {
                    continue;
                }
                return a < b ? 1 /* GT */ : -1 /* LT */;
            }
            else {
                var a = getKey(x);
                var b = getKey(y);
                if (a === b) {
                    continue;
                }
                return a > b ? 1 /* GT */ : -1 /* LT */;
            }
        }
        return 0 /* EQ */;
    });
}
exports.sortOn = sortOn;
/**
 * @hidden
 */
function distinctBy(seq, keyExtractor) {
    var knownKeys = HashSet_1.HashSet.empty();
    return seq.filter(function (x) {
        var key = keyExtractor(x);
        var r = knownKeys.contains(key);
        if (!r) {
            knownKeys = knownKeys.add(key);
        }
        return !r;
    });
}
exports.distinctBy = distinctBy;
/**
 * Utility function to help converting a value to string
 * util.inspect seems to depend on node.
 * @hidden
 */
function toStringHelper(obj, options) {
    if (options === void 0) { options = { quoteStrings: true }; }
    if (Array.isArray(obj)) {
        return "[" + obj.map(function (o) { return toStringHelper(o, options); }) + "]";
    }
    if (typeof obj === "string") {
        return options.quoteStrings ? "'" + obj + "'" : obj;
    }
    if (obj && (obj.toString !== Object.prototype.toString)) {
        return obj.toString();
    }
    // We used to use JSON.stringify here, but that will
    // throw an exception if there are cycles, which we
    // absolutely don't want!
    // https://stackoverflow.com/a/48254637/516188
    var customStringify = function (v) {
        var cache = new Set();
        return JSON.stringify(v, function (key, value) {
            if (typeof value === 'object' && value !== null) {
                if (cache.has(value)) {
                    // Circular reference found, discard key
                    return;
                }
                // Store value in our set
                cache.add(value);
            }
            return value;
        });
    };
    return customStringify(obj);
}
exports.toStringHelper = toStringHelper;
/**
 * @hidden
 */
function minBy(coll, compare) {
    return coll.reduce(function (v1, v2) { return compare(v1, v2) < 0 ? v2 : v1; });
}
exports.minBy = minBy;
/**
 * @hidden
 */
function minOn(coll, getSortable) {
    if (coll.isEmpty()) {
        return Option_1.Option.none();
    }
    var iter = coll[Symbol.iterator]();
    var step = iter.next();
    var val = getSortable(step.value);
    var result = step.value;
    while (!(step = iter.next()).done) {
        var curVal = getSortable(step.value);
        if (curVal < val) {
            val = curVal;
            result = step.value;
        }
    }
    return Option_1.Option.of(result);
}
exports.minOn = minOn;
/**
 * @hidden
 */
function maxBy(coll, compare) {
    return coll.reduce(function (v1, v2) { return compare(v1, v2) > 0 ? v2 : v1; });
}
exports.maxBy = maxBy;
/**
 * @hidden
 */
function maxOn(coll, getSortable) {
    if (coll.isEmpty()) {
        return Option_1.Option.none();
    }
    var iter = coll[Symbol.iterator]();
    var step = iter.next();
    var val = getSortable(step.value);
    var result = step.value;
    while (!(step = iter.next()).done) {
        var curVal = getSortable(step.value);
        if (curVal > val) {
            val = curVal;
            result = step.value;
        }
    }
    return Option_1.Option.of(result);
}
exports.maxOn = maxOn;
/**
 * @hidden
 */
function sumOn(coll, getNumber) {
    return coll.foldLeft(0, function (soFar, cur) { return soFar + getNumber(cur); });
}
exports.sumOn = sumOn;
/**
 * @hidden
 */
function reduce(coll, combine) {
    if (coll.isEmpty()) {
        return Option_1.Option.none();
    }
    var iter = coll[Symbol.iterator]();
    var step = iter.next();
    var result = step.value;
    while (!(step = iter.next()).done) {
        result = combine(result, step.value);
    }
    return Option_1.Option.of(result);
}
exports.reduce = reduce;
/**
 * @hidden
 */
function sliding(seq, count) {
    // in a way should get better performance with Seq.splitAt instead
    // of Seq.take+Seq.drop, but we should be lazy and not hold another
    // version of the sequence in memory (though for linked list it's free,
    // it's not the case for Vector)
    return seq.isEmpty() ?
        Stream_1.Stream.empty() :
        new Stream_1.ConsStream(seq.take(count), Lazy_1.Lazy.of(function () { return sliding(seq.drop(count), count); }));
}
exports.sliding = sliding;
/**
 * @hidden
 */
function removeAll(seq, elts) {
    var toRemove = HashSet_1.HashSet.ofIterable(elts);
    // I know T must have equality since the parameter has it and is the same type.
    return seq.filter(function (x) { return !toRemove.contains(x); });
}
exports.removeAll = removeAll;
//# sourceMappingURL=SeqHelpers.js.map
},{"./Option":"node_modules/prelude-ts/dist/src/Option.js","./Stream":"node_modules/prelude-ts/dist/src/Stream.js","./Lazy":"node_modules/prelude-ts/dist/src/Lazy.js","./HashSet":"node_modules/prelude-ts/dist/src/HashSet.js"}],"node_modules/prelude-ts/dist/src/HashMap.js":[function(require,module,exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Comparison_1 = require("./Comparison");
var SeqHelpers_1 = require("./SeqHelpers");
var Contract_1 = require("./Contract");
var Option_1 = require("./Option");
var HashSet_1 = require("./HashSet");
var Vector_1 = require("./Vector");
var LinkedList_1 = require("./LinkedList");
var SeqHelpers = require("./SeqHelpers");
var Value_1 = require("./Value");
var hamt = require("hamt_plus");
// HashMap could extend Collection, conceptually. But I'm
// not super happy of having the callbacks get a pair, for instance
// 'HashMap.filter' takes two parameters in the current HashMap;
// if HashMap did implement Collection, it would have to take a k,v
// pair. There's also another trick with 'contains'. The Collection signature
// says T&WithEquality, but here we get [K&WithEquality,V&WithEquality],
// but arrays don't have equality so that doesn't type-check :-(
/**
 * A dictionary, mapping keys to values.
 * @param K the key type
 * @param V the value type
 */
var HashMap = /** @class */ (function () {
    /**
     * @hidden
     */
    function HashMap(hamt) {
        this.hamt = hamt;
    }
    /**
     * The empty map.
     * @param K the key type
     * @param V the value type
     */
    HashMap.empty = function () {
        return emptyHashMap;
    };
    /**
     * Build a HashMap from key-value pairs.
     *
     *     HashMap.of([1,"a"],[2,"b"])
     *
     */
    HashMap.of = function () {
        var entries = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            entries[_i] = arguments[_i];
        }
        return HashMap.ofIterable(entries);
    };
    /**
     * Build a HashMap from an iterable containing key-value pairs.
     *
     *    HashMap.ofIterable(Vector.of<[number,string]>([1,"a"],[2,"b"]));
     */
    HashMap.ofIterable = function (entries) {
        // remember we must set up the hamt with the custom equality
        var iterator = entries[Symbol.iterator]();
        var curItem = iterator.next();
        if (curItem.done) {
            return new EmptyHashMap();
        }
        // emptyhashmap.put sets up the custom equality+hashcode
        var startH = (new EmptyHashMap()).put(curItem.value[0], curItem.value[1]).hamt;
        curItem = iterator.next();
        return new HashMap(startH.mutate(function (h) {
            while (!curItem.done) {
                h.set(curItem.value[0], curItem.value[1]);
                curItem = iterator.next();
            }
        }));
    };
    /**
     * Build a HashMap from a javascript object literal representing
     * a dictionary. Note that the key type must always be string,
     * as that's the way it works in javascript.
     * Also note that entries with undefined values will be stripped
     * from the map.
     *
     *     HashMap.ofObjectDictionary<number>({a:1,b:2})
     *     => HashMap.of(["a",1],["b",2])
     */
    HashMap.ofObjectDictionary = function (object) {
        // no need to bother with the proper equals & hashcode
        // as I know the key type supports ===
        var h = hamt.make().beginMutation();
        for (var property in object) {
            // the reason we strip entries with undefined values on
            // import from object dictionaries are: sanity, and also
            // partial object definitions like {[TKey in MyEnum]?:number}
            // where typescript sees the value type as 'number|undefined'
            // (there is a test covering that)
            if (object.hasOwnProperty(property) &&
                (typeof object[property] !== "undefined")) {
                h.set(property, object[property]);
            }
        }
        return new HashMap(h.endMutation());
    };
    /**
     * Curried predicate to find out whether the HashMap is empty.
     *
     *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())
     *         .filter(HashMap.isEmpty)
     *     => Vector.of(HashMap.empty<number,number>())
     */
    HashMap.isEmpty = function (v) {
        return v.isEmpty();
    };
    /**
     * Curried predicate to find out whether the HashMap is empty.
     *
     *     Vector.of(HashMap.of([1,2]), HashMap.empty<number,number>())
     *         .filter(HashMap.isNotEmpty)
     *     => Vector.of(HashMap.of([1,2]))
     */
    HashMap.isNotEmpty = function (v) {
        return !v.isEmpty();
    };
    /**
     * Get the value for the key you give, if the key is present.
     */
    HashMap.prototype.get = function (k) {
        return Option_1.Option.of(this.hamt.get(k));
    };
    /**
     * Implementation of the Iterator interface.
     */
    HashMap.prototype[Symbol.iterator] = function () {
        return this.hamt.entries();
    };
    /**
     * @hidden
     */
    HashMap.prototype.hasTrueEquality = function () {
        // for true equality, need both key & value to have true
        // equality. but i can't check when they're in an array,
        // as array doesn't have true equality => extract them
        // and check them separately.
        return Option_1.Option.of(this.hamt.entries().next().value)
            .map(function (x) { return x[0]; }).hasTrueEquality() &&
            Option_1.Option.of(this.hamt.entries().next().value)
                .map(function (x) { return x[1]; }).hasTrueEquality();
    };
    /**
     * Add a new entry in the map. If there was entry with the same
     * key, it will be overwritten.
     * @param k the key
     * @param v the value
     */
    HashMap.prototype.put = function (k, v) {
        return new HashMap(this.hamt.set(k, v));
    };
    /**
     * Return a new map with the key you give removed.
     */
    HashMap.prototype.remove = function (k) {
        return new HashMap(this.hamt.remove(k));
    };
    /**
     * Add a new entry in the map; in case there was already an
     * entry with the same key, the merge function will be invoked
     * with the old and the new value to produce the value to take
     * into account.
     *
     * It is guaranteed that the merge function first parameter
     * will be the entry from this map, and the second parameter
     * from the map you give.
     * @param k the key
     * @param v the value
     * @param merge a function to merge old and new values in case of conflict.
     */
    HashMap.prototype.putWithMerge = function (k, v, merge) {
        return new HashMap(this.hamt.modify(k, function (curV) {
            if (curV === undefined) {
                return v;
            }
            return merge(curV, v);
        }));
    };
    /**
     * number of items in the map
     */
    HashMap.prototype.length = function () {
        return this.hamt.size;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    HashMap.prototype.single = function () {
        return this.hamt.size === 1
            ? Option_1.Option.of(this.hamt.entries().next().value)
            : Option_1.Option.none();
    };
    /**
     * true if the map is empty, false otherwise.
     */
    HashMap.prototype.isEmpty = function () {
        return this.hamt.size === 0;
    };
    /**
     * Get a Set containing all the keys in the map
     */
    HashMap.prototype.keySet = function () {
        return HashSet_1.HashSet.ofIterable(this.hamt.keys());
    };
    /**
     * Get an iterable containing all the values in the map
     * (can't return a set as we don't constrain map values
     * to have equality in the generics type)
     */
    HashMap.prototype.valueIterable = function () {
        var _a;
        var hamt = this.hamt;
        return _a = {},
            _a[Symbol.iterator] = function () { return hamt.values(); },
            _a;
    };
    /**
     * Create a new map combining the entries of this map, and
     * the other map you give. In case an entry from this map
     * and the other map have the same key, the merge function
     * will be invoked to get a combined value.
     *
     * It is guaranteed that the merge function first parameter
     * will be the entry from this map, and the second parameter
     * from the map you give.
     * @param other another map to merge with this one
     * @param merge a merge function to combine two values
     *        in case two entries share the same key.
     */
    HashMap.prototype.mergeWith = function (elts, merge) {
        var iterator = elts[Symbol.iterator]();
        var map = this;
        var curItem = iterator.next();
        while (!curItem.done) {
            map = map.putWithMerge(curItem.value[0], curItem.value[1], merge);
            curItem = iterator.next();
        }
        return map;
    };
    /**
     * Return a new map where each entry was transformed
     * by the mapper function you give. You return key,value
     * as pairs.
     */
    HashMap.prototype.map = function (fn) {
        return this.hamt.fold(function (acc, value, key) {
            var _a = fn(key, value), newk = _a[0], newv = _a[1];
            return acc.put(newk, newv);
        }, HashMap.empty());
    };
    /**
     * Return a new map where keys are the same as in this one,
     * but values are transformed
     * by the mapper function you give. You return key,value
     * as pairs.
     */
    HashMap.prototype.mapValues = function (fn) {
        return this.hamt.fold(function (acc, value, key) {
            return acc.put(key, fn(value));
        }, HashMap.empty());
    };
    /**
     * Call a function for element in the collection.
     */
    HashMap.prototype.forEach = function (fun) {
        var iterator = this.hamt.entries();
        var curItem = iterator.next();
        while (!curItem.done) {
            fun(curItem.value);
            curItem = iterator.next();
        }
        return this;
    };
    /**
     * Calls the function you give for each item in the map,
     * your function returns a map, all the maps are
     * merged.
     */
    HashMap.prototype.flatMap = function (fn) {
        return this.foldLeft(HashMap.empty(), function (soFar, cur) { return soFar.mergeWith(fn(cur[0], cur[1]), function (a, b) { return b; }); });
    };
    /**
     * Returns true if the predicate returns true for all the
     * elements in the collection.
     */
    HashMap.prototype.allMatch = function (predicate) {
        var iterator = this.hamt.entries();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (!predicate(curItem.value[0], curItem.value[1])) {
                return false;
            }
            curItem = iterator.next();
        }
        return true;
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    HashMap.prototype.anyMatch = function (predicate) {
        var iterator = this.hamt.entries();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value[0], curItem.value[1])) {
                return true;
            }
            curItem = iterator.next();
        }
        return false;
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    HashMap.prototype.contains = function (val) {
        return Comparison_1.areEqual(this.hamt.get(val[0]), val[1]);
    };
    /**
     * Returns true if there is item with that key in the collection,
     * false otherwise.
     *
     *     HashMap.of<number,string>([1,"a"],[2,"b"]).containsKey(1);
     *     => true
     *
     *     HashMap.of<number,string>([1,"a"],[2,"b"]).containsKey(3);
     *     => false
     */
    HashMap.prototype.containsKey = function (key) {
        return this.hamt.has(key);
    };
    /**
     * Call a predicate for each element in the collection,
     * build a new collection holding only the elements
     * for which the predicate returned true.
     */
    HashMap.prototype.filter = function (predicate) {
        var _this = this;
        return new HashMap(hamt.make({ hash: this.hamt._config.hash, keyEq: this.hamt._config.keyEq }).mutate(function (h) {
            var iterator = _this.hamt.entries();
            var curItem = iterator.next();
            while (!curItem.done) {
                if (predicate(curItem.value[0], curItem.value[1])) {
                    h.set(curItem.value[0], curItem.value[1]);
                }
                curItem = iterator.next();
            }
        }));
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     * We name the method findAny instead of find to emphasize
     * that there is not ordering in a hashset.
     *
     *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])
     *         .findAny((k,v) => k>=2 && v === "c")
     *     => Option.of([3,'c'])
     *
     *     HashMap.of<number,string>([1,'a'],[2,'b'],[3,'c'])
     *         .findAny((k,v) => k>=3 && v === "b")
     *     => Option.none<[number,string]>()
     */
    HashMap.prototype.findAny = function (predicate) {
        var iterator = this.hamt.entries();
        var curItem = iterator.next();
        while (!curItem.done) {
            if (predicate(curItem.value[0], curItem.value[1])) {
                return Option_1.Option.of(curItem.value);
            }
            curItem = iterator.next();
        }
        return Option_1.Option.none();
    };
    HashMap.prototype.filterKeys = function (predicate) {
        return this.filter(function (k, v) { return predicate(k); });
    };
    HashMap.prototype.filterValues = function (predicate) {
        return this.filter(function (k, v) { return predicate(v); });
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     HashMap.of<number,string>([1,"a"],[2,"b"],[3,"c"])
     *      .fold([0,""], ([a,b],[c,d])=>[a+c, b>d?b:d])
     *     => [6,"c"]
     */
    HashMap.prototype.fold = function (zero, fn) {
        return this.foldLeft(zero, fn);
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     * No guarantees for the order of items in a hashset!
     *
     * Example:
     *
     *     HashMap.of([1,"a"], [2,"bb"], [3,"ccc"])
     *     .foldLeft(0, (soFar,[item,val])=>soFar+val.length);
     *     => 6
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    HashMap.prototype.foldLeft = function (zero, fn) {
        return this.hamt.fold(function (acc, v, k) {
            return fn(acc, [k, v]);
        }, zero);
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     * No guarantees for the order of items in a hashset!
     *
     * Example:
     *
     *     HashMap.of([1,"a"], [2,"bb"], [3,"ccc"])
     *     .foldRight(0, ([item,value],soFar)=>soFar+value.length);
     *     => 6
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    HashMap.prototype.foldRight = function (zero, fn) {
        return this.foldLeft(zero, function (cur, soFar) { return fn(soFar, cur); });
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    HashMap.prototype.reduce = function (combine) {
        // not really glorious with any...
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Convert to array.
     */
    HashMap.prototype.toArray = function () {
        return this.hamt.fold(function (acc, value, key) { acc.push([key, value]); return acc; }, []);
    };
    /**
     * Convert this map to a vector of key,value pairs.
     * Note that Map is already an iterable of key,value pairs!
     */
    HashMap.prototype.toVector = function () {
        return this.hamt.fold(function (acc, value, key) {
            return acc.append([key, value]);
        }, Vector_1.Vector.empty());
    };
    /**
     * Convert this map to a list of key,value pairs.
     * Note that Map is already an iterable of key,value pairs!
     */
    HashMap.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.ofIterable(this);
    };
    /**
     * Convert to a javascript object dictionary
     * You must provide a function to convert the
     * key to a string.
     *
     *     HashMap.of<string,number>(["a",1],["b",2])
     *         .toObjectDictionary(x=>x);
     *     => {a:1,b:2}
     */
    HashMap.prototype.toObjectDictionary = function (keyConvert) {
        return this.foldLeft({}, function (soFar, cur) {
            soFar[keyConvert(cur[0])] = cur[1];
            return soFar;
        });
    };
    HashMap.prototype.toJsMap = function (keyConvert) {
        return this.foldLeft(new Map(), function (soFar, cur) { return soFar.set(keyConvert(cur[0]), cur[1]); });
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    HashMap.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    HashMap.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (!other || !other.valueIterable) {
            return false;
        }
        Contract_1.contractTrueEquality("HashMap.equals", this, other);
        var sz = this.hamt.size;
        if (other.length() === 0 && sz === 0) {
            // we could get that i'm not the empty map
            // but my size is zero, after some filtering and such.
            return true;
        }
        if (sz !== other.length()) {
            return false;
        }
        var keys = Array.from(this.hamt.keys());
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var myVal = this.hamt.get(k);
            var hisVal = other.get(k).getOrUndefined();
            if (myVal === undefined || hisVal === undefined) {
                return false;
            }
            if (!Comparison_1.areEqual(myVal, hisVal)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    HashMap.prototype.hashCode = function () {
        return this.hamt.fold(function (acc, value, key) {
            return Comparison_1.getHashCode(key) + Comparison_1.getHashCode(value);
        }, 0);
    };
    /*
     * Get a human-friendly string representation of that value.
     */
    HashMap.prototype.toString = function () {
        return "HashMap(" +
            this.hamt.fold(function (acc, value, key) {
                acc.push(SeqHelpers_1.toStringHelper(key, { quoteStrings: false }) +
                    ": " + SeqHelpers_1.toStringHelper(value));
                return acc;
            }, [])
                .join(", ") + ")";
    };
    HashMap.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return HashMap;
}());
exports.HashMap = HashMap;
// we need to override the empty hashmap
// because i don't know how to get the hash & keyset
// functions for the keys without a key value to get
// the functions from
var EmptyHashMap = /** @class */ (function (_super) {
    __extends(EmptyHashMap, _super);
    function EmptyHashMap() {
        return _super.call(this, {}) || this;
    }
    EmptyHashMap.prototype.get = function (k) {
        return Option_1.none;
    };
    EmptyHashMap.prototype[Symbol.iterator] = function () {
        return { next: function () { return ({ done: true, value: undefined }); } };
    };
    EmptyHashMap.prototype.put = function (k, v) {
        Contract_1.contractTrueEquality("Error building a HashMap", k);
        if (Comparison_1.hasEquals(k)) {
            return new HashMap(hamt.make({
                hash: function (v) { return v.hashCode(); },
                keyEq: function (a, b) { return a.equals(b); }
            }).set(k, v));
        }
        return new HashMap(hamt.make().set(k, v));
    };
    EmptyHashMap.prototype.remove = function (k) {
        return this;
    };
    EmptyHashMap.prototype.hasTrueEquality = function () {
        return true;
    };
    EmptyHashMap.prototype.putWithMerge = function (k, v, merge) {
        return this.put(k, v);
    };
    EmptyHashMap.prototype.length = function () {
        return 0;
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    EmptyHashMap.prototype.single = function () {
        return Option_1.Option.none();
    };
    EmptyHashMap.prototype.isEmpty = function () {
        return true;
    };
    EmptyHashMap.prototype.keySet = function () {
        return HashSet_1.HashSet.empty();
    };
    EmptyHashMap.prototype.valueIterable = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                return {
                    next: function () {
                        return {
                            done: true,
                            value: undefined
                        };
                    }
                };
            },
            _a;
    };
    EmptyHashMap.prototype.mergeWith = function (other, merge) {
        return HashMap.ofIterable(other);
    };
    EmptyHashMap.prototype.map = function (fn) {
        return HashMap.empty();
    };
    EmptyHashMap.prototype.mapValues = function (fn) {
        return HashMap.empty();
    };
    EmptyHashMap.prototype.forEach = function (fun) {
        return this;
    };
    EmptyHashMap.prototype.allMatch = function (predicate) {
        return true;
    };
    EmptyHashMap.prototype.anyMatch = function (predicate) {
        return false;
    };
    EmptyHashMap.prototype.contains = function (val) {
        return false;
    };
    EmptyHashMap.prototype.containsKey = function (key) {
        return false;
    };
    EmptyHashMap.prototype.filter = function (predicate) {
        return this;
    };
    EmptyHashMap.prototype.findAny = function (predicate) {
        return Option_1.Option.none();
    };
    EmptyHashMap.prototype.foldLeft = function (zero, fn) {
        return zero;
    };
    EmptyHashMap.prototype.toArray = function () {
        return [];
    };
    EmptyHashMap.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    EmptyHashMap.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.empty();
    };
    EmptyHashMap.prototype.equals = function (other) {
        if (!other || !other.valueIterable) {
            return false;
        }
        return other === emptyHashMap || other.length() === 0;
    };
    EmptyHashMap.prototype.hashCode = function () {
        return 0;
    };
    EmptyHashMap.prototype.toString = function () {
        return "HashMap()";
    };
    return EmptyHashMap;
}(HashMap));
var emptyHashMap = new EmptyHashMap();
//# sourceMappingURL=HashMap.js.map
},{"./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js","./Contract":"node_modules/prelude-ts/dist/src/Contract.js","./Option":"node_modules/prelude-ts/dist/src/Option.js","./HashSet":"node_modules/prelude-ts/dist/src/HashSet.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./LinkedList":"node_modules/prelude-ts/dist/src/LinkedList.js","./Value":"node_modules/prelude-ts/dist/src/Value.js","hamt_plus":"node_modules/hamt_plus/hamt.js"}],"node_modules/list/dist/es/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backwards = backwards;
exports.list = list;
exports.empty = empty;
exports.of = of;
exports.pair = pair;
exports.from = from;
exports.range = range;
exports.repeat = repeat;
exports.times = times;
exports.nth = nth;
exports.prepend = prepend;
exports.append = append;
exports.length = length;
exports.first = first;
exports.last = last;
exports.map = map;
exports.pluck = pluck;
exports.foldl = foldl;
exports.traverse = traverse;
exports.sequence = sequence;
exports.scan = scan;
exports.forEach = forEach;
exports.filter = filter;
exports.reject = reject;
exports.partition = partition;
exports.join = join;
exports.foldr = foldr;
exports.ap = ap;
exports.flatten = flatten;
exports.flatMap = flatMap;
exports.foldlWhile = foldlWhile;
exports.every = every;
exports.some = some;
exports.none = none;
exports.find = find;
exports.findLast = findLast;
exports.indexOf = indexOf;
exports.lastIndexOf = lastIndexOf;
exports.findIndex = findIndex;
exports.includes = includes;
exports.equals = equals;
exports.equalsWith = equalsWith;
exports.concat = concat;
exports.update = update;
exports.adjust = adjust;
exports.slice = slice;
exports.take = take;
exports.takeWhile = takeWhile;
exports.takeLastWhile = takeLastWhile;
exports.dropWhile = dropWhile;
exports.dropRepeats = dropRepeats;
exports.dropRepeatsWith = dropRepeatsWith;
exports.takeLast = takeLast;
exports.splitAt = splitAt;
exports.splitWhen = splitWhen;
exports.splitEvery = splitEvery;
exports.remove = remove;
exports.drop = drop;
exports.dropLast = dropLast;
exports.pop = pop;
exports.tail = tail;
exports.toArray = toArray;
exports.insert = insert;
exports.insertAll = insertAll;
exports.reverse = reverse;
exports.isList = isList;
exports.zip = zip;
exports.zipWith = zipWith;
exports.sort = sort;
exports.sortWith = sortWith;
exports.sortBy = sortBy;
exports.group = group;
exports.groupWith = groupWith;
exports.intersperse = intersperse;
exports.isEmpty = isEmpty;
exports.init = exports.contains = exports.any = exports.all = exports.reduceWhile = exports.chain = exports.reduceRight = exports.reduce = exports.List = exports.Node = void 0;

var __extends = void 0 && (void 0).__extends ||
/*#__PURE__*/
function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var branchingFactor = 32;
var branchBits = 5;
var mask = 31;

function isSetoid(a) {
  return a && typeof a["fantasy-land/equals"] === "function";
}

function elementEquals(a, b) {
  if (a === b) {
    return true;
  } else if (isSetoid(a)) {
    return a["fantasy-land/equals"](b);
  } else {
    return false;
  }
}

function createPath(depth, value) {
  var current = value;

  for (var i = 0; i < depth; ++i) {
    current = new Node(undefined, [current]);
  }

  return current;
}

function copyArray(source) {
  var array = [];

  for (var i = 0; i < source.length; ++i) {
    array[i] = source[i];
  }

  return array;
}

function pushElements(source, target, offset, amount) {
  for (var i = offset; i < offset + amount; ++i) {
    target.push(source[i]);
  }
}

function copyIndices(source, sourceStart, target, targetStart, length) {
  for (var i = 0; i < length; ++i) {
    target[targetStart + i] = source[sourceStart + i];
  }
}

function arrayPrepend(value, array) {
  var newLength = array.length + 1;
  var result = new Array(newLength);
  result[0] = value;

  for (var i = 1; i < newLength; ++i) {
    result[i] = array[i - 1];
  }

  return result;
}

function reverseArray(array) {
  return array.slice().reverse();
}

function arrayFirst(array) {
  return array[0];
}

function arrayLast(array) {
  return array[array.length - 1];
}

var pathResult = {
  path: 0,
  index: 0,
  updatedOffset: 0
};

function getPath(index, offset, depth, sizes) {
  if (sizes === undefined && offset !== 0) {
    pathResult.updatedOffset = 0;
    index = handleOffset(depth, offset, index);
  }

  var path = index >> depth * branchBits & mask;

  if (sizes !== undefined) {
    while (sizes[path] <= index) {
      path++;
    }

    var traversed = path === 0 ? 0 : sizes[path - 1];
    index -= traversed;
    pathResult.updatedOffset = offset;
  }

  pathResult.path = path;
  pathResult.index = index;
  return pathResult;
}

function updateNode(node, depth, index, offset, value) {
  var _a = getPath(index, offset, depth, node.sizes),
      path = _a.path,
      newIndex = _a.index,
      updatedOffset = _a.updatedOffset;

  var array = copyArray(node.array);
  array[path] = depth > 0 ? updateNode(array[path], depth - 1, newIndex, updatedOffset, value) : value;
  return new Node(node.sizes, array);
}

var Node =
/*#__PURE__*/
function () {
  function Node(sizes, array) {
    this.sizes = sizes;
    this.array = array;
  }

  return Node;
}();

exports.Node = Node;

function cloneNode(_a) {
  var sizes = _a.sizes,
      array = _a.array;
  return new Node(sizes === undefined ? undefined : copyArray(sizes), copyArray(array));
}

var emptyAffix = [0];
var affixBits = 6;
var affixMask = 63;

function getSuffixSize(l) {
  return l.bits & affixMask;
}

function getPrefixSize(l) {
  return l.bits >> affixBits & affixMask;
}

function getDepth(l) {
  return l.bits >> affixBits * 2;
}

function setPrefix(size, bits) {
  return size << affixBits | bits & ~(affixMask << affixBits);
}

function setSuffix(size, bits) {
  return size | bits & ~affixMask;
}

function setDepth(depth, bits) {
  return depth << affixBits * 2 | bits & (affixMask | affixMask << affixBits);
}

function incrementPrefix(bits) {
  return bits + (1 << affixBits);
}

function incrementSuffix(bits) {
  return bits + 1;
}

function incrementDepth(bits) {
  return bits + (1 << affixBits * 2);
}

function decrementDepth(bits) {
  return bits - (1 << affixBits * 2);
}

var List =
/*#__PURE__*/
function () {
  function List(bits, offset, length, prefix, root, suffix) {
    this.bits = bits;
    this.offset = offset;
    this.length = length;
    this.prefix = prefix;
    this.root = root;
    this.suffix = suffix;
  }

  List.prototype[Symbol.iterator] = function () {
    return new ForwardListIterator(this);
  };

  List.prototype.toJSON = function () {
    return toArray(this);
  };

  return List;
}();

exports.List = List;

function cloneList(l) {
  return new List(l.bits, l.offset, l.length, l.prefix, l.root, l.suffix);
}

var ListIterator =
/*#__PURE__*/
function () {
  function ListIterator(l, direction) {
    this.l = l;
    this.result = {
      done: false,
      value: undefined
    };
    this.idx = direction === 1 ? -1 : l.length;
    this.prefixSize = getPrefixSize(l);
    this.middleSize = l.length - getSuffixSize(l);

    if (l.root !== undefined) {
      var depth = getDepth(l);
      this.stack = new Array(depth + 1);
      this.indices = new Array(depth + 1);
      var currentNode = l.root.array;

      for (var i = depth; 0 <= i; --i) {
        this.stack[i] = currentNode;
        var idx = direction === 1 ? 0 : currentNode.length - 1;
        this.indices[i] = idx;
        currentNode = currentNode[idx].array;
      }

      this.indices[0] -= direction;
    }
  }

  return ListIterator;
}();

var ForwardListIterator =
/*#__PURE__*/
function (_super) {
  __extends(ForwardListIterator, _super);

  function ForwardListIterator(l) {
    return _super.call(this, l, 1) || this;
  }

  ForwardListIterator.prototype.nextInTree = function () {
    for (var i = 0; ++this.indices[i] === this.stack[i].length; ++i) {
      this.indices[i] = 0;
    }

    for (; 0 < i; --i) {
      this.stack[i - 1] = this.stack[i][this.indices[i]].array;
    }
  };

  ForwardListIterator.prototype.next = function () {
    var newVal;
    var idx = ++this.idx;

    if (idx < this.prefixSize) {
      newVal = this.l.prefix[this.prefixSize - idx - 1];
    } else if (idx < this.middleSize) {
      this.nextInTree();
      newVal = this.stack[0][this.indices[0]];
    } else if (idx < this.l.length) {
      newVal = this.l.suffix[idx - this.middleSize];
    } else {
      this.result.done = true;
    }

    this.result.value = newVal;
    return this.result;
  };

  return ForwardListIterator;
}(ListIterator);

var BackwardsListIterator =
/*#__PURE__*/
function (_super) {
  __extends(BackwardsListIterator, _super);

  function BackwardsListIterator(l) {
    return _super.call(this, l, -1) || this;
  }

  BackwardsListIterator.prototype.prevInTree = function () {
    for (var i = 0; this.indices[i] === 0; ++i) {}

    --this.indices[i];

    for (; 0 < i; --i) {
      var n = this.stack[i][this.indices[i]].array;
      this.stack[i - 1] = n;
      this.indices[i - 1] = n.length - 1;
    }
  };

  BackwardsListIterator.prototype.next = function () {
    var newVal;
    var idx = --this.idx;

    if (this.middleSize <= idx) {
      newVal = this.l.suffix[idx - this.middleSize];
    } else if (this.prefixSize <= idx) {
      this.prevInTree();
      newVal = this.stack[0][this.indices[0]];
    } else if (0 <= idx) {
      newVal = this.l.prefix[this.prefixSize - idx - 1];
    } else {
      this.result.done = true;
    }

    this.result.value = newVal;
    return this.result;
  };

  return BackwardsListIterator;
}(ListIterator);

function backwards(l) {
  var _a;

  return _a = {}, _a[Symbol.iterator] = function () {
    return new BackwardsListIterator(l);
  }, _a;
}

function emptyPushable() {
  return new List(0, 0, 0, [], undefined, []);
}

function push(value, l) {
  var suffixSize = getSuffixSize(l);

  if (l.length === 0) {
    l.bits = setPrefix(1, l.bits);
    l.prefix = [value];
  } else if (suffixSize < 32) {
    l.bits = incrementSuffix(l.bits);
    l.suffix.push(value);
  } else if (l.root === undefined) {
    l.root = new Node(undefined, l.suffix);
    l.suffix = [value];
    l.bits = setSuffix(1, l.bits);
  } else {
    var newNode = new Node(undefined, l.suffix);
    var index = l.length - 1 - 32 + 1;
    var current = l.root;
    var depth = getDepth(l);
    l.suffix = [value];
    l.bits = setSuffix(1, l.bits);

    if (index - 1 < Math.pow(branchingFactor, depth + 1)) {
      for (; depth >= 0; --depth) {
        var path = index >> depth * branchBits & mask;

        if (path < current.array.length) {
          current = current.array[path];
        } else {
          current.array.push(createPath(depth - 1, newNode));
          break;
        }
      }
    } else {
      l.bits = incrementDepth(l.bits);
      l.root = new Node(undefined, [l.root, createPath(depth, newNode)]);
    }
  }

  l.length++;
  return l;
}

function list() {
  var elements = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    elements[_i] = arguments[_i];
  }

  var l = emptyPushable();

  for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {
    var element = elements_1[_a];
    push(element, l);
  }

  return l;
}

function empty() {
  return new List(0, 0, 0, emptyAffix, undefined, emptyAffix);
}

function of(a) {
  return list(a);
}

function pair(first, second) {
  return new List(2, 0, 2, emptyAffix, undefined, [first, second]);
}

function from(sequence) {
  var l = emptyPushable();

  if (sequence.length > 0 && (sequence[0] !== undefined || 0 in sequence)) {
    for (var i = 0; i < sequence.length; ++i) {
      push(sequence[i], l);
    }
  } else if (Symbol.iterator in sequence) {
    var iterator = sequence[Symbol.iterator]();
    var cur = void 0;

    while (!(cur = iterator.next()).done) {
      push(cur.value, l);
    }
  }

  return l;
}

function range(start, end) {
  var list = emptyPushable();

  for (var i = start; i < end; ++i) {
    push(i, list);
  }

  return list;
}

function repeat(value, times) {
  var l = emptyPushable();

  while (--times >= 0) {
    push(value, l);
  }

  return l;
}

function times(func, times) {
  var l = emptyPushable();

  for (var i = 0; i < times; i++) {
    push(func(i), l);
  }

  return l;
}

function nodeNthDense(node, depth, index) {
  var current = node;

  for (; depth >= 0; --depth) {
    current = current.array[index >> depth * branchBits & mask];
  }

  return current;
}

function handleOffset(depth, offset, index) {
  index += offset;

  for (; depth >= 0; --depth) {
    index = index - (offset & mask << depth * branchBits);

    if ((index >> depth * branchBits & mask) !== 0) {
      break;
    }
  }

  return index;
}

function nodeNth(node, depth, offset, index) {
  var path;
  var current = node;

  while (current.sizes !== undefined) {
    path = index >> depth * branchBits & mask;

    while (current.sizes[path] <= index) {
      path++;
    }

    if (path !== 0) {
      index -= current.sizes[path - 1];
      offset = 0;
    }

    depth--;
    current = current.array[path];
  }

  return nodeNthDense(current, depth, offset === 0 ? index : handleOffset(depth, offset, index));
}

function nth(index, l) {
  if (index < 0 || l.length <= index) {
    return undefined;
  }

  var prefixSize = getPrefixSize(l);
  var suffixSize = getSuffixSize(l);

  if (index < prefixSize) {
    return l.prefix[prefixSize - index - 1];
  } else if (index >= l.length - suffixSize) {
    return l.suffix[index - (l.length - suffixSize)];
  }

  var offset = l.offset;
  var depth = getDepth(l);
  return l.root.sizes === undefined ? nodeNthDense(l.root, depth, offset === 0 ? index - prefixSize : handleOffset(depth, offset, index - prefixSize)) : nodeNth(l.root, depth, offset, index - prefixSize);
}

function setSizes(node, height) {
  var sum = 0;
  var sizeTable = [];

  for (var i = 0; i < node.array.length; ++i) {
    sum += sizeOfSubtree(node.array[i], height - 1);
    sizeTable[i] = sum;
  }

  node.sizes = sizeTable;
  return node;
}

function sizeOfSubtree(node, height) {
  if (height !== 0) {
    if (node.sizes !== undefined) {
      return arrayLast(node.sizes);
    } else {
      var lastSize = sizeOfSubtree(arrayLast(node.array), height - 1);
      return (node.array.length - 1 << height * branchBits) + lastSize;
    }
  } else {
    return node.array.length;
  }
}

function affixPush(a, array, length) {
  if (array.length === length) {
    array.push(a);
    return array;
  } else {
    var newArray = [];
    copyIndices(array, 0, newArray, 0, length);
    newArray.push(a);
    return newArray;
  }
}

function prepend(value, l) {
  var prefixSize = getPrefixSize(l);

  if (prefixSize < 32) {
    return new List(incrementPrefix(l.bits), l.offset, l.length + 1, affixPush(value, l.prefix, prefixSize), l.root, l.suffix);
  } else {
    var newList = cloneList(l);
    prependNodeToTree(newList, reverseArray(l.prefix));
    var newPrefix = [value];
    newList.prefix = newPrefix;
    newList.length++;
    newList.bits = setPrefix(1, newList.bits);
    return newList;
  }
}

function copyLeft(l, k) {
  var currentNode = cloneNode(l.root);
  l.root = currentNode;

  for (var i = 1; i < k; ++i) {
    var index = 0;

    if (currentNode.sizes !== undefined) {
      for (var i_1 = 0; i_1 < currentNode.sizes.length; ++i_1) {
        currentNode.sizes[i_1] += 32;
      }
    }

    var newNode = cloneNode(currentNode.array[index]);
    currentNode.array[index] = newNode;
    currentNode = newNode;
  }

  return currentNode;
}

function nodePrepend(value, size, node) {
  var array = arrayPrepend(value, node.array);
  var sizes = undefined;

  if (node.sizes !== undefined) {
    sizes = new Array(node.sizes.length + 1);
    sizes[0] = size;

    for (var i = 0; i < node.sizes.length; ++i) {
      sizes[i + 1] = node.sizes[i] + size;
    }
  }

  return new Node(sizes, array);
}

function prependTopTree(l, depth, node) {
  var newOffset;

  if (l.root.array.length < branchingFactor) {
    newOffset = Math.pow(32, depth) - 32;
    l.root = new Node(undefined, arrayPrepend(createPath(depth - 1, node), l.root.array));
  } else {
    l.bits = incrementDepth(l.bits);
    var sizes = l.root.sizes === undefined ? undefined : [32, arrayLast(l.root.sizes) + 32];
    newOffset = depth === 0 ? 0 : Math.pow(32, depth + 1) - 32;
    l.root = new Node(sizes, [createPath(depth, node), l.root]);
  }

  return newOffset;
}

function prependNodeToTree(l, array) {
  if (l.root === undefined) {
    if (getSuffixSize(l) === 0) {
      l.bits = setSuffix(array.length, l.bits);
      l.suffix = array;
    } else {
      l.root = new Node(undefined, array);
    }

    return l;
  } else {
    var node = new Node(undefined, array);
    var depth = getDepth(l);
    var newOffset_1 = 0;

    if (l.root.sizes === undefined) {
      if (l.offset !== 0) {
        newOffset_1 = l.offset - branchingFactor;
        l.root = prependDense(l.root, depth, l.offset, node);
      } else {
        newOffset_1 = prependTopTree(l, depth, node);
      }
    } else {
      var copyableCount = 0;
      var nodesTraversed = 0;
      var currentNode = l.root;

      while (currentNode.sizes !== undefined && nodesTraversed < depth) {
        ++nodesTraversed;

        if (currentNode.array.length < 32) {
          copyableCount = nodesTraversed;
        }

        currentNode = currentNode.array[0];
      }

      if (l.offset !== 0) {
        var copiedNode = copyLeft(l, nodesTraversed);

        for (var i = 0; i < copiedNode.sizes.length; ++i) {
          copiedNode.sizes[i] += branchingFactor;
        }

        copiedNode.array[0] = prependDense(copiedNode.array[0], depth - nodesTraversed, l.offset, node);
        l.offset = l.offset - branchingFactor;
        return l;
      } else {
        if (copyableCount === 0) {
          l.offset = prependTopTree(l, depth, node);
        } else {
          var parent_1;
          var prependableNode = void 0;

          if (copyableCount > 1) {
            parent_1 = copyLeft(l, copyableCount - 1);
            prependableNode = parent_1.array[0];
          } else {
            parent_1 = undefined;
            prependableNode = l.root;
          }

          var path = createPath(depth - copyableCount, node);
          l.offset = Math.pow(32, depth - copyableCount + 1) - 32;
          var prepended = nodePrepend(path, 32, prependableNode);

          if (parent_1 === undefined) {
            l.root = prepended;
          } else {
            parent_1.array[0] = prepended;
          }
        }

        return l;
      }
    }

    l.offset = newOffset_1;
    return l;
  }
}

function prependDense(node, depth, offset, value) {
  var curOffset = offset >> depth * branchBits & mask;
  var path = (offset - 1 >> depth * branchBits & mask) - curOffset;

  if (path < 0) {
    return new Node(undefined, arrayPrepend(createPath(depth - 1, value), node.array));
  } else {
    var array = copyArray(node.array);
    array[0] = prependDense(array[0], depth - 1, offset, value);
    return new Node(undefined, array);
  }
}

function append(value, l) {
  var suffixSize = getSuffixSize(l);

  if (suffixSize < 32) {
    return new List(incrementSuffix(l.bits), l.offset, l.length + 1, l.prefix, l.root, affixPush(value, l.suffix, suffixSize));
  }

  var newSuffix = [value];
  var newList = cloneList(l);
  appendNodeToTree(newList, l.suffix);
  newList.suffix = newSuffix;
  newList.length++;
  newList.bits = setSuffix(1, newList.bits);
  return newList;
}

function length(l) {
  return l.length;
}

function first(l) {
  var prefixSize = getPrefixSize(l);
  return prefixSize !== 0 ? l.prefix[prefixSize - 1] : l.length !== 0 ? l.suffix[0] : undefined;
}

function last(l) {
  var suffixSize = getSuffixSize(l);
  return suffixSize !== 0 ? l.suffix[suffixSize - 1] : l.length !== 0 ? l.prefix[0] : undefined;
}

function mapArray(f, array) {
  var result = new Array(array.length);

  for (var i = 0; i < array.length; ++i) {
    result[i] = f(array[i]);
  }

  return result;
}

function mapNode(f, node, depth) {
  if (depth !== 0) {
    var array = node.array;
    var result = new Array(array.length);

    for (var i = 0; i < array.length; ++i) {
      result[i] = mapNode(f, array[i], depth - 1);
    }

    return new Node(node.sizes, result);
  } else {
    return new Node(undefined, mapArray(f, node.array));
  }
}

function mapPrefix(f, prefix, length) {
  var newPrefix = new Array(length);

  for (var i = length - 1; 0 <= i; --i) {
    newPrefix[i] = f(prefix[i]);
  }

  return newPrefix;
}

function mapAffix(f, suffix, length) {
  var newSuffix = new Array(length);

  for (var i = 0; i < length; ++i) {
    newSuffix[i] = f(suffix[i]);
  }

  return newSuffix;
}

function map(f, l) {
  return new List(l.bits, l.offset, l.length, mapPrefix(f, l.prefix, getPrefixSize(l)), l.root === undefined ? undefined : mapNode(f, l.root, getDepth(l)), mapAffix(f, l.suffix, getSuffixSize(l)));
}

function pluck(key, l) {
  return map(function (a) {
    return a[key];
  }, l);
}

function foldlSuffix(f, acc, array, length) {
  for (var i = 0; i < length; ++i) {
    acc = f(acc, array[i]);
  }

  return acc;
}

function foldlPrefix(f, acc, array, length) {
  for (var i = length - 1; 0 <= i; --i) {
    acc = f(acc, array[i]);
  }

  return acc;
}

function foldlNode(f, acc, node, depth) {
  var array = node.array;

  if (depth === 0) {
    return foldlSuffix(f, acc, array, array.length);
  }

  for (var i = 0; i < array.length; ++i) {
    acc = foldlNode(f, acc, array[i], depth - 1);
  }

  return acc;
}

function foldl(f, initial, l) {
  var suffixSize = getSuffixSize(l);
  var prefixSize = getPrefixSize(l);
  initial = foldlPrefix(f, initial, l.prefix, prefixSize);

  if (l.root !== undefined) {
    initial = foldlNode(f, initial, l.root, getDepth(l));
  }

  return foldlSuffix(f, initial, l.suffix, suffixSize);
}

var reduce = foldl;
exports.reduce = reduce;

function traverse(of, f, l) {
  return foldr(function (a, fl) {
    return fl["fantasy-land/ap"](f(a)["fantasy-land/map"](function (a) {
      return function (l) {
        return prepend(a, l);
      };
    }));
  }, of["fantasy-land/of"](empty()), l);
}

function sequence(ofObj, l) {
  return traverse(ofObj, function (a) {
    return a;
  }, l);
}

function scan(f, initial, l) {
  return foldl(function (l2, a) {
    return push(f(last(l2), a), l2);
  }, push(initial, emptyPushable()), l);
}

function forEach(callback, l) {
  foldl(function (_, element) {
    return callback(element);
  }, undefined, l);
}

function filter(predicate, l) {
  return foldl(function (acc, a) {
    return predicate(a) ? push(a, acc) : acc;
  }, emptyPushable(), l);
}

function reject(predicate, l) {
  return foldl(function (acc, a) {
    return predicate(a) ? acc : push(a, acc);
  }, emptyPushable(), l);
}

function partition(predicate, l) {
  return foldl(function (arr, a) {
    return predicate(a) ? push(a, arr[0]) : push(a, arr[1]), arr;
  }, [emptyPushable(), emptyPushable()], l);
}

function join(separator, l) {
  return foldl(function (a, b) {
    return a.length === 0 ? b : a + separator + b;
  }, "", l);
}

function foldrSuffix(f, initial, array, length) {
  var acc = initial;

  for (var i = length - 1; 0 <= i; --i) {
    acc = f(array[i], acc);
  }

  return acc;
}

function foldrPrefix(f, initial, array, length) {
  var acc = initial;

  for (var i = 0; i < length; ++i) {
    acc = f(array[i], acc);
  }

  return acc;
}

function foldrNode(f, initial, _a, depth) {
  var array = _a.array;

  if (depth === 0) {
    return foldrSuffix(f, initial, array, array.length);
  }

  var acc = initial;

  for (var i = array.length - 1; 0 <= i; --i) {
    acc = foldrNode(f, acc, array[i], depth - 1);
  }

  return acc;
}

function foldr(f, initial, l) {
  var suffixSize = getSuffixSize(l);
  var prefixSize = getPrefixSize(l);
  var acc = foldrSuffix(f, initial, l.suffix, suffixSize);

  if (l.root !== undefined) {
    acc = foldrNode(f, acc, l.root, getDepth(l));
  }

  return foldrPrefix(f, acc, l.prefix, prefixSize);
}

var reduceRight = foldr;
exports.reduceRight = reduceRight;

function ap(listF, l) {
  return flatten(map(function (f) {
    return map(f, l);
  }, listF));
}

function flatten(nested) {
  return foldl(concat, empty(), nested);
}

function flatMap(f, l) {
  return flatten(map(f, l));
}

var chain = flatMap;
exports.chain = chain;

function foldlArrayCb(cb, state, array, from, to) {
  for (var i = from; i < to && cb(array[i], state); ++i) {}

  return i === to;
}

function foldrArrayCb(cb, state, array, from, to) {
  for (var i = from - 1; to <= i && cb(array[i], state); --i) {}

  return i === to - 1;
}

function foldlNodeCb(cb, state, node, depth) {
  var array = node.array;

  if (depth === 0) {
    return foldlArrayCb(cb, state, array, 0, array.length);
  }

  var to = array.length;

  for (var i = 0; i < to; ++i) {
    if (!foldlNodeCb(cb, state, array[i], depth - 1)) {
      return false;
    }
  }

  return true;
}

function foldlCb(cb, state, l) {
  var prefixSize = getPrefixSize(l);

  if (!foldrArrayCb(cb, state, l.prefix, prefixSize, 0) || l.root !== undefined && !foldlNodeCb(cb, state, l.root, getDepth(l))) {
    return state;
  }

  var suffixSize = getSuffixSize(l);
  foldlArrayCb(cb, state, l.suffix, 0, suffixSize);
  return state;
}

function foldrNodeCb(cb, state, node, depth) {
  var array = node.array;

  if (depth === 0) {
    return foldrArrayCb(cb, state, array, array.length, 0);
  }

  for (var i = array.length - 1; 0 <= i; --i) {
    if (!foldrNodeCb(cb, state, array[i], depth - 1)) {
      return false;
    }
  }

  return true;
}

function foldrCb(cb, state, l) {
  var suffixSize = getSuffixSize(l);
  var prefixSize = getPrefixSize(l);

  if (!foldrArrayCb(cb, state, l.suffix, suffixSize, 0) || l.root !== undefined && !foldrNodeCb(cb, state, l.root, getDepth(l))) {
    return state;
  }

  var prefix = l.prefix;
  foldlArrayCb(cb, state, l.prefix, prefix.length - prefixSize, prefix.length);
  return state;
}

function foldlWhileCb(a, state) {
  if (state.predicate(state.result, a) === false) {
    return false;
  }

  state.result = state.f(state.result, a);
  return true;
}

function foldlWhile(predicate, f, initial, l) {
  return foldlCb(foldlWhileCb, {
    predicate: predicate,
    f: f,
    result: initial
  }, l).result;
}

var reduceWhile = foldlWhile;
exports.reduceWhile = reduceWhile;

function everyCb(value, state) {
  return state.result = state.predicate(value);
}

function every(predicate, l) {
  return foldlCb(everyCb, {
    predicate: predicate,
    result: true
  }, l).result;
}

var all = every;
exports.all = all;

function someCb(value, state) {
  return !(state.result = state.predicate(value));
}

function some(predicate, l) {
  return foldlCb(someCb, {
    predicate: predicate,
    result: false
  }, l).result;
}

var any = some;
exports.any = any;

function none(predicate, l) {
  return !some(predicate, l);
}

function findCb(value, state) {
  if (state.predicate(value)) {
    state.result = value;
    return false;
  } else {
    return true;
  }
}

function find(predicate, l) {
  return foldlCb(findCb, {
    predicate: predicate,
    result: undefined
  }, l).result;
}

function findLast(predicate, l) {
  return foldrCb(findCb, {
    predicate: predicate,
    result: undefined
  }, l).result;
}

function indexOfCb(value, state) {
  ++state.index;
  return !(state.found = elementEquals(value, state.element));
}

function indexOf(element, l) {
  var state = {
    element: element,
    found: false,
    index: -1
  };
  foldlCb(indexOfCb, state, l);
  return state.found ? state.index : -1;
}

function lastIndexOf(element, l) {
  var state = {
    element: element,
    found: false,
    index: 0
  };
  foldrCb(indexOfCb, state, l);
  return state.found ? l.length - state.index : -1;
}

function findIndexCb(value, state) {
  ++state.index;
  return !(state.found = state.predicate(value));
}

function findIndex(predicate, l) {
  var _a = foldlCb(findIndexCb, {
    predicate: predicate,
    found: false,
    index: -1
  }, l),
      found = _a.found,
      index = _a.index;

  return found ? index : -1;
}

var containsState = {
  element: undefined,
  result: false
};

function containsCb(value, state) {
  return !(state.result = value === state.element);
}

function includes(element, l) {
  containsState.element = element;
  containsState.result = false;
  return foldlCb(containsCb, containsState, l).result;
}

var contains = includes;
exports.contains = contains;

function equalsCb(value2, state) {
  var value = state.iterator.next().value;
  return state.equals = state.f(value, value2);
}

function equals(l1, l2) {
  return equalsWith(elementEquals, l1, l2);
}

function equalsWith(f, l1, l2) {
  if (l1 === l2) {
    return true;
  } else if (l1.length !== l2.length) {
    return false;
  } else {
    var s = {
      iterator: l2[Symbol.iterator](),
      equals: true,
      f: f
    };
    return foldlCb(equalsCb, s, l1).equals;
  }
}

var eMax = 2;

function createConcatPlan(array) {
  var sizes = [];
  var sum = 0;

  for (var i_2 = 0; i_2 < array.length; ++i_2) {
    sum += array[i_2].array.length;
    sizes[i_2] = array[i_2].array.length;
  }

  var optimalLength = Math.ceil(sum / branchingFactor);
  var n = array.length;
  var i = 0;

  if (optimalLength + eMax >= n) {
    return undefined;
  }

  while (optimalLength + eMax < n) {
    while (sizes[i] > branchingFactor - eMax / 2) {
      ++i;
    }

    var remaining = sizes[i];

    do {
      var size = Math.min(remaining + sizes[i + 1], branchingFactor);
      sizes[i] = size;
      remaining = remaining - (size - sizes[i + 1]);
      ++i;
    } while (remaining > 0);

    for (var j = i; j <= n - 1; ++j) {
      sizes[j] = sizes[j + 1];
    }

    --i;
    --n;
  }

  sizes.length = n;
  return sizes;
}

function concatNodeMerge(left, center, right) {
  var array = [];

  if (left !== undefined) {
    for (var i = 0; i < left.array.length - 1; ++i) {
      array.push(left.array[i]);
    }
  }

  for (var i = 0; i < center.array.length; ++i) {
    array.push(center.array[i]);
  }

  if (right !== undefined) {
    for (var i = 1; i < right.array.length; ++i) {
      array.push(right.array[i]);
    }
  }

  return array;
}

function executeConcatPlan(merged, plan, height) {
  var result = [];
  var sourceIdx = 0;
  var offset = 0;

  for (var _i = 0, plan_1 = plan; _i < plan_1.length; _i++) {
    var toMove = plan_1[_i];
    var source = merged[sourceIdx].array;

    if (toMove === source.length && offset === 0) {
      result.push(merged[sourceIdx]);
      ++sourceIdx;
    } else {
      var node = new Node(undefined, []);

      while (toMove > 0) {
        var available = source.length - offset;
        var itemsToCopy = Math.min(toMove, available);
        pushElements(source, node.array, offset, itemsToCopy);

        if (toMove >= available) {
          ++sourceIdx;
          source = merged[sourceIdx].array;
          offset = 0;
        } else {
          offset += itemsToCopy;
        }

        toMove -= itemsToCopy;
      }

      if (height > 1) {
        setSizes(node, height - 1);
      }

      result.push(node);
    }
  }

  return result;
}

function rebalance(left, center, right, height, top) {
  var merged = concatNodeMerge(left, center, right);
  var plan = createConcatPlan(merged);
  var balanced = plan !== undefined ? executeConcatPlan(merged, plan, height) : merged;

  if (balanced.length <= branchingFactor) {
    if (top === true) {
      return new Node(undefined, balanced);
    } else {
      return new Node(undefined, [setSizes(new Node(undefined, balanced), height)]);
    }
  } else {
    return new Node(undefined, [setSizes(new Node(undefined, balanced.slice(0, branchingFactor)), height), setSizes(new Node(undefined, balanced.slice(branchingFactor)), height)]);
  }
}

function concatSubTree(left, lDepth, right, rDepth, isTop) {
  if (lDepth > rDepth) {
    var c = concatSubTree(arrayLast(left.array), lDepth - 1, right, rDepth, false);
    return rebalance(left, c, undefined, lDepth, isTop);
  } else if (lDepth < rDepth) {
    var c = concatSubTree(left, lDepth, arrayFirst(right.array), rDepth - 1, false);
    return rebalance(undefined, c, right, rDepth, isTop);
  } else if (lDepth === 0) {
    return new Node(undefined, [left, right]);
  } else {
    var c = concatSubTree(arrayLast(left.array), lDepth - 1, arrayFirst(right.array), rDepth - 1, false);
    return rebalance(left, c, right, lDepth, isTop);
  }
}

function getHeight(node) {
  if (node.array[0] instanceof Node) {
    return 1 + getHeight(node.array[0]);
  } else {
    return 0;
  }
}

function appendNodeToTree(l, array) {
  if (l.root === undefined) {
    if (getPrefixSize(l) === 0) {
      l.bits = setPrefix(array.length, l.bits);
      l.prefix = reverseArray(array);
    } else {
      l.root = new Node(undefined, array);
    }

    return l;
  }

  var depth = getDepth(l);
  var index = handleOffset(depth, l.offset, l.length - 1 - getPrefixSize(l));
  var nodesToCopy = 0;
  var nodesVisited = 0;
  var shift = depth * 5;
  var currentNode = l.root;

  if (Math.pow(32, depth + 1) < index) {
    shift = 0;
    nodesVisited = depth;
  }

  while (shift > 5) {
    var childIndex = void 0;

    if (currentNode.sizes === undefined) {
      childIndex = index >> shift & mask;
      index &= ~(mask << shift);
    } else {
      childIndex = currentNode.array.length - 1;
      index -= currentNode.sizes[childIndex - 1];
    }

    nodesVisited++;

    if (childIndex < mask) {
      nodesToCopy = nodesVisited;
    }

    currentNode = currentNode.array[childIndex];

    if (currentNode === undefined) {
      nodesToCopy = nodesVisited;
      shift = 5;
    }

    shift -= 5;
  }

  if (shift !== 0) {
    nodesVisited++;

    if (currentNode.array.length < branchingFactor) {
      nodesToCopy = nodesVisited;
    }
  }

  var node = new Node(undefined, array);

  if (nodesToCopy === 0) {
    var newPath = nodesVisited === 0 ? node : createPath(nodesVisited, node);
    var newRoot = new Node(undefined, [l.root, newPath]);
    l.root = newRoot;
    l.bits = incrementDepth(l.bits);
  } else {
    var copiedNode = copyFirstK(l, nodesToCopy, array.length);
    copiedNode.array.push(createPath(depth - nodesToCopy, node));
  }

  return l;
}

function copyFirstK(newList, k, leafSize) {
  var currentNode = cloneNode(newList.root);
  newList.root = currentNode;

  for (var i = 1; i < k; ++i) {
    var index = currentNode.array.length - 1;

    if (currentNode.sizes !== undefined) {
      currentNode.sizes[index] += leafSize;
    }

    var newNode = cloneNode(currentNode.array[index]);
    currentNode.array[index] = newNode;
    currentNode = newNode;
  }

  if (currentNode.sizes !== undefined) {
    currentNode.sizes.push(arrayLast(currentNode.sizes) + leafSize);
  }

  return currentNode;
}

var concatBuffer =
/*#__PURE__*/
new Array(3);

function concatAffixes(left, right) {
  var nr = 0;
  var arrIdx = 0;
  var i = 0;
  var length = getSuffixSize(left);
  concatBuffer[nr] = [];

  for (i = 0; i < length; ++i) {
    concatBuffer[nr][arrIdx++] = left.suffix[i];
  }

  length = getPrefixSize(right);

  for (i = 0; i < length; ++i) {
    if (arrIdx === 32) {
      arrIdx = 0;
      ++nr;
      concatBuffer[nr] = [];
    }

    concatBuffer[nr][arrIdx++] = right.prefix[length - 1 - i];
  }

  length = getSuffixSize(right);

  for (i = 0; i < length; ++i) {
    if (arrIdx === 32) {
      arrIdx = 0;
      ++nr;
      concatBuffer[nr] = [];
    }

    concatBuffer[nr][arrIdx++] = right.suffix[i];
  }

  return nr;
}

function concat(left, right) {
  if (left.length === 0) {
    return right;
  } else if (right.length === 0) {
    return left;
  }

  var newSize = left.length + right.length;
  var rightSuffixSize = getSuffixSize(right);
  var newList = cloneList(left);

  if (right.root === undefined) {
    var nrOfAffixes = concatAffixes(left, right);

    for (var i = 0; i < nrOfAffixes; ++i) {
      newList = appendNodeToTree(newList, concatBuffer[i]);
      newList.length += concatBuffer[i].length;
      concatBuffer[i] = undefined;
    }

    newList.length = newSize;
    newList.suffix = concatBuffer[nrOfAffixes];
    newList.bits = setSuffix(concatBuffer[nrOfAffixes].length, newList.bits);
    concatBuffer[nrOfAffixes] = undefined;
    return newList;
  } else {
    var leftSuffixSize = getSuffixSize(left);

    if (leftSuffixSize > 0) {
      newList = appendNodeToTree(newList, left.suffix.slice(0, leftSuffixSize));
      newList.length += leftSuffixSize;
    }

    newList = appendNodeToTree(newList, right.prefix.slice(0, getPrefixSize(right)).reverse());
    var newNode = concatSubTree(newList.root, getDepth(newList), right.root, getDepth(right), true);
    var newDepth = getHeight(newNode);
    setSizes(newNode, newDepth);
    newList.root = newNode;
    newList.offset &= ~(mask << getDepth(left) * branchBits);
    newList.length = newSize;
    newList.bits = setSuffix(rightSuffixSize, setDepth(newDepth, newList.bits));
    newList.suffix = right.suffix;
    return newList;
  }
}

function update(index, a, l) {
  if (index < 0 || l.length <= index) {
    return l;
  }

  var prefixSize = getPrefixSize(l);
  var suffixSize = getSuffixSize(l);
  var newList = cloneList(l);

  if (index < prefixSize) {
    var newPrefix = copyArray(newList.prefix);
    newPrefix[newPrefix.length - index - 1] = a;
    newList.prefix = newPrefix;
  } else if (index >= l.length - suffixSize) {
    var newSuffix = copyArray(newList.suffix);
    newSuffix[index - (l.length - suffixSize)] = a;
    newList.suffix = newSuffix;
  } else {
    newList.root = updateNode(l.root, getDepth(l), index - prefixSize, l.offset, a);
  }

  return newList;
}

function adjust(index, f, l) {
  if (index < 0 || l.length <= index) {
    return l;
  }

  return update(index, f(nth(index, l)), l);
}

var newAffix;

function sliceNode(node, index, depth, pathLeft, pathRight, childLeft, childRight) {
  var array = node.array.slice(pathLeft, pathRight + 1);

  if (childLeft !== undefined) {
    array[0] = childLeft;
  }

  if (childRight !== undefined) {
    array[array.length - 1] = childRight;
  }

  var sizes = node.sizes;

  if (sizes !== undefined) {
    sizes = sizes.slice(pathLeft, pathRight + 1);
    var slicedOffLeft = pathLeft !== 0 ? node.sizes[pathLeft - 1] : 0;

    if (childLeft !== undefined) {
      if (childLeft.sizes !== undefined) {
        var oldChild = node.array[pathLeft];
        slicedOffLeft += arrayLast(oldChild.sizes) - arrayLast(childLeft.sizes);
      } else {
        slicedOffLeft += (index - slicedOffLeft & ~31) + 32;
      }
    }

    for (var i = 0; i < sizes.length; ++i) {
      sizes[i] -= slicedOffLeft;
    }

    if (childRight !== undefined) {
      var slicedOffRight = sizeOfSubtree(node.array[pathRight], depth - 1) - sizeOfSubtree(childRight, depth - 1);
      sizes[sizes.length - 1] -= slicedOffRight;
    }
  }

  return new Node(sizes, array);
}

var newOffset = 0;

function sliceLeft(tree, depth, index, offset, top) {
  var _a = getPath(index, offset, depth, tree.sizes),
      path = _a.path,
      newIndex = _a.index,
      updatedOffset = _a.updatedOffset;

  if (depth === 0) {
    newAffix = tree.array.slice(path).reverse();
    return undefined;
  } else {
    var child = sliceLeft(tree.array[path], depth - 1, newIndex, updatedOffset, false);

    if (child === undefined) {
      ++path;

      if (path === tree.array.length) {
        return undefined;
      }
    }

    if (tree.sizes === undefined && top === false) {
      newOffset |= 32 - (tree.array.length - path) << depth * branchBits;
    }

    return sliceNode(tree, index, depth, path, tree.array.length - 1, child, undefined);
  }
}

function sliceRight(node, depth, index, offset) {
  var _a = getPath(index, offset, depth, node.sizes),
      path = _a.path,
      newIndex = _a.index;

  if (depth === 0) {
    newAffix = node.array.slice(0, path + 1);
    return undefined;
  } else {
    var child = sliceRight(node.array[path], depth - 1, newIndex, path === 0 ? offset : 0);

    if (child === undefined) {
      --path;

      if (path === -1) {
        return undefined;
      }
    }

    var array = node.array.slice(0, path + 1);

    if (child !== undefined) {
      array[array.length - 1] = child;
    }

    var sizes = node.sizes;

    if (sizes !== undefined) {
      sizes = sizes.slice(0, path + 1);

      if (child !== undefined) {
        var slicedOff = sizeOfSubtree(node.array[path], depth - 1) - sizeOfSubtree(child, depth - 1);
        sizes[sizes.length - 1] -= slicedOff;
      }
    }

    return new Node(sizes, array);
  }
}

function sliceTreeList(from, to, tree, depth, offset, l) {
  var sizes = tree.sizes;

  var _a = getPath(from, offset, depth, sizes),
      pathLeft = _a.path,
      newFrom = _a.index;

  var _b = getPath(to, offset, depth, sizes),
      pathRight = _b.path,
      newTo = _b.index;

  if (depth === 0) {
    l.prefix = emptyAffix;
    l.suffix = tree.array.slice(pathLeft, pathRight + 1);
    l.root = undefined;
    l.bits = setSuffix(pathRight - pathLeft + 1, 0);
    return l;
  } else if (pathLeft === pathRight) {
    l.bits = decrementDepth(l.bits);
    return sliceTreeList(newFrom, newTo, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);
  } else {
    var childRight = sliceRight(tree.array[pathRight], depth - 1, newTo, 0);
    l.bits = setSuffix(newAffix.length, l.bits);
    l.suffix = newAffix;

    if (childRight === undefined) {
      --pathRight;
    }

    newOffset = 0;
    var childLeft = sliceLeft(tree.array[pathLeft], depth - 1, newFrom, pathLeft === 0 ? offset : 0, pathLeft === pathRight);
    l.offset = newOffset;
    l.bits = setPrefix(newAffix.length, l.bits);
    l.prefix = newAffix;

    if (childLeft === undefined) {
      ++pathLeft;
    }

    if (pathLeft >= pathRight) {
      if (pathLeft > pathRight) {
        l.bits = setDepth(0, l.bits);
        l.root = undefined;
      } else {
        l.bits = decrementDepth(l.bits);
        var newRoot = childRight !== undefined ? childRight : childLeft !== undefined ? childLeft : tree.array[pathLeft];
        l.root = new Node(newRoot.sizes, newRoot.array);
      }
    } else {
      l.root = sliceNode(tree, from, depth, pathLeft, pathRight, childLeft, childRight);
    }

    return l;
  }
}

function slice(from, to, l) {
  var bits = l.bits,
      length = l.length;
  to = Math.min(length, to);

  if (from < 0) {
    from = length + from;
  }

  if (to < 0) {
    to = length + to;
  }

  if (to <= from || to <= 0 || length <= from) {
    return empty();
  }

  if (from <= 0 && length <= to) {
    return l;
  }

  var newLength = to - from;
  var prefixSize = getPrefixSize(l);
  var suffixSize = getSuffixSize(l);

  if (to <= prefixSize) {
    return new List(setPrefix(newLength, 0), 0, newLength, l.prefix.slice(prefixSize - to, prefixSize - from), undefined, emptyAffix);
  }

  var suffixStart = length - suffixSize;

  if (suffixStart <= from) {
    return new List(setSuffix(newLength, 0), 0, newLength, emptyAffix, undefined, l.suffix.slice(from - suffixStart, to - suffixStart));
  }

  var newList = cloneList(l);
  newList.length = newLength;

  if (prefixSize <= from && to <= suffixStart) {
    sliceTreeList(from - prefixSize + l.offset, to - prefixSize + l.offset - 1, l.root, getDepth(l), l.offset, newList);
    return newList;
  }

  if (0 < from) {
    if (from < prefixSize) {
      newList.prefix = l.prefix.slice(0, prefixSize - from);
      bits = setPrefix(prefixSize - from, bits);
    } else {
      newOffset = 0;
      newList.root = sliceLeft(newList.root, getDepth(l), from - prefixSize, l.offset, true);
      newList.offset = newOffset;

      if (newList.root === undefined) {
        bits = setDepth(0, bits);
      }

      bits = setPrefix(newAffix.length, bits);
      prefixSize = newAffix.length;
      newList.prefix = newAffix;
    }
  }

  if (to < length) {
    if (length - to < suffixSize) {
      bits = setSuffix(suffixSize - (length - to), bits);
      newList.suffix = l.suffix.slice(0, suffixSize - (length - to));
    } else {
      newList.root = sliceRight(newList.root, getDepth(l), to - prefixSize - 1, newList.offset);

      if (newList.root === undefined) {
        bits = setDepth(0, bits);
        newList.offset = 0;
      }

      bits = setSuffix(newAffix.length, bits);
      newList.suffix = newAffix;
    }
  }

  newList.bits = bits;
  return newList;
}

function take(n, l) {
  return slice(0, n, l);
}

function findNotIndexCb(value, state) {
  if (state.predicate(value)) {
    ++state.index;
    return true;
  } else {
    return false;
  }
}

function takeWhile(predicate, l) {
  var index = foldlCb(findNotIndexCb, {
    predicate: predicate,
    index: 0
  }, l).index;
  return slice(0, index, l);
}

function takeLastWhile(predicate, l) {
  var index = foldrCb(findNotIndexCb, {
    predicate: predicate,
    index: 0
  }, l).index;
  return slice(l.length - index, l.length, l);
}

function dropWhile(predicate, l) {
  var index = foldlCb(findNotIndexCb, {
    predicate: predicate,
    index: 0
  }, l).index;
  return slice(index, l.length, l);
}

function dropRepeats(l) {
  return dropRepeatsWith(elementEquals, l);
}

function dropRepeatsWith(predicate, l) {
  return foldl(function (acc, a) {
    return acc.length !== 0 && predicate(last(acc), a) ? acc : push(a, acc);
  }, emptyPushable(), l);
}

function takeLast(n, l) {
  return slice(l.length - n, l.length, l);
}

function splitAt(index, l) {
  return [slice(0, index, l), slice(index, l.length, l)];
}

function splitWhen(predicate, l) {
  var idx = findIndex(predicate, l);
  return idx === -1 ? [l, empty()] : splitAt(idx, l);
}

function splitEvery(size, l) {
  var _a = foldl(function (_a, elm) {
    var l2 = _a.l2,
        buffer = _a.buffer;
    push(elm, buffer);

    if (buffer.length === size) {
      return {
        l2: push(buffer, l2),
        buffer: emptyPushable()
      };
    } else {
      return {
        l2: l2,
        buffer: buffer
      };
    }
  }, {
    l2: emptyPushable(),
    buffer: emptyPushable()
  }, l),
      l2 = _a.l2,
      buffer = _a.buffer;

  return buffer.length === 0 ? l2 : push(buffer, l2);
}

function remove(from, amount, l) {
  return concat(slice(0, from, l), slice(from + amount, l.length, l));
}

function drop(n, l) {
  return slice(n, l.length, l);
}

function dropLast(n, l) {
  return slice(0, l.length - n, l);
}

function pop(l) {
  return slice(0, -1, l);
}

var init = pop;
exports.init = init;

function tail(l) {
  return slice(1, l.length, l);
}

function arrayPush(array, a) {
  array.push(a);
  return array;
}

function toArray(l) {
  return foldl(arrayPush, [], l);
}

function insert(index, element, l) {
  return concat(append(element, slice(0, index, l)), slice(index, l.length, l));
}

function insertAll(index, elements, l) {
  return concat(concat(slice(0, index, l), elements), slice(index, l.length, l));
}

function reverse(l) {
  return foldl(function (newL, element) {
    return prepend(element, newL);
  }, empty(), l);
}

function isList(l) {
  return typeof l === "object" && Array.isArray(l.suffix);
}

function zip(as, bs) {
  return zipWith(function (a, b) {
    return [a, b];
  }, as, bs);
}

function zipWith(f, as, bs) {
  var swapped = bs.length < as.length;
  var iterator = (swapped ? as : bs)[Symbol.iterator]();
  return map(function (a) {
    var b = iterator.next().value;
    return swapped ? f(b, a) : f(a, b);
  }, swapped ? bs : as);
}

function isPrimitive(value) {
  return typeof value === "number" || typeof value === "string";
}

function comparePrimitive(a, b) {
  return a === b ? 0 : a < b ? -1 : 1;
}

var ord = "fantasy-land/lte";

function compareOrd(a, b) {
  return a[ord](b) ? b[ord](a) ? 0 : -1 : 1;
}

function sort(l) {
  if (l.length === 0) {
    return l;
  } else if (isPrimitive(first(l))) {
    return from(toArray(l).sort(comparePrimitive));
  } else {
    return sortWith(compareOrd, l);
  }
}

function sortWith(comparator, l) {
  var arr = [];
  var i = 0;
  forEach(function (elm) {
    return arr.push({
      idx: i++,
      elm: elm
    });
  }, l);
  arr.sort(function (_a, _b) {
    var a = _a.elm,
        i = _a.idx;
    var b = _b.elm,
        j = _b.idx;
    var c = comparator(a, b);
    return c !== 0 ? c : i < j ? -1 : 1;
  });
  var newL = emptyPushable();

  for (var i_3 = 0; i_3 < arr.length; ++i_3) {
    push(arr[i_3].elm, newL);
  }

  return newL;
}

function sortBy(f, l) {
  if (l.length === 0) {
    return l;
  }

  var arr = [];
  var i = 0;
  forEach(function (elm) {
    return arr.push({
      idx: i++,
      elm: elm,
      prop: f(elm)
    });
  }, l);
  var comparator = isPrimitive(arr[0].prop) ? comparePrimitive : compareOrd;
  arr.sort(function (_a, _b) {
    var a = _a.prop,
        i = _a.idx;
    var b = _b.prop,
        j = _b.idx;
    var c = comparator(a, b);
    return c !== 0 ? c : i < j ? -1 : 1;
  });
  var newL = emptyPushable();

  for (var i_4 = 0; i_4 < arr.length; ++i_4) {
    push(arr[i_4].elm, newL);
  }

  return newL;
}

function group(l) {
  return groupWith(elementEquals, l);
}

function groupWith(f, l) {
  var result = emptyPushable();
  var buffer = emptyPushable();
  forEach(function (a) {
    if (buffer.length !== 0 && !f(last(buffer), a)) {
      push(buffer, result);
      buffer = emptyPushable();
    }

    push(a, buffer);
  }, l);
  return buffer.length === 0 ? result : push(buffer, result);
}

function intersperse(separator, l) {
  return pop(foldl(function (l2, a) {
    return push(separator, push(a, l2));
  }, emptyPushable(), l));
}

function isEmpty(l) {
  return l.length === 0;
}
},{}],"node_modules/prelude-ts/dist/src/Vector.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var Value_1 = require("./Value");
var Option_1 = require("./Option");
var HashMap_1 = require("./HashMap");
var HashSet_1 = require("./HashSet");
var Comparison_1 = require("./Comparison");
var SeqHelpers = require("./SeqHelpers");
var L = require("list");
/**
 * A general-purpose list class with all-around good performance.
 * quasi-O(1) (actually O(log32(n))) access, append, replace.
 * It's backed by a bit-mapped vector trie.
 * @param T the item type
 */
var Vector = /** @class */ (function () {
    /**
     * @hidden
     */
    // _contents will be undefined only if length===0
    function Vector(_list) {
        this._list = _list;
    }
    /**
     * The empty vector.
     * @param T the item type
     */
    Vector.empty = function () {
        return new Vector(L.empty());
    };
    /**
     * Build a vector from a series of items (any number, as parameters)
     * @param T the item type
     */
    Vector.of = function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        return Vector.ofIterable(data);
    };
    /**
     * Build a vector from any iterable, which means also
     * an array for instance.
     * @param T the item type
     */
    Vector.ofIterable = function (elts) {
        return new Vector(L.from(elts));
    };
    /**
     * Curried predicate to find out whether the vector is empty.
     *
     *     LinkedList.of(Vector.of(1), Vector.empty<number>())
     *         .filter(Vector.isEmpty)
     *     => LinkedList.of(Vector.empty<number>())
     */
    Vector.isEmpty = function (v) {
        return v.isEmpty();
    };
    /**
     * Curried predicate to find out whether the vector is empty.
     *
     *     LinkedList.of(Vector.of(1), Vector.empty<number>())
     *         .filter(Vector.isNotEmpty)
     *     => LinkedList.of(Vector.of(1))
     */
    Vector.isNotEmpty = function (v) {
        return !v.isEmpty();
    };
    /**
     * Get the length of the collection.
     */
    Vector.prototype.length = function () {
        return L.length(this._list);
    };
    /**
     * true if the collection is empty, false otherwise.
     */
    Vector.prototype.isEmpty = function () {
        return L.length(this._list) === 0;
    };
    /**
     * Dual to the foldRight function. Build a collection from a seed.
     * Takes a starting element and a function.
     * It applies the function on the starting element; if the
     * function returns None, it stops building the list, if it
     * returns Some of a pair, it adds the first element to the result
     * and takes the second element as a seed to keep going.
     *
     *     Vector.unfoldRight(
     *          10, x=>Option.of(x)
     *              .filter(x => x!==0)
     *              .map<[number,number]>(x => [x,x-1]))
     *     => Vector.of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
     */
    Vector.unfoldRight = function (seed, fn) {
        var nextVal = fn(seed);
        var r = L.empty();
        while (nextVal.isSome()) {
            r = L.append(nextVal.get()[0], r);
            nextVal = fn(nextVal.get()[1]);
        }
        return new Vector(r);
    };
    /**
     * Retrieve the element at index idx.
     * Returns an option because the collection may
     * contain less elements than the index.
     */
    Vector.prototype.get = function (index) {
        return Option_1.Option.of(L.nth(index, this._list));
    };
    /**
     * If the collection contains a single element,
     * return Some of its value, otherwise return None.
     */
    Vector.prototype.single = function () {
        return L.length(this._list) === 1 ?
            this.head() :
            Option_1.Option.none();
    };
    /**
     * Replace the value of element at the index you give.
     * Will throw if the index is out of bounds!
     */
    Vector.prototype.replace = function (index, val) {
        if (index >= this.length() || index < 0) {
            throw new Error('Vector.replace: index is out of range: ' + index);
        }
        return new Vector(L.update(index, val, this._list));
    };
    /**
     * Append an element at the end of the collection.
     */
    Vector.prototype.append = function (val) {
        return new Vector(L.append(val, this._list));
    };
    /**
     * Append multiple elements at the end of the collection.
     * Note that arrays are also iterables.
     */
    Vector.prototype.appendAll = function (elts) {
        if (elts._list && elts.replace) {
            // elts is a vector too
            return new Vector(L.concat(this._list, elts._list));
        }
        return new Vector(L.concat(this._list, L.from(elts)));
    };
    /**
     * Remove multiple elements from a vector
     *
     *     Vector.of(1,2,3,4,3,2,1).removeAll([2,4])
     *     => Vector.of(1,3,3,1)
     */
    Vector.prototype.removeAll = function (elts) {
        return SeqHelpers.removeAll(this, elts);
    };
    /**
     * Get the first value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    Vector.prototype.head = function () {
        return this.get(0);
    };
    /**
     * Get the last value of the collection, if any.
     * returns Option.Some if the collection is not empty,
     * Option.None if it's empty.
     */
    Vector.prototype.last = function () {
        return Option_1.Option.of(L.last(this._list));
    };
    /**
     * Return a new vector containing all the elements in this
     * vector except the last one, or the empty vector if this
     * is the empty vector.
     *
     *     Vector.of(1,2,3).init()
     *     => Vector.of(1,2)
     */
    Vector.prototype.init = function () {
        return new Vector(L.pop(this._list));
    };
    /**
     * Returns a new collection, discarding the first elements
     * until one element fails the predicate. All elements
     * after that point are retained.
     */
    Vector.prototype.dropWhile = function (predicate) {
        return new Vector(L.dropWhile(predicate, this._list));
    };
    /**
     * Search for an item matching the predicate you pass,
     * return Option.Some of that element if found,
     * Option.None otherwise.
     */
    Vector.prototype.find = function (predicate) {
        return Option_1.Option.of(L.find(predicate, this._list));
    };
    /**
     * Returns true if the predicate returns true for all the
     * elements in the collection.
     */
    Vector.prototype.allMatch = function (predicate) {
        return L.every(predicate, this._list);
    };
    /**
     * Returns true if there the predicate returns true for any
     * element in the collection.
     */
    Vector.prototype.anyMatch = function (predicate) {
        return L.some(predicate, this._list);
    };
    Vector.prototype.partition = function (predicate) {
        return L.partition(predicate, this._list)
            .map(function (x) { return new Vector(x); });
    };
    /**
     * Returns true if the item is in the collection,
     * false otherwise.
     */
    Vector.prototype.contains = function (v) {
        return this.find(function (x) { return Comparison_1.areEqual(x, v); }).isSome();
    };
    /**
     * Group elements in the collection using a classifier function.
     * Elements are then organized in a map. The key is the value of
     * the classifier, and in value we get the list of elements
     * matching that value.
     *
     * also see [[Vector.arrangeBy]]
     */
    Vector.prototype.groupBy = function (classifier) {
        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, v) {
            return acc.putWithMerge(classifier(v), Vector.of(v), // !!! DOUBLE CHECK THIS
            function (v1, v2) { return v1.append(L.nth(0, v2._list)); });
        });
    };
    /**
     * Matches each element with a unique key that you extract from it.
     * If the same key is present twice, the function will return None.
     *
     * also see [[Vector.groupBy]]
     */
    Vector.prototype.arrangeBy = function (getKey) {
        return SeqHelpers.arrangeBy(this, getKey);
    };
    /**
     * Remove duplicate items; elements are mapped to keys, those
     * get compared.
     *
     *     Vector.of(1,1,2,3,2,3,1).distinctBy(x => x);
     *     => Vector.of(1,2,3)
     */
    Vector.prototype.distinctBy = function (keyExtractor) {
        return SeqHelpers.distinctBy(this, keyExtractor);
    };
    Vector.prototype[Symbol.iterator] = function () {
        return this._list[Symbol.iterator]();
    };
    /**
     * Call a function for element in the collection.
     */
    Vector.prototype.forEach = function (fun) {
        L.forEach(fun, this._list);
        return this;
    };
    /**
     * Return a new collection where each element was transformed
     * by the mapper function you give.
     */
    Vector.prototype.map = function (fun) {
        return new Vector(L.map(fun, this._list));
    };
    Vector.prototype.filter = function (fun) {
        return new Vector(L.filter(fun, this._list));
    };
    /**
     * Apply the mapper function on every element of this collection.
     * The mapper function returns an Option; if the Option is a Some,
     * the value it contains is added to the result Collection, if it's
     * a None, the value is discarded.
     *
     *     Vector.of(1,2,6).mapOption(x => x%2===0 ?
     *         Option.of(x+1) : Option.none<number>())
     *     => Vector.of(3, 7)
     */
    Vector.prototype.mapOption = function (mapper) {
        var vec = L.empty();
        for (var i = 0; i < this.length(); i++) {
            var v = mapper(L.nth(i, this._list));
            if (v.isSome()) {
                vec = L.append(v.get(), vec);
            }
        }
        return new Vector(vec);
    };
    /**
     * Calls the function you give for each item in the collection,
     * your function returns a collection, all the collections are
     * concatenated.
     * This is the monadic bind.
     */
    Vector.prototype.flatMap = function (mapper) {
        return new Vector(L.chain(function (x) { return mapper(x)._list; }, this._list));
    };
    /**
     * Reduces the collection to a single value using the
     * associative binary function you give. Since the function
     * is associative, order of application doesn't matter.
     *
     * Example:
     *
     *     Vector.of(1,2,3).fold(0, (a,b) => a + b);
     *     => 6
     */
    Vector.prototype.fold = function (zero, fn) {
        return this.foldLeft(zero, fn);
    };
    /**
     * Reduces the collection to a single value.
     * Left-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldLeft("!", (xs,x) => x+xs);
     *     => "cba!"
     *
     * @param zero The initial value
     * @param fn A function taking the previous value and
     *           the current collection item, and returning
     *           an updated value.
     */
    Vector.prototype.foldLeft = function (zero, fn) {
        return L.foldl(fn, zero, this._list);
    };
    /**
     * Reduces the collection to a single value.
     * Right-associative.
     *
     * Example:
     *
     *     Vector.of("a", "b", "c").foldRight("!", (x,xs) => xs+x);
     *     => "!cba"
     *
     * @param zero The initial value
     * @param fn A function taking the current collection item and
     *           the previous value , and returning
     *           an updated value.
     */
    Vector.prototype.foldRight = function (zero, fn) {
        return L.foldr(fn, zero, this._list);
    };
    // indexOf(element:T, fromIndex:number): number {
    // }
    /**
     * Randomly reorder the elements of the collection.
     */
    Vector.prototype.shuffle = function () {
        return Vector.ofIterable(SeqHelpers.shuffle(this.toArray()));
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Vector.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Vector.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (!other || (!other._list) || (!L.isList(other._list))) {
            return false;
        }
        if (this.length() !== other.length())
            return false;
        for (var i = 0; i < this.length(); i++) {
            var myVal = L.nth(i, this._list);
            var hisVal = L.nth(i, other._list);
            if ((myVal === undefined) !== (hisVal === undefined)) {
                return false;
            }
            if (myVal === undefined || hisVal === undefined) {
                // they are both undefined, the || is for TS's flow analysis
                // so he realizes none of them is undefined after this.
                continue;
            }
            if (!Comparison_1.areEqual(myVal, hisVal)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Vector.prototype.hashCode = function () {
        var hash = 1;
        for (var i = 0; i < this.length(); i++) {
            hash = 31 * hash + Comparison_1.getHashCode(L.nth(i, this._list));
        }
        return hash;
    };
    /**
     * Get a human-friendly string representation of that value.
     *
     * Also see [[Vector.mkString]]
     */
    Vector.prototype.toString = function () {
        var r = "Vector(";
        for (var i = 0; i < this.length(); i++) {
            if (i > 0) {
                r += ", ";
            }
            r += SeqHelpers.toStringHelper(L.nth(i, this._list));
        }
        return r + ")";
    };
    /**
     * Used by the node REPL to display values.
     * Most of the time should be the same as toString()
     */
    Vector.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    /**
     * Joins elements of the collection by a separator.
     * Example:
     *
     *     Vector.of(1,2,3).mkString(", ")
     *     => "1, 2, 3"
     */
    Vector.prototype.mkString = function (separator) {
        var r = "";
        for (var i = 0; i < this.length(); i++) {
            if (i > 0) {
                r += separator;
            }
            r += SeqHelpers.toStringHelper(L.nth(i, this._list), { quoteStrings: false });
        }
        return r;
    };
    /**
     * Returns a new collection with elements
     * sorted according to the comparator you give.
     *
     * also see [[Vector.sortOn]]
     */
    Vector.prototype.sortBy = function (compare) {
        return Vector.ofIterable(this.toArray().sort(compare));
    };
    /**
     * Give a function associating a number or a string with
     * elements from the collection, and the elements
     * are sorted according to that value.
     *
     *     Vector.of({a:3,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a)
     *     => Vector.of({a:1,b:"test"},{a:2,b:"a"},{a:3,b:"b"})
     *
     * You can also sort by multiple criteria, and request 'descending'
     * sorting:
     *
     *     Vector.of({a:1,b:"b"},{a:1,b:"test"},{a:2,b:"a"}).sortOn(elt=>elt.a,{desc:elt=>elt.b})
     *     => Vector.of({a:1,b:"test"},{a:1,b:"b"},{a:2,b:"a"})
     *
     * also see [[Vector.sortBy]]
     */
    Vector.prototype.sortOn = function () {
        var getKeys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            getKeys[_i] = arguments[_i];
        }
        return SeqHelpers.sortOn(this, getKeys);
    };
    /**
     * Convert this collection to a map. You give a function which
     * for each element in the collection returns a pair. The
     * key of the pair will be used as a key in the map, the value,
     * as a value in the map. If several values get the same key,
     * entries will be lost.
     *
     *     Vector.of(1,2,3).toMap(x=>[x.toString(), x])
     *     => HashMap.of(["1",1], ["2",2], ["3",3])
     */
    Vector.prototype.toMap = function (converter) {
        return this.foldLeft(HashMap_1.HashMap.empty(), function (acc, cur) {
            var converted = converter(cur);
            return acc.put(converted[0], converted[1]);
        });
    };
    /**
     * Convert this collection to a set. Since the elements of the
     * Seq may not support equality, you must pass a function returning
     * a value supporting equality.
     *
     *     Vector.of(1,2,3,3,4).toSet(x=>x)
     *     => HashSet.of(1,2,3,4)
     */
    Vector.prototype.toSet = function (converter) {
        return this.foldLeft(HashSet_1.HashSet.empty(), function (acc, cur) {
            return acc.add(converter(cur));
        });
    };
    /**
     * Convert to array.
     */
    Vector.prototype.toArray = function () {
        return L.toArray(this._list);
    };
    ;
    /**
     * @hidden
     */
    Vector.prototype.hasTrueEquality = function () {
        return SeqHelpers.seqHasTrueEquality(this);
    };
    /**
     * Combine any number of iterables you give in as
     * parameters to produce a new collection which combines all,
     * in tuples. For instance:
     *
     *     Vector.zip(Vector.of(1,2,3), ["a","b","c"], LinkedList.of(8,9,10))
     *     => Vector.of([1,"a",8], [2,"b",9], [3,"c",10])
     *
     * The result collection will have the length of the shorter
     * of the input iterables. Extra elements will be discarded.
     *
     * Also see [the non-static version](#zip), which only combines two
     * collections.
     * @param A A is the type of the tuple that'll be generated
     *          (`[number,string,number]` for the code sample)
     */
    Vector.zip = function () {
        var iterables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            iterables[_i] = arguments[_i];
        }
        var r = L.empty();
        var iterators = iterables.map(function (i) { return i[Symbol.iterator](); });
        var items = iterators.map(function (i) { return i.next(); });
        while (!items.some(function (item) { return item.done; })) {
            r = L.append(items.map(function (item) { return item.value; }), r);
            items = iterators.map(function (i) { return i.next(); });
        }
        return new Vector(r);
    };
    /**
     * Combine this collection with the collection you give in
     * parameter to produce a new collection which combines both,
     * in pairs. For instance:
     *
     *     Vector.of(1,2,3).zip(["a","b","c"])
     *     => Vector.of([1,"a"], [2,"b"], [3,"c"])
     *
     * The result collection will have the length of the shorter
     * of both collections. Extra elements will be discarded.
     *
     * Also see [[Vector.zip]] (static version which can more than two
     * iterables)
     */
    Vector.prototype.zip = function (other) {
        var r = L.empty();
        var thisIterator = this[Symbol.iterator]();
        var otherIterator = other[Symbol.iterator]();
        var thisCurItem = thisIterator.next();
        var otherCurItem = otherIterator.next();
        while (!thisCurItem.done && !otherCurItem.done) {
            r = L.append([thisCurItem.value, otherCurItem.value], r);
            thisCurItem = thisIterator.next();
            otherCurItem = otherIterator.next();
        }
        return new Vector(r);
    };
    /**
     * Reverse the collection. For instance:
     *
     *     Vector.of(1,2,3).reverse();
     *     => Vector.of(3,2,1)
     */
    Vector.prototype.reverse = function () {
        return new Vector(L.reverse(this._list));
    };
    /**
     * Combine this collection with the index of the elements
     * in it. Handy if you need the index when you map on
     * the collection for instance:
     *
     *     Vector.of("a","b").zipWithIndex().map(([v,idx]) => v+idx)
     *     => Vector.of("a0", "b1")
     */
    Vector.prototype.zipWithIndex = function () {
        return SeqHelpers.zipWithIndex(this);
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate.
     */
    Vector.prototype.takeWhile = function (predicate) {
        return new Vector(L.takeWhile(predicate, this._list));
    };
    /**
     * Returns a new collection, discarding the elements
     * after the first element which fails the predicate,
     * but starting from the end of the collection.
     *
     *     Vector.of(1,2,3,4).takeRightWhile(x => x > 2)
     *     => Vector.of(3,4)
     */
    Vector.prototype.takeRightWhile = function (predicate) {
        return new Vector(L.takeLastWhile(predicate, this._list));
    };
    /**
     * Split the collection at a specific index.
     *
     *     Vector.of(1,2,3,4,5).splitAt(3)
     *     => [Vector.of(1,2,3), Vector.of(4,5)]
     */
    Vector.prototype.splitAt = function (index) {
        if (index < 0) {
            return [Vector.empty(), this];
        }
        return L.splitAt(index, this._list).map(function (x) { return new Vector(x); });
    };
    /**
     * Takes a predicate; returns a pair of collections.
     * The first one is the longest prefix of this collection
     * which satisfies the predicate, and the second collection
     * is the remainder of the collection.
     *
     *    Vector.of(1,2,3,4,5,6).span(x => x <3)
     *    => [Vector.of(1,2), Vector.of(3,4,5,6)]
     */
    Vector.prototype.span = function (predicate) {
        // could be potentially faster using splitAt.
        var first = this.takeWhile(predicate);
        return [first, this.drop(first.length())];
    };
    /**
     * Returns a new collection with the first
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    Vector.prototype.drop = function (n) {
        return new Vector(L.drop(n, this._list));
    };
    /**
     * Return a new collection containing the first n
     * elements from this collection
     *
     *     Vector.of(1,2,3,4).take(2)
     *     => Vector.of(1,2)
     */
    Vector.prototype.take = function (n) {
        if (n < 0) {
            return Vector.empty();
        }
        return new Vector(L.take(n, this._list));
    };
    /**
     * Prepend an element at the beginning of the collection.
     */
    Vector.prototype.prepend = function (elt) {
        return new Vector(L.prepend(elt, this._list));
    };
    /**
     * Prepend multiple elements at the beginning of the collection.
     */
    Vector.prototype.prependAll = function (elts) {
        return Vector.ofIterable(elts).appendAll(this);
    };
    /**
     * Removes the first element matching the predicate
     * (use [[Seq.filter]] to remove all elements matching a predicate)
     */
    Vector.prototype.removeFirst = function (predicate) {
        var v1 = this.takeWhile(function (x) { return !predicate(x); });
        return v1.appendAll(this.drop(v1.length() + 1));
    };
    /**
     * Returns a new collection with the last
     * n elements discarded.
     * If the collection has less than n elements,
     * returns the empty collection.
     */
    Vector.prototype.dropRight = function (n) {
        if (n >= this.length()) {
            return Vector.empty();
        }
        return new Vector(L.dropLast(n, this._list));
    };
    /**
     * Returns a new collection, discarding the last elements
     * until one element fails the predicate. All elements
     * before that point are retained.
     */
    Vector.prototype.dropRightWhile = function (predicate) {
        var i = this.length() - 1;
        for (; i >= 0; i--) {
            if (!predicate(L.nth(i, this._list))) {
                return this.take(i + 1);
            }
        }
        return Vector.empty();
    };
    /**
     * Get all the elements in the collection but the first one.
     * If the collection is empty, return None.
     */
    Vector.prototype.tail = function () {
        if (this.isEmpty()) {
            return Option_1.Option.none();
        }
        return Option_1.Option.of(new Vector(L.tail(this._list)));
    };
    /**
     * Reduces the collection to a single value by repeatedly
     * calling the combine function.
     * No starting value. The order in which the elements are
     * passed to the combining function is undetermined.
     */
    Vector.prototype.reduce = function (combine) {
        return SeqHelpers.reduce(this, combine);
    };
    /**
     * Compare values in the collection and return the smallest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[Vector.minOn]]
     */
    Vector.prototype.minBy = function (compare) {
        return SeqHelpers.minBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the smallest.
     * Returns Option.none if the collection is empty.
     *
     *     Vector.of({name:"Joe", age:12}, {name:"Paula", age:6}).minOn(x=>x.age)
     *     => Option.of({name:"Paula", age:6})
     *
     * also see [[Vector.minBy]]
     */
    Vector.prototype.minOn = function (getOrderable) {
        return SeqHelpers.minOn(this, getOrderable);
    };
    /**
     * Compare values in the collection and return the largest element.
     * Returns Option.none if the collection is empty.
     *
     * also see [[Vector.maxOn]]
     */
    Vector.prototype.maxBy = function (compare) {
        return SeqHelpers.maxBy(this, compare);
    };
    /**
     * Call the function you give for each value in the collection
     * and return the element for which the result was the largest.
     * Returns Option.none if the collection is empty.
     *
     *     Vector.of({name:"Joe", age:12}, {name:"Paula", age:6}).maxOn(x=>x.age)
     *     => Option.of({name:"Joe", age:12})
     *
     * also see [[Vector.maxBy]]
     */
    Vector.prototype.maxOn = function (getOrderable) {
        return SeqHelpers.maxOn(this, getOrderable);
    };
    /**
     * Call the function you give for each element in the collection
     * and sum all the numbers, return that sum.
     * Will return 0 if the collection is empty.
     *
     *     Vector.of(1,2,3).sumOn(x=>x)
     *     => 6
     */
    Vector.prototype.sumOn = function (getNumber) {
        return SeqHelpers.sumOn(this, getNumber);
    };
    /**
     * Slides a window of a specific size over the sequence.
     * Returns a lazy stream so memory use is not prohibitive.
     *
     *     Vector.of(1,2,3,4,5,6,7,8).sliding(3)
     *     => Stream.of(Vector.of(1,2,3), Vector.of(4,5,6), Vector.of(7,8))
     */
    Vector.prototype.sliding = function (count) {
        return SeqHelpers.sliding(this, count);
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The last element of the result is the final cumulative result.
     *
     *     Vector.of(1,2,3).scanLeft(0, (soFar,cur)=>soFar+cur)
     *     => Vector.of(0,1,3,6)
     */
    Vector.prototype.scanLeft = function (init, fn) {
        return new Vector(L.scan(fn, init, this._list));
    };
    /**
     * Apply the function you give to all elements of the sequence
     * in turn, keeping the intermediate results and returning them
     * along with the final result in a list.
     * The first element of the result is the final cumulative result.
     *
     *     Vector.of(1,2,3).scanRight(0, (cur,soFar)=>soFar+cur)
     *     => Vector.of(6,5,3,0)
     */
    Vector.prototype.scanRight = function (init, fn) {
        var r = [];
        r.unshift(init);
        var cur = init;
        for (var i = this.length() - 1; i >= 0; i--) {
            cur = fn(L.nth(i, this._list), cur);
            r.unshift(cur);
        }
        return Vector.ofIterable(r);
    };
    return Vector;
}());
exports.Vector = Vector;
//# sourceMappingURL=Vector.js.map
},{"./Value":"node_modules/prelude-ts/dist/src/Value.js","./Option":"node_modules/prelude-ts/dist/src/Option.js","./HashMap":"node_modules/prelude-ts/dist/src/HashMap.js","./HashSet":"node_modules/prelude-ts/dist/src/HashSet.js","./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js","list":"node_modules/list/dist/es/index.js"}],"node_modules/prelude-ts/dist/src/Either.js":[function(require,module,exports) {
"use strict";
/**
 * The [[Either]] type represents an alternative between two value types.
 * A "left" value which is also conceptually tied to a failure,
 * or a "right" value which is conceptually tied to success.
 *
 * The code is organized through the class [[Left]], the class [[Right]],
 * and the type alias [[Either]] (Left or Right).
 *
 * Finally, "static" functions on Option are arranged in the class
 * [[EitherStatic]] and are accessed through the global constant Either.
 *
 * Examples:
 *
 *     Either.right<number,number>(5);
 *     Either.left<number,number>(2);
 *     Either.right<number,number>(5).map(x => x*2);
 *
 * Left has the extra [[Left.getLeft]] method that [[Right]] doesn't have.
 * Right has the extra [[Right.get]] method that [[Left]] doesn't have.
 */
exports.__esModule = true;
var Value_1 = require("./Value");
var Option_1 = require("./Option");
var LinkedList_1 = require("./LinkedList");
var Vector_1 = require("./Vector");
var Comparison_1 = require("./Comparison");
var Contract_1 = require("./Contract");
/**
 * Holds the "static methods" for [[Either]]
 */
var EitherStatic = /** @class */ (function () {
    function EitherStatic() {
    }
    /**
     * Constructs an Either containing a left value which you give.
     */
    EitherStatic.prototype.left = function (val) {
        return new Left(val);
    };
    /**
     * Constructs an Either containing a right value which you give.
     */
    EitherStatic.prototype.right = function (val) {
        return new Right(val);
    };
    /**
     * Curried type guard for Either
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))
     *         .filter(Either.isLeft)
     *         .map(o => o.getLeft())
     *     => Vector.of(1)
     */
    EitherStatic.prototype.isLeft = function (e) {
        return e.isLeft();
    };
    /**
     * Curried type guard for Either
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Either.right<number,number>(2), Either.left<number,number>(1))
     *         .filter(Either.isRight)
     *         .map(o => o.get())
     *     => Vector.of(2)
     */
    EitherStatic.prototype.isRight = function (e) {
        return e.isRight();
    };
    /**
     * Turns a list of eithers in an either containing a list of items.
     * Useful in many contexts.
     *
     *     Either.sequence(Vector.of(
     *         Either.right<number,number>(1),
     *         Either.right<number,number>(2)));
     *     => Either.right(Vector.of(1,2))
     *
     * But if a single element is Left, everything is discarded:
     *
     *     Either.sequence(Vector.of(
     *           Either.right<number,number>(1),
     *           Either.left<number,number>(2),
     *           Either.left<number,number>(3)));
     *     => Either.left(2)
     *
     * Also see [[EitherStatic.traverse]]
     */
    EitherStatic.prototype.sequence = function (elts) {
        return exports.Either.traverse(elts, function (x) { return x; });
    };
    /**
     * Takes a list, a function that can transform list elements
     * to eithers, then return an either containing a list of
     * the transformed elements.
     *
     *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?
     *         Either.right("user" + x.toString()) : Either.left("invalid id!");
     *     Either.traverse([4, 3, 2], getUserById);
     *     => Either.right(Vector.of("user4", "user3", "user2"))
     *
     * But if a single element results in Left, everything is discarded:
     *
     *     const getUserById: (x:number)=>Either<string,string> = x => x > 0 ?
     *         Either.right("user" + x.toString()) : Either.left("invalid id!");
     *     Either.traverse([4, -3, 2], getUserById);
     *     => Either.left("invalid id!")
     *
     * Also see [[EitherStatic.sequence]]
     */
    EitherStatic.prototype.traverse = function (elts, fn) {
        var r = Vector_1.Vector.empty();
        var iterator = elts[Symbol.iterator]();
        var curItem = iterator.next();
        while (!curItem.done) {
            var v = fn(curItem.value);
            if (v.isLeft()) {
                return v;
            }
            r = r.append(v.get());
            curItem = iterator.next();
        }
        return exports.Either.right(r);
    };
    /**
     * Turns a list of eithers in an either containing a list of items.
     * Compared to [[EitherStatic.sequence]], sequenceAcc 'accumulates'
     * the errors, instead of short-circuiting on the first error.
     *
     *     Either.sequenceAcc(Vector.of(
     *         Either.right<number,number>(1),
     *         Either.right<number,number>(2)));
     *     => Either.right(Vector.of(1,2))
     *
     * But if a single element is Left, you get all the lefts:
     *
     *     Either.sequenceAcc(Vector.of(
     *           Either.right<number,number>(1),
     *           Either.left<number,number>(2),
     *           Either.left<number,number>(3)));
     *     => Either.left(Vector.of(2,3))
     */
    EitherStatic.prototype.sequenceAcc = function (elts) {
        var _a = Vector_1.Vector.ofIterable(elts).partition(exports.Either.isLeft), lefts = _a[0], rights = _a[1];
        if (lefts.isEmpty()) {
            return exports.Either.right(rights.map(function (r) { return r.getOrThrow(); }));
        }
        return exports.Either.left(lefts.map(function (l) { return l.getLeft(); }));
    };
    /**
     * Applicative lifting for Either.
     * Takes a function which operates on basic values, and turns it
     * in a function that operates on eithers of these values ('lifts'
     * the function). The 2 is because it works on functions taking two
     * parameters.
     *
     *     const lifted = Either.liftA2(
     *         (x:number,y:number) => x+y, {} as string);
     *     lifted(
     *         Either.right<string,number>(5),
     *         Either.right<string,number>(6));
     *     => Either.right(11)
     *
     *     const lifted = Either.liftA2(
     *         (x:number,y:number) => x+y, {} as string);
     *     lifted(
     *         Either.right<string,number>(5),
     *         Either.left<string,number>("bad"));
     *     => Either.left("bad")
     *
     * @param R1 the first right type
     * @param R2 the second right type
     * @param L the left type
     * @param V the new right type as returned by the combining function.
     */
    EitherStatic.prototype.liftA2 = function (fn, leftWitness) {
        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };
    };
    /**
     * Applicative lifting for Either. 'p' stands for 'properties'.
     *
     * Takes a function which operates on a simple JS object, and turns it
     * in a function that operates on the same JS object type except which each field
     * wrapped in an Either ('lifts' the function).
     * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters
     * is not two.
     *
     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;
     *     const lifted = Either.liftAp(fn, {} as number);
     *     lifted({
     *         a: Either.right<number,number>(5),
     *         b: Either.right<number,number>(6),
     *         c: Either.right<number,number>(3)});
     *     => Either.right(14)
     *
     *     const lifted = Either.liftAp<number,{a:number,b:number},number>(
     *         x => x.a+x.b);
     *     lifted({
     *         a: Either.right<number,number>(5),
     *         b: Either.left<number,number>(2)});
     *     => Either.left(2)
     *
     * @param L the left type
     * @param A the object property type specifying the parameters for your function
     * @param B the type returned by your function, returned wrapped in an either by liftAp.
     */
    EitherStatic.prototype.liftAp = function (fn, leftWitness) {
        return function (x) {
            var copy = {};
            for (var p in x) {
                if (x[p].isLeft()) {
                    return x[p];
                }
                copy[p] = x[p].getOrThrow();
            }
            return exports.Either.right(fn(copy));
        };
    };
    /**
     * Applicative lifting for Either. 'p' stands for 'properties'.
     * Compared to [[EitherStatic.liftAp]], liftApAcc 'accumulates'
     * the errors, instead of short-circuiting on the first error.
     *
     * Takes a function which operates on a simple JS object, and turns it
     * in a function that operates on the same JS object type except which each field
     * wrapped in an Either ('lifts' the function).
     * It's an alternative to [[EitherStatic.liftA2]] when the number of parameters
     * is not two.
     *
     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;
     *     const lifted = Either.liftApAcc(fn, {} as number);
     *     lifted({
     *         a: Either.right<number,number>(5),
     *         b: Either.right<number,number>(6),
     *         c:Either.right<number,number>(3)});
     *     => Either.right(14)
     *
     *     const fn = (x:{a:number,b:number,c:number}) => x.a+x.b+x.c;
     *     const lifted = Either.liftApAcc(fn, {} as number);
     *     lifted({
     *         a: Either.right<number,number>(5),
     *         b: Either.left<number,number>(2),
     *         c: Either.left<number,number>(6)});
     *     => Either.left(Vector.of(2, 6))
     *
     * @param L the left type
     * @param A the object property type specifying the parameters for your function
     * @param B the type returned by your function, returned wrapped in an either by liftAp.
     */
    EitherStatic.prototype.liftApAcc = function (fn, leftWitness) {
        var leftErrs = [];
        return function (x) {
            var copy = {};
            for (var p in x) {
                var field = x[p];
                if (field.isLeft()) {
                    leftErrs.push(field.getLeft());
                }
                else {
                    copy[p] = x[p].getOrThrow();
                }
            }
            if (leftErrs.length === 0) {
                return exports.Either.right(fn(copy));
            }
            else {
                return exports.Either.left(Vector_1.Vector.ofIterable(leftErrs));
            }
        };
    };
    /**
     * Take a partial function (may return undefined or throw),
     * and lift it to return an [[Either]] instead.
     *
     * Note that unlike the [[OptionStatic.lift]] version, if
     * the function returns undefined, the Either.lift version will throw
     * (the Option.lift version returns None()): if you want to do
     * pure side-effects which may throw, you're better off just using
     * javascript try blocks.
     *
     * When using typescript, to help the compiler infer the left type,
     * you can either pass a second parameter like `{} as <type>`, or
     * call with `lift<L,R>(...)`.
     *
     *     const add = Either.lift((x:number,y:number) => x+y, {} as string);
     *     add(1,2);
     *     => Either.right(3)
     *
     *     const undef = Either.lift((x:number,y:number,z:number) => undefined);
     *     undef(1,2,3);
     *     => throws
     *
     *     const throws = Either.lift(() => {throw "x"});
     *     throws();
     *     => Either.left("x")
     */
    EitherStatic.prototype.lift = function (fn, witness) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                var r = fn.apply(void 0, args);
                if (r !== undefined) {
                    return exports.Either.right(r);
                }
            }
            catch (err) {
                return exports.Either.left(err);
            }
            throw new Error("liftEither got undefined!");
        };
    };
    /**
     * Take a no-parameter partial function (may return undefined or throw),
     * call it, and return an [[Either]] instead.
     *
     * Note that unlike the [[OptionStatic.try_]] version, if
     * the function returns undefined, this function will throw
     * (the Option.try_ version returns None()): if you want to do
     * pure side-effects which may throw, you're better off just using
     * javascript try blocks.
     *
     * When using typescript, to help the compiler infer the left type,
     * you can either pass a second parameter like `{} as <type>`, or
     * call with `try_<L,R>(...)`.
     *
     *     Either.try_(Math.random, {} as string);
     *     => Either.right(0.49884723907769635)
     *
     *     Either.try_(() => undefined);
     *     => throws
     *
     *     Either.try_(() => {throw "x"});
     *     => Either.left("x")
     *
     * Also see [[EitherStatic.lift]], [[OptionStatic.try_]],
     * [[OptionStatic.tryNullable]]
     */
    EitherStatic.prototype.try_ = function (fn, witness) {
        return exports.Either.lift(fn)();
    };
    return EitherStatic;
}());
exports.EitherStatic = EitherStatic;
/**
 * The Either constant allows to call the either "static" methods
 */
exports.Either = new EitherStatic();
/**
 * Represents an [[Either]] containing a left value,
 * conceptually tied to a failure.
 * "static methods" available through [[EitherStatic]]
 * @param L the "left" item type 'failure'
 * @param R the "right" item type 'success'
 */
var Left = /** @class */ (function () {
    function Left(value) {
        this.value = value;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Returns true since this is a Left
     */
    Left.prototype.isLeft = function () {
        return true;
    };
    /**
     * Returns false since this is a Left
     */
    Left.prototype.isRight = function () {
        return false;
    };
    /**
     * Returns true if this is either is a right and contains the value you give.
     */
    Left.prototype.contains = function (val) {
        return false;
    };
    /**
     * If this either is a right, applies the function you give
     * to its contents and build a new right either, otherwise return this.
     */
    Left.prototype.map = function (fn) {
        return this;
    };
    /**
     * If this either is a right, call the function you give with
     * the contents, and return what the function returns, else
     * returns this.
     * This is the monadic bind.
     */
    Left.prototype.flatMap = function (fn) {
        return this;
    };
    /**
     * If this either is a left, call the function you give with
     * the left value and return a new either left with the result
     * of the function, else return this.
     */
    Left.prototype.mapLeft = function (fn) {
        return new Left(fn(this.value));
    };
    /**
     * Map the either: you give a function to apply to the value,
     * a function in case it's a left, a function in case it's a right.
     */
    Left.prototype.bimap = function (fnL, fnR) {
        return new Left(fnL(this.value));
    };
    /**
     * "filter" the either. If it was a Left, it stays a Left.
     * If it was a Right and the predicate you pass returns
     * true for its value, return the either unchanged.
     * But if it was a left and the predicate returns false,
     * return a Left with the value returned by the function
     * passed as second parameter.
     *
     *     Either.right<string,number>(-3)
     *         .filter(x => x >= 0, v => "got negative value: " + v);
     *     => Either.left<string,number>("got negative value: -3")
     */
    Left.prototype.filter = function (p, filterVal) {
        return this;
    };
    /**
     * Combines two eithers. If this either is a right, returns it.
     * If it's a left, returns the other one.
     */
    Left.prototype.orElse = function (other) {
        return other;
    };
    /**
     * Execute a side-effecting function if the either
     * is a right; returns the either.
     */
    Left.prototype.ifRight = function (fn) {
        return this;
    };
    /**
     * Execute a side-effecting function if the either
     * is a left; returns the either.
     */
    Left.prototype.ifLeft = function (fn) {
        fn(this.value);
        return this;
    };
    /**
     * Handle both branches of the either and return a value
     * (can also be used for side-effects).
     * This is the catamorphism for either.
     *
     *     Either.right<string,number>(5).match({
     *         Left:  x => "left " + x,
     *         Right: x => "right " + x
     *     });
     *     => "right 5"
     */
    Left.prototype.match = function (cases) {
        return cases.Left(this.value);
    };
    /**
     * If this either is a right, return its value, else throw
     * an exception.
     * You can optionally pass a message that'll be used as the
     * exception message, or an Error object.
     */
    Left.prototype.getOrThrow = function (errorInfo) {
        if (typeof errorInfo === 'string') {
            throw new Error(errorInfo || "Left.getOrThrow called!");
        }
        throw errorInfo || new Error("Left.getOrThrow called!");
    };
    /**
     * If this either is a right, return its value, else return
     * the value you give.
     */
    Left.prototype.getOrElse = function (other) {
        return other;
    };
    /**
     * Get the value contained in this left.
     * NOTE: we know it's there, since this method
     * belongs to Left, not Either.
     */
    Left.prototype.getLeft = function () {
        return this.value;
    };
    /**
     * If this either is a left, return its value, else throw
     * an exception.
     * You can optionally pass a message that'll be used as the
     * exception message.
     */
    Left.prototype.getLeftOrThrow = function (message) {
        return this.value;
    };
    /**
     * If this either is a left, return its value, else return
     * the value you give.
     */
    Left.prototype.getLeftOrElse = function (other) {
        return this.value;
    };
    /**
     * Convert this either to an option, conceptually dropping
     * the left (failing) value.
     */
    Left.prototype.toOption = function () {
        return Option_1.Option.none();
    };
    /**
     * Convert to a vector. If it's a left, it's the empty
     * vector, if it's a right, it's a one-element vector with
     * the contents of the either.
     */
    Left.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    /**
     * Convert to a list. If it's a left, it's the empty
     * list, if it's a right, it's a one-element list with
     * the contents of the either.
     */
    Left.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.empty();
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Left.prototype.transform = function (converter) {
        return converter(this);
    };
    Left.prototype.hasTrueEquality = function () {
        return (this.value && this.value.hasTrueEquality) ?
            this.value.hasTrueEquality() :
            Comparison_1.hasTrueEquality(this.value);
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Left.prototype.hashCode = function () {
        return Comparison_1.getHashCode(this.value);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Left.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if ((!other) || (!other.isRight) || other.isRight()) {
            return false;
        }
        var leftOther = other;
        Contract_1.contractTrueEquality("Either.equals", this, leftOther);
        return Comparison_1.areEqual(this.value, leftOther.value);
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Left.prototype.toString = function () {
        return "Left(" + this.value + ")";
    };
    /**
     * Used by the node REPL to display values.
     */
    Left.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Left;
}());
exports.Left = Left;
/**
 * Represents an [[Either]] containing a success value,
 * conceptually tied to a success.
 * "static methods" available through [[EitherStatic]]
 * @param L the "left" item type 'failure'
 * @param R the "right" item type 'success'
 */
var Right = /** @class */ (function () {
    function Right(value) {
        this.value = value;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Returns false since this is a Right
     */
    Right.prototype.isLeft = function () {
        return false;
    };
    /**
     * Returns true since this is a Right
     */
    Right.prototype.isRight = function () {
        return true;
    };
    /**
     * Returns true if this is either is a right and contains the value you give.
     */
    Right.prototype.contains = function (val) {
        return Comparison_1.areEqual(this.value, val);
    };
    /**
     * If this either is a right, applies the function you give
     * to its contents and build a new right either, otherwise return this.
     */
    Right.prototype.map = function (fn) {
        return new Right(fn(this.value));
    };
    /**
     * If this either is a right, call the function you give with
     * the contents, and return what the function returns, else
     * returns this.
     * This is the monadic bind.
     */
    Right.prototype.flatMap = function (fn) {
        return fn(this.value);
    };
    /**
     * If this either is a left, call the function you give with
     * the left value and return a new either left with the result
     * of the function, else return this.
     */
    Right.prototype.mapLeft = function (fn) {
        return this;
    };
    /**
     * Map the either: you give a function to apply to the value,
     * a function in case it's a left, a function in case it's a right.
     */
    Right.prototype.bimap = function (fnL, fnR) {
        return new Right(fnR(this.value));
    };
    /**
     * "filter" the either. If it was a Left, it stays a Left.
     * If it was a Right and the predicate you pass returns
     * true for its value, return the either unchanged.
     * But if it was a left and the predicate returns false,
     * return a Left with the value returned by the function
     * passed as second parameter.
     *
     *     Either.right<string,number>(-3)
     *         .filter(x => x >= 0, v => "got negative value: " + v);
     *     => Either.left<string,number>("got negative value: -3")
     */
    Right.prototype.filter = function (p, filterVal) {
        if (p(this.value)) {
            return this;
        }
        return new Left(filterVal(this.value));
    };
    /**
     * Combines two eithers. If this either is a right, returns it.
     * If it's a left, returns the other one.
     */
    Right.prototype.orElse = function (other) {
        return this;
    };
    /**
     * Execute a side-effecting function if the either
     * is a right; returns the either.
     */
    Right.prototype.ifRight = function (fn) {
        fn(this.value);
        return this;
    };
    /**
     * Execute a side-effecting function if the either
     * is a left; returns the either.
     */
    Right.prototype.ifLeft = function (fn) {
        return this;
    };
    /**
     * Handle both branches of the either and return a value
     * (can also be used for side-effects).
     * This is the catamorphism for either.
     *
     *     Either.right<string,number>(5).match({
     *         Left:  x => "left " + x,
     *         Right: x => "right " + x
     *     });
     *     => "right 5"
     */
    Right.prototype.match = function (cases) {
        return cases.Right(this.value);
    };
    /**
     * Get the value contained in this right.
     * NOTE: we know it's there, since this method
     * belongs to Right, not Either.
     */
    Right.prototype.get = function () {
        return this.value;
    };
    /**
     * If this either is a right, return its value, else throw
     * an exception.
     * You can optionally pass a message that'll be used as the
     * exception message, or an Error object.
     */
    Right.prototype.getOrThrow = function (errorInfo) {
        return this.value;
    };
    /**
     * If this either is a right, return its value, else return
     * the value you give.
     */
    Right.prototype.getOrElse = function (other) {
        return this.value;
    };
    /**
     * If this either is a left, return its value, else throw
     * an exception.
     * You can optionally pass a message that'll be used as the
     * exception message.
     */
    Right.prototype.getLeftOrThrow = function (message) {
        throw message || "Left.getOrThrow called!";
    };
    /**
     * If this either is a left, return its value, else return
     * the value you give.
     */
    Right.prototype.getLeftOrElse = function (other) {
        return other;
    };
    /**
     * Convert this either to an option, conceptually dropping
     * the left (failing) value.
     */
    Right.prototype.toOption = function () {
        return Option_1.Option.of(this.value);
    };
    /**
     * Convert to a vector. If it's a left, it's the empty
     * vector, if it's a right, it's a one-element vector with
     * the contents of the either.
     */
    Right.prototype.toVector = function () {
        return Vector_1.Vector.of(this.value);
    };
    /**
     * Convert to a list. If it's a left, it's the empty
     * list, if it's a right, it's a one-element list with
     * the contents of the either.
     */
    Right.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.of(this.value);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Right.prototype.transform = function (converter) {
        return converter(this);
    };
    Right.prototype.hasTrueEquality = function () {
        return (this.value && this.value.hasTrueEquality) ?
            this.value.hasTrueEquality() :
            Comparison_1.hasTrueEquality(this.value);
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Right.prototype.hashCode = function () {
        return Comparison_1.getHashCode(this.value);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Right.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if ((!other) || (!other.isRight) || (!other.isRight())) {
            return false;
        }
        var rightOther = other;
        Contract_1.contractTrueEquality("Either.equals", this, rightOther);
        return Comparison_1.areEqual(this.value, rightOther.value);
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Right.prototype.toString = function () {
        return "Right(" + this.value + ")";
    };
    /**
     * Used by the node REPL to display values.
     */
    Right.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Right;
}());
exports.Right = Right;
//# sourceMappingURL=Either.js.map
},{"./Value":"node_modules/prelude-ts/dist/src/Value.js","./Option":"node_modules/prelude-ts/dist/src/Option.js","./LinkedList":"node_modules/prelude-ts/dist/src/LinkedList.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./Contract":"node_modules/prelude-ts/dist/src/Contract.js"}],"node_modules/prelude-ts/dist/src/Option.js":[function(require,module,exports) {
"use strict";
/**
 * The [[Option]] type expresses that a value may be present or not.
 * The code is organized through the class [[None]] (value not
 * present), the class [[Some]] (value present), and the type alias
 * [[Option]] (Some or None).
 *
 * Finally, "static" functions on Option are arranged in the class
 * [[OptionStatic]] and are accessed through the global constant Option.
 *
 * Examples:
 *
 *     Option.of(5);
 *     Option.none<number>();
 *     Option.of(5).map(x => x*2);
 *
 * To get the value out of an option, you can use [[Some.getOrThrow]],
 * or [[Some.get]]. The latter is available if you've checked that you
 * indeed have a some, for example:
 *
 *     const opt = Option.of(5);
 *     if (opt.isSome()) {
 *         opt.get();
 *     }
 *
 * You also have other options like [[Some.getOrElse]], [[Some.getOrUndefined]]
 * and so on. [[Some]] and [[None]] have the same methods, except that
 * Some has the extra [[Some.get]] method that [[None]] doesn't have.
 */
exports.__esModule = true;
var Value_1 = require("./Value");
var Vector_1 = require("./Vector");
var Either_1 = require("./Either");
var Comparison_1 = require("./Comparison");
var SeqHelpers_1 = require("./SeqHelpers");
var Contract_1 = require("./Contract");
/**
 * Holds the "static methods" for [[Option]]
 */
var OptionStatic = /** @class */ (function () {
    function OptionStatic() {
    }
    /**
     * Builds an optional value.
     * * T is wrapped in a [[Some]]
     * * undefined becomes a [[None]]
     * * null becomes a [[Some]].
     *
     *     Option.of(5).isSome()
     *     => true
     *
     *     Option.of(undefined).isSome()
     *     => false
     *
     *     Option.of(null).isSome()
     *     => true
     *
     * Also see [[OptionStatic.some]], [[OptionStatic.ofNullable]]
     */
    OptionStatic.prototype.of = function (v) {
        return (v === undefined) ? exports.none : new Some(v);
    };
    /**
     * Build an optional value from a nullable.
     * * T is wrapped in a [[Some]]
     * * undefined becomes a [[None]]
     * * null becomes a [[None]].
     *
     *     Option.ofNullable(5).isSome()
     *     => true
     *
     *     Option.ofNullable(undefined).isSome()
     *     => false
     *
     *     Option.ofNullable(null).isSome()
     *     => false
     *
     * Also see [[OptionStatic.some]], [[OptionStatic.of]]
     */
    OptionStatic.prototype.ofNullable = function (v) {
        return (v !== undefined && v !== null) ? new Some(v) : exports.none;
    };
    /**
     * Build a [[Some]], unlike [[OptionStatic.of]], which may build a [[Some]]
     * or a [[None]].
     * Will throw if given undefined.
     *
     *     Option.some(5).isSome()
     *     => true
     *
     *     Option.some(undefined).isSome()
     *     => throws
     *
     *     Option.some(null).isSome()
     *     => true
     *
     * Also see [[OptionStatic.of]], [[OptionStatic.ofNullable]]
     */
    OptionStatic.prototype.some = function (v) {
        // the reason I decided to add a some in addition to 'of'
        // instead of making 'of' smarter (which is possible in
        // typescript, see https://github.com/bcherny/tsoption)
        // is that sometimes you really want an Option, not a Some.
        // for instance you can't mix an a Some and an Option in a list
        // if you put the Some first, without calling asOption().
        if (typeof v === "undefined") {
            throw "Option.some got undefined!";
        }
        return new Some(v);
    };
    /**
     * The optional value expressing a missing value.
     */
    OptionStatic.prototype.none = function () {
        return exports.none;
    };
    /**
     * Curried type guard for Option
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Option.of(2), Option.none<number>())
     *         .filter(Option.isSome)
     *         .map(o => o.get())
     *     => Vector.of(2)
     */
    OptionStatic.prototype.isSome = function (o) {
        return o.isSome();
    };
    /**
     * Curried type guard for Option
     * Sometimes needed also due to https://github.com/Microsoft/TypeScript/issues/20218
     *
     *     Vector.of(Option.of(2), Option.none<number>())
     *         .filter(Option.isNone)
     *     => Vector.of(Option.none<number>())
     */
    OptionStatic.prototype.isNone = function (o) {
        return o.isNone();
    };
    /**
     * Turns a list of options in an option containing a list of items.
     * Useful in many contexts.
     *
     *     Option.sequence(Vector.of(Option.of(1),Option.of(2)))
     *     => Option.of(Vector.of(1,2))
     *
     * But if a single element is None, everything is discarded:
     *
     *     Option.sequence(Vector.of(Option.of(1), Option.none()))
     *     => Option.none()
     *
     * Also see [[OptionStatic.traverse]]
     */
    OptionStatic.prototype.sequence = function (elts) {
        return exports.Option.traverse(elts, function (x) { return x; });
    };
    /**
     * Takes a list, a function that can transform list elements
     * to options, then return an option containing a list of
     * the transformed elements.
     *
     *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?
     *         Option.of("user" + x.toString()) : Option.none();
     *     Option.traverse([4, 3, 2], getUserById);
     *     => Option.of(Vector.of("user4", "user3", "user2"))
     *
     * But if a single element results in None, everything is discarded:
     *
     *     const getUserById: (x:number)=>Option<string> = x => x > 0 ?
     *         Option.of("user" + x.toString()) : Option.none();
     *     Option.traverse([4, -3, 2], getUserById);
     *     => Option.none()
     *
     * Also see [[OptionStatic.sequence]]
     */
    OptionStatic.prototype.traverse = function (elts, fn) {
        var r = Vector_1.Vector.empty();
        var iterator = elts[Symbol.iterator]();
        var curItem = iterator.next();
        while (!curItem.done) {
            var v = fn(curItem.value);
            if (v.isNone()) {
                return exports.none;
            }
            r = r.append(v.get());
            curItem = iterator.next();
        }
        return exports.Option.of(r);
    };
    /**
     * Applicative lifting for Option.
     * Takes a function which operates on basic values, and turns it
     * in a function that operates on options of these values ('lifts'
     * the function). The 2 is because it works on functions taking two
     * parameters.
     *
     *     const lifted = Option.liftA2((x:number,y:number) => x+y);
     *     lifted(Option.of(5), Option.of(6));
     *     => Option.of(11)
     *
     *     const lifted2 = Option.liftA2((x:number,y:number) => x+y);
     *     lifted2(Option.of(5), Option.none<number>());
     *     => Option.none()
     *
     * @param T the first option type
     * @param U the second option type
     * @param V the new type as returned by the combining function.
     */
    OptionStatic.prototype.liftA2 = function (fn) {
        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };
    };
    /**
     * Applicative lifting for Option. 'p' stands for 'properties'.
     *
     * Takes a function which operates on a simple JS object, and turns it
     * in a function that operates on the same JS object type except which each field
     * wrapped in an Option ('lifts' the function).
     * It's an alternative to [[OptionStatic.liftA2]] when the number of parameters
     * is not two.
     *
     *     const lifted = Option.liftAp((x:{a:number,b:number,c:number}) => x.a+x.b+x.c);
     *     lifted({a:Option.of(5), b:Option.of(6), c:Option.of(3)});
     *     => Option.of(14)
     *
     *     const lifted = Option.liftAp((x:{a:number,b:number}) => x.a+x.b);
     *     lifted({a:Option.of(5), b:Option.none<number>()});
     *     => Option.none()
     *
     * @param A the object property type specifying the parameters for your function
     * @param B the type returned by your function, returned wrapped in an option by liftAp.
     */
    OptionStatic.prototype.liftAp = function (fn) {
        return function (x) {
            var copy = {};
            for (var p in x) {
                if (x[p].isNone()) {
                    return exports.Option.none();
                }
                copy[p] = x[p].getOrThrow();
            }
            return exports.Option.of(fn(copy));
        };
    };
    /**
     * Take a partial function (may return undefined or throw),
     * and lift it to return an [[Option]] instead.
     * undefined becomes a [[None]], everything else a [[Some]]
     *
     *     const plus = Option.lift((x:number,y:number)=>x+y);
     *     plus(1,2);
     *     => Option.of(3)
     *
     *     const undef = Option.lift((x:number)=>undefined);
     *     undef(1);
     *     => Option.none()
     *
     *     const nl = Option.lift((x:number,y:number,z:number)=>null);
     *     nl(1,2,3);
     *     => Option.some(null)
     *
     *     const throws = Option.lift((x:number,y:number)=>{throw "x"});
     *     throws(1,2);
     *     => Option.none()
     */
    OptionStatic.prototype.lift = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                return exports.Option.of(fn.apply(void 0, args));
            }
            catch (_a) {
                return exports.Option.none();
            }
        };
    };
    /**
     * Take a partial function (may return undefined or throw),
     * and lift it to return an [[Option]] instead.
     * null and undefined become a [[None]], everything else a [[Some]]
     *
     *     const plus = Option.liftNullable((x:number,y:number)=>x+y);
     *     plus(1,2);
     *     => Option.of(3)
     *
     *     const undef = Option.liftNullable((x:number,y:number,z:string)=>undefined);
     *     undef(1,2,"");
     *     => Option.none()
     *
     *     const nl = Option.liftNullable((x:number)=>null);
     *     nl(1);
     *     => Option.none()
     *
     *     const throws = Option.liftNullable((x:number,y:number)=>{throw "x"});
     *     throws(1,2);
     *     => Option.none()
     */
    OptionStatic.prototype.liftNullable = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                return exports.Option.ofNullable(fn.apply(void 0, args));
            }
            catch (_a) {
                return exports.Option.none();
            }
        };
    };
    /**
     * Take a no-parameter partial function (may return undefined or throw),
     * and call it, return an [[Option]] instead.
     * undefined becomes a [[None]], everything else a [[Some]]
     *
     *     Option.try_(Math.random);
     *     => Option.of(0.49884723907769635)
     *
     *     Option.try_(()=>undefined);
     *     => Option.none()
     *
     *     Option.try_(()=>null);
     *     => Option.of(null)
     *
     *     Option.try_(()=>{throw "x"});
     *     => Option.none()
     *
     * Also see [[OptionStatic.tryNullable]], [[OptionStatic.lift]],
     * [[OptionStatic.liftNullable]], [[EitherStatic.try_]].
     */
    OptionStatic.prototype.try_ = function (fn) {
        return exports.Option.lift(fn)();
    };
    /**
     * Take a no-parameter partial function (may return null, undefined or throw),
     * and call it, return an [[Option]] instead.
     * null and undefined become a [[None]], everything else a [[Some]]
     *
     *     Option.tryNullable(Math.random);
     *     => Option.of(0.49884723907769635)
     *
     *     Option.tryNullable(()=>undefined);
     *     => Option.none()
     *
     *     Option.tryNullable(()=>null);
     *     => Option.none()
     *
     *     Option.tryNullable(()=>{throw "x"});
     *     => Option.none()
     *
     * Also see [[OptionStatic.try_]], [[OptionStatic.liftNullable]],
     * [[OptionStatic.lift]], [[EitherStatic.try_]].
     */
    OptionStatic.prototype.tryNullable = function (fn) {
        return exports.Option.liftNullable(fn)();
    };
    return OptionStatic;
}());
exports.OptionStatic = OptionStatic;
/**
 * The Option constant allows to call the option "static" methods
 */
exports.Option = new OptionStatic();
function optionHasTrueEquality(opt) {
    return opt.flatMap(function (x) { return (x && x.hasTrueEquality) ?
        exports.Option.of(x.hasTrueEquality()) :
        Comparison_1.hasTrueEquality(x); })
        .getOrElse(true);
}
/**
 * Some represents an [[Option]] with a value.
 * "static methods" available through [[OptionStatic]]
 *
 * [[Some]] and [[None]] have the same methods, except that
 * Some has the extra [[Some.get]] method that [[None]] doesn't have.
 * @param T the item type
 */
var Some = /** @class */ (function () {
    /**
     * @hidden
     */
    function Some(value) {
        this.value = value;
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Returns true since this is a Some (contains a value)
     */
    Some.prototype.isSome = function () {
        return true;
    };
    /**
     * Returns false since this is a Some (contains a value)
     */
    Some.prototype.isNone = function () {
        return false;
    };
    /**
     * View this Some a as Option. Useful to help typescript type
     * inference sometimes.
     */
    Some.prototype.asOption = function () {
        return this;
    };
    /**
     * Get the value contained in this option.
     * NOTE: we know it's there, since this method
     * belongs to Some, not Option.
     */
    Some.prototype.get = function () {
        return this.value;
    };
    /**
     * Combines two options. If this option is a Some, returns it.
     * If it's a None, returns the other one.
     */
    Some.prototype.orElse = function (other) {
        return this;
    };
    /**
     * Get the value from this option if it's a Some, otherwise
     * throw an exception.
     * You can optionally pass a message that'll be used as the
     * exception message.
     */
    Some.prototype.getOrThrow = function (errorInfo) {
        return this.value;
    };
    /**
     * Returns true if the option is a Some and contains the
     * value you give, false otherwise.
     */
    Some.prototype.contains = function (v) {
        return v === this.value;
    };
    /**
     * Get the value contained in the option if it's a Some,
     * return undefined if it's a None.
     *
     *     Option.of(5).getOrUndefined()
     *     => 5
     *
     *     Option.none<number>().getOrUndefined()
     *     => undefined
     */
    Some.prototype.getOrUndefined = function () {
        return this.value;
    };
    /**
     * Get the value contained in the option if it's a Some,
     * return null if it's a None.
     *
     *     Option.of(5).getOrNull()
     *     => 5
     *
     *     Option.none<number>().getOrNull()
     *     => null
     */
    Some.prototype.getOrNull = function () {
        return this.value;
    };
    /**
     * Get the value from this option; if it's a None (no value
     * present), then return the default value that you give.
     */
    Some.prototype.getOrElse = function (alt) {
        return this.value;
    };
    /**
     * Get the value from this option; if it's a None (no value
     * present), then return the value returned by the function that you give.
     *
     *     Option.of(5).getOrCall(() => 6)
     *     => 5
     *
     *     Option.none<number>().getOrCall(() => 6)
     *     => 6
     */
    Some.prototype.getOrCall = function (fn) {
        return this.value;
    };
    /**
     * Return a new option where the element (if present) was transformed
     * by the mapper function you give. If the option was None it'll stay None.
     *
     *     Option.of(5).map(x => x*2)
     *     => Option.of(10)
     *
     *     Option.of(5).map(x => null)
     *     => Option.of(null)
     *
     * Also see [[Some.mapNullable]], [[Some.flatMap]]
     */
    Some.prototype.map = function (fn) {
        return exports.Option.of(fn(this.value));
    };
    /**
     * Return a new option where the element (if present) was transformed
     * by the mapper function you give. If the mapped value is `null` or
     * `undefined`, then a Some will turn into a None.
     * If the option was None it'll stay None.
     *
     *     Option.of(5).mapNullable(x => x*2)
     *     => Option.of(10)
     *
     *     Option.of(5).mapNullable(x => null)
     *     => Option.none()
     *
     * Also see [[Some.map]], [[Some.flatMap]]
     */
    Some.prototype.mapNullable = function (fn) {
        return exports.Option.ofNullable(fn(this.value));
    };
    /**
     * If this is a Some, calls the function you give on
     * the item in the option and return its result.
     * If the option is a None, return none.
     * This is the monadic bind.
     */
    Some.prototype.flatMap = function (mapper) {
        return mapper(this.value);
    };
    Some.prototype.filter = function (fn) {
        return fn(this.value) ? this : exports.Option.none();
    };
    /**
     * Execute a side-effecting function if the option
     * is a Some; returns the option.
     */
    Some.prototype.ifSome = function (fn) {
        fn(this.value);
        return this;
    };
    /**
     * Execute a side-effecting function if the option
     * is a None; returns the option.
     */
    Some.prototype.ifNone = function (fn) {
        return this;
    };
    /**
     * Handle both branches of the option and return a value
     * (can also be used for side-effects).
     * This is the catamorphism for option.
     *
     *     Option.of(5).match({
     *         Some: x  => "got " + x,
     *         None: () => "got nothing!"
     *     });
     *     => "got 5"
     */
    Some.prototype.match = function (cases) {
        return cases.Some(this.value);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Some.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Convert to a vector. If it's a None, it's the empty
     * vector, if it's a Some, it's a one-element vector with
     * the contents of the option.
     */
    Some.prototype.toVector = function () {
        return Vector_1.Vector.of(this.value);
    };
    /**
     * Convert to an either. You must provide a left value
     * in case this is a None.
     */
    Some.prototype.toEither = function (left) {
        return Either_1.Either.right(this.value);
    };
    Some.prototype.hasTrueEquality = function () {
        return optionHasTrueEquality(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Some.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        // the .isSome doesn't test if it's a Some, but
        // if the object has a field called isSome.
        if (other === exports.none || !other || !other.isSome) {
            return false;
        }
        var someOther = other;
        Contract_1.contractTrueEquality("Option.equals", this, someOther);
        return Comparison_1.areEqual(this.value, someOther.value);
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Some.prototype.hashCode = function () {
        return Comparison_1.getHashCode(this.value);
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Some.prototype.toString = function () {
        return "Some(" + SeqHelpers_1.toStringHelper(this.value) + ")";
    };
    /**
     * Used by the node REPL to display values.
     */
    Some.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Some;
}());
exports.Some = Some;
/**
 * None represents an [[Option]] without value.
 * "static methods" available through [[OptionStatic]]
 *
 * [[Some]] and [[None]] have the same methods, except that
 * Some has the extra [[Some.get]] method that [[None]] doesn't have.
 * @param T the item type
 */
var None = /** @class */ (function () {
    function None() {
        /**
         * @hidden
         */
        this.className = undefined; // https://stackoverflow.com/a/47841595/516188
    }
    /**
     * Returns false since this is a None (doesn'tcontains a value)
     */
    None.prototype.isSome = function () {
        return false;
    };
    /**
     * Returns true since this is a None (doesn'tcontains a value)
     */
    None.prototype.isNone = function () {
        return true;
    };
    /**
     * View this Some a as Option. Useful to help typescript type
     * inference sometimes.
     */
    None.prototype.asOption = function () {
        return this;
    };
    /**
     * Combines two options. If this option is a Some, returns it.
     * If it's a None, returns the other one.
     */
    None.prototype.orElse = function (other) {
        return other;
    };
    /**
     * Get the value from this option if it's a Some, otherwise
     * throw an exception.
     * You can optionally pass a message that'll be used as the
     * exception message, or an Error object.
     */
    None.prototype.getOrThrow = function (errorInfo) {
        if (typeof errorInfo === 'string') {
            throw new Error(errorInfo || "getOrThrow called on none!");
        }
        throw errorInfo || new Error("getOrThrow called on none!");
    };
    /**
     * Returns true if the option is a Some and contains the
     * value you give, false otherwise.
     */
    None.prototype.contains = function (v) {
        return false;
    };
    /**
     * Get the value contained in the option if it's a Some,
     * return undefined if it's a None.
     *
     *     Option.of(5).getOrUndefined()
     *     => 5
     *
     *     Option.none<number>().getOrUndefined()
     *     => undefined
     */
    None.prototype.getOrUndefined = function () {
        return undefined;
    };
    /**
     * Get the value contained in the option if it's a Some,
     * return null if it's a None.
     *
     *     Option.of(5).getOrNull()
     *     => 5
     *
     *     Option.none<number>().getOrNull()
     *     => null
     */
    None.prototype.getOrNull = function () {
        return null;
    };
    /**
     * Get the value from this option; if it's a None (no value
     * present), then return the default value that you give.
     */
    None.prototype.getOrElse = function (alt) {
        return alt;
    };
    /**
     * Get the value from this option; if it's a None (no value
     * present), then return the value returned by the function that you give.
     *
     *     Option.of(5).getOrCall(() => 6)
     *     => 5
     *
     *     Option.none<number>().getOrCall(() => 6)
     *     => 6
     */
    None.prototype.getOrCall = function (fn) {
        return fn();
    };
    /**
     * Return a new option where the element (if present) was transformed
     * by the mapper function you give. If the option was None it'll stay None.
     *
     *     Option.of(5).map(x => x*2)
     *     => Option.of(10)
     *
     *     Option.of(5).map(x => null)
     *     => Option.of(null)
     *
     * Also see [[None.mapNullable]], [[None.flatMap]]
     */
    None.prototype.map = function (fn) {
        return exports.none;
    };
    /**
     * Return a new option where the element (if present) was transformed
     * by the mapper function you give. If the mapped value is `null` or
     * `undefined`, then a Some will turn into a None.
     * If the option was None it'll stay None.
     *
     *     Option.of(5).mapNullable(x => x*2)
     *     => Option.of(10)
     *
     *     Option.of(5).mapNullable(x => null)
     *     => Option.none()
     *
     * Also see [[None.map]], [[None.flatMap]]
     */
    None.prototype.mapNullable = function (fn) {
        return exports.none;
    };
    /**
     * If this is a Some, calls the function you give on
     * the item in the option and return its result.
     * If the option is a None, return none.
     * This is the monadic bind.
     */
    None.prototype.flatMap = function (mapper) {
        return exports.none;
    };
    None.prototype.filter = function (fn) {
        return exports.none;
    };
    /**
     * Execute a side-effecting function if the option
     * is a Some; returns the option.
     */
    None.prototype.ifSome = function (fn) {
        return this;
    };
    /**
     * Execute a side-effecting function if the option
     * is a Some; returns the option.
     */
    None.prototype.ifNone = function (fn) {
        fn();
        return this;
    };
    /**
     * Handle both branches of the option and return a value
     * (can also be used for side-effects).
     * This is the catamorphism for option.
     *
     *     Option.of(5).match({
     *         Some: x  => "got " + x,
     *         None: () => "got nothing!"
     *     });
     *     => "got 5"
     */
    None.prototype.match = function (cases) {
        return cases.None();
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    None.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Convert to a vector. If it's a None, it's the empty
     * vector, if it's a Some, it's a one-element vector with
     * the contents of the option.
     */
    None.prototype.toVector = function () {
        return Vector_1.Vector.empty();
    };
    /**
     * Convert to an either. You must provide a left value
     * in case this is a None.
     */
    None.prototype.toEither = function (left) {
        return Either_1.Either.left(left);
    };
    None.prototype.hasTrueEquality = function () {
        return optionHasTrueEquality(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    None.prototype.equals = function (other) {
        return other === exports.none;
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    None.prototype.hashCode = function () {
        return 1;
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    None.prototype.toString = function () {
        return "None()";
    };
    /**
     * Used by the node REPL to display values.
     */
    None.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return None;
}());
exports.None = None;
/**
 * @hidden
 */
exports.none = new None();
//# sourceMappingURL=Option.js.map
},{"./Value":"node_modules/prelude-ts/dist/src/Value.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./Either":"node_modules/prelude-ts/dist/src/Either.js","./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js","./Contract":"node_modules/prelude-ts/dist/src/Contract.js"}],"node_modules/prelude-ts/dist/src/Tuple2.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var Value_1 = require("./Value");
var Option_1 = require("./Option");
var Vector_1 = require("./Vector");
var LinkedList_1 = require("./LinkedList");
var Comparison_1 = require("./Comparison");
var SeqHelpers_1 = require("./SeqHelpers");
var Contract_1 = require("./Contract");
/**
 * Contains a pair of two values, which may or may not have the same type.
 * Compared to the builtin typescript [T,U] type, we get equality semantics
 * and helper functions (like mapping and so on).
 * @param T the first item type
 * @param U the second item type
 */
var Tuple2 = /** @class */ (function () {
    function Tuple2(_fst, _snd) {
        this._fst = _fst;
        this._snd = _snd;
    }
    /**
     * Build a pair of value from both values.
     */
    Tuple2.of = function (fst, snd) {
        return new Tuple2(fst, snd);
    };
    /**
     * Build a tuple2 from javascript array. Compared to [[Tuple2.ofPair]],
     * it checks the length of the array and will return [[None]] in case
     * the length isn't two. However the types of the elements aren't checked.
     */
    Tuple2.ofArray = function (pair) {
        if (pair && pair.length === 2) {
            return Option_1.Option.of(new Tuple2(pair[0], pair[1]));
        }
        return Option_1.Option.none();
    };
    /**
     * Build a tuple2 from javascript pair.
     * Also see [[Tuple2.ofArray]]
     */
    Tuple2.ofPair = function (pair) {
        return new Tuple2(pair[0], pair[1]);
    };
    /**
     * @hidden
     */
    Tuple2.prototype.hasTrueEquality = function () {
        return Option_1.Option.of(this.fst()).hasTrueEquality() &&
            Option_1.Option.of(this.snd()).hasTrueEquality();
    };
    /**
     * Extract the first value from the pair
     */
    Tuple2.prototype.fst = function () {
        return this._fst;
    };
    /**
     * Extract the second value from the pair
     */
    Tuple2.prototype.snd = function () {
        return this._snd;
    };
    /**
     * Maps the first component of this tuple to a new value.
     */
    Tuple2.prototype.map1 = function (fn) {
        return new Tuple2(fn(this._fst), this._snd);
    };
    /**
     * Maps the second component of this tuple to a new value.
     */
    Tuple2.prototype.map2 = function (fn) {
        return new Tuple2(this._fst, fn(this._snd));
    };
    /**
     * Make a new tuple by mapping both values inside this one.
     */
    Tuple2.prototype.map = function (fn) {
        return fn(this._fst, this._snd);
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Tuple2.prototype.transform = function (converter) {
        return converter(this);
    };
    /**
     * Two objects are equal if they represent the same value,
     * regardless of whether they are the same object physically
     * in memory.
     */
    Tuple2.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (!other || !other._fst) {
            return false;
        }
        Contract_1.contractTrueEquality("Tuple2.equals", this, other);
        return Comparison_1.areEqual(this._fst, other._fst) &&
            Comparison_1.areEqual(this._snd, other._snd);
    };
    /**
     * Get a number for that object. Two different values
     * may get the same number, but one value must always get
     * the same number. The formula can impact performance.
     */
    Tuple2.prototype.hashCode = function () {
        return Comparison_1.getHashCode(this._fst) * 53 + Comparison_1.getHashCode(this._snd);
    };
    /**
     * Convert the tuple to a javascript pair.
     * Compared to [[Tuple2.toArray]], it behaves the
     * same at runtime, the only difference is the
     * typescript type definition.
     */
    Tuple2.prototype.toPair = function () {
        return [this._fst, this._snd];
    };
    /**
     * Convert the tuple to a javascript array.
     * Compared to [[Tuple2.toPair]], it behaves the
     * same at runtime, the only difference is the
     * typescript type definition.
     */
    Tuple2.prototype.toArray = function () {
        return [this._fst, this._snd];
    };
    /**
     * Convert the tuple to a vector.
     */
    Tuple2.prototype.toVector = function () {
        return Vector_1.Vector.of(this._fst, this._snd);
    };
    /**
     * Convert the tuple to a linked list.
     */
    Tuple2.prototype.toLinkedList = function () {
        return LinkedList_1.LinkedList.of(this._fst, this._snd);
    };
    /**
     * Get a human-friendly string representation of that value.
     */
    Tuple2.prototype.toString = function () {
        return "Tuple2(" + SeqHelpers_1.toStringHelper(this._fst) + ", " + SeqHelpers_1.toStringHelper(this._snd) + ")";
    };
    /**
     * Used by the node REPL to display values.
     * Most of the time should be the same as toString()
     */
    Tuple2.prototype[Value_1.inspect] = function () {
        return this.toString();
    };
    return Tuple2;
}());
exports.Tuple2 = Tuple2;
//# sourceMappingURL=Tuple2.js.map
},{"./Value":"node_modules/prelude-ts/dist/src/Value.js","./Option":"node_modules/prelude-ts/dist/src/Option.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./LinkedList":"node_modules/prelude-ts/dist/src/LinkedList.js","./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./SeqHelpers":"node_modules/prelude-ts/dist/src/SeqHelpers.js","./Contract":"node_modules/prelude-ts/dist/src/Contract.js"}],"node_modules/prelude-ts/dist/src/Predicate.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
/**
 * A predicate is a function taking one parameter and returning a boolean.
 * In other words the predicate checks whether some proposition holds for the parameter.
 *
 * The Predicate interface offers normal function-calling, to make sure that the
 * predicate holds (just call predicate(x)), but also some helper methods to
 * deal with logical operations between propositions.
 *
 * You can build predicates using [[PredicateStatic]] through the
 * 'Predicate' global constant.
 *
 * Examples:
 *
 *     const check = Predicate.of((x: number) => x > 10).and(x => x < 20);
 *     check(12); // => true
 *     check(21);
 *     => false
 *
 *     Vector.of(1,2,3,4,5).filter(
 *         Predicate.isIn([2,3]).negate())
 *     => Vector.of(1, 4, 5)
 */
var Comparison_1 = require("./Comparison");
var Vector_1 = require("./Vector");
/**
 * The Predicates class offers some helper functions to deal
 * with [[Predicate]] including the ability to build [[Predicate]]
 * from functions using [[PredicateStatic.of]], some builtin predicates
 * like [[PredicateStatic.isIn]], and the ability to combine to combine
 * Predicates like with [[PredicateStatic.allOf]].
 */
var PredicateStatic = /** @class */ (function () {
    function PredicateStatic() {
    }
    /**
     * Take a predicate function and of it to become a [[Predicate]]
     * (enabling you to call [[Predicate.and]], and other logic operations on it)
     */
    PredicateStatic.prototype.of = function (fn) {
        var r = fn;
        r.and = function (other) { return exports.Predicate.of(function (x) { return r(x) && other(x); }); };
        r.or = function (other) { return exports.Predicate.of(function (x) { return r(x) || other(x); }); };
        r.negate = function () { return exports.Predicate.of(function (x) { return !fn(x); }); };
        return r;
    };
    /**
     * Return a [[Predicate]] checking whether a value is equal to the
     * value you give as parameter.
     */
    PredicateStatic.prototype.equals = function (other) {
        return exports.Predicate.of(function (x) { return Comparison_1.areEqual(other, x); });
    };
    /**
     * Return a [[Predicate]] checking whether a value is contained in the
     * list of values you give as parameter.
     */
    PredicateStatic.prototype.isIn = function (others) {
        return exports.Predicate.of(function (x) { return Vector_1.Vector.ofIterable(others).contains(x); });
    };
    /**
     * Return a [[Predicate]] checking whether all of the predicate functions given hold
     */
    PredicateStatic.prototype.allOf = function () {
        var predicates = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            predicates[_i] = arguments[_i];
        }
        return exports.Predicate.of(function (x) { return Vector_1.Vector.ofIterable(predicates).allMatch(function (p) { return p(x); }); });
    };
    /**
     * Return a [[Predicate]] checking whether any of the predicate functions given hold
     */
    PredicateStatic.prototype.anyOf = function () {
        var predicates = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            predicates[_i] = arguments[_i];
        }
        return exports.Predicate.of(function (x) { return Vector_1.Vector.ofIterable(predicates).anyMatch(function (p) { return p(x); }); });
    };
    /**
     * Return a [[Predicate]] checking whether none of the predicate functions given hold
     */
    PredicateStatic.prototype.noneOf = function () {
        var predicates = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            predicates[_i] = arguments[_i];
        }
        return exports.Predicate.of(function (x) { return !Vector_1.Vector.ofIterable(predicates).anyMatch(function (p) { return p(x); }); });
    };
    return PredicateStatic;
}());
exports.PredicateStatic = PredicateStatic;
/**
 * The Predicate constant allows to call the [[Predicate]] "static" methods.
 */
exports.Predicate = new PredicateStatic();
//# sourceMappingURL=Predicate.js.map
},{"./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js"}],"node_modules/prelude-ts/dist/src/Function.js":[function(require,module,exports) {
"use strict";
/**
 * Rich functions with helpers such as [[Function1.andThen]],
 * [[Function2.apply1]] and so on.
 *
 * We support functions of arities up to 5. For each arity, we have
 * the interface ([[Function1]], [[Function2]], ...), builders are on functions
 * on [[Function1Static]], [[Function2Static]]... accessible on constants
 * named Function1, Function2,...
 *
 * Examples:
 *
 *     const combined = Function1.of((x:number)=>x+2).andThen(x=>x*3);
 *     combined(6);
 *     => 24
 *
 *     const plus5 = Function2.of((x:number,y:number)=>x+y).apply1(5);
 *     plus5(1);
 *     => 6
 */
exports.__esModule = true;
/**
 * This is the type of the Function0 constant, which
 * offers some helper functions to deal
 * with [[Function0]] including
 * the ability to build [[Function0]]
 * from functions using [[Function0Static.of]].
 * It also offers some builtin functions like [[Function0Static.constant]].
 */
var Function0Static = /** @class */ (function () {
    function Function0Static() {
    }
    /**
     * The constant function of one parameter:
     * will always return the value you give, no
     * matter the parameter it's given.
     */
    Function0Static.prototype.constant = function (val) {
        return exports.Function0.of(function () { return val; });
    };
    /**
     * Take a one-parameter function and lift it to become a [[Function1Static]],
     * enabling you to call [[Function1.andThen]] and other such methods on it.
     */
    Function0Static.prototype.of = function (fn) {
        var r = (function () { return fn(); });
        r.andThen = function (fn2) { return exports.Function0.of(function () { return fn2(r()); }); };
        return r;
    };
    return Function0Static;
}());
exports.Function0Static = Function0Static;
/**
 * The Function1 constant allows to call the [[Function0]] "static" methods.
 */
exports.Function0 = new Function0Static();
/**
 * This is the type of the Function1 constant, which
 * offers some helper functions to deal
 * with [[Function1]] including
 * the ability to build [[Function1]]
 * from functions using [[Function1Static.of]].
 * It also offers some builtin functions like [[Function1Static.constant]].
 */
var Function1Static = /** @class */ (function () {
    function Function1Static() {
    }
    /**
     * The identity function.
     */
    Function1Static.prototype.id = function () {
        return exports.Function1.of(function (x) { return x; });
    };
    /**
     * The constant function of one parameter:
     * will always return the value you give, no
     * matter the parameter it's given.
     */
    Function1Static.prototype.constant = function (val) {
        return exports.Function1.of(function (x) { return val; });
    };
    /**
     * Take a one-parameter function and lift it to become a [[Function1Static]],
     * enabling you to call [[Function1.andThen]] and other such methods on it.
     */
    Function1Static.prototype.of = function (fn) {
        var r = (function (x) { return fn(x); });
        r.andThen = function (fn2) { return exports.Function1.of(function (x) { return fn2(r(x)); }); };
        r.compose = function (fn2) { return exports.Function1.of(function (x) { return r(fn2(x)); }); };
        return r;
    };
    return Function1Static;
}());
exports.Function1Static = Function1Static;
/**
 * The Function1 constant allows to call the [[Function1]] "static" methods.
 */
exports.Function1 = new Function1Static();
/**
 * This is the type of the Function2 constant, which
 * offers some helper functions to deal
 * with [[Function2]] including
 * the ability to build [[Function2]]
 * from functions using [[Function2Static.of]].
 * It also offers some builtin functions like [[Function2Static.constant]].
 */
var Function2Static = /** @class */ (function () {
    function Function2Static() {
    }
    /**
     * The constant function of two parameters:
     * will always return the value you give, no
     * matter the parameters it's given.
     */
    Function2Static.prototype.constant = function (val) {
        return exports.Function2.of(function (x, y) { return val; });
    };
    /**
     * Take a two-parameter function and lift it to become a [[Function2]],
     * enabling you to call [[Function2.andThen]] and other such methods on it.
     */
    Function2Static.prototype.of = function (fn) {
        var r = (function (x, y) { return fn(x, y); });
        r.andThen = function (fn2) { return exports.Function2.of(function (x, y) { return fn2(r(x, y)); }); };
        r.curried = function () { return exports.Function1.of(function (x) { return exports.Function1.of(function (y) { return r(x, y); }); }); };
        r.tupled = function () { return exports.Function1.of(function (pair) { return r(pair[0], pair[1]); }); };
        r.flipped = function () { return exports.Function2.of(function (x, y) { return r(y, x); }); };
        r.apply1 = function (x) { return exports.Function1.of(function (y) { return r(x, y); }); };
        return r;
    };
    return Function2Static;
}());
exports.Function2Static = Function2Static;
/**
 * The Function2 constant allows to call the [[Function2]] "static" methods.
 */
exports.Function2 = new Function2Static();
/**
 * This is the type of the Function3 constant, which
 * offers some helper functions to deal
 * with [[Function3]] including
 * the ability to build [[Function3]]
 * from functions using [[Function3Static.of]].
 * It also offers some builtin functions like [[Function3Static.constant]].
 */
var Function3Static = /** @class */ (function () {
    function Function3Static() {
    }
    /**
     * The constant function of three parameters:
     * will always return the value you give, no
     * matter the parameters it's given.
     */
    Function3Static.prototype.constant = function (val) {
        return exports.Function3.of(function (x, y, z) { return val; });
    };
    /**
     * Take a three-parameter function and lift it to become a [[Function3]],
     * enabling you to call [[Function3.andThen]] and other such methods on it.
     */
    Function3Static.prototype.of = function (fn) {
        var r = (function (x, y, z) { return fn(x, y, z); });
        r.andThen = function (fn2) { return exports.Function3.of(function (x, y, z) { return fn2(r(x, y, z)); }); };
        r.curried = function () { return exports.Function1.of(function (x) { return exports.Function1.of(function (y) { return exports.Function1.of(function (z) { return r(x, y, z); }); }); }); };
        r.tupled = function () { return exports.Function1.of(function (tuple) { return r(tuple[0], tuple[1], tuple[2]); }); };
        r.flipped = function () { return exports.Function3.of(function (x, y, z) { return r(z, y, x); }); };
        r.apply1 = function (x) { return exports.Function2.of(function (y, z) { return r(x, y, z); }); };
        r.apply2 = function (x, y) { return exports.Function1.of(function (z) { return r(x, y, z); }); };
        return r;
    };
    return Function3Static;
}());
exports.Function3Static = Function3Static;
/**
 * The Function3 constant allows to call the [[Function3]] "static" methods.
 */
exports.Function3 = new Function3Static();
/**
 * This is the type of the Function4 constant, which
 * offers some helper functions to deal
 * with [[Function4]] including
 * the ability to build [[Function4]]
 * from functions using [[Function4Static.of]].
 * It also offers some builtin functions like [[Function4Static.constant]].
 */
var Function4Static = /** @class */ (function () {
    function Function4Static() {
    }
    /**
     * The constant function of four parameters:
     * will always return the value you give, no
     * matter the parameters it's given.
     */
    Function4Static.prototype.constant = function (val) {
        return exports.Function4.of(function (x, y, z, a) { return val; });
    };
    /**
     * Take a four-parameter function and lift it to become a [[Function4]],
     * enabling you to call [[Function4.andThen]] and other such methods on it.
     */
    Function4Static.prototype.of = function (fn) {
        var r = (function (x, y, z, a) { return fn(x, y, z, a); });
        r.andThen = function (fn2) { return exports.Function4.of(function (x, y, z, a) { return fn2(r(x, y, z, a)); }); };
        r.curried = function () { return exports.Function1.of(function (x) { return exports.Function1.of(function (y) { return exports.Function1.of(function (z) { return exports.Function1.of(function (a) { return r(x, y, z, a); }); }); }); }); };
        r.tupled = function () { return exports.Function1.of(function (tuple) { return r(tuple[0], tuple[1], tuple[2], tuple[3]); }); };
        r.flipped = function () { return exports.Function4.of(function (x, y, z, a) { return r(a, z, y, x); }); };
        r.apply1 = function (x) { return exports.Function3.of(function (y, z, a) { return r(x, y, z, a); }); };
        r.apply2 = function (x, y) { return exports.Function2.of(function (z, a) { return r(x, y, z, a); }); };
        r.apply3 = function (x, y, z) { return exports.Function1.of(function (a) { return r(x, y, z, a); }); };
        return r;
    };
    return Function4Static;
}());
exports.Function4Static = Function4Static;
;
/**
 * The Function4 constant allows to call the [[Function4]] "static" methods.
 */
exports.Function4 = new Function4Static();
/**
 * This is the type of the Function5 constant, which
 * offers some helper functions to deal
 * with [[Function5]] including
 * the ability to build [[Function5]]
 * from functions using [[Function5Static.of]].
 * It also offers some builtin functions like [[Function5Static.constant]].
 */
var Function5Static = /** @class */ (function () {
    function Function5Static() {
    }
    /**
     * The constant function of five parameters:
     * will always return the value you give, no
     * matter the parameters it's given.
     */
    Function5Static.prototype.constant = function (val) {
        return exports.Function5.of(function (x, y, z, a, b) { return val; });
    };
    /**
     * Take a five-parameter function and lift it to become a [[Function5]],
     * enabling you to call [[Function5.andThen]] and other such methods on it.
     */
    Function5Static.prototype.of = function (fn) {
        var r = (function (x, y, z, a, b) { return fn(x, y, z, a, b); });
        r.andThen = function (fn2) { return exports.Function5.of(function (x, y, z, a, b) { return fn2(r(x, y, z, a, b)); }); };
        r.curried = function () { return exports.Function1.of(function (x) { return exports.Function1.of(function (y) { return exports.Function1.of(function (z) { return exports.Function1.of(function (a) { return exports.Function1.of(function (b) { return r(x, y, z, a, b); }); }); }); }); }); };
        r.tupled = function () { return exports.Function1.of(function (tuple) { return r(tuple[0], tuple[1], tuple[2], tuple[3], tuple[4]); }); };
        r.flipped = function () { return exports.Function5.of(function (x, y, z, a, b) { return r(b, a, z, y, x); }); };
        r.apply1 = function (x) { return exports.Function4.of(function (y, z, a, b) { return r(x, y, z, a, b); }); };
        r.apply2 = function (x, y) { return exports.Function3.of(function (z, a, b) { return r(x, y, z, a, b); }); };
        r.apply3 = function (x, y, z) { return exports.Function2.of(function (a, b) { return r(x, y, z, a, b); }); };
        r.apply4 = function (x, y, z, a) { return exports.Function1.of(function (b) { return r(x, y, z, a, b); }); };
        return r;
    };
    return Function5Static;
}());
exports.Function5Static = Function5Static;
/**
 * The Function5 constant allows to call the [[Function5]] "static" methods.
 */
exports.Function5 = new Function5Static();
//# sourceMappingURL=Function.js.map
},{}],"node_modules/prelude-ts/dist/src/Future.js":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var Vector_1 = require("./Vector");
var Option_1 = require("./Option");
var Either_1 = require("./Either");
var HashMap_1 = require("./HashMap");
/**
 * A Future is the equivalent, and ultimately wraps, a javascript Promise.
 * While Futures support the [[Future.then]] call (so that among others
 * you can use `await` on them), you should call [[Future.map]] and
 * [[Future.flatMap]].
 *
 * Futures represent an asynchronous computation. A Future will only ever
 * be computed once at most. Once it's computed, calling [[Future.map]] or
 * `await` will return instantly.
 */
var Future = /** @class */ (function () {
    // careful cause i can't have my type be F<F<T>>
    // while the code does F<T> as JS's then does!!!
    // for that reason I wrap the value in an array
    // to make sure JS will never turn a Promise<Promise<T>>
    // in a Promise<T>
    function Future(promise) {
        this.promise = promise;
    }
    /**
     * Build a Future in the same way as the 'new Promise'
     * constructor.
     * You get one callback to signal success (resolve),
     * failure (reject), or you can throw to signal failure.
     *
     *     Future.ofPromiseCtor<string>((resolve,reject) => setTimeout(resolve, 10, "hello!"))
     */
    Future.ofPromiseCtor = function (executor) {
        return new Future(new Promise(executor).then(function (v) { return [v]; }));
    };
    /**
     * Build a Future from an existing javascript Promise.
     */
    Future.of = function (promise) {
        return new Future(promise.then(function (x) { return [x]; }));
    };
    /**
     * Build a Future from a node-style callback API, for instance:
     *
     *     Future.ofCallback<string>(cb => fs.readFile('/etc/passwd', 'utf-8', cb))
     */
    Future.ofCallback = function (fn) {
        return Future.ofPromiseCtor(function (resolve, reject) { return fn(function (err, data) {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        }); });
    };
    /**
     * Build a successful Future with the value you provide.
     */
    Future.ok = function (val) {
        return new Future(Promise.resolve([val]));
    };
    /**
     * Build a failed Future with the error data you provide.
     */
    Future.failed = function (reason) {
        return new Future(Promise.reject(reason));
    };
    /**
     * Creates a Future from a function returning a Promise,
     * which can be inline in the call, for instance:
     *
     *     const f1 = Future.ok(1);
     *     const f2 = Future.ok(2);
     *     return Future.do(async () => {
     *         const v1 = await f1;
     *         const v2 = await f2;
     *         return v1 + v2;
     *     });
     */
    Future["do"] = function (fn) {
        return Future.of(fn());
    };
    /**
     * The `then` call is not meant to be a part of the `Future` API,
     * we need then so that `await` works directly.
     *
     * Please rather use [[Future.map]] or [[Future.flatMap]].
     */
    Future.prototype.then = function (onfulfilled, onrejected) {
        return this.promise.then(function (_a) {
            var x = _a[0];
            return onfulfilled(x);
        }, function (rejected) { return onrejected ? onrejected(rejected) : Promise.reject(rejected); });
    };
    /**
     * Get a `Promise` from this `Future`.
     */
    Future.prototype.toPromise = function () {
        return this.promise.then(function (_a) {
            var x = _a[0];
            return x;
        });
    };
    /**
     * Returns a `Future` that'll complete when the first `Future` of
     * the iterable you give will complete, with the value of that first
     * future. Be careful, completing doesn't necessarily mean completing
     * successfully!
     *
     * Also see [[Future.firstSuccessfulOf]]
     */
    Future.firstCompletedOf = function (elts) {
        return Future.of(Promise.race(Vector_1.Vector.ofIterable(elts).map(function (f) { return f.toPromise(); })));
    };
    /**
     * Returns a `Future` that'll complete when the first `Future` of
     * the iterable you give will complete successfully, with the value of that first
     * future.
     *
     * Also see [[Future.firstCompletedOf]]
     */
    Future.firstSuccessfulOf = function (elts) {
        // https://stackoverflow.com/a/37235274/516188
        return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (p) {
            // If a request fails, count that as a resolution so it will keep
            // waiting for other possible successes. If a request succeeds,
            // treat it as a rejection so Promise.all immediately bails out.
            return p.then(function (val) { return Promise.reject(val); }, function (err) { return Promise.resolve(err); });
        })).then(
        // If '.all' resolved, we've just got an array of errors.
        function (errors) { return Promise.reject(errors); }, 
        // If '.all' rejected, we've got the result we wanted.
        function (val) { return Promise.resolve(val); }));
    };
    /**
     * Turns a list of futures in a future containing a list of items.
     * Useful in many contexts.
     *
     * But if a single future is failed, you get back a failed Future.
     *
     * Also see [[Future.traverse]]
     */
    Future.sequence = function (elts) {
        return Future.traverse(elts, function (x) { return x; });
    };
    /**
     * Takes a list, a function that can transform list elements
     * to futures, then return a Future containing a list of
     * the transformed elements.
     *
     * But if a single element results in failure, the result also
     * resolves to a failure.
     *
     * There is an optional third parameter to specify options.
     * You can specify `{maxConcurrent: number}` to request that
     * the futures are not all triggered at the same time, but
     * rather only 'number' at a time.
     *
     * Also see [[Future.sequence]]
     */
    Future.traverse = function (elts, fn, opts) {
        if (!opts) {
            return Future.of(Promise.all(Vector_1.Vector.ofIterable(elts).map(function (x) { return fn(x).toPromise(); }))
                .then(Vector_1.Vector.ofIterable));
        }
        // maxConcurrent algorithm inspired by https://stackoverflow.com/a/38778887/516188
        var index = 0;
        var active = [];
        var results = {};
        var it = elts[Symbol.iterator]();
        var failed;
        var addAsNeeded = function (_) {
            if (failed) {
                return failed;
            }
            var cur;
            var _loop_1 = function () {
                var p = fn(cur.value);
                active.push(p);
                var curIdx = index++;
                p.onComplete(function (eitherRes) {
                    active.splice(active.indexOf(p), 1);
                    if (eitherRes.isLeft()) {
                        failed = p;
                    }
                    else {
                        results[curIdx] = eitherRes.get();
                    }
                });
            };
            while (active.length < opts.maxConcurrent &&
                !(cur = it.next()).done) {
                _loop_1();
            }
            if (!failed && active.length === 0 && cur && cur.done) {
                return Future.ok(HashMap_1.HashMap.ofObjectDictionary(results)
                    .toVector()
                    .sortOn(function (kv) { return parseInt(kv[0]); })
                    .map(function (kv) { return kv[1]; }));
            }
            return Future.firstCompletedOf(active).flatMap(addAsNeeded);
        };
        return addAsNeeded();
    };
    /**
     * From the list of Futures you give, will attempt to find a successful
     * Future which value matches the predicate you give.
     * We return a Future of an [[Option]], which will [[None]] in case
     * no matching Future is found.
     */
    Future.find = function (elts, p) {
        var origElts = Vector_1.Vector.ofIterable(elts);
        if (origElts.isEmpty()) {
            return Future.ok(Option_1.Option.none());
        }
        // map the failures to successes with option.none
        // backup the original future object matching the new future
        var velts = origElts
            .map(function (f) { return f
            .map(function (item) { return [f, Option_1.Option.of(item)]; })
            .recoverWith(function (_) { return Future.ok([f, Option_1.Option.none()]); }); });
        // go for the first completed of the iterable
        // remember after our map they're all successful now
        var success = Future.firstCompletedOf(velts);
        return success
            .flatMap(function (_a) {
            var originalFuture = _a[0], option = _a[1];
            if (option.isSome() && p(option.get())) {
                // this successful future matches our predicate, that's it.
                return success.map(function (x) { return x[1]; });
            }
            else {
                // this future failed or doesn't match our predicate.
                // remove the future from the input list (we can do that
                // because we "backed up" the original future in the future
                // result), and try again only with the remaining candidates
                return Future.find(origElts.removeFirst(function (future) { return future === originalFuture; }), p);
            }
        });
    };
    /**
     * Applicative lifting for Future. 'p' stands for 'properties'.
     *
     * Takes a function which operates on a simple JS object, and turns it
     * in a function that operates on the same JS object type except which each field
     * wrapped in a Future ('lifts' the function).
     * It's an alternative to [[Future.liftA2]] when the number of parameters
     * is not two.
     *
     * @param A the object property type specifying the parameters for your function
     * @param B the type returned by your function, returned wrapped in a future by liftAp.
     */
    Future.liftAp = function (fn) {
        return function (x) {
            var fieldNames = Object.keys(x);
            var promisesAr = fieldNames.map(function (n) { return x[n]; });
            var i = 0;
            return Future.of(Promise.all(promisesAr)
                .then(function (resultAr) { return resultAr.reduce(function (sofar, cur) {
                sofar[fieldNames[i++]] = cur;
                return sofar;
            }, {}); })).map(fn);
        };
    };
    /**
     * Applicative lifting for Future.
     * Takes a function which operates on basic values, and turns it
     * in a function that operates on futures of these values ('lifts'
     * the function). The 2 is because it works on functions taking two
     * parameters.
     *
     * @param R1 the first future type
     * @param R2 the second future type
     * @param V the new future type as returned by the combining function.
     */
    Future.liftA2 = function (fn) {
        return function (p1, p2) { return p1.flatMap(function (a1) { return p2.map(function (a2) { return fn(a1, a2); }); }); };
    };
    /**
     * Take a function returning a Promise
     * and lift it to return a [[Future]] instead.
     */
    Future.lift = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Future.of(fn.apply(void 0, args));
        };
    };
    /**
     * Transform the value contained in a successful Future. Has no effect
     * if the Future was failed. Will turn a successful Future in a failed
     * one if you throw an exception in the map callback (but please don't
     * do it.. Rather use [[Future.filter]] or another mechanism).
     */
    Future.prototype.map = function (fn) {
        return new Future(this.promise.then(function (_a) {
            var x = _a[0];
            return [fn(x)];
        }));
    };
    /**
     * Transform the value contained in a successful Future. You return a
     * Future, but it is then "flattened" so we still return a Future<T>
     * (and not a Future<Future<T>>).
     * Has no effect if the Future was failed. Will turn a successful Future in a failed
     * one if you throw an exception in the map callback (but please don't
     * do it.. Rather use [[Future.filter]] or another mechanism).
     * This is the monadic bind.
     */
    Future.prototype.flatMap = function (fn) {
        return new Future(this.promise.then(function (_a) {
            var x = _a[0];
            return fn(x).promise;
        }));
    };
    /**
     * Transform the value contained in a failed Future. Has no effect
     * if the Future was successful.
     */
    Future.prototype.mapFailure = function (fn) {
        return new Future(this.promise["catch"](function (x) { throw fn(x); }));
    };
    /**
     * Execute the side-effecting function you give if the Future is a failure.
     *
     * The Future is unchanged by this call.
     */
    Future.prototype.onFailure = function (fn) {
        this.promise["catch"](function (x) { return fn(x); });
        return this;
    };
    /**
     * Execute the side-effecting function you give if the Future is a success.
     *
     * The Future is unchanged by this call.
     */
    Future.prototype.onSuccess = function (fn) {
        // we create a new promise here, need to catch errors on it,
        // to avoid node UnhandledPromiseRejectionWarning warnings
        this.promise.then(function (x) { fn(x[0]); return x; })["catch"](function (_) { });
        return this;
    };
    /**
     * Execute the side-effecting function you give when the Future is
     * completed. You get an [[Either]], a `Right` if the Future is a
     * success, a `Left` if it's a failure.
     *
     * The Future is unchanged by this call.
     */
    Future.prototype.onComplete = function (fn) {
        this.promise.then(function (x) { fn(Either_1.Either.right(x[0])); return x; }, function (x) { return fn(Either_1.Either.left(x)); });
        return this;
    };
    /**
     * Has no effect on a failed Future. If the Future was successful,
     * will check whether its value matches the predicate you give as
     * first parameter. If the value matches the predicate, an equivalent
     * Future to the input one is returned.
     *
     * If the value doesn't match predicate however, the second parameter
     * function is used to compute the contents of a failed Future that'll
     * be returned.
     */
    Future.prototype.filter = function (p, ifFail) {
        return this.flatMap(function (x) { return p(x) ? Future.ok(x) : Future.failed(ifFail(x)); });
    };
    /**
     * Has no effect if this Future is successful. If it's failed however,
     * the function you give will be called, receiving as parameter
     * the error contents, and a Future equivalent to the one your
     * function returns will be returned.
     */
    Future.prototype.recoverWith = function (f) {
        return new Future(this.promise["catch"](function (err) { return f(err).promise; }));
    };
    /**
     * Transform this value to another value type.
     * Enables fluent-style programming by chaining calls.
     */
    Future.prototype.transform = function (fn) {
        return fn(this);
    };
    return Future;
}());
exports.Future = Future;
//# sourceMappingURL=Future.js.map
},{"./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./Option":"node_modules/prelude-ts/dist/src/Option.js","./Either":"node_modules/prelude-ts/dist/src/Either.js","./HashMap":"node_modules/prelude-ts/dist/src/HashMap.js"}],"node_modules/prelude-ts/dist/src/index.js":[function(require,module,exports) {
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
exports.__esModule = true;
// Not re-exporting the abstract types such as Seq, Collection and so on,
// on purpose. Right now they are more an help to design the library, not meant
// for the user.
// Seq<T>.equals is a lot less type-precise than Vector<T>.equals, so I'd rather
// the users use concrete types.
__export(require("./Option"));
__export(require("./Either"));
__export(require("./Lazy"));
__export(require("./Vector"));
__export(require("./LinkedList"));
__export(require("./HashMap"));
__export(require("./HashSet"));
__export(require("./Tuple2"));
__export(require("./Value"));
__export(require("./Comparison"));
__export(require("./Stream"));
__export(require("./Contract"));
__export(require("./Predicate"));
__export(require("./Function"));
__export(require("./Future"));
//# sourceMappingURL=index.js.map
},{"./Option":"node_modules/prelude-ts/dist/src/Option.js","./Either":"node_modules/prelude-ts/dist/src/Either.js","./Lazy":"node_modules/prelude-ts/dist/src/Lazy.js","./Vector":"node_modules/prelude-ts/dist/src/Vector.js","./LinkedList":"node_modules/prelude-ts/dist/src/LinkedList.js","./HashMap":"node_modules/prelude-ts/dist/src/HashMap.js","./HashSet":"node_modules/prelude-ts/dist/src/HashSet.js","./Tuple2":"node_modules/prelude-ts/dist/src/Tuple2.js","./Value":"node_modules/prelude-ts/dist/src/Value.js","./Comparison":"node_modules/prelude-ts/dist/src/Comparison.js","./Stream":"node_modules/prelude-ts/dist/src/Stream.js","./Contract":"node_modules/prelude-ts/dist/src/Contract.js","./Predicate":"node_modules/prelude-ts/dist/src/Predicate.js","./Function":"node_modules/prelude-ts/dist/src/Function.js","./Future":"node_modules/prelude-ts/dist/src/Future.js"}],"node_modules/isomorphic-git/dist/bundle.umd.min.js":[function(require,module,exports) {
var define;
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.git = e() : t.git = e();
}(self, function () {
  return function (t) {
    var e = {};

    function r(n) {
      if (e[n]) return e[n].exports;
      var i = e[n] = {
        i: n,
        l: !1,
        exports: {}
      };
      return t[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;
    }

    return r.m = t, r.c = e, r.d = function (t, e, n) {
      r.o(t, e) || Object.defineProperty(t, e, {
        enumerable: !0,
        get: n
      });
    }, r.r = function (t) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(t, "__esModule", {
        value: !0
      });
    }, r.t = function (t, e) {
      if (1 & e && (t = r(t)), 8 & e) return t;
      if (4 & e && "object" == _typeof(t) && t && t.__esModule) return t;
      var n = Object.create(null);
      if (r.r(n), Object.defineProperty(n, "default", {
        enumerable: !0,
        value: t
      }), 2 & e && "string" != typeof t) for (var i in t) {
        r.d(n, i, function (e) {
          return t[e];
        }.bind(null, i));
      }
      return n;
    }, r.n = function (t) {
      var e = t && t.__esModule ? function () {
        return t.default;
      } : function () {
        return t;
      };
      return r.d(e, "a", e), e;
    }, r.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, r.p = "", r(r.s = 129);
  }([function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return i;
    }), r.d(e, "b", function () {
      return o;
    });
    var n = {
      FileReadError: 'Could not read file "{ filepath }".',
      MissingRequiredParameterError: 'The function "{ function }" requires a "{ parameter }" parameter but none was provided.',
      InvalidRefNameError: 'Failed to { verb } { noun } "{ ref }" because that name would not be a valid git reference. A valid alternative would be "{ suggestion }".',
      InvalidParameterCombinationError: 'The function "{ function }" doesn\'t take these parameters simultaneously: { parameters }',
      RefExistsError: 'Failed to create { noun } "{ ref }" because { noun } "{ ref }" already exists.',
      RefNotExistsError: 'Failed to { verb } { noun } "{ ref }" because { noun } "{ ref }" does not exists.',
      BranchDeleteError: 'Failed to delete branch "{ ref }" because branch "{ ref }" checked out now.',
      NoHeadCommitError: 'Failed to create { noun } "{ ref }" because the HEAD ref could not be resolved to a commit.',
      CommitNotFetchedError: 'Failed to checkout "{ ref }" because commit { oid } is not available locally. Do a git fetch to make the branch available locally.',
      ObjectTypeUnknownFail: 'Object { oid } has unknown type "{ type }".',
      ObjectTypeAssertionFail: "Object { oid } was anticipated to be a { expected } but it is a { type }. This is probably a bug deep in isomorphic-git!",
      ObjectTypeAssertionInTreeFail: 'Object { oid } in tree for "{ entrypath }" was an unexpected object type "{ type }".',
      ObjectTypeAssertionInRefFail: '{ ref } is not pointing to a "{ expected }" object but a "{ type }" object.',
      ObjectTypeAssertionInPathFail: 'Found a blob { oid } in the path "{ path }" where a tree was expected.',
      MissingAuthorError: "Author name and email must be specified as an argument or in the .git/config file.",
      MissingCommitterError: "Committer name and email must be specified if a committer object is passed.",
      MissingTaggerError: "Tagger name and email must be specified as an argument or in the .git/config file.",
      GitRootNotFoundError: "Unable to find git root for { filepath }.",
      UnparseableServerResponseFail: 'Unparsable response from server! Expected "unpack ok" or "unpack [error message]" but received "{ line }".',
      InvalidDepthParameterError: "Invalid value for depth parameter: { depth }",
      RemoteDoesNotSupportShallowFail: "Remote does not support shallow fetches.",
      RemoteDoesNotSupportDeepenSinceFail: "Remote does not support shallow fetches by date.",
      RemoteDoesNotSupportDeepenNotFail: "Remote does not support shallow fetches excluding commits reachable by refs.",
      RemoteDoesNotSupportDeepenRelativeFail: "Remote does not support shallow fetches relative to the current shallow depth.",
      RemoteDoesNotSupportSmartHTTP: 'Remote does not support the "smart" HTTP protocol, and isomorphic-git does not support the "dumb" HTTP protocol, so they are incompatible.',
      CorruptShallowOidFail: "non-40 character shallow oid: { oid }",
      FastForwardFail: "A simple fast-forward merge was not possible.",
      MergeNotSupportedFail: "Merges with conflicts are not supported yet.",
      DirectorySeparatorsError: '"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms',
      ResolveTreeError: "Could not resolve { oid } to a tree.",
      ResolveCommitError: "Could not resolve { oid } to a commit.",
      DirectoryIsAFileError: 'Unable to read "{ oid }:{ filepath }" because encountered a file where a directory was expected.',
      TreeOrBlobNotFoundError: 'No file or directory found at "{ oid }:{ filepath }".',
      NotImplementedFail: "TODO: { thing } still needs to be implemented!",
      ReadObjectFail: "Failed to read git object with oid { oid }",
      NotAnOidFail: 'Expected a 40-char hex object id but saw "{ value }".',
      NoRefspecConfiguredError: 'Could not find a fetch refspec for remote "{ remote }".\\nMake sure the config file has an entry like the following:\\n[remote "{ remote }"]\\nfetch = +refs/heads/*:refs/remotes/origin/*',
      MismatchRefValueError: 'Provided oldValue doesn\\\'t match the actual value of "{ ref }".',
      ResolveRefError: 'Could not resolve reference "{ ref }".',
      ExpandRefError: 'Could not expand reference "{ ref }".',
      EmptyServerResponseFail: "Empty response from git server.",
      AssertServerResponseFail: 'Expected "{ expected }" but got "{ actual }".',
      HTTPError: "HTTP Error: { statusCode } { statusMessage }",
      RemoteUrlParseError: 'Cannot parse remote URL: "{ url }"',
      UnknownTransportError: 'Git remote "{ url }" uses an unrecognized transport protocol: "{ transport }"',
      AcquireLockFileFail: 'Unable to acquire lockfile "{ filename }". Exhausted tries.',
      DoubleReleaseLockFileFail: 'Cannot double-release lockfile "{ filename }".',
      InternalFail: "An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: { message }",
      UnknownOauth2Format: "I do not know how { company } expects its Basic Auth headers to be formatted for OAuth2 usage. If you do, you can use the regular username and password parameters to set the basic auth header yourself.",
      MissingPasswordTokenError: "Missing password or token",
      MissingUsernameError: "Missing username",
      MixPasswordTokenError: 'Cannot mix "password" with "token"',
      MixUsernamePasswordTokenError: 'Cannot mix "username" and "password" with "token"',
      MissingTokenError: "Missing token",
      MixUsernameOauth2formatMissingTokenError: 'Cannot mix "username" with "oauth2format". Missing token.',
      MixPasswordOauth2formatMissingTokenError: 'Cannot mix "password" with "oauth2format". Missing token.',
      MixUsernamePasswordOauth2formatMissingTokenError: 'Cannot mix "username" and "password" with "oauth2format". Missing token.',
      MixUsernameOauth2formatTokenError: 'Cannot mix "username" with "oauth2format" and "token"',
      MixPasswordOauth2formatTokenError: 'Cannot mix "password" with "oauth2format" and "token"',
      MixUsernamePasswordOauth2formatTokenError: 'Cannot mix "username" and "password" with "oauth2format" and "token"',
      MaxSearchDepthExceeded: "Maximum search depth of { depth } exceeded.",
      PushRejectedNonFastForward: 'Push rejected because it was not a simple fast-forward. Use "force: true" to override.',
      PushRejectedTagExists: 'Push rejected because tag already exists. Use "force: true" to override.',
      AddingRemoteWouldOverwrite: 'Adding remote { remote } would overwrite the existing remote. Use "force: true" to override.',
      PluginUndefined: 'A command required the "{ plugin }" plugin but it was undefined.',
      CoreNotFound: 'No plugin core with the name "{ core }" is registered.',
      PluginSchemaViolation: 'Schema check failed for "{ plugin }" plugin; missing { method } method.',
      PluginUnrecognized: 'Unrecognized plugin type "{ plugin }"',
      AmbiguousShortOid: 'Found multiple oids matching "{ short }" ({ matches }). Use a longer abbreviation length to disambiguate them.',
      ShortOidNotFound: 'Could not find an object matching "{ short }".'
    },
        i = {
      FileReadError: "FileReadError",
      MissingRequiredParameterError: "MissingRequiredParameterError",
      InvalidRefNameError: "InvalidRefNameError",
      InvalidParameterCombinationError: "InvalidParameterCombinationError",
      RefExistsError: "RefExistsError",
      RefNotExistsError: "RefNotExistsError",
      BranchDeleteError: "BranchDeleteError",
      NoHeadCommitError: "NoHeadCommitError",
      CommitNotFetchedError: "CommitNotFetchedError",
      ObjectTypeUnknownFail: "ObjectTypeUnknownFail",
      ObjectTypeAssertionFail: "ObjectTypeAssertionFail",
      ObjectTypeAssertionInTreeFail: "ObjectTypeAssertionInTreeFail",
      ObjectTypeAssertionInRefFail: "ObjectTypeAssertionInRefFail",
      ObjectTypeAssertionInPathFail: "ObjectTypeAssertionInPathFail",
      MissingAuthorError: "MissingAuthorError",
      MissingCommitterError: "MissingCommitterError",
      MissingTaggerError: "MissingTaggerError",
      GitRootNotFoundError: "GitRootNotFoundError",
      UnparseableServerResponseFail: "UnparseableServerResponseFail",
      InvalidDepthParameterError: "InvalidDepthParameterError",
      RemoteDoesNotSupportShallowFail: "RemoteDoesNotSupportShallowFail",
      RemoteDoesNotSupportDeepenSinceFail: "RemoteDoesNotSupportDeepenSinceFail",
      RemoteDoesNotSupportDeepenNotFail: "RemoteDoesNotSupportDeepenNotFail",
      RemoteDoesNotSupportDeepenRelativeFail: "RemoteDoesNotSupportDeepenRelativeFail",
      RemoteDoesNotSupportSmartHTTP: "RemoteDoesNotSupportSmartHTTP",
      CorruptShallowOidFail: "CorruptShallowOidFail",
      FastForwardFail: "FastForwardFail",
      MergeNotSupportedFail: "MergeNotSupportedFail",
      DirectorySeparatorsError: "DirectorySeparatorsError",
      ResolveTreeError: "ResolveTreeError",
      ResolveCommitError: "ResolveCommitError",
      DirectoryIsAFileError: "DirectoryIsAFileError",
      TreeOrBlobNotFoundError: "TreeOrBlobNotFoundError",
      NotImplementedFail: "NotImplementedFail",
      ReadObjectFail: "ReadObjectFail",
      NotAnOidFail: "NotAnOidFail",
      NoRefspecConfiguredError: "NoRefspecConfiguredError",
      MismatchRefValueError: "MismatchRefValueError",
      ResolveRefError: "ResolveRefError",
      ExpandRefError: "ExpandRefError",
      EmptyServerResponseFail: "EmptyServerResponseFail",
      AssertServerResponseFail: "AssertServerResponseFail",
      HTTPError: "HTTPError",
      RemoteUrlParseError: "RemoteUrlParseError",
      UnknownTransportError: "UnknownTransportError",
      AcquireLockFileFail: "AcquireLockFileFail",
      DoubleReleaseLockFileFail: "DoubleReleaseLockFileFail",
      InternalFail: "InternalFail",
      UnknownOauth2Format: "UnknownOauth2Format",
      MissingPasswordTokenError: "MissingPasswordTokenError",
      MissingUsernameError: "MissingUsernameError",
      MixPasswordTokenError: "MixPasswordTokenError",
      MixUsernamePasswordTokenError: "MixUsernamePasswordTokenError",
      MissingTokenError: "MissingTokenError",
      MixUsernameOauth2formatMissingTokenError: "MixUsernameOauth2formatMissingTokenError",
      MixPasswordOauth2formatMissingTokenError: "MixPasswordOauth2formatMissingTokenError",
      MixUsernamePasswordOauth2formatMissingTokenError: "MixUsernamePasswordOauth2formatMissingTokenError",
      MixUsernameOauth2formatTokenError: "MixUsernameOauth2formatTokenError",
      MixPasswordOauth2formatTokenError: "MixPasswordOauth2formatTokenError",
      MixUsernamePasswordOauth2formatTokenError: "MixUsernamePasswordOauth2formatTokenError",
      MaxSearchDepthExceeded: "MaxSearchDepthExceeded",
      PushRejectedNonFastForward: "PushRejectedNonFastForward",
      PushRejectedTagExists: "PushRejectedTagExists",
      AddingRemoteWouldOverwrite: "AddingRemoteWouldOverwrite",
      PluginUndefined: "PluginUndefined",
      CoreNotFound: "CoreNotFound",
      PluginSchemaViolation: "PluginSchemaViolation",
      PluginUnrecognized: "PluginUnrecognized",
      AmbiguousShortOid: "AmbiguousShortOid",
      ShortOidNotFound: "ShortOidNotFound"
    };

    var o =
    /*#__PURE__*/
    function (_Error) {
      _inherits(o, _Error);

      function o(t, e) {
        var _this;

        _classCallCheck(this, o);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(o).call(this)), _this.name = t, _this.code = t, _this.data = e, _this.message = function (t, e) {
          var r = t;

          for (var _i = 0, _Object$keys = Object.keys(e); _i < _Object$keys.length; _i++) {
            var _t2 = _Object$keys[_i];

            var _n2 = void 0;

            _n2 = Array.isArray(e[_t2]) ? e[_t2].join(", ") : String(e[_t2]), r = r.replace(new RegExp("{ ".concat(_t2, " }"), "g"), _n2);
          }

          return r;
        }(n[t], e || {}), Error.captureStackTrace && Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
        return _this;
      }

      _createClass(o, [{
        key: "toJSON",
        value: function toJSON() {
          return {
            code: this.code,
            data: this.data,
            caller: this.caller,
            message: this.message
          };
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.stack.toString();
        }
      }]);

      return o;
    }(_wrapNativeSuper(Error));
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return h;
      });
      var n = r(15),
          i = r.n(n),
          o = r(0),
          a = r(40),
          s = r(21),
          u = r(61);

      function c(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function f(t) {
        return function () {
          var e = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = t.apply(e, r);

            function a(t) {
              c(o, n, i, a, s, "next", t);
            }

            function s(t) {
              c(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        };
      }

      var l = new Map(),
          d = new WeakMap();

      var h =
      /*#__PURE__*/
      function () {
        function h(t) {
          _classCallCheck(this, h);

          if (void 0 === t) throw new o.b(o.a.PluginUndefined, {
            plugin: "fs"
          });
          return d.has(t) ? d.get(t) : d.has(t._original_unwrapped_fs) ? d.get(t._original_unwrapped_fs) : void 0 !== t._original_unwrapped_fs ? t : (Object.getOwnPropertyDescriptor(t, "promises") && Object.getOwnPropertyDescriptor(t, "promises").enumerable ? (this._readFile = t.promises.readFile.bind(t.promises), this._writeFile = t.promises.writeFile.bind(t.promises), this._mkdir = t.promises.mkdir.bind(t.promises), this._rmdir = t.promises.rmdir.bind(t.promises), this._unlink = t.promises.unlink.bind(t.promises), this._stat = t.promises.stat.bind(t.promises), this._lstat = t.promises.lstat.bind(t.promises), this._readdir = t.promises.readdir.bind(t.promises), this._readlink = t.promises.readlink.bind(t.promises), this._symlink = t.promises.symlink.bind(t.promises)) : (this._readFile = i()(t.readFile.bind(t)), this._writeFile = i()(t.writeFile.bind(t)), this._mkdir = i()(t.mkdir.bind(t)), this._rmdir = i()(t.rmdir.bind(t)), this._unlink = i()(t.unlink.bind(t)), this._stat = i()(t.stat.bind(t)), this._lstat = i()(t.lstat.bind(t)), this._readdir = i()(t.readdir.bind(t)), this._readlink = i()(t.readlink.bind(t)), this._symlink = i()(t.symlink.bind(t))), this._original_unwrapped_fs = t, void d.set(t, this));
        }

        _createClass(h, [{
          key: "exists",
          value: function exists(t) {
            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var r = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee() {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.prev = 0;
                      _context.next = 3;
                      return r._stat(t);

                    case 3:
                      return _context.abrupt("return", !0);

                    case 6:
                      _context.prev = 6;
                      _context.t0 = _context["catch"](0);

                      if (!("ENOENT" === _context.t0.code || "ENOTDIR" === _context.t0.code)) {
                        _context.next = 10;
                        break;
                      }

                      return _context.abrupt("return", !1);

                    case 10:
                      throw console.log('Unhandled error in "FileSystem.exists()" function', _context.t0), _context.t0;

                    case 11:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[0, 6]]);
            }))();
          }
        }, {
          key: "read",
          value: function read(e) {
            var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var n = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee2() {
              var _i2;

              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.prev = 0;
                      _context2.next = 3;
                      return n._readFile(e, r);

                    case 3:
                      _i2 = _context2.sent;
                      return _context2.abrupt("return", ("string" != typeof _i2 && (_i2 = t.from(_i2)), _i2));

                    case 7:
                      _context2.prev = 7;
                      _context2.t0 = _context2["catch"](0);
                      return _context2.abrupt("return", null);

                    case 10:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, null, [[0, 7]]);
            }))();
          }
        }, {
          key: "write",
          value: function write(t, e) {
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var n = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee3() {
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.prev = 0;
                      _context3.next = 3;
                      return n._writeFile(t, e, r);

                    case 3:
                      return _context3.abrupt("return", void _context3.sent);

                    case 6:
                      _context3.prev = 6;
                      _context3.t0 = _context3["catch"](0);
                      _context3.next = 10;
                      return n.mkdir(Object(s.a)(t));

                    case 10:
                      _context3.next = 12;
                      return n._writeFile(t, e, r);

                    case 12:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, null, [[0, 6]]);
            }))();
          }
        }, {
          key: "mkdir",
          value: function mkdir(t) {
            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
            var r = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee4() {
              var _e2;

              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.prev = 0;
                      _context4.next = 3;
                      return r._mkdir(t);

                    case 3:
                      return _context4.abrupt("return", void _context4.sent);

                    case 6:
                      _context4.prev = 6;
                      _context4.t0 = _context4["catch"](0);

                      if (!(null === _context4.t0)) {
                        _context4.next = 10;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 10:
                      if (!("EEXIST" === _context4.t0.code)) {
                        _context4.next = 12;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 12:
                      if (!e) {
                        _context4.next = 14;
                        break;
                      }

                      throw _context4.t0;

                    case 14:
                      if (!("ENOENT" === _context4.t0.code)) {
                        _context4.next = 22;
                        break;
                      }

                      _e2 = Object(s.a)(t);

                      if (!("." === _e2 || "/" === _e2 || _e2 === t)) {
                        _context4.next = 18;
                        break;
                      }

                      throw _context4.t0;

                    case 18:
                      _context4.next = 20;
                      return r.mkdir(_e2);

                    case 20:
                      _context4.next = 22;
                      return r.mkdir(t, !0);

                    case 22:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, null, [[0, 6]]);
            }))();
          }
        }, {
          key: "rm",
          value: function rm(t) {
            var e = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee5() {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.prev = 0;
                      _context5.next = 3;
                      return e._unlink(t);

                    case 3:
                      _context5.next = 9;
                      break;

                    case 5:
                      _context5.prev = 5;
                      _context5.t0 = _context5["catch"](0);

                      if (!("ENOENT" !== _context5.t0.code)) {
                        _context5.next = 9;
                        break;
                      }

                      throw _context5.t0;

                    case 9:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, null, [[0, 5]]);
            }))();
          }
        }, {
          key: "readdir",
          value: function readdir(t) {
            var e = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee6() {
              var _r2;

              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.prev = 0;
                      _context6.next = 3;
                      return e._readdir(t);

                    case 3:
                      _r2 = _context6.sent;
                      return _context6.abrupt("return", (_r2.sort(a.a), _r2));

                    case 7:
                      _context6.prev = 7;
                      _context6.t0 = _context6["catch"](0);
                      return _context6.abrupt("return", "ENOTDIR" === _context6.t0.code ? null : []);

                    case 10:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, null, [[0, 7]]);
            }))();
          }
        }, {
          key: "readdirDeep",
          value: function readdirDeep(t) {
            var e = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee8() {
              var r;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      _context8.next = 2;
                      return e._readdir(t);

                    case 2:
                      r = _context8.sent;
                      _context8.next = 5;
                      return Promise.all(r.map(function () {
                        var r = f(
                        /*#__PURE__*/
                        regeneratorRuntime.mark(function _callee7(r) {
                          var n;
                          return regeneratorRuntime.wrap(function _callee7$(_context7) {
                            while (1) {
                              switch (_context7.prev = _context7.next) {
                                case 0:
                                  n = t + "/" + r;
                                  _context7.next = 3;
                                  return e._stat(n);

                                case 3:
                                  if (!_context7.sent.isDirectory()) {
                                    _context7.next = 7;
                                    break;
                                  }

                                  _context7.t0 = e.readdirDeep(n);
                                  _context7.next = 8;
                                  break;

                                case 7:
                                  _context7.t0 = n;

                                case 8:
                                  return _context7.abrupt("return", _context7.t0);

                                case 9:
                                case "end":
                                  return _context7.stop();
                              }
                            }
                          }, _callee7);
                        }));
                        return function (t) {
                          return r.apply(this, arguments);
                        };
                      }()));

                    case 5:
                      _context8.t0 = function (t, e) {
                        return t.concat(e);
                      };

                      _context8.t1 = [];
                      return _context8.abrupt("return", _context8.sent.reduce(_context8.t0, _context8.t1));

                    case 8:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8);
            }))();
          }
        }, {
          key: "lstat",
          value: function lstat(t) {
            var e = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee9() {
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.prev = 0;
                      _context9.next = 3;
                      return e._lstat(t);

                    case 3:
                      return _context9.abrupt("return", _context9.sent);

                    case 6:
                      _context9.prev = 6;
                      _context9.t0 = _context9["catch"](0);

                      if (!("ENOENT" === _context9.t0.code)) {
                        _context9.next = 10;
                        break;
                      }

                      return _context9.abrupt("return", null);

                    case 10:
                      throw _context9.t0;

                    case 11:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, null, [[0, 6]]);
            }))();
          }
        }, {
          key: "readlink",
          value: function readlink(t) {
            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              encoding: "buffer"
            };
            var r = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee10() {
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      _context10.prev = 0;
                      return _context10.abrupt("return", r._readlink(t, e));

                    case 4:
                      _context10.prev = 4;
                      _context10.t0 = _context10["catch"](0);

                      if (!("ENOENT" === _context10.t0.code)) {
                        _context10.next = 8;
                        break;
                      }

                      return _context10.abrupt("return", null);

                    case 8:
                      throw _context10.t0;

                    case 9:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, null, [[0, 4]]);
            }))();
          }
        }, {
          key: "writelink",
          value: function writelink(t, e) {
            var r = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee11() {
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      return _context11.abrupt("return", r._symlink(e.toString("utf8"), t));

                    case 1:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11);
            }))();
          }
        }, {
          key: "lock",
          value: function lock(t) {
            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
            var r = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee12() {
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      if (!l.has(t)) {
                        _context12.next = 2;
                        break;
                      }

                      return _context12.abrupt("return", (clearTimeout(l.get(t)), void l.delete(t)));

                    case 2:
                      if (!(0 === e)) {
                        _context12.next = 4;
                        break;
                      }

                      throw new o.b(o.a.AcquireLockFileFail, {
                        filename: t
                      });

                    case 4:
                      _context12.prev = 4;
                      _context12.next = 7;
                      return r._mkdir("".concat(t, ".lock"));

                    case 7:
                      _context12.next = 17;
                      break;

                    case 9:
                      _context12.prev = 9;
                      _context12.t0 = _context12["catch"](4);
                      _context12.t1 = "EEXIST" === _context12.t0.code;

                      if (!_context12.t1) {
                        _context12.next = 17;
                        break;
                      }

                      _context12.next = 15;
                      return Object(u.a)(100);

                    case 15:
                      _context12.next = 17;
                      return r.lock(t, e - 1);

                    case 17:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, null, [[4, 9]]);
            }))();
          }
        }, {
          key: "unlock",
          value: function unlock(t) {
            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;
            var r = this;
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee14() {
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      if (!l.has(t)) {
                        _context14.next = 2;
                        break;
                      }

                      throw new o.b(o.a.DoubleReleaseLockFileFail, {
                        filename: t
                      });

                    case 2:
                      l.set(t, setTimeout(f(
                      /*#__PURE__*/
                      regeneratorRuntime.mark(function _callee13() {
                        return regeneratorRuntime.wrap(function _callee13$(_context13) {
                          while (1) {
                            switch (_context13.prev = _context13.next) {
                              case 0:
                                l.delete(t);
                                _context13.next = 3;
                                return r._rmdir("".concat(t, ".lock"));

                              case 3:
                              case "end":
                                return _context13.stop();
                            }
                          }
                        }, _callee13);
                      })), e));

                    case 3:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14);
            }))();
          }
        }]);

        return h;
      }();
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      return t.replace(/\/\.\//g, "/").replace(/\/{2,}/g, "/").replace(/^\/\.$/, "/").replace(/^\.\/$/, ".").replace(/^\.\//, "").replace(/\/\.$/, "").replace(/(.+)\/$/, "$1").replace(/^$/, ".");
    }

    function i() {
      for (var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++) {
        t[_key] = arguments[_key];
      }

      return n(t.map(n).join("/"));
    }

    r.d(e, "a", function () {
      return i;
    });
  }, function (t, e, r) {
    "use strict";

    r.d(e, "b", function () {
      return i;
    }), r.d(e, "a", function () {
      return a;
    });
    var n = r(0);
    var i = new (
    /*#__PURE__*/
    function (_Map) {
      _inherits(_class, _Map);

      function _class() {
        _classCallCheck(this, _class);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));
      }

      _createClass(_class, [{
        key: "set",
        value: function set(t, e) {
          (function (t, e) {
            "fs" === t && Object.getOwnPropertyDescriptor(e, "promises") && Object.getOwnPropertyDescriptor(e, "promises").enumerable && (e = e.promises);
            var r = {
              credentialManager: ["fill", "approved", "rejected"],
              emitter: ["emit"],
              fs: ["lstat", "mkdir", "readdir", "readFile", "rmdir", "stat", "unlink", "writeFile"],
              pgp: ["sign", "verify"],
              http: []
            };
            if (!Object.prototype.hasOwnProperty.call(r, t)) throw new n.b(n.a.PluginUnrecognized, {
              plugin: t
            });
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = r[t][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _i3 = _step.value;
                if (void 0 === e[_i3]) throw new n.b(n.a.PluginSchemaViolation, {
                  plugin: t,
                  method: _i3
                });
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          })(t, e), _get(_getPrototypeOf(_class.prototype), "set", this).call(this, t, e);
        }
      }, {
        key: "get",
        value: function get(t) {
          var e = new Set(["credentialManager", "fs", "pgp"]);
          if (!_get(_getPrototypeOf(_class.prototype), "has", this).call(this, t) && e.has(t)) throw new n.b(n.a.PluginUndefined, {
            plugin: t
          });
          return _get(_getPrototypeOf(_class.prototype), "get", this).call(this, t);
        }
      }]);

      return _class;
    }(_wrapNativeSuper(Map)))(),
        o = new Map([["default", i]]),
        a = {
      get: function get(t) {
        if (o.has(t)) return o.get(t);
        throw new n.b(n.a.CoreNotFound, {
          core: t
        });
      },
      create: function create(t) {
        return o.has(t) ? o.get(t) : (o.set(t, new Map()), o.get(t));
      }
    };
  }, function (t, e, r) {
    "use strict";

    var n = r(1),
        i = r(0);

    var o =
    /*#__PURE__*/
    function () {
      function o(t) {
        var _this2 = this;

        _classCallCheck(this, o);

        if (this.refs = new Map(), this.parsedConfig = [], t) {
          var _e3 = null;
          this.parsedConfig = t.trim().split("\n").map(function (t) {
            if (/^\s*#/.test(t)) return {
              line: t,
              comment: !0
            };
            var r = t.indexOf(" ");

            if (t.startsWith("^")) {
              var _r3 = t.slice(1);

              return _this2.refs.set(_e3 + "^{}", _r3), {
                line: t,
                ref: _e3,
                peeled: _r3
              };
            }

            {
              var _n3 = t.slice(0, r);

              return _e3 = t.slice(r + 1), _this2.refs.set(_e3, _n3), {
                line: t,
                ref: _e3,
                oid: _n3
              };
            }
          });
        }

        return this;
      }

      _createClass(o, [{
        key: "delete",
        value: function _delete(t) {
          this.parsedConfig = this.parsedConfig.filter(function (e) {
            return e.ref !== t;
          }), this.refs.delete(t);
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.parsedConfig.map(function (_ref) {
            var t = _ref.line;
            return t;
          }).join("\n") + "\n";
        }
      }], [{
        key: "from",
        value: function from(t) {
          return new o(t);
        }
      }]);

      return o;
    }();

    var a = r(64);

    function s(t, e) {
      var r = t.replace(/\^\{\}$/, ""),
          n = e.replace(/\^\{\}$/, ""),
          i = -(r < n) || +(r > n);
      return 0 === i ? t.endsWith("^{}") ? 1 : -1 : i;
    }

    var u = r(2),
        c = r(22);

    function f(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function l(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            f(o, n, i, a, s, "next", t);
          }

          function s(t) {
            f(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    r.d(e, "a", function () {
      return p;
    });

    var d = function d(t) {
      return ["".concat(t), "refs/".concat(t), "refs/tags/".concat(t), "refs/heads/".concat(t), "refs/remotes/".concat(t), "refs/remotes/".concat(t, "/HEAD")];
    },
        h = ["config", "description", "index", "shallow", "commondir"];

    var p =
    /*#__PURE__*/
    function () {
      function p() {
        _classCallCheck(this, p);
      }

      _createClass(p, null, [{
        key: "updateRemoteRefs",
        value: function updateRemoteRefs(_ref2) {
          var t = _ref2.fs,
              e = _ref2.gitdir,
              r = _ref2.remote,
              o = _ref2.refs,
              s = _ref2.symrefs,
              f = _ref2.tags,
              d = _ref2.refspecs,
              _ref2$prune = _ref2.prune,
              h = _ref2$prune === void 0 ? !1 : _ref2$prune,
              _ref2$pruneTags = _ref2.pruneTags,
              g = _ref2$pruneTags === void 0 ? !1 : _ref2$pruneTags;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee15() {
            var l, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _t6, m, y, v, _t3, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _t4, _e4, w, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _step4$value, _t7, _e5, _r4, b, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _step5$value, _t8, _e6, _r5, _n4, _, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _loop, _iterator6, _step6, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, _step8$value, _t9, _r6;

            return regeneratorRuntime.wrap(function _callee15$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    l = new n.a(t);
                    _iteratorNormalCompletion2 = true;
                    _didIteratorError2 = false;
                    _iteratorError2 = undefined;
                    _context16.prev = 4;
                    _iterator2 = o.values()[Symbol.iterator]();

                  case 6:
                    if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                      _context16.next = 13;
                      break;
                    }

                    _t6 = _step2.value;

                    if (_t6.match(/[0-9a-f]{40}/)) {
                      _context16.next = 10;
                      break;
                    }

                    throw new i.b(i.a.NotAnOidFail, {
                      value: _t6
                    });

                  case 10:
                    _iteratorNormalCompletion2 = true;
                    _context16.next = 6;
                    break;

                  case 13:
                    _context16.next = 19;
                    break;

                  case 15:
                    _context16.prev = 15;
                    _context16.t0 = _context16["catch"](4);
                    _didIteratorError2 = true;
                    _iteratorError2 = _context16.t0;

                  case 19:
                    _context16.prev = 19;
                    _context16.prev = 20;

                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                      _iterator2.return();
                    }

                  case 22:
                    _context16.prev = 22;

                    if (!_didIteratorError2) {
                      _context16.next = 25;
                      break;
                    }

                    throw _iteratorError2;

                  case 25:
                    return _context16.finish(22);

                  case 26:
                    return _context16.finish(19);

                  case 27:
                    _context16.next = 29;
                    return c.a.get({
                      fs: l,
                      gitdir: e
                    });

                  case 29:
                    m = _context16.sent;

                    if (d) {
                      _context16.next = 37;
                      break;
                    }

                    _context16.next = 33;
                    return m.getall("remote.".concat(r, ".fetch"));

                  case 33:
                    _context16.t1 = (d = _context16.sent).length;

                    if (!(0 === _context16.t1)) {
                      _context16.next = 36;
                      break;
                    }

                    throw new i.b(i.a.NoRefspecConfiguredError, {
                      remote: r
                    });

                  case 36:
                    d.unshift("+HEAD:refs/remotes/".concat(r, "/HEAD"));

                  case 37:
                    y = a.a.from(d), v = new Map();

                    if (!g) {
                      _context16.next = 44;
                      break;
                    }

                    _context16.next = 41;
                    return p.listRefs({
                      fs: l,
                      gitdir: e,
                      filepath: "refs/tags"
                    });

                  case 41:
                    _t3 = _context16.sent;
                    _context16.next = 44;
                    return p.deleteRefs({
                      fs: l,
                      gitdir: e,
                      refs: _t3.map(function (t) {
                        return "refs/tags/".concat(t);
                      })
                    });

                  case 44:
                    if (!f) {
                      _context16.next = 77;
                      break;
                    }

                    _iteratorNormalCompletion3 = true;
                    _didIteratorError3 = false;
                    _iteratorError3 = undefined;
                    _context16.prev = 48;
                    _iterator3 = o.keys()[Symbol.iterator]();

                  case 50:
                    if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                      _context16.next = 63;
                      break;
                    }

                    _t4 = _step3.value;
                    _context16.t2 = _t4.startsWith("refs/tags") && !_t4.endsWith("^{}");

                    if (!_context16.t2) {
                      _context16.next = 57;
                      break;
                    }

                    _context16.next = 56;
                    return p.exists({
                      fs: l,
                      gitdir: e,
                      ref: _t4
                    });

                  case 56:
                    _context16.t2 = !_context16.sent;

                  case 57:
                    if (!_context16.t2) {
                      _context16.next = 60;
                      break;
                    }

                    _e4 = o.get(_t4 + "^{}") || o.get(_t4);
                    v.set(_t4, _e4);

                  case 60:
                    _iteratorNormalCompletion3 = true;
                    _context16.next = 50;
                    break;

                  case 63:
                    _context16.next = 69;
                    break;

                  case 65:
                    _context16.prev = 65;
                    _context16.t3 = _context16["catch"](48);
                    _didIteratorError3 = true;
                    _iteratorError3 = _context16.t3;

                  case 69:
                    _context16.prev = 69;
                    _context16.prev = 70;

                    if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                      _iterator3.return();
                    }

                  case 72:
                    _context16.prev = 72;

                    if (!_didIteratorError3) {
                      _context16.next = 75;
                      break;
                    }

                    throw _iteratorError3;

                  case 75:
                    return _context16.finish(72);

                  case 76:
                    return _context16.finish(69);

                  case 77:
                    w = y.translate(_toConsumableArray(o.keys()));
                    _iteratorNormalCompletion4 = true;
                    _didIteratorError4 = false;
                    _iteratorError4 = undefined;
                    _context16.prev = 81;

                    for (_iterator4 = w[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      _step4$value = _slicedToArray(_step4.value, 2), _t7 = _step4$value[0], _e5 = _step4$value[1];
                      _r4 = o.get(_t7);
                      v.set(_e5, _r4);
                    }

                    _context16.next = 89;
                    break;

                  case 85:
                    _context16.prev = 85;
                    _context16.t4 = _context16["catch"](81);
                    _didIteratorError4 = true;
                    _iteratorError4 = _context16.t4;

                  case 89:
                    _context16.prev = 89;
                    _context16.prev = 90;

                    if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                      _iterator4.return();
                    }

                  case 92:
                    _context16.prev = 92;

                    if (!_didIteratorError4) {
                      _context16.next = 95;
                      break;
                    }

                    throw _iteratorError4;

                  case 95:
                    return _context16.finish(92);

                  case 96:
                    return _context16.finish(89);

                  case 97:
                    b = y.translate(_toConsumableArray(s.keys()));
                    _iteratorNormalCompletion5 = true;
                    _didIteratorError5 = false;
                    _iteratorError5 = undefined;
                    _context16.prev = 101;

                    for (_iterator5 = b[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                      _step5$value = _slicedToArray(_step5.value, 2), _t8 = _step5$value[0], _e6 = _step5$value[1];
                      _r5 = s.get(_t8), _n4 = y.translateOne(_r5);
                      _n4 && v.set(_e6, "ref: ".concat(_n4));
                    }

                    _context16.next = 109;
                    break;

                  case 105:
                    _context16.prev = 105;
                    _context16.t5 = _context16["catch"](101);
                    _didIteratorError5 = true;
                    _iteratorError5 = _context16.t5;

                  case 109:
                    _context16.prev = 109;
                    _context16.prev = 110;

                    if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                      _iterator5.return();
                    }

                  case 112:
                    _context16.prev = 112;

                    if (!_didIteratorError5) {
                      _context16.next = 115;
                      break;
                    }

                    throw _iteratorError5;

                  case 115:
                    return _context16.finish(112);

                  case 116:
                    return _context16.finish(109);

                  case 117:
                    _ = [];

                    if (!h) {
                      _context16.next = 148;
                      break;
                    }

                    _iteratorNormalCompletion6 = true;
                    _didIteratorError6 = false;
                    _iteratorError6 = undefined;
                    _context16.prev = 122;
                    _loop =
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _loop() {
                      var t, r, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, _t5;

                      return regeneratorRuntime.wrap(function _loop$(_context15) {
                        while (1) {
                          switch (_context15.prev = _context15.next) {
                            case 0:
                              t = _step6.value;
                              _context15.next = 3;
                              return p.listRefs({
                                fs: l,
                                gitdir: e,
                                filepath: t
                              });

                            case 3:
                              _context15.t0 = function (e) {
                                return "".concat(t, "/").concat(e);
                              };

                              r = _context15.sent.map(_context15.t0);
                              _iteratorNormalCompletion7 = true;
                              _didIteratorError7 = false;
                              _iteratorError7 = undefined;
                              _context15.prev = 8;

                              for (_iterator7 = r[Symbol.iterator](); !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                                _t5 = _step7.value;
                                v.has(_t5) || _.push(_t5);
                              }

                              _context15.next = 16;
                              break;

                            case 12:
                              _context15.prev = 12;
                              _context15.t1 = _context15["catch"](8);
                              _didIteratorError7 = true;
                              _iteratorError7 = _context15.t1;

                            case 16:
                              _context15.prev = 16;
                              _context15.prev = 17;

                              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                                _iterator7.return();
                              }

                            case 19:
                              _context15.prev = 19;

                              if (!_didIteratorError7) {
                                _context15.next = 22;
                                break;
                              }

                              throw _iteratorError7;

                            case 22:
                              return _context15.finish(19);

                            case 23:
                              return _context15.finish(16);

                            case 24:
                            case "end":
                              return _context15.stop();
                          }
                        }
                      }, _loop, null, [[8, 12, 16, 24], [17,, 19, 23]]);
                    });
                    _iterator6 = y.localNamespaces()[Symbol.iterator]();

                  case 125:
                    if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
                      _context16.next = 130;
                      break;
                    }

                    return _context16.delegateYield(_loop(), "t6", 127);

                  case 127:
                    _iteratorNormalCompletion6 = true;
                    _context16.next = 125;
                    break;

                  case 130:
                    _context16.next = 136;
                    break;

                  case 132:
                    _context16.prev = 132;
                    _context16.t7 = _context16["catch"](122);
                    _didIteratorError6 = true;
                    _iteratorError6 = _context16.t7;

                  case 136:
                    _context16.prev = 136;
                    _context16.prev = 137;

                    if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                      _iterator6.return();
                    }

                  case 139:
                    _context16.prev = 139;

                    if (!_didIteratorError6) {
                      _context16.next = 142;
                      break;
                    }

                    throw _iteratorError6;

                  case 142:
                    return _context16.finish(139);

                  case 143:
                    return _context16.finish(136);

                  case 144:
                    _context16.t8 = _.length > 0;

                    if (!_context16.t8) {
                      _context16.next = 148;
                      break;
                    }

                    _context16.next = 148;
                    return p.deleteRefs({
                      fs: l,
                      gitdir: e,
                      refs: _
                    });

                  case 148:
                    _iteratorNormalCompletion8 = true;
                    _didIteratorError8 = false;
                    _iteratorError8 = undefined;
                    _context16.prev = 151;
                    _iterator8 = v[Symbol.iterator]();

                  case 153:
                    if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
                      _context16.next = 160;
                      break;
                    }

                    _step8$value = _slicedToArray(_step8.value, 2), _t9 = _step8$value[0], _r6 = _step8$value[1];
                    _context16.next = 157;
                    return l.write(Object(u.a)(e, _t9), "".concat(_r6.trim(), "\n"), "utf8");

                  case 157:
                    _iteratorNormalCompletion8 = true;
                    _context16.next = 153;
                    break;

                  case 160:
                    _context16.next = 166;
                    break;

                  case 162:
                    _context16.prev = 162;
                    _context16.t9 = _context16["catch"](151);
                    _didIteratorError8 = true;
                    _iteratorError8 = _context16.t9;

                  case 166:
                    _context16.prev = 166;
                    _context16.prev = 167;

                    if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                      _iterator8.return();
                    }

                  case 169:
                    _context16.prev = 169;

                    if (!_didIteratorError8) {
                      _context16.next = 172;
                      break;
                    }

                    throw _iteratorError8;

                  case 172:
                    return _context16.finish(169);

                  case 173:
                    return _context16.finish(166);

                  case 174:
                    return _context16.abrupt("return", {
                      pruned: _
                    });

                  case 175:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee15, null, [[4, 15, 19, 27], [20,, 22, 26], [48, 65, 69, 77], [70,, 72, 76], [81, 85, 89, 97], [90,, 92, 96], [101, 105, 109, 117], [110,, 112, 116], [122, 132, 136, 144], [137,, 139, 143], [151, 162, 166, 174], [167,, 169, 173]]);
          }))();
        }
      }, {
        key: "writeRef",
        value: function writeRef(_ref3) {
          var t = _ref3.fs,
              e = _ref3.gitdir,
              r = _ref3.ref,
              o = _ref3.value;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee16() {
            var a;
            return regeneratorRuntime.wrap(function _callee16$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    a = new n.a(t);

                    if (o.match(/[0-9a-f]{40}/)) {
                      _context17.next = 3;
                      break;
                    }

                    throw new i.b(i.a.NotAnOidFail, {
                      value: o
                    });

                  case 3:
                    _context17.next = 5;
                    return a.write(Object(u.a)(e, r), "".concat(o.trim(), "\n"), "utf8");

                  case 5:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee16);
          }))();
        }
      }, {
        key: "writeSymbolicRef",
        value: function writeSymbolicRef(_ref4) {
          var t = _ref4.fs,
              e = _ref4.gitdir,
              r = _ref4.ref,
              i = _ref4.value;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee17() {
            var o;
            return regeneratorRuntime.wrap(function _callee17$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    o = new n.a(t);
                    _context18.next = 3;
                    return o.write(Object(u.a)(e, r), "ref: " + "".concat(i.trim(), "\n"), "utf8");

                  case 3:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee17);
          }))();
        }
      }, {
        key: "deleteRef",
        value: function deleteRef(_ref5) {
          var t = _ref5.fs,
              e = _ref5.gitdir,
              r = _ref5.ref;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee18() {
            return regeneratorRuntime.wrap(function _callee18$(_context19) {
              while (1) {
                switch (_context19.prev = _context19.next) {
                  case 0:
                    return _context19.abrupt("return", p.deleteRefs({
                      fs: t,
                      gitdir: e,
                      refs: [r]
                    }));

                  case 1:
                  case "end":
                    return _context19.stop();
                }
              }
            }, _callee18);
          }))();
        }
      }, {
        key: "deleteRefs",
        value: function deleteRefs(_ref6) {
          var t = _ref6.fs,
              e = _ref6.gitdir,
              r = _ref6.refs;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee19() {
            var i, a, s, c, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, _t10;

            return regeneratorRuntime.wrap(function _callee19$(_context20) {
              while (1) {
                switch (_context20.prev = _context20.next) {
                  case 0:
                    i = new n.a(t);
                    _context20.next = 3;
                    return Promise.all(r.map(function (t) {
                      return i.rm(Object(u.a)(e, t));
                    }));

                  case 3:
                    _context20.next = 5;
                    return i.read("".concat(e, "/packed-refs"), {
                      encoding: "utf8"
                    });

                  case 5:
                    a = _context20.sent;
                    s = o.from(a), c = s.refs.size;
                    _iteratorNormalCompletion9 = true;
                    _didIteratorError9 = false;
                    _iteratorError9 = undefined;
                    _context20.prev = 10;

                    for (_iterator9 = r[Symbol.iterator](); !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                      _t10 = _step9.value;
                      s.refs.has(_t10) && s.delete(_t10);
                    }

                    _context20.next = 18;
                    break;

                  case 14:
                    _context20.prev = 14;
                    _context20.t0 = _context20["catch"](10);
                    _didIteratorError9 = true;
                    _iteratorError9 = _context20.t0;

                  case 18:
                    _context20.prev = 18;
                    _context20.prev = 19;

                    if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                      _iterator9.return();
                    }

                  case 21:
                    _context20.prev = 21;

                    if (!_didIteratorError9) {
                      _context20.next = 24;
                      break;
                    }

                    throw _iteratorError9;

                  case 24:
                    return _context20.finish(21);

                  case 25:
                    return _context20.finish(18);

                  case 26:
                    _context20.t1 = s.refs.size < c;

                    if (!_context20.t1) {
                      _context20.next = 31;
                      break;
                    }

                    a = s.toString();
                    _context20.next = 31;
                    return i.write("".concat(e, "/packed-refs"), a, {
                      encoding: "utf8"
                    });

                  case 31:
                  case "end":
                    return _context20.stop();
                }
              }
            }, _callee19, null, [[10, 14, 18, 26], [19,, 21, 25]]);
          }))();
        }
      }, {
        key: "resolve",
        value: function resolve(_ref7) {
          var t = _ref7.fs,
              e = _ref7.gitdir,
              r = _ref7.ref,
              o = _ref7.depth;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee20() {
            var a, s, u, c, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, _t11;

            return regeneratorRuntime.wrap(function _callee20$(_context21) {
              while (1) {
                switch (_context21.prev = _context21.next) {
                  case 0:
                    a = new n.a(t);

                    if (!(void 0 !== o && -1 === --o)) {
                      _context21.next = 3;
                      break;
                    }

                    return _context21.abrupt("return", r);

                  case 3:
                    if (!r.startsWith("ref: ")) {
                      _context21.next = 5;
                      break;
                    }

                    return _context21.abrupt("return", (r = r.slice("ref: ".length), p.resolve({
                      fs: a,
                      gitdir: e,
                      ref: r,
                      depth: o
                    })));

                  case 5:
                    if (!(40 === r.length && /[0-9a-f]{40}/.test(r))) {
                      _context21.next = 7;
                      break;
                    }

                    return _context21.abrupt("return", r);

                  case 7:
                    _context21.next = 9;
                    return p.packedRefs({
                      fs: a,
                      gitdir: e
                    });

                  case 9:
                    u = _context21.sent;
                    c = d(r).filter(function (t) {
                      return !h.includes(t);
                    });
                    _iteratorNormalCompletion10 = true;
                    _didIteratorError10 = false;
                    _iteratorError10 = undefined;
                    _context21.prev = 14;
                    _iterator10 = c[Symbol.iterator]();

                  case 16:
                    if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
                      _context21.next = 28;
                      break;
                    }

                    _t11 = _step10.value;
                    _context21.next = 20;
                    return a.read("".concat(e, "/").concat(_t11), {
                      encoding: "utf8"
                    });

                  case 20:
                    _context21.t0 = _context21.sent;

                    if (_context21.t0) {
                      _context21.next = 23;
                      break;
                    }

                    _context21.t0 = u.get(_t11);

                  case 23:
                    if (!(s = _context21.t0)) {
                      _context21.next = 25;
                      break;
                    }

                    return _context21.abrupt("return", p.resolve({
                      fs: a,
                      gitdir: e,
                      ref: s.trim(),
                      depth: o
                    }));

                  case 25:
                    _iteratorNormalCompletion10 = true;
                    _context21.next = 16;
                    break;

                  case 28:
                    _context21.next = 34;
                    break;

                  case 30:
                    _context21.prev = 30;
                    _context21.t1 = _context21["catch"](14);
                    _didIteratorError10 = true;
                    _iteratorError10 = _context21.t1;

                  case 34:
                    _context21.prev = 34;
                    _context21.prev = 35;

                    if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                      _iterator10.return();
                    }

                  case 37:
                    _context21.prev = 37;

                    if (!_didIteratorError10) {
                      _context21.next = 40;
                      break;
                    }

                    throw _iteratorError10;

                  case 40:
                    return _context21.finish(37);

                  case 41:
                    return _context21.finish(34);

                  case 42:
                    throw new i.b(i.a.ResolveRefError, {
                      ref: r
                    });

                  case 43:
                  case "end":
                    return _context21.stop();
                }
              }
            }, _callee20, null, [[14, 30, 34, 42], [35,, 37, 41]]);
          }))();
        }
      }, {
        key: "exists",
        value: function exists(_ref8) {
          var t = _ref8.fs,
              e = _ref8.gitdir,
              r = _ref8.ref;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee21() {
            return regeneratorRuntime.wrap(function _callee21$(_context22) {
              while (1) {
                switch (_context22.prev = _context22.next) {
                  case 0:
                    _context22.prev = 0;
                    _context22.next = 3;
                    return p.expand({
                      fs: t,
                      gitdir: e,
                      ref: r
                    });

                  case 3:
                    return _context22.abrupt("return", !0);

                  case 6:
                    _context22.prev = 6;
                    _context22.t0 = _context22["catch"](0);
                    return _context22.abrupt("return", !1);

                  case 9:
                  case "end":
                    return _context22.stop();
                }
              }
            }, _callee21, null, [[0, 6]]);
          }))();
        }
      }, {
        key: "expand",
        value: function expand(_ref9) {
          var t = _ref9.fs,
              e = _ref9.gitdir,
              r = _ref9.ref;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee22() {
            var o, a, s, _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, _t12;

            return regeneratorRuntime.wrap(function _callee22$(_context23) {
              while (1) {
                switch (_context23.prev = _context23.next) {
                  case 0:
                    o = new n.a(t);

                    if (!(40 === r.length && /[0-9a-f]{40}/.test(r))) {
                      _context23.next = 3;
                      break;
                    }

                    return _context23.abrupt("return", r);

                  case 3:
                    _context23.next = 5;
                    return p.packedRefs({
                      fs: o,
                      gitdir: e
                    });

                  case 5:
                    a = _context23.sent;
                    s = d(r);
                    _iteratorNormalCompletion11 = true;
                    _didIteratorError11 = false;
                    _iteratorError11 = undefined;
                    _context23.prev = 10;
                    _iterator11 = s[Symbol.iterator]();

                  case 12:
                    if (_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done) {
                      _context23.next = 23;
                      break;
                    }

                    _t12 = _step11.value;
                    _context23.next = 16;
                    return o.exists("".concat(e, "/").concat(_t12));

                  case 16:
                    if (!_context23.sent) {
                      _context23.next = 18;
                      break;
                    }

                    return _context23.abrupt("return", _t12);

                  case 18:
                    if (!a.has(_t12)) {
                      _context23.next = 20;
                      break;
                    }

                    return _context23.abrupt("return", _t12);

                  case 20:
                    _iteratorNormalCompletion11 = true;
                    _context23.next = 12;
                    break;

                  case 23:
                    _context23.next = 29;
                    break;

                  case 25:
                    _context23.prev = 25;
                    _context23.t0 = _context23["catch"](10);
                    _didIteratorError11 = true;
                    _iteratorError11 = _context23.t0;

                  case 29:
                    _context23.prev = 29;
                    _context23.prev = 30;

                    if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
                      _iterator11.return();
                    }

                  case 32:
                    _context23.prev = 32;

                    if (!_didIteratorError11) {
                      _context23.next = 35;
                      break;
                    }

                    throw _iteratorError11;

                  case 35:
                    return _context23.finish(32);

                  case 36:
                    return _context23.finish(29);

                  case 37:
                    throw new i.b(i.a.ExpandRefError, {
                      ref: r
                    });

                  case 38:
                  case "end":
                    return _context23.stop();
                }
              }
            }, _callee22, null, [[10, 25, 29, 37], [30,, 32, 36]]);
          }))();
        }
      }, {
        key: "expandAgainstMap",
        value: function expandAgainstMap(_ref10) {
          var t = _ref10.ref,
              e = _ref10.map;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee23() {
            var r, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, _t13;

            return regeneratorRuntime.wrap(function _callee23$(_context24) {
              while (1) {
                switch (_context24.prev = _context24.next) {
                  case 0:
                    r = d(t);
                    _iteratorNormalCompletion12 = true;
                    _didIteratorError12 = false;
                    _iteratorError12 = undefined;
                    _context24.prev = 4;
                    _iterator12 = r[Symbol.iterator]();

                  case 6:
                    if (_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done) {
                      _context24.next = 15;
                      break;
                    }

                    _t13 = _step12.value;
                    _context24.next = 10;
                    return e.has(_t13);

                  case 10:
                    if (!_context24.sent) {
                      _context24.next = 12;
                      break;
                    }

                    return _context24.abrupt("return", _t13);

                  case 12:
                    _iteratorNormalCompletion12 = true;
                    _context24.next = 6;
                    break;

                  case 15:
                    _context24.next = 21;
                    break;

                  case 17:
                    _context24.prev = 17;
                    _context24.t0 = _context24["catch"](4);
                    _didIteratorError12 = true;
                    _iteratorError12 = _context24.t0;

                  case 21:
                    _context24.prev = 21;
                    _context24.prev = 22;

                    if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                      _iterator12.return();
                    }

                  case 24:
                    _context24.prev = 24;

                    if (!_didIteratorError12) {
                      _context24.next = 27;
                      break;
                    }

                    throw _iteratorError12;

                  case 27:
                    return _context24.finish(24);

                  case 28:
                    return _context24.finish(21);

                  case 29:
                    throw new i.b(i.a.ExpandRefError, {
                      ref: t
                    });

                  case 30:
                  case "end":
                    return _context24.stop();
                }
              }
            }, _callee23, null, [[4, 17, 21, 29], [22,, 24, 28]]);
          }))();
        }
      }, {
        key: "resolveAgainstMap",
        value: function resolveAgainstMap(_ref11) {
          var t = _ref11.ref,
              _ref11$fullref = _ref11.fullref,
              e = _ref11$fullref === void 0 ? t : _ref11$fullref,
              r = _ref11.depth,
              n = _ref11.map;
          if (void 0 !== r && -1 === --r) return {
            fullref: e,
            oid: t
          };
          if (t.startsWith("ref: ")) return t = t.slice("ref: ".length), p.resolveAgainstMap({
            ref: t,
            fullref: e,
            depth: r,
            map: n
          });
          if (40 === t.length && /[0-9a-f]{40}/.test(t)) return {
            fullref: e,
            oid: t
          };
          var o = d(t);
          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            for (var _iterator13 = o[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var _t14 = _step13.value;

              var _e7 = n.get(_t14);

              if (_e7) return p.resolveAgainstMap({
                ref: _e7.trim(),
                fullref: _t14,
                depth: r,
                map: n
              });
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
                _iterator13.return();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }

          throw new i.b(i.a.ResolveRefError, {
            ref: t
          });
        }
      }, {
        key: "packedRefs",
        value: function packedRefs(_ref12) {
          var t = _ref12.fs,
              e = _ref12.gitdir;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee24() {
            var r, i;
            return regeneratorRuntime.wrap(function _callee24$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    r = new n.a(t);
                    _context25.next = 3;
                    return r.read("".concat(e, "/packed-refs"), {
                      encoding: "utf8"
                    });

                  case 3:
                    i = _context25.sent;
                    return _context25.abrupt("return", o.from(i).refs);

                  case 5:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee24);
          }))();
        }
      }, {
        key: "listRefs",
        value: function listRefs(_ref13) {
          var t = _ref13.fs,
              e = _ref13.gitdir,
              r = _ref13.filepath;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee25() {
            var i, o, a, _iteratorNormalCompletion14, _didIteratorError14, _iteratorError14, _iterator14, _step14, _t15;

            return regeneratorRuntime.wrap(function _callee25$(_context26) {
              while (1) {
                switch (_context26.prev = _context26.next) {
                  case 0:
                    i = new n.a(t), o = p.packedRefs({
                      fs: i,
                      gitdir: e
                    });
                    a = null;
                    _context26.prev = 2;
                    _context26.next = 5;
                    return i.readdirDeep("".concat(e, "/").concat(r));

                  case 5:
                    _context26.t0 = function (t) {
                      return t.replace("".concat(e, "/").concat(r, "/"), "");
                    };

                    a = (a = _context26.sent).map(_context26.t0);
                    _context26.next = 12;
                    break;

                  case 9:
                    _context26.prev = 9;
                    _context26.t1 = _context26["catch"](2);
                    a = [];

                  case 12:
                    _iteratorNormalCompletion14 = true;
                    _didIteratorError14 = false;
                    _iteratorError14 = undefined;
                    _context26.prev = 15;
                    _context26.next = 18;
                    return o;

                  case 18:
                    _context26.t2 = Symbol.iterator;
                    _iterator14 = _context26.sent.keys()[_context26.t2]();

                  case 20:
                    if (_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done) {
                      _context26.next = 26;
                      break;
                    }

                    _t15 = _step14.value;
                    _t15.startsWith(r) && (_t15 = _t15.replace(r + "/", ""), a.includes(_t15) || a.push(_t15));

                  case 23:
                    _iteratorNormalCompletion14 = true;
                    _context26.next = 20;
                    break;

                  case 26:
                    _context26.next = 32;
                    break;

                  case 28:
                    _context26.prev = 28;
                    _context26.t3 = _context26["catch"](15);
                    _didIteratorError14 = true;
                    _iteratorError14 = _context26.t3;

                  case 32:
                    _context26.prev = 32;
                    _context26.prev = 33;

                    if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
                      _iterator14.return();
                    }

                  case 35:
                    _context26.prev = 35;

                    if (!_didIteratorError14) {
                      _context26.next = 38;
                      break;
                    }

                    throw _iteratorError14;

                  case 38:
                    return _context26.finish(35);

                  case 39:
                    return _context26.finish(32);

                  case 40:
                    return _context26.abrupt("return", (a.sort(s), a));

                  case 41:
                  case "end":
                    return _context26.stop();
                }
              }
            }, _callee25, null, [[2, 9], [15, 28, 32, 40], [33,, 35, 39]]);
          }))();
        }
      }, {
        key: "listBranches",
        value: function listBranches(_ref14) {
          var t = _ref14.fs,
              e = _ref14.gitdir,
              r = _ref14.remote;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee26() {
            var i;
            return regeneratorRuntime.wrap(function _callee26$(_context27) {
              while (1) {
                switch (_context27.prev = _context27.next) {
                  case 0:
                    i = new n.a(t);
                    return _context27.abrupt("return", r ? p.listRefs({
                      fs: i,
                      gitdir: e,
                      filepath: "refs/remotes/".concat(r)
                    }) : p.listRefs({
                      fs: i,
                      gitdir: e,
                      filepath: "refs/heads"
                    }));

                  case 2:
                  case "end":
                    return _context27.stop();
                }
              }
            }, _callee26);
          }))();
        }
      }, {
        key: "listTags",
        value: function listTags(_ref15) {
          var t = _ref15.fs,
              e = _ref15.gitdir;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee27() {
            var r;
            return regeneratorRuntime.wrap(function _callee27$(_context28) {
              while (1) {
                switch (_context28.prev = _context28.next) {
                  case 0:
                    r = new n.a(t);
                    _context28.next = 3;
                    return p.listRefs({
                      fs: r,
                      gitdir: e,
                      filepath: "refs/tags"
                    });

                  case 3:
                    _context28.t0 = function (t) {
                      return !t.endsWith("^{}");
                    };

                    return _context28.abrupt("return", _context28.sent.filter(_context28.t0));

                  case 5:
                  case "end":
                    return _context28.stop();
                }
              }
            }, _callee27);
          }))();
        }
      }]);

      return p;
    }();
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return d;
      });
      var n = r(18),
          i = r.n(n),
          o = r(1),
          a = r(0),
          s = r(17),
          u = r(90),
          c = r(91),
          f = r(12);

      function l(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function d(t) {
        return h.apply(this, arguments);
      }

      function h() {
        var e;
        return e =
        /*#__PURE__*/
        regeneratorRuntime.mark(function e(_ref16) {
          var e, r, n, _ref16$format, l, h, p, g, _e8, _s$a$unwrap, _r7, _o;

          return regeneratorRuntime.wrap(function e$(_context29) {
            while (1) {
              switch (_context29.prev = _context29.next) {
                case 0:
                  e = _ref16.fs, r = _ref16.gitdir, n = _ref16.oid, _ref16$format = _ref16.format, l = _ref16$format === void 0 ? "content" : _ref16$format;
                  h = new o.a(e), p = function p(t) {
                    return d({
                      fs: h,
                      gitdir: r,
                      oid: t
                    });
                  };
                  "4b825dc642cb6eb9a060e54bf8d69288fbee4904" === n && (g = {
                    format: "wrapped",
                    object: t.from("tree 0\0")
                  });
                  _context29.t0 = g;

                  if (_context29.t0) {
                    _context29.next = 8;
                    break;
                  }

                  _context29.next = 7;
                  return Object(u.a)({
                    fs: h,
                    gitdir: r,
                    oid: n
                  });

                case 7:
                  g = _context29.sent;

                case 8:
                  _context29.t1 = g;

                  if (_context29.t1) {
                    _context29.next = 13;
                    break;
                  }

                  _context29.next = 12;
                  return Object(c.a)({
                    fs: h,
                    gitdir: r,
                    oid: n,
                    getExternalRefDelta: p
                  });

                case 12:
                  g = _context29.sent;

                case 13:
                  if (g) {
                    _context29.next = 15;
                    break;
                  }

                  throw new a.b(a.a.ReadObjectFail, {
                    oid: n
                  });

                case 15:
                  if (!("deflated" === l)) {
                    _context29.next = 17;
                    break;
                  }

                  return _context29.abrupt("return", g);

                case 17:
                  _context29.t2 = g.format;
                  _context29.next = _context29.t2 === "deflated" ? 20 : _context29.t2 === "wrapped" ? 21 : _context29.t2 === "content" ? 28 : 31;
                  break;

                case 20:
                  g.object = t.from(i.a.inflate(g.object)), g.format = "wrapped";

                case 21:
                  if (!("wrapped" === l && "wrapped" === g.format)) {
                    _context29.next = 23;
                    break;
                  }

                  return _context29.abrupt("return", g);

                case 23:
                  _e8 = Object(f.a)(g.object);

                  if (!(_e8 !== n)) {
                    _context29.next = 26;
                    break;
                  }

                  throw new a.b(a.a.InternalFail, {
                    message: "SHA check failed! Expected ".concat(n, ", computed ").concat(_e8)
                  });

                case 26:
                  _s$a$unwrap = s.a.unwrap(g.object), _r7 = _s$a$unwrap.object, _o = _s$a$unwrap.type;
                  g.type = _o, g.object = _r7, g.format = "content";

                case 28:
                  if (!("content" === l)) {
                    _context29.next = 30;
                    break;
                  }

                  return _context29.abrupt("return", g);

                case 30:
                  return _context29.abrupt("break", 32);

                case 31:
                  throw new a.b(a.a.InternalFail, {
                    message: "invalid format \"".concat(g.format, "\"")
                  });

                case 32:
                case "end":
                  return _context29.stop();
              }
            }
          }, e);
        }), (h = function h() {
          var t = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = e.apply(t, r);

            function a(t) {
              l(o, n, i, a, s, "next", t);
            }

            function s(t) {
              l(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        }).apply(this, arguments);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return n;
    }), r.d(e, "b", function () {
      return i;
    });
    var n,
        i,
        o = "undefined" != typeof performance && performance,
        a = o && o.now ? function () {
      return o.now();
    } : function () {
      return Date.now();
    };

    function s(t) {
      if (!t) throw new Error("name must be non-empty");
    }

    if (o && o.mark) n = function n(t) {
      s(t), o.mark("start " + t);
    }, i = function i(t) {
      s(t), o.mark("end " + t), o.measure(t, "start " + t, "end " + t);
      var e = o.getEntriesByName(t);
      return e[e.length - 1];
    }, function () {
      return o.getEntriesByType("measure");
    }, function () {
      o.clearMarks(), o.clearMeasures();
    };else {
      var u = {},
          c = [];
      n = function n(t) {
        s(t);
        var e = a();
        u["$" + t] = e;
      }, i = function i(t) {
        s(t);
        var e = a(),
            r = u["$" + t];
        if (!r) throw new Error("no known mark: " + t);
        var n = {
          startTime: r,
          name: t,
          duration: e - r,
          entryType: "measure"
        };
        return function (t, e) {
          for (var r, n = 0, i = t.length; n < i;) {
            t[r = n + i >>> 1].startTime < e.startTime ? n = r + 1 : i = r;
          }

          t.splice(n, 0, e);
        }(c, n), n;
      }, function () {
        return c;
      }, function () {
        u = {}, c = [];
      };
    }
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return l;
      });
      var n = r(0),
          i = r(43),
          o = r(34),
          a = r(13),
          s = r(95),
          u = r(33);

      function c(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function f(t) {
        return function () {
          var e = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = t.apply(e, r);

            function a(t) {
              c(o, n, i, a, s, "next", t);
            }

            function s(t) {
              c(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        };
      }

      var l =
      /*#__PURE__*/
      function () {
        function l(e) {
          _classCallCheck(this, l);

          if ("string" == typeof e) this._commit = e;else if (t.isBuffer(e)) this._commit = e.toString("utf8");else {
            if ("object" != _typeof(e)) throw new n.b(n.a.InternalFail, {
              message: "invalid type passed to GitCommit constructor"
            });
            this._commit = l.render(e);
          }
        }

        _createClass(l, [{
          key: "toObject",
          value: function toObject() {
            return t.from(this._commit, "utf8");
          }
        }, {
          key: "headers",
          value: function headers() {
            return this.parseHeaders();
          }
        }, {
          key: "message",
          value: function message() {
            return l.justMessage(this._commit);
          }
        }, {
          key: "parse",
          value: function parse() {
            return Object.assign({
              message: this.message()
            }, this.headers());
          }
        }, {
          key: "parseHeaders",
          value: function parseHeaders() {
            var t = l.justHeaders(this._commit).split("\n"),
                e = [];
            var _iteratorNormalCompletion15 = true;
            var _didIteratorError15 = false;
            var _iteratorError15 = undefined;

            try {
              for (var _iterator15 = t[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                var _r8 = _step15.value;
                " " === _r8[0] ? e[e.length - 1] += "\n" + _r8.slice(1) : e.push(_r8);
              }
            } catch (err) {
              _didIteratorError15 = true;
              _iteratorError15 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
                  _iterator15.return();
                }
              } finally {
                if (_didIteratorError15) {
                  throw _iteratorError15;
                }
              }
            }

            var r = {
              parent: []
            };

            for (var _i4 = 0, _e9 = e; _i4 < _e9.length; _i4++) {
              var _t16 = _e9[_i4];

              var _e10 = _t16.slice(0, _t16.indexOf(" ")),
                  _n5 = _t16.slice(_t16.indexOf(" ") + 1);

              Array.isArray(r[_e10]) ? r[_e10].push(_n5) : r[_e10] = _n5;
            }

            return r.author && (r.author = Object(u.a)(r.author)), r.committer && (r.committer = Object(u.a)(r.committer)), r;
          }
        }, {
          key: "render",
          value: function render() {
            return this._commit;
          }
        }, {
          key: "withoutSignature",
          value: function withoutSignature() {
            var t = Object(a.a)(this._commit);
            if (-1 === t.indexOf("\ngpgsig")) return t;
            var e = t.slice(0, t.indexOf("\ngpgsig")),
                r = t.slice(t.indexOf("-----END PGP SIGNATURE-----\n") + "-----END PGP SIGNATURE-----\n".length);
            return Object(a.a)(e + "\n" + r);
          }
        }, {
          key: "isolateSignature",
          value: function isolateSignature() {
            var t = this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"), this._commit.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length);

            return Object(s.a)(t);
          }
        }], [{
          key: "fromPayloadSignature",
          value: function fromPayloadSignature(_ref17) {
            var t = _ref17.payload,
                e = _ref17.signature;
            var r = l.justHeaders(t),
                n = l.justMessage(t),
                i = Object(a.a)(r + "\ngpgsig" + Object(o.a)(e) + "\n" + n);
            return new l(i);
          }
        }, {
          key: "from",
          value: function from(t) {
            return new l(t);
          }
        }, {
          key: "justMessage",
          value: function justMessage(t) {
            return Object(a.a)(t.slice(t.indexOf("\n\n") + 2));
          }
        }, {
          key: "justHeaders",
          value: function justHeaders(t) {
            return t.slice(0, t.indexOf("\n\n"));
          }
        }, {
          key: "renderHeaders",
          value: function renderHeaders(t) {
            var e = "";

            if (t.tree ? e += "tree ".concat(t.tree, "\n") : e += "tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n", t.parent) {
              if (void 0 === t.parent.length) throw new n.b(n.a.InternalFail, {
                message: "commit 'parent' property should be an array"
              });
              var _iteratorNormalCompletion16 = true;
              var _didIteratorError16 = false;
              var _iteratorError16 = undefined;

              try {
                for (var _iterator16 = t.parent[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                  var _r9 = _step16.value;
                  e += "parent ".concat(_r9, "\n");
                }
              } catch (err) {
                _didIteratorError16 = true;
                _iteratorError16 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
                    _iterator16.return();
                  }
                } finally {
                  if (_didIteratorError16) {
                    throw _iteratorError16;
                  }
                }
              }
            }

            var r = t.author;
            e += "author ".concat(Object(i.a)(r), "\n");
            var a = t.committer || t.author;
            return e += "committer ".concat(Object(i.a)(a), "\n"), t.gpgsig && (e += "gpgsig" + Object(o.a)(t.gpgsig)), e;
          }
        }, {
          key: "render",
          value: function render(t) {
            return l.renderHeaders(t) + "\n" + Object(a.a)(t.message);
          }
        }, {
          key: "sign",
          value: function sign(t, e, r) {
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee28() {
              var n, i, _ref18, s, u;

              return regeneratorRuntime.wrap(function _callee28$(_context30) {
                while (1) {
                  switch (_context30.prev = _context30.next) {
                    case 0:
                      n = t.withoutSignature(), i = l.justMessage(t._commit);
                      _context30.next = 3;
                      return e.sign({
                        payload: n,
                        secretKey: r
                      });

                    case 3:
                      _ref18 = _context30.sent;
                      s = _ref18.signature;
                      s = Object(a.a)(s);
                      u = l.justHeaders(t._commit) + "\ngpgsig" + Object(o.a)(s) + "\n" + i;
                      return _context30.abrupt("return", l.from(u));

                    case 8:
                    case "end":
                      return _context30.stop();
                  }
                }
              }, _callee28);
            }))();
          }
        }, {
          key: "verify",
          value: function verify(t, e, r) {
            return f(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee29() {
              var n, i;
              return regeneratorRuntime.wrap(function _callee29$(_context31) {
                while (1) {
                  switch (_context31.prev = _context31.next) {
                    case 0:
                      n = t.withoutSignature(), i = t.isolateSignature();
                      return _context31.abrupt("return", e.verify({
                        payload: n,
                        publicKey: r,
                        signature: i
                      }));

                    case 2:
                    case "end":
                      return _context31.stop();
                  }
                }
              }, _callee29);
            }))();
          }
        }]);

        return l;
      }();
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return i;
      });
      var n = null;

      function i() {
        var _console;

        null === n && (n = t && t.env && t.env.DEBUG && ("*" === t.env.DEBUG || "isomorphic-git" === t.env.DEBUG) || "undefined" != typeof window && void 0 !== window.localStorage && ("*" === window.localStorage.debug || "isomorphic-git" === window.localStorage.debug)), n && (_console = console).log.apply(_console, arguments);
      }
    }).call(this, r(47));
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return a;
      });
      var n = r(55),
          i = r(32);

      function o(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      var a =
      /*#__PURE__*/
      function () {
        function a() {
          _classCallCheck(this, a);
        }

        _createClass(a, null, [{
          key: "flush",
          value: function flush() {
            return t.from("0000", "utf8");
          }
        }, {
          key: "encode",
          value: function encode(e) {
            "string" == typeof e && (e = t.from(e));
            var r = e.length + 4,
                n = Object(i.a)(4, r);
            return t.concat([t.from(n, "utf8"), e]);
          }
        }, {
          key: "streamReader",
          value: function streamReader(t) {
            var e = new n.a(t);
            return function () {
              var t,
                  r = (t =
              /*#__PURE__*/
              regeneratorRuntime.mark(function t() {
                var _t17, _r10;

                return regeneratorRuntime.wrap(function t$(_context32) {
                  while (1) {
                    switch (_context32.prev = _context32.next) {
                      case 0:
                        _context32.prev = 0;
                        _context32.next = 3;
                        return e.read(4);

                      case 3:
                        _t17 = _context32.sent;

                        if (!(null == _t17)) {
                          _context32.next = 6;
                          break;
                        }

                        return _context32.abrupt("return", !0);

                      case 6:
                        if (!(0 === (_t17 = parseInt(_t17.toString("utf8"), 16)))) {
                          _context32.next = 8;
                          break;
                        }

                        return _context32.abrupt("return", null);

                      case 8:
                        _context32.next = 10;
                        return e.read(_t17 - 4);

                      case 10:
                        _r10 = _context32.sent;
                        return _context32.abrupt("return", null == _r10 || _r10);

                      case 14:
                        _context32.prev = 14;
                        _context32.t0 = _context32["catch"](0);
                        return _context32.abrupt("return", (console.log("error", _context32.t0), !0));

                      case 17:
                      case "end":
                        return _context32.stop();
                    }
                  }
                }, t, null, [[0, 14]]);
              }), function () {
                var e = this,
                    r = arguments;
                return new Promise(function (n, i) {
                  var a = t.apply(e, r);

                  function s(t) {
                    o(a, n, i, s, u, "next", t);
                  }

                  function u(t) {
                    o(a, n, i, s, u, "throw", t);
                  }

                  s(void 0);
                });
              });
              return function () {
                return r.apply(this, arguments);
              };
            }();
          }
        }]);

        return a;
      }();
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      /*!
       * The buffer module from node.js, for the browser.
       *
       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
       * @license  MIT
       */
      var n = r(59),
          i = r(99),
          o = r(100);

      function a() {
        return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }

      function s(t, e) {
        if (a() < e) throw new RangeError("Invalid typed array length");
        return u.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = u.prototype : (null === t && (t = new u(e)), t.length = e), t;
      }

      function u(t, e, r) {
        if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u)) return new u(t, e, r);

        if ("number" == typeof t) {
          if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string");
          return l(this, t);
        }

        return c(this, t, e, r);
      }

      function c(t, e, r, n) {
        if ("number" == typeof e) throw new TypeError('"value" argument must not be a number');
        return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, r, n) {
          if (e.byteLength, r < 0 || e.byteLength < r) throw new RangeError("'offset' is out of bounds");
          if (e.byteLength < r + (n || 0)) throw new RangeError("'length' is out of bounds");
          e = void 0 === r && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, r) : new Uint8Array(e, r, n);
          u.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = u.prototype : t = d(t, e);
          return t;
        }(t, e, r, n) : "string" == typeof e ? function (t, e, r) {
          "string" == typeof r && "" !== r || (r = "utf8");
          if (!u.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding');
          var n = 0 | p(e, r),
              i = (t = s(t, n)).write(e, r);
          i !== n && (t = t.slice(0, i));
          return t;
        }(t, e, r) : function (t, e) {
          if (u.isBuffer(e)) {
            var r = 0 | h(e.length);
            return 0 === (t = s(t, r)).length ? t : (e.copy(t, 0, 0, r), t);
          }

          if (e) {
            if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || (n = e.length) != n ? s(t, 0) : d(t, e);
            if ("Buffer" === e.type && o(e.data)) return d(t, e.data);
          }

          var n;
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }(t, e);
      }

      function f(t) {
        if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
        if (t < 0) throw new RangeError('"size" argument must not be negative');
      }

      function l(t, e) {
        if (f(e), t = s(t, e < 0 ? 0 : 0 | h(e)), !u.TYPED_ARRAY_SUPPORT) for (var r = 0; r < e; ++r) {
          t[r] = 0;
        }
        return t;
      }

      function d(t, e) {
        var r = e.length < 0 ? 0 : 0 | h(e.length);
        t = s(t, r);

        for (var n = 0; n < r; n += 1) {
          t[n] = 255 & e[n];
        }

        return t;
      }

      function h(t) {
        if (t >= a()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
        return 0 | t;
      }

      function p(t, e) {
        if (u.isBuffer(t)) return t.length;
        if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
        "string" != typeof t && (t = "" + t);
        var r = t.length;
        if (0 === r) return 0;

        for (var n = !1;;) {
          switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;

            case "utf8":
            case "utf-8":
            case void 0:
              return z(t).length;

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r;

            case "hex":
              return r >>> 1;

            case "base64":
              return H(t).length;

            default:
              if (n) return z(t).length;
              e = ("" + e).toLowerCase(), n = !0;
          }
        }
      }

      function g(t, e, r) {
        var n = !1;
        if ((void 0 === e || e < 0) && (e = 0), e > this.length) return "";
        if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
        if ((r >>>= 0) <= (e >>>= 0)) return "";

        for (t || (t = "utf8");;) {
          switch (t) {
            case "hex":
              return A(this, e, r);

            case "utf8":
            case "utf-8":
              return j(this, e, r);

            case "ascii":
              return S(this, e, r);

            case "latin1":
            case "binary":
              return R(this, e, r);

            case "base64":
              return O(this, e, r);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return $(this, e, r);

            default:
              if (n) throw new TypeError("Unknown encoding: " + t);
              t = (t + "").toLowerCase(), n = !0;
          }
        }
      }

      function m(t, e, r) {
        var n = t[e];
        t[e] = t[r], t[r] = n;
      }

      function y(t, e, r, n, i) {
        if (0 === t.length) return -1;

        if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = i ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
          if (i) return -1;
          r = t.length - 1;
        } else if (r < 0) {
          if (!i) return -1;
          r = 0;
        }

        if ("string" == typeof e && (e = u.from(e, n)), u.isBuffer(e)) return 0 === e.length ? -1 : v(t, e, r, n, i);
        if ("number" == typeof e) return e &= 255, u.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : v(t, [e], r, n, i);
        throw new TypeError("val must be string, number or Buffer");
      }

      function v(t, e, r, n, i) {
        var o,
            a = 1,
            s = t.length,
            u = e.length;

        if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
          if (t.length < 2 || e.length < 2) return -1;
          a = 2, s /= 2, u /= 2, r /= 2;
        }

        function c(t, e) {
          return 1 === a ? t[e] : t.readUInt16BE(e * a);
        }

        if (i) {
          var f = -1;

          for (o = r; o < s; o++) {
            if (c(t, o) === c(e, -1 === f ? 0 : o - f)) {
              if (-1 === f && (f = o), o - f + 1 === u) return f * a;
            } else -1 !== f && (o -= o - f), f = -1;
          }
        } else for (r + u > s && (r = s - u), o = r; o >= 0; o--) {
          for (var l = !0, d = 0; d < u; d++) {
            if (c(t, o + d) !== c(e, d)) {
              l = !1;
              break;
            }
          }

          if (l) return o;
        }

        return -1;
      }

      function w(t, e, r, n) {
        r = Number(r) || 0;
        var i = t.length - r;
        n ? (n = Number(n)) > i && (n = i) : n = i;
        var o = e.length;
        if (o % 2 != 0) throw new TypeError("Invalid hex string");
        n > o / 2 && (n = o / 2);

        for (var a = 0; a < n; ++a) {
          var s = parseInt(e.substr(2 * a, 2), 16);
          if (isNaN(s)) return a;
          t[r + a] = s;
        }

        return a;
      }

      function b(t, e, r, n) {
        return L(z(e, t.length - r), t, r, n);
      }

      function _(t, e, r, n) {
        return L(function (t) {
          for (var e = [], r = 0; r < t.length; ++r) {
            e.push(255 & t.charCodeAt(r));
          }

          return e;
        }(e), t, r, n);
      }

      function x(t, e, r, n) {
        return _(t, e, r, n);
      }

      function E(t, e, r, n) {
        return L(H(e), t, r, n);
      }

      function k(t, e, r, n) {
        return L(function (t, e) {
          for (var r, n, i, o = [], a = 0; a < t.length && !((e -= 2) < 0); ++a) {
            r = t.charCodeAt(a), n = r >> 8, i = r % 256, o.push(i), o.push(n);
          }

          return o;
        }(e, t.length - r), t, r, n);
      }

      function O(t, e, r) {
        return 0 === e && r === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(e, r));
      }

      function j(t, e, r) {
        r = Math.min(t.length, r);

        for (var n = [], i = e; i < r;) {
          var o,
              a,
              s,
              u,
              c = t[i],
              f = null,
              l = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
          if (i + l <= r) switch (l) {
            case 1:
              c < 128 && (f = c);
              break;

            case 2:
              128 == (192 & (o = t[i + 1])) && (u = (31 & c) << 6 | 63 & o) > 127 && (f = u);
              break;

            case 3:
              o = t[i + 1], a = t[i + 2], 128 == (192 & o) && 128 == (192 & a) && (u = (15 & c) << 12 | (63 & o) << 6 | 63 & a) > 2047 && (u < 55296 || u > 57343) && (f = u);
              break;

            case 4:
              o = t[i + 1], a = t[i + 2], s = t[i + 3], 128 == (192 & o) && 128 == (192 & a) && 128 == (192 & s) && (u = (15 & c) << 18 | (63 & o) << 12 | (63 & a) << 6 | 63 & s) > 65535 && u < 1114112 && (f = u);
          }
          null === f ? (f = 65533, l = 1) : f > 65535 && (f -= 65536, n.push(f >>> 10 & 1023 | 55296), f = 56320 | 1023 & f), n.push(f), i += l;
        }

        return function (t) {
          var e = t.length;
          if (e <= P) return String.fromCharCode.apply(String, t);
          var r = "",
              n = 0;

          for (; n < e;) {
            r += String.fromCharCode.apply(String, t.slice(n, n += P));
          }

          return r;
        }(n);
      }

      e.Buffer = u, e.SlowBuffer = function (t) {
        +t != t && (t = 0);
        return u.alloc(+t);
      }, e.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function () {
        try {
          var t = new Uint8Array(1);
          return t.__proto__ = {
            __proto__: Uint8Array.prototype,
            foo: function foo() {
              return 42;
            }
          }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength;
        } catch (t) {
          return !1;
        }
      }(), e.kMaxLength = a(), u.poolSize = 8192, u._augment = function (t) {
        return t.__proto__ = u.prototype, t;
      }, u.from = function (t, e, r) {
        return c(null, t, e, r);
      }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, {
        value: null,
        configurable: !0
      })), u.alloc = function (t, e, r) {
        return function (t, e, r, n) {
          return f(e), e <= 0 ? s(t, e) : void 0 !== r ? "string" == typeof n ? s(t, e).fill(r, n) : s(t, e).fill(r) : s(t, e);
        }(null, t, e, r);
      }, u.allocUnsafe = function (t) {
        return l(null, t);
      }, u.allocUnsafeSlow = function (t) {
        return l(null, t);
      }, u.isBuffer = function (t) {
        return !(null == t || !t._isBuffer);
      }, u.compare = function (t, e) {
        if (!u.isBuffer(t) || !u.isBuffer(e)) throw new TypeError("Arguments must be Buffers");
        if (t === e) return 0;

        for (var r = t.length, n = e.length, i = 0, o = Math.min(r, n); i < o; ++i) {
          if (t[i] !== e[i]) {
            r = t[i], n = e[i];
            break;
          }
        }

        return r < n ? -1 : n < r ? 1 : 0;
      }, u.isEncoding = function (t) {
        switch (String(t).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;

          default:
            return !1;
        }
      }, u.concat = function (t, e) {
        if (!o(t)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t.length) return u.alloc(0);
        var r;
        if (void 0 === e) for (e = 0, r = 0; r < t.length; ++r) {
          e += t[r].length;
        }
        var n = u.allocUnsafe(e),
            i = 0;

        for (r = 0; r < t.length; ++r) {
          var a = t[r];
          if (!u.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
          a.copy(n, i), i += a.length;
        }

        return n;
      }, u.byteLength = p, u.prototype._isBuffer = !0, u.prototype.swap16 = function () {
        var t = this.length;
        if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");

        for (var e = 0; e < t; e += 2) {
          m(this, e, e + 1);
        }

        return this;
      }, u.prototype.swap32 = function () {
        var t = this.length;
        if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");

        for (var e = 0; e < t; e += 4) {
          m(this, e, e + 3), m(this, e + 1, e + 2);
        }

        return this;
      }, u.prototype.swap64 = function () {
        var t = this.length;
        if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");

        for (var e = 0; e < t; e += 8) {
          m(this, e, e + 7), m(this, e + 1, e + 6), m(this, e + 2, e + 5), m(this, e + 3, e + 4);
        }

        return this;
      }, u.prototype.toString = function () {
        var t = 0 | this.length;
        return 0 === t ? "" : 0 === arguments.length ? j(this, 0, t) : g.apply(this, arguments);
      }, u.prototype.equals = function (t) {
        if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
        return this === t || 0 === u.compare(this, t);
      }, u.prototype.inspect = function () {
        var t = "",
            r = e.INSPECT_MAX_BYTES;
        return this.length > 0 && (t = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (t += " ... ")), "<Buffer " + t + ">";
      }, u.prototype.compare = function (t, e, r, n, i) {
        if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
        if (void 0 === e && (e = 0), void 0 === r && (r = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), e < 0 || r > t.length || n < 0 || i > this.length) throw new RangeError("out of range index");
        if (n >= i && e >= r) return 0;
        if (n >= i) return -1;
        if (e >= r) return 1;
        if (this === t) return 0;

        for (var o = (i >>>= 0) - (n >>>= 0), a = (r >>>= 0) - (e >>>= 0), s = Math.min(o, a), c = this.slice(n, i), f = t.slice(e, r), l = 0; l < s; ++l) {
          if (c[l] !== f[l]) {
            o = c[l], a = f[l];
            break;
          }
        }

        return o < a ? -1 : a < o ? 1 : 0;
      }, u.prototype.includes = function (t, e, r) {
        return -1 !== this.indexOf(t, e, r);
      }, u.prototype.indexOf = function (t, e, r) {
        return y(this, t, e, r, !0);
      }, u.prototype.lastIndexOf = function (t, e, r) {
        return y(this, t, e, r, !1);
      }, u.prototype.write = function (t, e, r, n) {
        if (void 0 === e) n = "utf8", r = this.length, e = 0;else if (void 0 === r && "string" == typeof e) n = e, r = this.length, e = 0;else {
          if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          e |= 0, isFinite(r) ? (r |= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0);
        }
        var i = this.length - e;
        if ((void 0 === r || r > i) && (r = i), t.length > 0 && (r < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        n || (n = "utf8");

        for (var o = !1;;) {
          switch (n) {
            case "hex":
              return w(this, t, e, r);

            case "utf8":
            case "utf-8":
              return b(this, t, e, r);

            case "ascii":
              return _(this, t, e, r);

            case "latin1":
            case "binary":
              return x(this, t, e, r);

            case "base64":
              return E(this, t, e, r);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return k(this, t, e, r);

            default:
              if (o) throw new TypeError("Unknown encoding: " + n);
              n = ("" + n).toLowerCase(), o = !0;
          }
        }
      }, u.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      var P = 4096;

      function S(t, e, r) {
        var n = "";
        r = Math.min(t.length, r);

        for (var i = e; i < r; ++i) {
          n += String.fromCharCode(127 & t[i]);
        }

        return n;
      }

      function R(t, e, r) {
        var n = "";
        r = Math.min(t.length, r);

        for (var i = e; i < r; ++i) {
          n += String.fromCharCode(t[i]);
        }

        return n;
      }

      function A(t, e, r) {
        var n = t.length;
        (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);

        for (var i = "", o = e; o < r; ++o) {
          i += N(t[o]);
        }

        return i;
      }

      function $(t, e, r) {
        for (var n = t.slice(e, r), i = "", o = 0; o < n.length; o += 2) {
          i += String.fromCharCode(n[o] + 256 * n[o + 1]);
        }

        return i;
      }

      function T(t, e, r) {
        if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
        if (t + e > r) throw new RangeError("Trying to access beyond buffer length");
      }

      function I(t, e, r, n, i, o) {
        if (!u.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > i || e < o) throw new RangeError('"value" argument is out of bounds');
        if (r + n > t.length) throw new RangeError("Index out of range");
      }

      function B(t, e, r, n) {
        e < 0 && (e = 65535 + e + 1);

        for (var i = 0, o = Math.min(t.length - r, 2); i < o; ++i) {
          t[r + i] = (e & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i);
        }
      }

      function F(t, e, r, n) {
        e < 0 && (e = 4294967295 + e + 1);

        for (var i = 0, o = Math.min(t.length - r, 4); i < o; ++i) {
          t[r + i] = e >>> 8 * (n ? i : 3 - i) & 255;
        }
      }

      function U(t, e, r, n, i, o) {
        if (r + n > t.length) throw new RangeError("Index out of range");
        if (r < 0) throw new RangeError("Index out of range");
      }

      function M(t, e, r, n, o) {
        return o || U(t, 0, r, 4), i.write(t, e, r, n, 23, 4), r + 4;
      }

      function C(t, e, r, n, o) {
        return o || U(t, 0, r, 8), i.write(t, e, r, n, 52, 8), r + 8;
      }

      u.prototype.slice = function (t, e) {
        var r,
            n = this.length;
        if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t), u.TYPED_ARRAY_SUPPORT) (r = this.subarray(t, e)).__proto__ = u.prototype;else {
          var i = e - t;
          r = new u(i, void 0);

          for (var o = 0; o < i; ++o) {
            r[o] = this[o + t];
          }
        }
        return r;
      }, u.prototype.readUIntLE = function (t, e, r) {
        t |= 0, e |= 0, r || T(t, e, this.length);

        for (var n = this[t], i = 1, o = 0; ++o < e && (i *= 256);) {
          n += this[t + o] * i;
        }

        return n;
      }, u.prototype.readUIntBE = function (t, e, r) {
        t |= 0, e |= 0, r || T(t, e, this.length);

        for (var n = this[t + --e], i = 1; e > 0 && (i *= 256);) {
          n += this[t + --e] * i;
        }

        return n;
      }, u.prototype.readUInt8 = function (t, e) {
        return e || T(t, 1, this.length), this[t];
      }, u.prototype.readUInt16LE = function (t, e) {
        return e || T(t, 2, this.length), this[t] | this[t + 1] << 8;
      }, u.prototype.readUInt16BE = function (t, e) {
        return e || T(t, 2, this.length), this[t] << 8 | this[t + 1];
      }, u.prototype.readUInt32LE = function (t, e) {
        return e || T(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
      }, u.prototype.readUInt32BE = function (t, e) {
        return e || T(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
      }, u.prototype.readIntLE = function (t, e, r) {
        t |= 0, e |= 0, r || T(t, e, this.length);

        for (var n = this[t], i = 1, o = 0; ++o < e && (i *= 256);) {
          n += this[t + o] * i;
        }

        return n >= (i *= 128) && (n -= Math.pow(2, 8 * e)), n;
      }, u.prototype.readIntBE = function (t, e, r) {
        t |= 0, e |= 0, r || T(t, e, this.length);

        for (var n = e, i = 1, o = this[t + --n]; n > 0 && (i *= 256);) {
          o += this[t + --n] * i;
        }

        return o >= (i *= 128) && (o -= Math.pow(2, 8 * e)), o;
      }, u.prototype.readInt8 = function (t, e) {
        return e || T(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
      }, u.prototype.readInt16LE = function (t, e) {
        e || T(t, 2, this.length);
        var r = this[t] | this[t + 1] << 8;
        return 32768 & r ? 4294901760 | r : r;
      }, u.prototype.readInt16BE = function (t, e) {
        e || T(t, 2, this.length);
        var r = this[t + 1] | this[t] << 8;
        return 32768 & r ? 4294901760 | r : r;
      }, u.prototype.readInt32LE = function (t, e) {
        return e || T(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
      }, u.prototype.readInt32BE = function (t, e) {
        return e || T(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
      }, u.prototype.readFloatLE = function (t, e) {
        return e || T(t, 4, this.length), i.read(this, t, !0, 23, 4);
      }, u.prototype.readFloatBE = function (t, e) {
        return e || T(t, 4, this.length), i.read(this, t, !1, 23, 4);
      }, u.prototype.readDoubleLE = function (t, e) {
        return e || T(t, 8, this.length), i.read(this, t, !0, 52, 8);
      }, u.prototype.readDoubleBE = function (t, e) {
        return e || T(t, 8, this.length), i.read(this, t, !1, 52, 8);
      }, u.prototype.writeUIntLE = function (t, e, r, n) {
        (t = +t, e |= 0, r |= 0, n) || I(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
        var i = 1,
            o = 0;

        for (this[e] = 255 & t; ++o < r && (i *= 256);) {
          this[e + o] = t / i & 255;
        }

        return e + r;
      }, u.prototype.writeUIntBE = function (t, e, r, n) {
        (t = +t, e |= 0, r |= 0, n) || I(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
        var i = r - 1,
            o = 1;

        for (this[e + i] = 255 & t; --i >= 0 && (o *= 256);) {
          this[e + i] = t / o & 255;
        }

        return e + r;
      }, u.prototype.writeUInt8 = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1;
      }, u.prototype.writeUInt16LE = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : B(this, t, e, !0), e + 2;
      }, u.prototype.writeUInt16BE = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : B(this, t, e, !1), e + 2;
      }, u.prototype.writeUInt32LE = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : F(this, t, e, !0), e + 4;
      }, u.prototype.writeUInt32BE = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : F(this, t, e, !1), e + 4;
      }, u.prototype.writeIntLE = function (t, e, r, n) {
        if (t = +t, e |= 0, !n) {
          var i = Math.pow(2, 8 * r - 1);
          I(this, t, e, r, i - 1, -i);
        }

        var o = 0,
            a = 1,
            s = 0;

        for (this[e] = 255 & t; ++o < r && (a *= 256);) {
          t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1), this[e + o] = (t / a >> 0) - s & 255;
        }

        return e + r;
      }, u.prototype.writeIntBE = function (t, e, r, n) {
        if (t = +t, e |= 0, !n) {
          var i = Math.pow(2, 8 * r - 1);
          I(this, t, e, r, i - 1, -i);
        }

        var o = r - 1,
            a = 1,
            s = 0;

        for (this[e + o] = 255 & t; --o >= 0 && (a *= 256);) {
          t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1), this[e + o] = (t / a >> 0) - s & 255;
        }

        return e + r;
      }, u.prototype.writeInt8 = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1;
      }, u.prototype.writeInt16LE = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : B(this, t, e, !0), e + 2;
      }, u.prototype.writeInt16BE = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : B(this, t, e, !1), e + 2;
      }, u.prototype.writeInt32LE = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : F(this, t, e, !0), e + 4;
      }, u.prototype.writeInt32BE = function (t, e, r) {
        return t = +t, e |= 0, r || I(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : F(this, t, e, !1), e + 4;
      }, u.prototype.writeFloatLE = function (t, e, r) {
        return M(this, t, e, !0, r);
      }, u.prototype.writeFloatBE = function (t, e, r) {
        return M(this, t, e, !1, r);
      }, u.prototype.writeDoubleLE = function (t, e, r) {
        return C(this, t, e, !0, r);
      }, u.prototype.writeDoubleBE = function (t, e, r) {
        return C(this, t, e, !1, r);
      }, u.prototype.copy = function (t, e, r, n) {
        if (r || (r = 0), n || 0 === n || (n = this.length), e >= t.length && (e = t.length), e || (e = 0), n > 0 && n < r && (n = r), n === r) return 0;
        if (0 === t.length || 0 === this.length) return 0;
        if (e < 0) throw new RangeError("targetStart out of bounds");
        if (r < 0 || r >= this.length) throw new RangeError("sourceStart out of bounds");
        if (n < 0) throw new RangeError("sourceEnd out of bounds");
        n > this.length && (n = this.length), t.length - e < n - r && (n = t.length - e + r);
        var i,
            o = n - r;
        if (this === t && r < e && e < n) for (i = o - 1; i >= 0; --i) {
          t[i + e] = this[i + r];
        } else if (o < 1e3 || !u.TYPED_ARRAY_SUPPORT) for (i = 0; i < o; ++i) {
          t[i + e] = this[i + r];
        } else Uint8Array.prototype.set.call(t, this.subarray(r, r + o), e);
        return o;
      }, u.prototype.fill = function (t, e, r, n) {
        if ("string" == typeof t) {
          if ("string" == typeof e ? (n = e, e = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), 1 === t.length) {
            var i = t.charCodeAt(0);
            i < 256 && (t = i);
          }

          if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
          if ("string" == typeof n && !u.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
        } else "number" == typeof t && (t &= 255);

        if (e < 0 || this.length < e || this.length < r) throw new RangeError("Out of range index");
        if (r <= e) return this;
        var o;
        if (e >>>= 0, r = void 0 === r ? this.length : r >>> 0, t || (t = 0), "number" == typeof t) for (o = e; o < r; ++o) {
          this[o] = t;
        } else {
          var a = u.isBuffer(t) ? t : z(new u(t, n).toString()),
              s = a.length;

          for (o = 0; o < r - e; ++o) {
            this[o + e] = a[o % s];
          }
        }
        return this;
      };
      var D = /[^+\/0-9A-Za-z-_]/g;

      function N(t) {
        return t < 16 ? "0" + t.toString(16) : t.toString(16);
      }

      function z(t, e) {
        var r;
        e = e || 1 / 0;

        for (var n = t.length, i = null, o = [], a = 0; a < n; ++a) {
          if ((r = t.charCodeAt(a)) > 55295 && r < 57344) {
            if (!i) {
              if (r > 56319) {
                (e -= 3) > -1 && o.push(239, 191, 189);
                continue;
              }

              if (a + 1 === n) {
                (e -= 3) > -1 && o.push(239, 191, 189);
                continue;
              }

              i = r;
              continue;
            }

            if (r < 56320) {
              (e -= 3) > -1 && o.push(239, 191, 189), i = r;
              continue;
            }

            r = 65536 + (i - 55296 << 10 | r - 56320);
          } else i && (e -= 3) > -1 && o.push(239, 191, 189);

          if (i = null, r < 128) {
            if ((e -= 1) < 0) break;
            o.push(r);
          } else if (r < 2048) {
            if ((e -= 2) < 0) break;
            o.push(r >> 6 | 192, 63 & r | 128);
          } else if (r < 65536) {
            if ((e -= 3) < 0) break;
            o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);
          } else {
            if (!(r < 1114112)) throw new Error("Invalid code point");
            if ((e -= 4) < 0) break;
            o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);
          }
        }

        return o;
      }

      function H(t) {
        return n.toByteArray(function (t) {
          if ((t = function (t) {
            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
          }(t).replace(D, "")).length < 2) return "";

          for (; t.length % 4 != 0;) {
            t += "=";
          }

          return t;
        }(t));
      }

      function L(t, e, r, n) {
        for (var i = 0; i < n && !(i + r >= e.length || i >= t.length); ++i) {
          e[i + r] = t[i];
        }

        return i;
      }
    }).call(this, r(72));
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return s;
      });
      var n = r(0),
          i = r(37);

      function o(t) {
        switch (t) {
          case "040000":
            return "tree";

          case "100644":
          case "100755":
          case "120000":
            return "blob";

          case "160000":
            return "commit";
        }

        throw new n.b(n.a.InternalFail, {
          message: "Unexpected GitTree entry mode: ".concat(t)
        });
      }

      function a(t) {
        return !t.oid && t.sha && (t.oid = t.sha), t.mode = function (t) {
          if ("number" == typeof t && (t = t.toString(8)), t.match(/^0?4.*/)) return "040000";
          if (t.match(/^1006.*/)) return "100644";
          if (t.match(/^1007.*/)) return "100755";
          if (t.match(/^120.*/)) return "120000";
          if (t.match(/^160.*/)) return "160000";
          throw new n.b(n.a.InternalFail, {
            message: "Could not understand file mode: ".concat(t)
          });
        }(t.mode), t.type || (t.type = "blob"), t;
      }

      var s =
      /*#__PURE__*/
      function () {
        function s(e) {
          _classCallCheck(this, s);

          if (t.isBuffer(e)) this._entries = function (t) {
            var e = [];
            var r = 0;

            for (; r < t.length;) {
              var _i5 = t.indexOf(32, r);

              if (-1 === _i5) throw new n.b(n.a.InternalFail, {
                message: "GitTree: Error parsing buffer at byte location ".concat(r, ": Could not find the next space character.")
              });

              var _a = t.indexOf(0, r);

              if (-1 === _a) throw new n.b(n.a.InternalFail, {
                message: "GitTree: Error parsing buffer at byte location ".concat(r, ": Could not find the next null character.")
              });

              var _s2 = t.slice(r, _i5).toString("utf8");

              "40000" === _s2 && (_s2 = "040000");
              var u = o(_s2),
                  c = t.slice(_i5 + 1, _a).toString("utf8"),
                  f = t.slice(_a + 1, _a + 21).toString("hex");
              r = _a + 21, e.push({
                mode: _s2,
                path: c,
                oid: f,
                type: u
              });
            }

            return e;
          }(e), this._entries.sort(i.a);else {
            if (!Array.isArray(e)) throw new n.b(n.a.InternalFail, {
              message: "invalid type passed to GitTree constructor"
            });
            this._entries = e.map(a);
          }
        }

        _createClass(s, [{
          key: "render",
          value: function render() {
            return this._entries.map(function (t) {
              return "".concat(t.mode, " ").concat(t.type, " ").concat(t.oid, "    ").concat(t.path);
            }).join("\n");
          }
        }, {
          key: "toObject",
          value: function toObject() {
            return t.concat(this._entries.map(function (e) {
              var r = t.from(e.mode.replace(/^0/, "")),
                  n = t.from(" "),
                  i = t.from(e.path, "utf8"),
                  o = t.from([0]),
                  a = t.from(e.oid, "hex");
              return t.concat([r, n, i, o, a]);
            }));
          }
        }, {
          key: "entries",
          value: function entries() {
            return this._entries;
          }
        }, {
          key: Symbol.iterator,
          value:
          /*#__PURE__*/
          regeneratorRuntime.mark(function value() {
            var _iteratorNormalCompletion17, _didIteratorError17, _iteratorError17, _iterator17, _step17, _t18;

            return regeneratorRuntime.wrap(function value$(_context33) {
              while (1) {
                switch (_context33.prev = _context33.next) {
                  case 0:
                    _iteratorNormalCompletion17 = true;
                    _didIteratorError17 = false;
                    _iteratorError17 = undefined;
                    _context33.prev = 3;
                    _iterator17 = this._entries[Symbol.iterator]();

                  case 5:
                    if (_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done) {
                      _context33.next = 12;
                      break;
                    }

                    _t18 = _step17.value;
                    _context33.next = 9;
                    return _t18;

                  case 9:
                    _iteratorNormalCompletion17 = true;
                    _context33.next = 5;
                    break;

                  case 12:
                    _context33.next = 18;
                    break;

                  case 14:
                    _context33.prev = 14;
                    _context33.t0 = _context33["catch"](3);
                    _didIteratorError17 = true;
                    _iteratorError17 = _context33.t0;

                  case 18:
                    _context33.prev = 18;
                    _context33.prev = 19;

                    if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
                      _iterator17.return();
                    }

                  case 21:
                    _context33.prev = 21;

                    if (!_didIteratorError17) {
                      _context33.next = 24;
                      break;
                    }

                    throw _iteratorError17;

                  case 24:
                    return _context33.finish(21);

                  case 25:
                    return _context33.finish(18);

                  case 26:
                  case "end":
                    return _context33.stop();
                }
              }
            }, value, this, [[3, 14, 18, 26], [19,, 21, 25]]);
          })
        }], [{
          key: "from",
          value: function from(t) {
            return new s(t);
          }
        }]);

        return s;
      }();
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return o;
    });
    var n = r(31),
        i = r.n(n);

    function o(t) {
      return new i.a().update(t).digest("hex");
    }
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      return t = (t = (t = t.replace(/\r/g, "")).replace(/^\n+/, "")).replace(/\n+$/, "") + "\n";
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return c;
      });
      var n = r(0),
          i = r(43),
          o = r(13),
          a = r(33);

      function s(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function u(t) {
        return function () {
          var e = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = t.apply(e, r);

            function a(t) {
              s(o, n, i, a, u, "next", t);
            }

            function u(t) {
              s(o, n, i, a, u, "throw", t);
            }

            a(void 0);
          });
        };
      }

      var c =
      /*#__PURE__*/
      function () {
        function c(e) {
          _classCallCheck(this, c);

          if ("string" == typeof e) this._tag = e;else if (t.isBuffer(e)) this._tag = e.toString("utf8");else {
            if ("object" != _typeof(e)) throw new n.b(n.a.InternalFail, {
              message: "invalid type passed to GitAnnotatedTag constructor"
            });
            this._tag = c.render(e);
          }
        }

        _createClass(c, [{
          key: "justHeaders",
          value: function justHeaders() {
            return this._tag.slice(0, this._tag.indexOf("\n\n"));
          }
        }, {
          key: "message",
          value: function message() {
            var t = this.withoutSignature();
            return t.slice(t.indexOf("\n\n") + 2);
          }
        }, {
          key: "parse",
          value: function parse() {
            return Object.assign(this.headers(), {
              message: this.message(),
              signature: this.signature()
            });
          }
        }, {
          key: "render",
          value: function render() {
            return this._tag;
          }
        }, {
          key: "headers",
          value: function headers() {
            var t = this.justHeaders().split("\n"),
                e = [];
            var _iteratorNormalCompletion18 = true;
            var _didIteratorError18 = false;
            var _iteratorError18 = undefined;

            try {
              for (var _iterator18 = t[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                var _r11 = _step18.value;
                " " === _r11[0] ? e[e.length - 1] += "\n" + _r11.slice(1) : e.push(_r11);
              }
            } catch (err) {
              _didIteratorError18 = true;
              _iteratorError18 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
                  _iterator18.return();
                }
              } finally {
                if (_didIteratorError18) {
                  throw _iteratorError18;
                }
              }
            }

            var r = {};

            for (var _i6 = 0, _e11 = e; _i6 < _e11.length; _i6++) {
              var _t19 = _e11[_i6];

              var _e12 = _t19.slice(0, _t19.indexOf(" ")),
                  _n6 = _t19.slice(_t19.indexOf(" ") + 1);

              Array.isArray(r[_e12]) ? r[_e12].push(_n6) : r[_e12] = _n6;
            }

            return r.tagger && (r.tagger = Object(a.a)(r.tagger)), r.committer && (r.committer = Object(a.a)(r.committer)), r;
          }
        }, {
          key: "withoutSignature",
          value: function withoutSignature() {
            var t = Object(o.a)(this._tag);
            return -1 === t.indexOf("\n-----BEGIN PGP SIGNATURE-----") ? t : t.slice(0, t.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"));
          }
        }, {
          key: "signature",
          value: function signature() {
            var t = this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"), this._tag.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length);

            return Object(o.a)(t);
          }
        }, {
          key: "toObject",
          value: function toObject() {
            return t.from(this._tag, "utf8");
          }
        }], [{
          key: "from",
          value: function from(t) {
            return new c(t);
          }
        }, {
          key: "render",
          value: function render(t) {
            return "object ".concat(t.object, "\ntype ").concat(t.type, "\ntag ").concat(t.tag, "\ntagger ").concat(Object(i.a)(t.tagger), "\n\n").concat(t.message, "\n").concat(t.signature ? t.signature : "");
          }
        }, {
          key: "sign",
          value: function sign(t, e, r) {
            return u(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee30() {
              var n, _ref19, i, a;

              return regeneratorRuntime.wrap(function _callee30$(_context34) {
                while (1) {
                  switch (_context34.prev = _context34.next) {
                    case 0:
                      n = t.withoutSignature() + "\n";
                      _context34.next = 3;
                      return e.sign({
                        payload: n,
                        secretKey: r
                      });

                    case 3:
                      _ref19 = _context34.sent;
                      i = _ref19.signature;
                      a = n + (i = Object(o.a)(i));
                      return _context34.abrupt("return", c.from(a));

                    case 7:
                    case "end":
                      return _context34.stop();
                  }
                }
              }, _callee30);
            }))();
          }
        }, {
          key: "verify",
          value: function verify(t, e, r) {
            return u(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee31() {
              var n, i;
              return regeneratorRuntime.wrap(function _callee31$(_context35) {
                while (1) {
                  switch (_context35.prev = _context35.next) {
                    case 0:
                      n = t.withoutSignature() + "\n", i = t.signature();
                      return _context35.abrupt("return", e.verify({
                        payload: n,
                        publicKey: r,
                        signature: i
                      }));

                    case 2:
                    case "end":
                      return _context35.stop();
                  }
                }
              }, _callee31);
            }))();
          }
        }]);

        return c;
      }();
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    var n = function n(t, e) {
      return function () {
        var _this3 = this;

        for (var _len2 = arguments.length, r = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          r[_key2] = arguments[_key2];
        }

        return new (0, e.promiseModule)(function (n, i) {
          e.multiArgs ? r.push(function () {
            for (var _len3 = arguments.length, t = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              t[_key3] = arguments[_key3];
            }

            e.errorFirst ? t[0] ? i(t) : (t.shift(), n(t)) : n(t);
          }) : e.errorFirst ? r.push(function (t, e) {
            t ? i(t) : n(e);
          }) : r.push(n), t.apply(_this3, r);
        });
      };
    };

    t.exports = function (t, e) {
      e = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: !0,
        promiseModule: Promise
      }, e);

      var r = _typeof(t);

      if (null === t || "object" !== r && "function" !== r) throw new TypeError("Expected `input` to be a `Function` or `Object`, got `".concat(null === t ? "null" : r, "`"));

      var i = function i(t) {
        var r = function r(e) {
          return "string" == typeof e ? t === e : e.test(t);
        };

        return e.include ? e.include.some(r) : !e.exclude.some(r);
      };

      var o;
      o = "function" === r ? function () {
        for (var _len4 = arguments.length, r = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          r[_key4] = arguments[_key4];
        }

        return e.excludeMain ? t.apply(void 0, r) : n(t, e).apply(this, r);
      } : Object.create(Object.getPrototypeOf(t));

      for (var _r12 in t) {
        var a = t[_r12];
        o[_r12] = "function" == typeof a && i(_r12) ? n(a, e) : a;
      }

      return o;
    };
  }, function (t, e, r) {
    "use strict";

    var n = r(42),
        i = r.n(n),
        o = r(1),
        a = r(62);

    var s = function s(t, e) {
      var _iteratorNormalCompletion19 = true;
      var _didIteratorError19 = false;
      var _iteratorError19 = undefined;

      try {
        for (var _iterator19 = t[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
          var _r13 = _step19.value;
          e.has(_r13) || e.set(_r13, new Map()), e = e.get(_r13);
        }
      } catch (err) {
        _didIteratorError19 = true;
        _iteratorError19 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
            _iterator19.return();
          }
        } finally {
          if (_didIteratorError19) {
            throw _iteratorError19;
          }
        }
      }

      return e;
    };

    var u =
    /*#__PURE__*/
    function () {
      function u() {
        _classCallCheck(this, u);

        this._root = new Map();
      }

      _createClass(u, [{
        key: "set",
        value: function set(t, e) {
          var r = t.pop();
          s(t, this._root).set(r, e);
        }
      }, {
        key: "get",
        value: function get(t) {
          var e = t.pop();
          return s(t, this._root).get(e);
        }
      }, {
        key: "has",
        value: function has(t) {
          var e = t.pop();
          return s(t, this._root).has(e);
        }
      }]);

      return u;
    }();

    var c = r(52);

    function f(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function l(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            f(o, n, i, a, s, "next", t);
          }

          function s(t) {
            f(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    r.d(e, "a", function () {
      return y;
    });
    var d = new u(),
        h = new u();
    var p = null;

    function g() {
      return (g = l(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee32(t, e) {
        var r, n, i;
        return regeneratorRuntime.wrap(function _callee32$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return t.lstat(e);

              case 2:
                r = _context36.sent;
                _context36.next = 5;
                return t.read(e);

              case 5:
                n = _context36.sent;
                i = a.a.from(n);
                d.set([t, e], i), h.set([t, e], r);

              case 8:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee32);
      }))).apply(this, arguments);
    }

    function m() {
      return (m = l(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee33(t, e) {
        var r, n;
        return regeneratorRuntime.wrap(function _callee33$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                r = h.get([t, e]);

                if (!(void 0 === r)) {
                  _context37.next = 3;
                  break;
                }

                return _context37.abrupt("return", !0);

              case 3:
                _context37.next = 5;
                return t.lstat(e);

              case 5:
                n = _context37.sent;
                return _context37.abrupt("return", null !== r && null !== n && Object(c.a)(r, n));

              case 7:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee33);
      }))).apply(this, arguments);
    }

    var y =
    /*#__PURE__*/
    function () {
      function y() {
        _classCallCheck(this, y);
      }

      _createClass(y, null, [{
        key: "acquire",
        value: function acquire(_ref20, r) {
          var t = _ref20.fs,
              e = _ref20.filepath;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee35() {
            var n;
            return regeneratorRuntime.wrap(function _callee35$(_context39) {
              while (1) {
                switch (_context39.prev = _context39.next) {
                  case 0:
                    n = new o.a(t);
                    null === p && (p = new i.a({
                      maxPending: 1 / 0
                    }));
                    _context39.next = 4;
                    return p.acquire(e, l(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee34() {
                      var t, _r14;

                      return regeneratorRuntime.wrap(function _callee34$(_context38) {
                        while (1) {
                          switch (_context38.prev = _context38.next) {
                            case 0:
                              _context38.next = 2;
                              return function (t, e) {
                                return m.apply(this, arguments);
                              }(n, e);

                            case 2:
                              _context38.t0 = _context38.sent;

                              if (!_context38.t0) {
                                _context38.next = 6;
                                break;
                              }

                              _context38.next = 6;
                              return function (t, e) {
                                return g.apply(this, arguments);
                              }(n, e);

                            case 6:
                              t = d.get([n, e]);
                              _context38.next = 9;
                              return r(t);

                            case 9:
                              if (!t._dirty) {
                                _context38.next = 20;
                                break;
                              }

                              _r14 = t.toObject();
                              _context38.next = 13;
                              return n.write(e, _r14);

                            case 13:
                              _context38.t1 = h;
                              _context38.t2 = [n, e];
                              _context38.next = 17;
                              return n.lstat(e);

                            case 17:
                              _context38.t3 = _context38.sent;

                              _context38.t1.set.call(_context38.t1, _context38.t2, _context38.t3);

                              t._dirty = !1;

                            case 20:
                            case "end":
                              return _context38.stop();
                          }
                        }
                      }, _callee34);
                    })));

                  case 4:
                  case "end":
                    return _context39.stop();
                }
              }
            }, _callee35);
          }))();
        }
      }]);

      return y;
    }();
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return i;
      });
      var n = r(0);

      var i =
      /*#__PURE__*/
      function () {
        function i() {
          _classCallCheck(this, i);
        }

        _createClass(i, null, [{
          key: "wrap",
          value: function wrap(_ref21) {
            var e = _ref21.type,
                r = _ref21.object;
            return t.concat([t.from("".concat(e, " ").concat(r.byteLength.toString(), "\0")), t.from(r)]);
          }
        }, {
          key: "unwrap",
          value: function unwrap(e) {
            var r = e.indexOf(32),
                i = e.indexOf(0),
                o = e.slice(0, r).toString("utf8"),
                a = e.slice(r + 1, i).toString("utf8"),
                s = e.length - (i + 1);
            if (parseInt(a) !== s) throw new n.b(n.a.InternalFail, {
              message: "Length mismatch: expected ".concat(a, " bytes but got ").concat(s, " instead.")
            });
            return {
              type: o,
              object: t.from(e.slice(i + 1))
            };
          }
        }]);

        return i;
      }();
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    var n = {};
    (0, r(23).assign)(n, r(104), r(107), r(78)), t.exports = n;
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return n;
    });

    var n =
    /*#__PURE__*/
    function () {
      function n(t) {
        _classCallCheck(this, n);

        this.buffer = t, this._start = 0;
      }

      _createClass(n, [{
        key: "eof",
        value: function eof() {
          return this._start >= this.buffer.length;
        }
      }, {
        key: "tell",
        value: function tell() {
          return this._start;
        }
      }, {
        key: "seek",
        value: function seek(t) {
          this._start = t;
        }
      }, {
        key: "slice",
        value: function slice(t) {
          var e = this.buffer.slice(this._start, this._start + t);
          return this._start += t, e;
        }
      }, {
        key: "toString",
        value: function toString(t, e) {
          var r = this.buffer.toString(t, this._start, this._start + e);
          return this._start += e, r;
        }
      }, {
        key: "write",
        value: function write(t, e, r) {
          var n = this.buffer.write(t, this._start, e, r);
          return this._start += e, n;
        }
      }, {
        key: "readUInt8",
        value: function readUInt8() {
          var t = this.buffer.readUInt8(this._start);
          return this._start += 1, t;
        }
      }, {
        key: "writeUInt8",
        value: function writeUInt8(t) {
          var e = this.buffer.writeUInt8(t, this._start);
          return this._start += 1, e;
        }
      }, {
        key: "readUInt16BE",
        value: function readUInt16BE() {
          var t = this.buffer.readUInt16BE(this._start);
          return this._start += 2, t;
        }
      }, {
        key: "writeUInt16BE",
        value: function writeUInt16BE(t) {
          var e = this.buffer.writeUInt16BE(t, this._start);
          return this._start += 2, e;
        }
      }, {
        key: "readUInt32BE",
        value: function readUInt32BE() {
          var t = this.buffer.readUInt32BE(this._start);
          return this._start += 4, t;
        }
      }, {
        key: "writeUInt32BE",
        value: function writeUInt32BE(t) {
          var e = this.buffer.writeUInt32BE(t, this._start);
          return this._start += 4, e;
        }
      }]);

      return n;
    }();
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return f;
      });
      var n = r(18),
          i = r.n(n),
          o = r(1),
          a = r(17),
          s = r(89),
          u = r(12);

      function c(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function f(t) {
        return l.apply(this, arguments);
      }

      function l() {
        var e;
        return e =
        /*#__PURE__*/
        regeneratorRuntime.mark(function e(_ref22) {
          var e, r, n, c, _ref22$format, f, l, _ref22$dryRun, d, _t20;

          return regeneratorRuntime.wrap(function e$(_context40) {
            while (1) {
              switch (_context40.prev = _context40.next) {
                case 0:
                  e = _ref22.fs, r = _ref22.gitdir, n = _ref22.type, c = _ref22.object, _ref22$format = _ref22.format, f = _ref22$format === void 0 ? "content" : _ref22$format, l = _ref22.oid, _ref22$dryRun = _ref22.dryRun, d = _ref22$dryRun === void 0 ? !1 : _ref22$dryRun;

                  if (!("deflated" !== f && ("wrapped" !== f && (c = a.a.wrap({
                    type: n,
                    object: c
                  })), l = Object(u.a)(c), c = t.from(i.a.deflate(c))), !d)) {
                    _context40.next = 5;
                    break;
                  }

                  _t20 = new o.a(e);
                  _context40.next = 5;
                  return Object(s.a)({
                    fs: _t20,
                    gitdir: r,
                    object: c,
                    format: "deflated",
                    oid: l
                  });

                case 5:
                  return _context40.abrupt("return", l);

                case 6:
                case "end":
                  return _context40.stop();
              }
            }
          }, e);
        }), (l = function l() {
          var t = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = e.apply(t, r);

            function a(t) {
              c(o, n, i, a, s, "next", t);
            }

            function s(t) {
              c(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        }).apply(this, arguments);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      var e = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
      return -1 === e ? "." : 0 === e ? "/" : t.slice(0, e);
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return s;
    });
    var n = r(1),
        i = r(63);

    function o(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function a(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var a = t.apply(e, r);

          function s(t) {
            o(a, n, i, s, u, "next", t);
          }

          function u(t) {
            o(a, n, i, s, u, "throw", t);
          }

          s(void 0);
        });
      };
    }

    var s =
    /*#__PURE__*/
    function () {
      function s() {
        _classCallCheck(this, s);
      }

      _createClass(s, null, [{
        key: "get",
        value: function get(_ref23) {
          var t = _ref23.fs,
              e = _ref23.gitdir;
          return a(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee36() {
            var r, o;
            return regeneratorRuntime.wrap(function _callee36$(_context41) {
              while (1) {
                switch (_context41.prev = _context41.next) {
                  case 0:
                    r = new n.a(t);
                    _context41.next = 3;
                    return r.read("".concat(e, "/config"), {
                      encoding: "utf8"
                    });

                  case 3:
                    o = _context41.sent;
                    return _context41.abrupt("return", i.a.from(o));

                  case 5:
                  case "end":
                    return _context41.stop();
                }
              }
            }, _callee36);
          }))();
        }
      }, {
        key: "save",
        value: function save(_ref24) {
          var t = _ref24.fs,
              e = _ref24.gitdir,
              r = _ref24.config;
          return a(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee37() {
            var i;
            return regeneratorRuntime.wrap(function _callee37$(_context42) {
              while (1) {
                switch (_context42.prev = _context42.next) {
                  case 0:
                    i = new n.a(t);
                    _context42.next = 3;
                    return i.write("".concat(e, "/config"), r.toString(), {
                      encoding: "utf8"
                    });

                  case 3:
                  case "end":
                    return _context42.stop();
                }
              }
            }, _callee37);
          }))();
        }
      }]);

      return s;
    }();
  }, function (t, e, r) {
    "use strict";

    var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;

    function i(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }

    e.assign = function (t) {
      for (var e = Array.prototype.slice.call(arguments, 1); e.length;) {
        var r = e.shift();

        if (r) {
          if ("object" != _typeof(r)) throw new TypeError(r + "must be non-object");

          for (var n in r) {
            i(r, n) && (t[n] = r[n]);
          }
        }
      }

      return t;
    }, e.shrinkBuf = function (t, e) {
      return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t);
    };
    var o = {
      arraySet: function arraySet(t, e, r, n, i) {
        if (e.subarray && t.subarray) t.set(e.subarray(r, r + n), i);else for (var o = 0; o < n; o++) {
          t[i + o] = e[r + o];
        }
      },
      flattenChunks: function flattenChunks(t) {
        var e, r, n, i, o, a;

        for (n = 0, e = 0, r = t.length; e < r; e++) {
          n += t[e].length;
        }

        for (a = new Uint8Array(n), i = 0, e = 0, r = t.length; e < r; e++) {
          o = t[e], a.set(o, i), i += o.length;
        }

        return a;
      }
    },
        a = {
      arraySet: function arraySet(t, e, r, n, i) {
        for (var o = 0; o < n; o++) {
          t[i + o] = e[r + o];
        }
      },
      flattenChunks: function flattenChunks(t) {
        return [].concat.apply([], t);
      }
    };
    e.setTyped = function (t) {
      t ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, o)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, a));
    }, e.setTyped(n);
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return n;
    });
    var n = {
      name: "isomorphic-git",
      version: "0.67.2",
      agent: "git/isomorphic-git@0.67.2"
    };
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      var e = t > 0 ? t >> 12 : 0;
      4 !== e && 8 !== e && 10 !== e && 14 !== e && (e = 8);
      var r = 511 & t;
      return r = 73 & r ? 493 : 420, 8 !== e && (r = 0), (e << 12) + r;
    }

    r.d(e, "a", function () {
      return a;
    });
    var i = Math.pow(2, 32);

    function o(t, e, r, n) {
      if (void 0 !== t && void 0 !== e) return [t, e];
      void 0 === r && (r = n.valueOf());
      var i = Math.floor(r / 1e3);
      return [i, 1e6 * (r - 1e3 * i)];
    }

    function a(t) {
      var _o2 = o(t.ctimeSeconds, t.ctimeNanoseconds, t.ctimeMs, t.ctime),
          _o3 = _slicedToArray(_o2, 2),
          e = _o3[0],
          r = _o3[1],
          _o4 = o(t.mtimeSeconds, t.mtimeNanoseconds, t.mtimeMs, t.mtime),
          _o5 = _slicedToArray(_o4, 2),
          a = _o5[0],
          s = _o5[1];

      return {
        ctimeSeconds: e % i,
        ctimeNanoseconds: r % i,
        mtimeSeconds: a % i,
        mtimeNanoseconds: s % i,
        dev: t.dev % i,
        ino: t.ino % i,
        mode: n(t.mode % i),
        uid: t.uid % i,
        gid: t.gid % i,
        size: t.size > -1 ? t.size % i : 0
      };
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return n;
    });
    var n = Symbol("GitWalkerSymbol");
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return o;
    });
    var n = r(56);

    function i(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function o(t, e) {
      return a.apply(this, arguments);
    }

    function a() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_t22, e) {
        var r, _ref25, _t21, _n7;

        return regeneratorRuntime.wrap(function t$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                r = Object(n.a)(_t22);

              case 1:
                _context43.next = 3;
                return r.next();

              case 3:
                _ref25 = _context43.sent;
                _t21 = _ref25.value;
                _n7 = _ref25.done;
                _context43.t0 = _t21;

                if (!_context43.t0) {
                  _context43.next = 10;
                  break;
                }

                _context43.next = 10;
                return e(_t21);

              case 10:
                if (!_n7) {
                  _context43.next = 12;
                  break;
                }

                return _context43.abrupt("break", 14);

              case 12:
                _context43.next = 1;
                break;

              case 14:
                r.return && r.return();

              case 15:
              case "end":
                return _context43.stop();
            }
          }
        }, t);
      }), (a = function a() {
        var e = this,
            r = arguments;
        return new Promise(function (n, o) {
          var a = t.apply(e, r);

          function s(t) {
            i(a, n, o, s, u, "next", t);
          }

          function u(t) {
            i(a, n, o, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      var e = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
      return e > -1 && (t = t.slice(e + 1)), t;
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    "use strict";

    var n = r(1),
        i = r(4),
        o = r(0),
        a = r(5),
        s = r(2),
        u = r(49),
        c = r(11);

    function f(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function l(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            f(o, n, i, a, s, "next", t);
          }

          function s(t) {
            f(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    var d =
    /*#__PURE__*/
    function () {
      function d(_ref26) {
        var t = _ref26.fs,
            e = _ref26.gitdir,
            r = _ref26.ref;

        _classCallCheck(this, d);

        var a = new n.a(t);
        this.fs = a, this.gitdir = e, this.mapPromise = l(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee38() {
          var t, n, s;
          return regeneratorRuntime.wrap(function _callee38$(_context44) {
            while (1) {
              switch (_context44.prev = _context44.next) {
                case 0:
                  t = new Map();
                  _context44.prev = 1;
                  _context44.next = 4;
                  return i.a.resolve({
                    fs: a,
                    gitdir: e,
                    ref: r
                  });

                case 4:
                  n = _context44.sent;
                  _context44.next = 10;
                  break;

                case 7:
                  _context44.prev = 7;
                  _context44.t0 = _context44["catch"](1);
                  _context44.t0.code === o.a.ResolveRefError && (n = "4b825dc642cb6eb9a060e54bf8d69288fbee4904");

                case 10:
                  _context44.next = 12;
                  return Object(u.a)({
                    fs: a,
                    gitdir: e,
                    oid: n
                  });

                case 12:
                  s = _context44.sent;
                  return _context44.abrupt("return", (s.type = "tree", t.set(".", s), t));

                case 14:
                case "end":
                  return _context44.stop();
              }
            }
          }, _callee38, null, [[1, 7]]);
        }))();
        var s = this;

        this.ConstructEntry =
        /*#__PURE__*/
        function () {
          function _class2(t) {
            _classCallCheck(this, _class2);

            Object.assign(this, t);
          }

          _createClass(_class2, [{
            key: "populateStat",
            value: function populateStat() {
              var t = this;
              return l(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee39() {
                return regeneratorRuntime.wrap(function _callee39$(_context45) {
                  while (1) {
                    switch (_context45.prev = _context45.next) {
                      case 0:
                        _context45.t0 = t.exists;

                        if (!_context45.t0) {
                          _context45.next = 4;
                          break;
                        }

                        _context45.next = 4;
                        return s.populateStat(t);

                      case 4:
                      case "end":
                        return _context45.stop();
                    }
                  }
                }, _callee39);
              }))();
            }
          }, {
            key: "populateContent",
            value: function populateContent() {
              var t = this;
              return l(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee40() {
                return regeneratorRuntime.wrap(function _callee40$(_context46) {
                  while (1) {
                    switch (_context46.prev = _context46.next) {
                      case 0:
                        _context46.t0 = t.exists;

                        if (!_context46.t0) {
                          _context46.next = 4;
                          break;
                        }

                        _context46.next = 4;
                        return s.populateContent(t);

                      case 4:
                      case "end":
                        return _context46.stop();
                    }
                  }
                }, _callee40);
              }))();
            }
          }, {
            key: "populateHash",
            value: function populateHash() {
              var t = this;
              return l(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee41() {
                return regeneratorRuntime.wrap(function _callee41$(_context47) {
                  while (1) {
                    switch (_context47.prev = _context47.next) {
                      case 0:
                        _context47.t0 = t.exists;

                        if (!_context47.t0) {
                          _context47.next = 4;
                          break;
                        }

                        _context47.next = 4;
                        return s.populateHash(t);

                      case 4:
                      case "end":
                        return _context47.stop();
                    }
                  }
                }, _callee41);
              }))();
            }
          }]);

          return _class2;
        }();
      }

      _createClass(d, [{
        key: "readdir",
        value: function readdir(t) {
          var e = this;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee42() {
            var r, n, i, o, u, f, _ref27, l, d, h, _iteratorNormalCompletion20, _didIteratorError20, _iteratorError20, _iterator20, _step20, _t23;

            return regeneratorRuntime.wrap(function _callee42$(_context48) {
              while (1) {
                switch (_context48.prev = _context48.next) {
                  case 0:
                    if (t.exists) {
                      _context48.next = 2;
                      break;
                    }

                    return _context48.abrupt("return", []);

                  case 2:
                    r = t.fullpath;
                    n = e.fs;
                    i = e.gitdir;
                    _context48.next = 7;
                    return e.mapPromise;

                  case 7:
                    o = _context48.sent;
                    u = o.get(r);

                    if (u) {
                      _context48.next = 11;
                      break;
                    }

                    throw new Error("No obj for ".concat(r));

                  case 11:
                    f = u.oid;

                    if (f) {
                      _context48.next = 14;
                      break;
                    }

                    throw new Error("No oid for obj ".concat(JSON.stringify(u)));

                  case 14:
                    if (!("commit" === u.type)) {
                      _context48.next = 16;
                      break;
                    }

                    return _context48.abrupt("return", null);

                  case 16:
                    _context48.next = 18;
                    return Object(a.a)({
                      fs: n,
                      gitdir: i,
                      oid: f
                    });

                  case 18:
                    _ref27 = _context48.sent;
                    l = _ref27.type;
                    d = _ref27.object;

                    if (!("blob" === l)) {
                      _context48.next = 23;
                      break;
                    }

                    return _context48.abrupt("return", null);

                  case 23:
                    if (!("tree" !== l)) {
                      _context48.next = 25;
                      break;
                    }

                    throw new Error("ENOTDIR: not a directory, scandir '".concat(r, "'"));

                  case 25:
                    h = c.a.from(d);
                    _iteratorNormalCompletion20 = true;
                    _didIteratorError20 = false;
                    _iteratorError20 = undefined;
                    _context48.prev = 29;

                    for (_iterator20 = h[Symbol.iterator](); !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                      _t23 = _step20.value;
                      o.set(Object(s.a)(r, _t23.path), _t23);
                    }

                    _context48.next = 37;
                    break;

                  case 33:
                    _context48.prev = 33;
                    _context48.t0 = _context48["catch"](29);
                    _didIteratorError20 = true;
                    _iteratorError20 = _context48.t0;

                  case 37:
                    _context48.prev = 37;
                    _context48.prev = 38;

                    if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
                      _iterator20.return();
                    }

                  case 40:
                    _context48.prev = 40;

                    if (!_didIteratorError20) {
                      _context48.next = 43;
                      break;
                    }

                    throw _iteratorError20;

                  case 43:
                    return _context48.finish(40);

                  case 44:
                    return _context48.finish(37);

                  case 45:
                    return _context48.abrupt("return", h.entries().map(function (t) {
                      return {
                        fullpath: Object(s.a)(r, t.path),
                        basename: t.path,
                        exists: !0
                      };
                    }));

                  case 46:
                  case "end":
                    return _context48.stop();
                }
              }
            }, _callee42, null, [[29, 33, 37, 45], [38,, 40, 44]]);
          }))();
        }
      }, {
        key: "populateStat",
        value: function populateStat(t) {
          var e = this;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee43() {
            var r, n, i;
            return regeneratorRuntime.wrap(function _callee43$(_context49) {
              while (1) {
                switch (_context49.prev = _context49.next) {
                  case 0:
                    _context49.next = 2;
                    return e.mapPromise;

                  case 2:
                    _context49.t0 = t.fullpath;
                    r = _context49.sent.get(_context49.t0);

                    if (r) {
                      _context49.next = 6;
                      break;
                    }

                    throw new Error("ENOENT: no such file or directory, lstat '".concat(t.fullpath, "'"));

                  case 6:
                    n = r.mode, i = r.type;
                    Object.assign(t, {
                      mode: n,
                      type: i
                    });

                  case 8:
                  case "end":
                    return _context49.stop();
                }
              }
            }, _callee43);
          }))();
        }
      }, {
        key: "populateContent",
        value: function populateContent(t) {
          var e = this;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee44() {
            var r, n, i, o, s, _ref28, u, c;

            return regeneratorRuntime.wrap(function _callee44$(_context50) {
              while (1) {
                switch (_context50.prev = _context50.next) {
                  case 0:
                    _context50.next = 2;
                    return e.mapPromise;

                  case 2:
                    r = _context50.sent;
                    n = e.fs;
                    i = e.gitdir;
                    o = r.get(t.fullpath);

                    if (o) {
                      _context50.next = 8;
                      break;
                    }

                    throw new Error("No obj for ".concat(t.fullpath));

                  case 8:
                    s = o.oid;

                    if (s) {
                      _context50.next = 11;
                      break;
                    }

                    throw new Error("No oid for entry ".concat(JSON.stringify(o)));

                  case 11:
                    _context50.next = 13;
                    return Object(a.a)({
                      fs: n,
                      gitdir: i,
                      oid: s
                    });

                  case 13:
                    _ref28 = _context50.sent;
                    u = _ref28.type;
                    c = _ref28.object;

                    if (!("tree" === u)) {
                      _context50.next = 18;
                      break;
                    }

                    throw new Error("EISDIR: illegal operation on a directory, read");

                  case 18:
                    Object.assign(t, {
                      content: c
                    });

                  case 19:
                  case "end":
                    return _context50.stop();
                }
              }
            }, _callee44);
          }))();
        }
      }, {
        key: "populateHash",
        value: function populateHash(t) {
          var e = this;
          return l(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee45() {
            var r, n;
            return regeneratorRuntime.wrap(function _callee45$(_context51) {
              while (1) {
                switch (_context51.prev = _context51.next) {
                  case 0:
                    _context51.next = 2;
                    return e.mapPromise;

                  case 2:
                    _context51.t0 = t.fullpath;
                    r = _context51.sent.get(_context51.t0);

                    if (r) {
                      _context51.next = 6;
                      break;
                    }

                    throw new Error("ENOENT: no such file or directory, open '".concat(t.fullpath, "'"));

                  case 6:
                    n = r.oid;
                    Object.assign(t, {
                      oid: n
                    });

                  case 8:
                  case "end":
                    return _context51.stop();
                }
              }
            }, _callee45);
          }))();
        }
      }]);

      return d;
    }();

    var h = r(3),
        p = r(26);

    function g(_ref29) {
      var _ref29$core = _ref29.core,
          t = _ref29$core === void 0 ? "default" : _ref29$core,
          e = _ref29.dir,
          _ref29$gitdir = _ref29.gitdir,
          r = _ref29$gitdir === void 0 ? Object(s.a)(e, ".git") : _ref29$gitdir,
          _ref29$fs = _ref29.fs,
          i = _ref29$fs === void 0 ? h.a.get(t).get("fs") : _ref29$fs,
          _ref29$ref = _ref29.ref,
          o = _ref29$ref === void 0 ? "HEAD" : _ref29$ref;
      var a = new n.a(i),
          u = Object.create(null);
      return Object.defineProperty(u, p.a, {
        value: function value() {
          return new d({
            fs: a,
            gitdir: r,
            ref: o
          });
        }
      }), Object.freeze(u), u;
    }

    r.d(e, "a", function () {
      return g;
    });
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return f;
    });
    var n = r(42),
        i = r.n(n),
        o = r(1),
        a = r(2);

    function s(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function u(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            s(o, n, i, a, u, "next", t);
          }

          function u(t) {
            s(o, n, i, a, u, "throw", t);
          }

          a(void 0);
        });
      };
    }

    var c = null;

    var f =
    /*#__PURE__*/
    function () {
      function f() {
        _classCallCheck(this, f);
      }

      _createClass(f, null, [{
        key: "read",
        value: function read(_ref30) {
          var t = _ref30.fs,
              e = _ref30.gitdir;
          return u(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee47() {
            var r, n, s;
            return regeneratorRuntime.wrap(function _callee47$(_context53) {
              while (1) {
                switch (_context53.prev = _context53.next) {
                  case 0:
                    r = new o.a(t);
                    null === c && (c = new i.a());
                    n = Object(a.a)(e, "shallow"), s = new Set();
                    _context53.next = 5;
                    return c.acquire(n, u(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee46() {
                      var t;
                      return regeneratorRuntime.wrap(function _callee46$(_context52) {
                        while (1) {
                          switch (_context52.prev = _context52.next) {
                            case 0:
                              _context52.next = 2;
                              return r.read(n, {
                                encoding: "utf8"
                              });

                            case 2:
                              t = _context52.sent;
                              return _context52.abrupt("return", null === t ? s : "" === t.trim() ? s : void t.trim().split("\n").map(function (t) {
                                return s.add(t);
                              }));

                            case 4:
                            case "end":
                              return _context52.stop();
                          }
                        }
                      }, _callee46);
                    })));

                  case 5:
                    return _context53.abrupt("return", s);

                  case 6:
                  case "end":
                    return _context53.stop();
                }
              }
            }, _callee47);
          }))();
        }
      }, {
        key: "write",
        value: function write(_ref31) {
          var t = _ref31.fs,
              e = _ref31.gitdir,
              r = _ref31.oids;
          return u(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee50() {
            var n, s, _t24;

            return regeneratorRuntime.wrap(function _callee50$(_context56) {
              while (1) {
                switch (_context56.prev = _context56.next) {
                  case 0:
                    n = new o.a(t);
                    null === c && (c = new i.a());
                    s = Object(a.a)(e, "shallow");

                    if (!(r.size > 0)) {
                      _context56.next = 9;
                      break;
                    }

                    _t24 = _toConsumableArray(r).join("\n") + "\n";
                    _context56.next = 7;
                    return c.acquire(s, u(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee48() {
                      return regeneratorRuntime.wrap(function _callee48$(_context54) {
                        while (1) {
                          switch (_context54.prev = _context54.next) {
                            case 0:
                              _context54.next = 2;
                              return n.write(s, _t24, {
                                encoding: "utf8"
                              });

                            case 2:
                            case "end":
                              return _context54.stop();
                          }
                        }
                      }, _callee48);
                    })));

                  case 7:
                    _context56.next = 11;
                    break;

                  case 9:
                    _context56.next = 11;
                    return c.acquire(s, u(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee49() {
                      return regeneratorRuntime.wrap(function _callee49$(_context55) {
                        while (1) {
                          switch (_context55.prev = _context55.next) {
                            case 0:
                              _context55.next = 2;
                              return n.rm(s);

                            case 2:
                            case "end":
                              return _context55.stop();
                          }
                        }
                      }, _callee49);
                    })));

                  case 11:
                  case "end":
                    return _context56.stop();
                }
              }
            }, _callee50);
          }))();
        }
      }]);

      return f;
    }();
  }, function (t, e, r) {
    var n = r(102),
        i = r(103),
        o = r(73).Buffer,
        a = [1518500249, 1859775393, -1894007588, -899497514],
        s = new Array(80);

    function u() {
      this.init(), this._w = s, i.call(this, 64, 56);
    }

    function c(t) {
      return t << 5 | t >>> 27;
    }

    function f(t) {
      return t << 30 | t >>> 2;
    }

    function l(t, e, r, n) {
      return 0 === t ? e & r | ~e & n : 2 === t ? e & r | e & n | r & n : e ^ r ^ n;
    }

    n(u, i), u.prototype.init = function () {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    }, u.prototype._update = function (t) {
      for (var e, r = this._w, n = 0 | this._a, i = 0 | this._b, o = 0 | this._c, s = 0 | this._d, u = 0 | this._e, d = 0; d < 16; ++d) {
        r[d] = t.readInt32BE(4 * d);
      }

      for (; d < 80; ++d) {
        r[d] = (e = r[d - 3] ^ r[d - 8] ^ r[d - 14] ^ r[d - 16]) << 1 | e >>> 31;
      }

      for (var h = 0; h < 80; ++h) {
        var p = ~~(h / 20),
            g = c(n) + l(p, i, o, s) + u + r[h] + a[p] | 0;
        u = s, s = o, o = f(i), i = n, n = g;
      }

      this._a = n + this._a | 0, this._b = i + this._b | 0, this._c = o + this._c | 0, this._d = s + this._d | 0, this._e = u + this._e | 0;
    }, u.prototype._hash = function () {
      var t = o.allocUnsafe(20);
      return t.writeInt32BE(0 | this._a, 0), t.writeInt32BE(0 | this._b, 4), t.writeInt32BE(0 | this._c, 8), t.writeInt32BE(0 | this._d, 12), t.writeInt32BE(0 | this._e, 16), t;
    }, t.exports = u;
  }, function (t, e, r) {
    "use strict";

    function n(t, e) {
      var r = e.toString(16);
      return "0".repeat(t - r.length) + r;
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      var _t$match = t.match(/^(.*) <(.*)> (.*) (.*)$/),
          _t$match2 = _slicedToArray(_t$match, 5),
          e = _t$match2[1],
          r = _t$match2[2],
          n = _t$match2[3],
          o = _t$match2[4];

      return {
        name: e,
        email: r,
        timestamp: Number(n),
        timezoneOffset: i(o)
      };
    }

    function i(t) {
      var _t$match3 = t.match(/(\+|-)(\d\d)(\d\d)/),
          _t$match4 = _slicedToArray(_t$match3, 4),
          e = _t$match4[1],
          r = _t$match4[2],
          n = _t$match4[3];

      return n = ("+" === e ? 1 : -1) * (60 * Number(r) + Number(n)), 0 === (i = n) ? i : -i;
      var i;
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      return t.trim().split("\n").map(function (t) {
        return " " + t;
      }).join("\n") + "\n";
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return o;
      });
      var n = r(27);

      function i(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function o(t) {
        return a.apply(this, arguments);
      }

      function a() {
        var e;
        return e =
        /*#__PURE__*/
        regeneratorRuntime.mark(function e(_e13) {
          var r;
          return regeneratorRuntime.wrap(function e$(_context57) {
            while (1) {
              switch (_context57.prev = _context57.next) {
                case 0:
                  r = [];
                  _context57.next = 3;
                  return Object(n.a)(_e13, function (e) {
                    return r.push(t.from(e));
                  });

                case 3:
                  return _context57.abrupt("return", t.concat(r));

                case 4:
                case "end":
                  return _context57.stop();
              }
            }
          }, e);
        }), (a = function a() {
          var t = this,
              r = arguments;
          return new Promise(function (n, o) {
            var a = e.apply(t, r);

            function s(t) {
              i(a, n, o, s, u, "next", t);
            }

            function u(t) {
              i(a, n, o, s, u, "throw", t);
            }

            s(void 0);
          });
        }).apply(this, arguments);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    function n(t, e, r) {
      return e = e instanceof RegExp ? e : new RegExp(e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), t.replace(e, r);
    }

    var i = {
      clean: function clean(t) {
        if ("string" != typeof t) throw new Error("Expected a string, received: " + t);
        return t = n(t, "./", "/"), t = n(t, "..", "."), t = n(t, " ", "-"), t = n(t, /^[~^:?*\\\-]/g, ""), t = n(t, /[~^:?*\\]/g, "-"), t = n(t, /[~^:?*\\\-]$/g, ""), t = n(t, "@{", "-"), t = n(t, /\.$/g, ""), t = n(t, /\/$/g, ""), t = n(t, /\.lock$/g, "");
      }
    };
    t.exports = i;
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return i;
    });
    var n = r(40);

    function i(t, e) {
      return Object(n.a)(t.path, e.path);
    }
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return v;
      });
      var n = r(92),
          i = r.n(n),
          o = r(93),
          a = r.n(o),
          s = r(6),
          u = r(18),
          c = r.n(u),
          f = r(0),
          l = r(19),
          d = r(94),
          h = r(8),
          p = r(12),
          g = r(17);

      function m(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function y(t) {
        return function () {
          var e = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = t.apply(e, r);

            function a(t) {
              m(o, n, i, a, s, "next", t);
            }

            function s(t) {
              m(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        };
      }

      var v =
      /*#__PURE__*/
      function () {
        function v(t) {
          _classCallCheck(this, v);

          Object.assign(this, t), this.offsetCache = {};
        }

        _createClass(v, [{
          key: "toBuffer",
          value: function toBuffer() {
            var e = [],
                r = function r(_r15, n) {
              e.push(t.from(_r15, n));
            };

            r("ff744f63", "hex"), r("00000002", "hex");
            var n = new l.a(t.alloc(1024));

            for (var _t25 = 0; _t25 < 256; _t25++) {
              var _e14 = 0;
              var _iteratorNormalCompletion21 = true;
              var _didIteratorError21 = false;
              var _iteratorError21 = undefined;

              try {
                for (var _iterator21 = this.hashes[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                  var _r16 = _step21.value;
                  parseInt(_r16.slice(0, 2), 16) <= _t25 && _e14++;
                }
              } catch (err) {
                _didIteratorError21 = true;
                _iteratorError21 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion21 && _iterator21.return != null) {
                    _iterator21.return();
                  }
                } finally {
                  if (_didIteratorError21) {
                    throw _iteratorError21;
                  }
                }
              }

              n.writeUInt32BE(_e14);
            }

            e.push(n.buffer);
            var _iteratorNormalCompletion22 = true;
            var _didIteratorError22 = false;
            var _iteratorError22 = undefined;

            try {
              for (var _iterator22 = this.hashes[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var _t26 = _step22.value;
                r(_t26, "hex");
              }
            } catch (err) {
              _didIteratorError22 = true;
              _iteratorError22 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                  _iterator22.return();
                }
              } finally {
                if (_didIteratorError22) {
                  throw _iteratorError22;
                }
              }
            }

            var i = new l.a(t.alloc(4 * this.hashes.length));
            var _iteratorNormalCompletion23 = true;
            var _didIteratorError23 = false;
            var _iteratorError23 = undefined;

            try {
              for (var _iterator23 = this.hashes[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                var _t27 = _step23.value;
                i.writeUInt32BE(this.crcs[_t27]);
              }
            } catch (err) {
              _didIteratorError23 = true;
              _iteratorError23 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion23 && _iterator23.return != null) {
                  _iterator23.return();
                }
              } finally {
                if (_didIteratorError23) {
                  throw _iteratorError23;
                }
              }
            }

            e.push(i.buffer);
            var o = new l.a(t.alloc(4 * this.hashes.length));
            var _iteratorNormalCompletion24 = true;
            var _didIteratorError24 = false;
            var _iteratorError24 = undefined;

            try {
              for (var _iterator24 = this.hashes[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                var _t28 = _step24.value;
                o.writeUInt32BE(this.offsets.get(_t28));
              }
            } catch (err) {
              _didIteratorError24 = true;
              _iteratorError24 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion24 && _iterator24.return != null) {
                  _iterator24.return();
                }
              } finally {
                if (_didIteratorError24) {
                  throw _iteratorError24;
                }
              }
            }

            e.push(o.buffer), r(this.packfileSha, "hex");
            var a = t.concat(e),
                s = Object(p.a)(a),
                u = t.alloc(20);
            return u.write(s, "hex"), t.concat([a, u]);
          }
        }, {
          key: "load",
          value: function load(_ref32) {
            var t = _ref32.pack;
            var e = this;
            return y(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee51() {
              return regeneratorRuntime.wrap(function _callee51$(_context58) {
                while (1) {
                  switch (_context58.prev = _context58.next) {
                    case 0:
                      e.pack = t;

                    case 1:
                    case "end":
                      return _context58.stop();
                  }
                }
              }, _callee51);
            }))();
          }
        }, {
          key: "unload",
          value: function unload() {
            var t = this;
            return y(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee52() {
              return regeneratorRuntime.wrap(function _callee52$(_context59) {
                while (1) {
                  switch (_context59.prev = _context59.next) {
                    case 0:
                      t.pack = null;

                    case 1:
                    case "end":
                      return _context59.stop();
                  }
                }
              }, _callee52);
            }))();
          }
        }, {
          key: "read",
          value: function read(_ref33) {
            var t = _ref33.oid;
            var e = this;
            return y(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee53() {
              var r;
              return regeneratorRuntime.wrap(function _callee53$(_context60) {
                while (1) {
                  switch (_context60.prev = _context60.next) {
                    case 0:
                      if (e.offsets.get(t)) {
                        _context60.next = 4;
                        break;
                      }

                      if (!e.getExternalRefDelta) {
                        _context60.next = 3;
                        break;
                      }

                      return _context60.abrupt("return", (e.externalReadDepth++, e.getExternalRefDelta(t)));

                    case 3:
                      throw new f.b(f.a.InternalFail, {
                        message: "Could not read object ".concat(t, " from packfile")
                      });

                    case 4:
                      r = e.offsets.get(t);
                      return _context60.abrupt("return", e.readSlice({
                        start: r
                      }));

                    case 6:
                    case "end":
                      return _context60.stop();
                  }
                }
              }, _callee53);
            }))();
          }
        }, {
          key: "readSlice",
          value: function readSlice(_ref34) {
            var e = _ref34.start;
            var r = this;
            return y(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee54() {
              var n, i, o, s, u, d, h, p, g, _t29, _n8, _ref35, _t30, _ref36, m;

              return regeneratorRuntime.wrap(function _callee54$(_context61) {
                while (1) {
                  switch (_context61.prev = _context61.next) {
                    case 0:
                      if (!r.offsetCache[e]) {
                        _context61.next = 2;
                        break;
                      }

                      return _context61.abrupt("return", Object.assign({}, r.offsetCache[e]));

                    case 2:
                      r.readDepth++;

                      if (r.pack) {
                        _context61.next = 5;
                        break;
                      }

                      throw new f.b(f.a.InternalFail, {
                        message: "Tried to read from a GitPackIndex with no packfile loaded into memory"
                      });

                    case 5:
                      _context61.next = 7;
                      return r.pack;

                    case 7:
                      _context61.t0 = e;
                      n = _context61.sent.slice(_context61.t0);
                      i = new l.a(n);
                      o = i.readUInt8();
                      s = 112 & o;
                      u = {
                        16: "commit",
                        32: "tree",
                        48: "blob",
                        64: "tag",
                        96: "ofs_delta",
                        112: "ref_delta"
                      }[s];

                      if (!(void 0 === u)) {
                        _context61.next = 15;
                        break;
                      }

                      throw new f.b(f.a.InternalFail, {
                        message: "Unrecognized type: 0b" + s.toString(2)
                      });

                    case 15:
                      d = 15 & o;
                      h = d;
                      128 & o && (h = function (t, e) {
                        var r = e,
                            n = 4,
                            i = null;

                        do {
                          r |= (127 & (i = t.readUInt8())) << n, n += 7;
                        } while (128 & i);

                        return r;
                      }(i, d));
                      p = null, g = null;

                      if (!("ofs_delta" === u)) {
                        _context61.next = 26;
                        break;
                      }

                      _t29 = function (t) {
                        var e = [];
                        var r = 0,
                            n = 0;

                        do {
                          var _i7 = 127 & (r = t.readUInt8());

                          e.push(_i7), n = 128 & r;
                        } while (n);

                        return e.reduce(function (t, e) {
                          return t + 1 << 7 | e;
                        }, -1);
                      }(i), _n8 = e - _t29;
                      _context61.next = 23;
                      return r.readSlice({
                        start: _n8
                      });

                    case 23:
                      _ref35 = _context61.sent;
                      p = _ref35.object;
                      u = _ref35.type;

                    case 26:
                      if (!("ref_delta" === u)) {
                        _context61.next = 33;
                        break;
                      }

                      _t30 = i.slice(20).toString("hex");
                      _context61.next = 30;
                      return r.read({
                        oid: _t30
                      });

                    case 30:
                      _ref36 = _context61.sent;
                      p = _ref36.object;
                      u = _ref36.type;

                    case 33:
                      m = n.slice(i.tell());

                      if (!((g = t.from(c.a.inflate(m))).byteLength !== h)) {
                        _context61.next = 36;
                        break;
                      }

                      throw new f.b(f.a.InternalFail, {
                        message: "Packfile told us object would have length ".concat(h, " but it had length ").concat(g.byteLength)
                      });

                    case 36:
                      return _context61.abrupt("return", (p && (g = t.from(a()(g, p))), r.readDepth > 3 && (r.offsetCache[e] = {
                        type: u,
                        object: g
                      }), {
                        type: u,
                        format: "content",
                        object: g
                      }));

                    case 37:
                    case "end":
                      return _context61.stop();
                  }
                }
              }, _callee54);
            }))();
          }
        }], [{
          key: "fromIdx",
          value: function fromIdx(_ref37) {
            var t = _ref37.idx,
                e = _ref37.getExternalRefDelta;
            return y(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee55() {
              var r, n, i, o, _t31, _e15, a, _t32, u;

              return regeneratorRuntime.wrap(function _callee55$(_context62) {
                while (1) {
                  switch (_context62.prev = _context62.next) {
                    case 0:
                      s.a("fromIdx");
                      r = new l.a(t);

                      if (!("ff744f63" !== r.slice(4).toString("hex"))) {
                        _context62.next = 4;
                        break;
                      }

                      return _context62.abrupt("return");

                    case 4:
                      n = r.readUInt32BE();

                      if (!(2 !== n)) {
                        _context62.next = 7;
                        break;
                      }

                      throw new f.b(f.a.InternalFail, {
                        message: "Unable to read version ".concat(n, " packfile IDX. (Only version 2 supported)")
                      });

                    case 7:
                      if (!(t.byteLength > 2147483648)) {
                        _context62.next = 9;
                        break;
                      }

                      throw new f.b(f.a.InternalFail, {
                        message: "To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size."
                      });

                    case 9:
                      r.seek(r.tell() + 1020);
                      i = r.readUInt32BE();
                      s.a("hashes");
                      o = [];

                      for (_t31 = 0; _t31 < i; _t31++) {
                        _e15 = r.slice(20).toString("hex");
                        o[_t31] = _e15;
                      }

                      Object(h.a)("hashes ".concat(s.b("hashes").duration)), r.seek(r.tell() + 4 * i), s.a("offsets");
                      a = new Map();

                      for (_t32 = 0; _t32 < i; _t32++) {
                        a.set(o[_t32], r.readUInt32BE());
                      }

                      Object(h.a)("offsets ".concat(s.b("offsets").duration));
                      u = r.slice(20).toString("hex");
                      return _context62.abrupt("return", (Object(h.a)("fromIdx ".concat(s.b("fromIdx").duration)), new v({
                        hashes: o,
                        crcs: {},
                        offsets: a,
                        packfileSha: u,
                        getExternalRefDelta: e
                      })));

                    case 20:
                    case "end":
                      return _context62.stop();
                  }
                }
              }, _callee55);
            }))();
          }
        }, {
          key: "fromPack",
          value: function fromPack(_ref38) {
            var t = _ref38.pack,
                e = _ref38.getExternalRefDelta,
                r = _ref38.emitter,
                n = _ref38.emitterPrefix;
            return y(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee56() {
              var o, a, u, c, f, l, m, y, w, b, _, x, _iteratorNormalCompletion25, _didIteratorError25, _iteratorError25, _iterator25, _step25, _step25$value, _e18, _r18, _n10, _o7, _s3, E, k, O, j, P, S, _t33, _e16, _i8, _ref40, _e17, _r17, _n9, _o6, R;

              return regeneratorRuntime.wrap(function _callee56$(_context63) {
                while (1) {
                  switch (_context63.prev = _context63.next) {
                    case 0:
                      o = {
                        1: "commit",
                        2: "tree",
                        3: "blob",
                        4: "tag",
                        6: "ofs-delta",
                        7: "ref-delta"
                      }, a = {}, u = t.slice(-20).toString("hex"), c = [], f = {}, l = new Map();
                      m = null, y = null;
                      w = {
                        hash: 0,
                        readSlice: 0,
                        offsets: 0,
                        crcs: 0,
                        sort: 0
                      };
                      b = {
                        commit: 0,
                        tree: 0,
                        blob: 0,
                        tag: 0,
                        "ofs-delta": 0,
                        "ref-delta": 0
                      }, _ = 0;
                      Object(h.a)("Indexing objects");
                      Object(h.a)("percent\tmilliseconds\tbytesProcessed\tcommits\ttrees\tblobs\ttags\tofs-deltas\tref-deltas");
                      s.a("total");
                      s.a("offsets");
                      s.a("percent");
                      _context63.next = 11;
                      return Object(d.a)([t], function (_ref39) {
                        var t = _ref39.data,
                            e = _ref39.type,
                            i = _ref39.reference,
                            u = _ref39.offset,
                            c = _ref39.num;
                        null === m && (m = c);
                        var f = Math.floor(100 * (m - c) / m);
                        f !== y && (r && r.emit("".concat(n, "progress"), {
                          phase: "Receiving objects",
                          loaded: m - c,
                          total: m,
                          lengthComputable: !0
                        }), Object(h.a)("".concat(f, "%\t").concat(Math.floor(s.b("percent").duration), "\t").concat(_, "\t").concat(b.commit, "\t").concat(b.tree, "\t").concat(b.blob, "\t").concat(b.tag, "\t").concat(b["ofs-delta"], "\t").concat(b["ref-delta"])), b = {
                          commit: 0,
                          tree: 0,
                          blob: 0,
                          tag: 0,
                          "ofs-delta": 0,
                          "ref-delta": 0
                        }, _ = 0, s.a("percent")), y = f, b[e = o[e]]++, _ += t.byteLength, ["commit", "tree", "blob", "tag"].includes(e) ? a[u] = {
                          type: e,
                          offset: u
                        } : "ofs-delta" === e ? a[u] = {
                          type: e,
                          offset: u
                        } : "ref-delta" === e && (a[u] = {
                          type: e,
                          offset: u
                        });
                      });

                    case 11:
                      w.offsets = Math.floor(s.b("offsets").duration);
                      Object(h.a)("Computing CRCs");
                      s.a("crcs");
                      x = Object.keys(a).map(Number);
                      _iteratorNormalCompletion25 = true;
                      _didIteratorError25 = false;
                      _iteratorError25 = undefined;
                      _context63.prev = 18;

                      for (_iterator25 = x.entries()[Symbol.iterator](); !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                        _step25$value = _slicedToArray(_step25.value, 2), _e18 = _step25$value[0], _r18 = _step25$value[1];
                        _n10 = _e18 + 1 === x.length ? t.byteLength - 20 : x[_e18 + 1], _o7 = a[_r18], _s3 = i.a.buf(t.slice(_r18, _n10)) >>> 0;
                        _o7.end = _n10, _o7.crc = _s3;
                      }

                      _context63.next = 26;
                      break;

                    case 22:
                      _context63.prev = 22;
                      _context63.t0 = _context63["catch"](18);
                      _didIteratorError25 = true;
                      _iteratorError25 = _context63.t0;

                    case 26:
                      _context63.prev = 26;
                      _context63.prev = 27;

                      if (!_iteratorNormalCompletion25 && _iterator25.return != null) {
                        _iterator25.return();
                      }

                    case 29:
                      _context63.prev = 29;

                      if (!_didIteratorError25) {
                        _context63.next = 32;
                        break;
                      }

                      throw _iteratorError25;

                    case 32:
                      return _context63.finish(29);

                    case 33:
                      return _context63.finish(26);

                    case 34:
                      w.crcs = Math.floor(s.b("crcs").duration);
                      E = new v({
                        pack: Promise.resolve(t),
                        packfileSha: u,
                        crcs: f,
                        hashes: c,
                        offsets: l,
                        getExternalRefDelta: e
                      });
                      Object(h.a)("Resolving deltas"), Object(h.a)("percent2\tmilliseconds2\tcallsToReadSlice\tcallsToGetExternal"), s.a("percent"), y = null;
                      k = 0, O = 0, j = 0;
                      P = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                      _context63.t1 = regeneratorRuntime.keys(a);

                    case 40:
                      if ((_context63.t2 = _context63.t1()).done) {
                        _context63.next = 66;
                        break;
                      }

                      _t33 = _context63.t2.value;
                      _t33 = Number(_t33);
                      _e16 = Math.floor(100 * k++ / m);
                      _e16 !== y && (Object(h.a)("".concat(_e16, "%\t").concat(Math.floor(s.b("percent").duration), "\t").concat(O, "\t").concat(j)), r && r.emit("".concat(n, "progress"), {
                        phase: "Resolving deltas",
                        loaded: k,
                        total: m,
                        lengthComputable: !0
                      }), s.a("percent"), O = 0, j = 0), y = _e16;
                      _i8 = a[_t33];

                      if (_i8.oid) {
                        _context63.next = 64;
                        break;
                      }

                      _context63.prev = 47;
                      E.readDepth = 0, E.externalReadDepth = 0, s.a("readSlice");
                      _context63.next = 51;
                      return E.readSlice({
                        start: _t33
                      });

                    case 51:
                      _ref40 = _context63.sent;
                      _e17 = _ref40.type;
                      _r17 = _ref40.object;
                      _n9 = s.b("readSlice").duration;
                      w.readSlice += _n9, O += E.readDepth, j += E.externalReadDepth, P[E.readDepth] += _n9, S[E.readDepth] += 1, s.a("hash");
                      _o6 = Object(p.a)(g.a.wrap({
                        type: _e17,
                        object: _r17
                      }));
                      w.hash += s.b("hash").duration, _i8.oid = _o6, c.push(_o6), l.set(_o6, _t33), f[_o6] = _i8.crc;
                      _context63.next = 64;
                      break;

                    case 60:
                      _context63.prev = 60;
                      _context63.t3 = _context63["catch"](47);
                      Object(h.a)("ERROR", _context63.t3);
                      return _context63.abrupt("continue", 40);

                    case 64:
                      _context63.next = 40;
                      break;

                    case 66:
                      s.a("sort"), c.sort(), w.sort = Math.floor(s.b("sort").duration);
                      R = s.b("total").duration;
                      return _context63.abrupt("return", (w.hash = Math.floor(w.hash), w.readSlice = Math.floor(w.readSlice), w.misc = Math.floor(Object.values(w).reduce(function (t, e) {
                        return t - e;
                      }, R)), Object(h.a)(Object.keys(w).join("\t")), Object(h.a)(Object.values(w).join("\t")), Object(h.a)("by depth:"), Object(h.a)([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].join("\t")), Object(h.a)(S.slice(0, 12).join("\t")), Object(h.a)(P.map(Math.floor).slice(0, 12).join("\t")), E));

                    case 69:
                    case "end":
                      return _context63.stop();
                  }
                }
              }, _callee56, null, [[18, 22, 26, 34], [27,, 29, 33], [47, 60]]);
            }))();
          }
        }]);

        return v;
      }();
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    var _marked =
    /*#__PURE__*/
    regeneratorRuntime.mark(s);

    var n = void 0 === Array.prototype.flat ? function (t) {
      return t.reduce(function (t, e) {
        return t.concat(e);
      }, []);
    } : function (t) {
      return t.flat();
    };
    var i = r(26);

    var o =
    /*#__PURE__*/
    function () {
      function o() {
        _classCallCheck(this, o);

        this.value = null;
      }

      _createClass(o, [{
        key: "consider",
        value: function consider(t) {
          null != t && (null === this.value ? this.value = t : t < this.value && (this.value = t));
        }
      }, {
        key: "reset",
        value: function reset() {
          this.value = null;
        }
      }]);

      return o;
    }();

    var a = r(28);

    function s(t) {
      var e, r, n, i, _r19, _o8, _s4;

      return regeneratorRuntime.wrap(function s$(_context64) {
        while (1) {
          switch (_context64.prev = _context64.next) {
            case 0:
              e = new o();
              n = [], i = t.length;

              for (_r19 = 0; _r19 < i; _r19++) {
                n[_r19] = t[_r19].next().value, void 0 !== n[_r19] && e.consider(n[_r19].fullpath);
              }

              if (!(null !== e.value)) {
                _context64.next = 13;
                break;
              }

            case 4:
              _o8 = [];
              r = e.value, e.reset();

              for (_s4 = 0; _s4 < i; _s4++) {
                void 0 !== n[_s4] && n[_s4].fullpath === r ? (_o8[_s4] = n[_s4], n[_s4] = t[_s4].next().value) : _o8[_s4] = {
                  fullpath: r,
                  basename: Object(a.a)(r),
                  exists: !1
                }, void 0 !== n[_s4] && e.consider(n[_s4].fullpath);
              }

              _context64.next = 9;
              return _o8;

            case 9:
              if (!(null === e.value)) {
                _context64.next = 11;
                break;
              }

              return _context64.abrupt("return");

            case 11:
              _context64.next = 4;
              break;

            case 13:
            case "end":
              return _context64.stop();
          }
        }
      }, _marked);
    }

    function u(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function c(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            u(o, n, i, a, s, "next", t);
          }

          function s(t) {
            u(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function f(t) {
      return l.apply(this, arguments);
    }

    function l() {
      return (l = c(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee62(_ref41) {
        var t, _ref41$filter, e, _ref41$map, r, _ref41$reduce, o, _ref41$iterate, a, _n11, _u, _f, _l, d;

        return regeneratorRuntime.wrap(function _callee62$(_context70) {
          while (1) {
            switch (_context70.prev = _context70.next) {
              case 0:
                t = _ref41.trees, _ref41$filter = _ref41.filter, e = _ref41$filter === void 0 ? c(
                /*#__PURE__*/
                regeneratorRuntime.mark(function _callee57() {
                  return regeneratorRuntime.wrap(function _callee57$(_context65) {
                    while (1) {
                      switch (_context65.prev = _context65.next) {
                        case 0:
                          return _context65.abrupt("return", !0);

                        case 1:
                        case "end":
                          return _context65.stop();
                      }
                    }
                  }, _callee57);
                })) : _ref41$filter, _ref41$map = _ref41.map, r = _ref41$map === void 0 ? function () {
                  var t = c(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee58(t) {
                    return regeneratorRuntime.wrap(function _callee58$(_context66) {
                      while (1) {
                        switch (_context66.prev = _context66.next) {
                          case 0:
                            return _context66.abrupt("return", t);

                          case 1:
                          case "end":
                            return _context66.stop();
                        }
                      }
                    }, _callee58);
                  }));
                  return function (e) {
                    return t.apply(this, arguments);
                  };
                }() : _ref41$map, _ref41$reduce = _ref41.reduce, o = _ref41$reduce === void 0 ? function () {
                  var t = c(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee59(t, e) {
                    var r;
                    return regeneratorRuntime.wrap(function _callee59$(_context67) {
                      while (1) {
                        switch (_context67.prev = _context67.next) {
                          case 0:
                            r = n(e);
                            return _context67.abrupt("return", (void 0 !== t && r.unshift(t), r));

                          case 2:
                          case "end":
                            return _context67.stop();
                        }
                      }
                    }, _callee59);
                  }));
                  return function (e, r) {
                    return t.apply(this, arguments);
                  };
                }() : _ref41$reduce, _ref41$iterate = _ref41.iterate, a = _ref41$iterate === void 0 ? function (t, e) {
                  return Promise.all(_toConsumableArray(e).map(t));
                } : _ref41$iterate;
                _context70.prev = 1;
                _n11 = t.map(function (t) {
                  return t[i.a]();
                }), _u = new Array(_n11.length).fill({
                  fullpath: ".",
                  basename: ".",
                  exists: !0
                }), _f = function (t, e) {
                  var r = e - t;
                  return Array.from({
                    length: r
                  }, function (e, r) {
                    return t + r;
                  });
                }(0, _n11.length), _l = function () {
                  var t = c(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee60(t) {
                    var e, r;
                    return regeneratorRuntime.wrap(function _callee60$(_context68) {
                      while (1) {
                        switch (_context68.prev = _context68.next) {
                          case 0:
                            _context68.next = 2;
                            return Promise.all(_f.map(function (e) {
                              return _n11[e].readdir(t[e]);
                            }));

                          case 2:
                            e = _context68.sent;

                            _f.map(function (e) {
                              t[e] = new _n11[e].ConstructEntry(t[e]);
                            });

                            r = e.map(function (t) {
                              return null === t ? [] : t;
                            }).map(function (t) {
                              return t[Symbol.iterator]();
                            });
                            return _context68.abrupt("return", {
                              entry: t,
                              children: s(r)
                            });

                          case 6:
                          case "end":
                            return _context68.stop();
                        }
                      }
                    }, _callee60);
                  }));
                  return function (e) {
                    return t.apply(this, arguments);
                  };
                }(), d = function () {
                  var t = c(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee61(t) {
                    var _ref42, n, i, _t34, _e19;

                    return regeneratorRuntime.wrap(function _callee61$(_context69) {
                      while (1) {
                        switch (_context69.prev = _context69.next) {
                          case 0:
                            _context69.next = 2;
                            return _l(t);

                          case 2:
                            _ref42 = _context69.sent;
                            n = _ref42.children;
                            i = _ref42.entry;
                            _context69.next = 7;
                            return e(i);

                          case 7:
                            if (!_context69.sent) {
                              _context69.next = 15;
                              break;
                            }

                            _context69.next = 10;
                            return r(i);

                          case 10:
                            _t34 = _context69.sent;
                            _context69.next = 13;
                            return a(d, n);

                          case 13:
                            _e19 = _context69.sent;
                            return _context69.abrupt("return", (_e19 = _e19.filter(function (t) {
                              return void 0 !== t;
                            }), o(_t34, _e19)));

                          case 15:
                          case "end":
                            return _context69.stop();
                        }
                      }
                    }, _callee61);
                  }));
                  return function (e) {
                    return t.apply(this, arguments);
                  };
                }();
                return _context70.abrupt("return", d(_u));

              case 6:
                _context70.prev = 6;
                _context70.t0 = _context70["catch"](1);
                throw _context70.t0.caller = "git.walk", _context70.t0;

              case 9:
              case "end":
                return _context70.stop();
            }
          }
        }, _callee62, null, [[1, 6]]);
      }))).apply(this, arguments);
    }

    r.d(e, "a", function () {
      return f;
    });
  }, function (t, e, r) {
    "use strict";

    function n(t, e) {
      return -(t < e) || +(t > e);
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    "use strict";

    var n = r(0),
        i = r(45),
        o = r(44);

    function a(t) {
      var e = t.match(/^https?:\/\/([^\/]+)@/);
      if (null == e) return null;
      e = e[1];

      var _e$split = e.split(":"),
          _e$split2 = _slicedToArray(_e$split, 2),
          r = _e$split2[0],
          n = _e$split2[1];

      return {
        url: t = t.replace("".concat(e, "@"), ""),
        username: r,
        password: n
      };
    }

    var s = r(58),
        u = r(24),
        c = r(3),
        f = r(66);

    function l(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function d(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            l(o, n, i, a, s, "next", t);
          }

          function s(t) {
            l(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    r.d(e, "a", function () {
      return p;
    });

    var h = function h(t, e) {
      return t.endsWith("?") ? "".concat(t).concat(e) : "".concat(t, "/").concat(e.replace(/^https?:\/\//, ""));
    };

    var p =
    /*#__PURE__*/
    function () {
      function p() {
        _classCallCheck(this, p);
      }

      _createClass(p, null, [{
        key: "capabilities",
        value: function capabilities() {
          return d(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee63() {
            return regeneratorRuntime.wrap(function _callee63$(_context71) {
              while (1) {
                switch (_context71.prev = _context71.next) {
                  case 0:
                    return _context71.abrupt("return", ["discover", "connect"]);

                  case 1:
                  case "end":
                    return _context71.stop();
                }
              }
            }, _callee63);
          }))();
        }
      }, {
        key: "discover",
        value: function discover(_ref43) {
          var t = _ref43.core,
              e = _ref43.corsProxy,
              r = _ref43.service,
              l = _ref43.url,
              p = _ref43.noGitSuffix,
              g = _ref43.auth,
              m = _ref43.headers;
          return d(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee64() {
            var d, y, v, w, b, _e20, _n12, _t35;

            return regeneratorRuntime.wrap(function _callee64$(_context72) {
              while (1) {
                switch (_context72.prev = _context72.next) {
                  case 0:
                    d = l;
                    l.endsWith(".git") || p || (l = l += ".git");
                    y = a(l);
                    y && (l = y.url, g.username = g.username || y.username, g.password = g.password || y.password), e && (l = h(e, l));
                    v = c.a.get(t).get("http") || s.a;
                    ("undefined" == typeof window || e) && (m["user-agent"] = m["user-agent"] || u.a.agent);
                    w = Object(o.a)(g, !!y);
                    w && (m.Authorization = Object(i.a)(w));
                    _context72.next = 10;
                    return v({
                      core: t,
                      method: "GET",
                      url: "".concat(l, "/info/refs?service=").concat(r),
                      headers: m
                    });

                  case 10:
                    b = _context72.sent;

                    if (!(401 === b.statusCode && c.a.get(t).has("credentialManager"))) {
                      _context72.next = 30;
                      break;
                    }

                    _e20 = c.a.get(t).get("credentialManager");
                    _context72.next = 15;
                    return _e20.fill({
                      url: d
                    });

                  case 15:
                    g = _context72.sent;
                    _n12 = Object(o.a)(g);
                    _n12 && (m.Authorization = Object(i.a)(_n12));
                    _context72.next = 20;
                    return v({
                      core: t,
                      method: "GET",
                      url: "".concat(l, "/info/refs?service=").concat(r),
                      headers: m
                    });

                  case 20:
                    _context72.t0 = (b = _context72.sent).statusCode;

                    if (!(401 === _context72.t0)) {
                      _context72.next = 26;
                      break;
                    }

                    _context72.next = 24;
                    return _e20.rejected({
                      url: d,
                      auth: g
                    });

                  case 24:
                    _context72.next = 30;
                    break;

                  case 26:
                    _context72.t1 = 200 === b.statusCode;

                    if (!_context72.t1) {
                      _context72.next = 30;
                      break;
                    }

                    _context72.next = 30;
                    return _e20.approved({
                      url: d,
                      auth: g
                    });

                  case 30:
                    if (!(200 !== b.statusCode)) {
                      _context72.next = 32;
                      break;
                    }

                    throw new n.b(n.a.HTTPError, {
                      statusCode: b.statusCode,
                      statusMessage: b.statusMessage
                    });

                  case 32:
                    _context72.prev = 32;
                    _context72.next = 35;
                    return Object(f.a)(b.body, {
                      service: r
                    });

                  case 35:
                    _t35 = _context72.sent;
                    return _context72.abrupt("return", (_t35.auth = g, _t35));

                  case 39:
                    _context72.prev = 39;
                    _context72.t2 = _context72["catch"](32);

                    if (!(_context72.t2.code === n.a.AssertServerResponseFail && _context72.t2.data.expected === "# service=".concat(r, "\\n") && b.headers["content-type"] !== "application/x-".concat(r, "-advertisement"))) {
                      _context72.next = 43;
                      break;
                    }

                    throw new n.b(n.a.RemoteDoesNotSupportSmartHTTP, {});

                  case 43:
                    throw _context72.t2;

                  case 44:
                  case "end":
                    return _context72.stop();
                }
              }
            }, _callee64, null, [[32, 39]]);
          }))();
        }
      }, {
        key: "connect",
        value: function connect(_ref44) {
          var t = _ref44.core,
              e = _ref44.emitter,
              r = _ref44.emitterPrefix,
              f = _ref44.corsProxy,
              l = _ref44.service,
              p = _ref44.url,
              g = _ref44.noGitSuffix,
              m = _ref44.auth,
              y = _ref44.body,
              v = _ref44.headers;
          return d(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee65() {
            var d, w, b;
            return regeneratorRuntime.wrap(function _callee65$(_context73) {
              while (1) {
                switch (_context73.prev = _context73.next) {
                  case 0:
                    p.endsWith(".git") || g || (p = p += ".git");
                    d = a(p);
                    d && (p = d.url, m.username = m.username || d.username, m.password = m.password || d.password), f && (p = h(f, p)), v["content-type"] = "application/x-".concat(l, "-request"), v.accept = "application/x-".concat(l, "-result");
                    w = c.a.get(t).get("http") || s.a;
                    ("undefined" == typeof window || f) && (v["user-agent"] = v["user-agent"] || u.a.agent), (m = Object(o.a)(m, !!d)) && (v.Authorization = Object(i.a)(m));
                    _context73.next = 7;
                    return w({
                      core: t,
                      emitter: e,
                      emitterPrefix: r,
                      method: "POST",
                      url: "".concat(p, "/").concat(l),
                      body: y,
                      headers: v
                    });

                  case 7:
                    b = _context73.sent;

                    if (!(200 !== b.statusCode)) {
                      _context73.next = 10;
                      break;
                    }

                    throw new n.b(n.a.HTTPError, {
                      statusCode: b.statusCode,
                      statusMessage: b.statusMessage
                    });

                  case 10:
                    return _context73.abrupt("return", b);

                  case 11:
                  case "end":
                    return _context73.stop();
                }
              }
            }, _callee65);
          }))();
        }
      }]);

      return p;
    }();
  }, function (t, e, r) {
    "use strict";

    t.exports = r(101);
  }, function (t, e, r) {
    "use strict";

    function n(_ref45) {
      var t = _ref45.name,
          e = _ref45.email,
          r = _ref45.timestamp,
          n = _ref45.timezoneOffset;
      return "".concat(t, " <").concat(e, "> ").concat(r, " ").concat(n = function (t) {
        var e = function (t) {
          return Math.sign(t) || (Object.is(t, -0) ? -1 : 1);
        }((r = t, 0 === r ? r : -r));

        var r;
        t = Math.abs(t);
        var n = Math.floor(t / 60);
        t -= 60 * n;
        var i = String(n),
            o = String(t);
        i.length < 2 && (i = "0" + i);
        o.length < 2 && (o = "0" + o);
        return (-1 === e ? "-" : "+") + i + o;
      }(n));
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return o;
    });
    var n = r(0),
        i = r(50);

    function o() {
      var _ref46 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          t = _ref46.username,
          e = _ref46.password,
          r = _ref46.token,
          o = _ref46.oauth2format;

      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;

      switch ([!!t, !!e, !!r, !!o].map(Number).join("")) {
        case "0000":
          return null;

        case "1000":
          if (a) return {
            username: t,
            password: ""
          };
          throw new n.b(n.a.MissingPasswordTokenError);

        case "0100":
          throw new n.b(n.a.MissingUsernameError);

        case "1100":
          return {
            username: t,
            password: e
          };

        case "0010":
          return {
            username: r,
            password: ""
          };

        case "1010":
          return {
            username: t,
            password: r
          };

        case "0110":
          throw new n.b(n.a.MixPasswordTokenError);

        case "1110":
          throw new n.b(n.a.MixUsernamePasswordTokenError);

        case "0001":
          throw new n.b(n.a.MissingTokenError);

        case "1001":
          throw new n.b(n.a.MixUsernameOauth2formatMissingTokenError);

        case "0101":
          throw new n.b(n.a.MixPasswordOauth2formatMissingTokenError);

        case "1101":
          throw new n.b(n.a.MixUsernamePasswordOauth2formatMissingTokenError);

        case "0011":
          return Object(i.a)(o, r);

        case "1011":
          throw new n.b(n.a.MixUsernameOauth2formatTokenError);

        case "0111":
          throw new n.b(n.a.MixPasswordOauth2formatTokenError);

        case "1111":
          throw new n.b(n.a.MixUsernamePasswordOauth2formatTokenError);
      }
    }
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      function n(_ref47) {
        var e = _ref47.username,
            r = _ref47.password;
        return "Basic ".concat(t.from("".concat(e, ":").concat(r)).toString("base64"));
      }

      r.d(e, "a", function () {
        return n;
      });
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    function n(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    r.d(e, "a", function () {
      return i;
    });

    var i =
    /*#__PURE__*/
    function () {
      function i() {
        _classCallCheck(this, i);

        this._queue = [];
      }

      _createClass(i, [{
        key: "write",
        value: function write(t) {
          if (this._ended) throw Error("You cannot write to a FIFO that has already been ended!");

          if (this._waiting) {
            var _e21 = this._waiting;
            this._waiting = null, _e21({
              value: t
            });
          } else this._queue.push(t);
        }
      }, {
        key: "end",
        value: function end() {
          if (this._ended = !0, this._waiting) {
            var _t36 = this._waiting;
            this._waiting = null, _t36({
              done: !0
            });
          }
        }
      }, {
        key: "destroy",
        value: function destroy(t) {
          this._ended = !0, this.error = t;
        }
      }, {
        key: "next",
        value: function next() {
          var t,
              e = this;
          return (t =
          /*#__PURE__*/
          regeneratorRuntime.mark(function t() {
            return regeneratorRuntime.wrap(function t$(_context74) {
              while (1) {
                switch (_context74.prev = _context74.next) {
                  case 0:
                    if (!(e._queue.length > 0)) {
                      _context74.next = 2;
                      break;
                    }

                    return _context74.abrupt("return", {
                      value: e._queue.shift()
                    });

                  case 2:
                    if (!e._ended) {
                      _context74.next = 4;
                      break;
                    }

                    return _context74.abrupt("return", {
                      done: !0
                    });

                  case 4:
                    if (!e._waiting) {
                      _context74.next = 6;
                      break;
                    }

                    throw Error("You cannot call read until the previous call to read has returned!");

                  case 6:
                    return _context74.abrupt("return", new Promise(function (t) {
                      e._waiting = t;
                    }));

                  case 7:
                  case "end":
                    return _context74.stop();
                }
              }
            }, t);
          }), function () {
            var e = this,
                r = arguments;
            return new Promise(function (i, o) {
              var a = t.apply(e, r);

              function s(t) {
                n(a, i, o, s, u, "next", t);
              }

              function u(t) {
                n(a, i, o, s, u, "throw", t);
              }

              s(void 0);
            });
          })();
        }
      }]);

      return i;
    }();
  }, function (t, e) {
    var r,
        n,
        i = t.exports = {};

    function o() {
      throw new Error("setTimeout has not been defined");
    }

    function a() {
      throw new Error("clearTimeout has not been defined");
    }

    function s(t) {
      if (r === setTimeout) return setTimeout(t, 0);
      if ((r === o || !r) && setTimeout) return r = setTimeout, setTimeout(t, 0);

      try {
        return r(t, 0);
      } catch (e) {
        try {
          return r.call(null, t, 0);
        } catch (e) {
          return r.call(this, t, 0);
        }
      }
    }

    !function () {
      try {
        r = "function" == typeof setTimeout ? setTimeout : o;
      } catch (t) {
        r = o;
      }

      try {
        n = "function" == typeof clearTimeout ? clearTimeout : a;
      } catch (t) {
        n = a;
      }
    }();
    var u,
        c = [],
        f = !1,
        l = -1;

    function d() {
      f && u && (f = !1, u.length ? c = u.concat(c) : l = -1, c.length && h());
    }

    function h() {
      if (!f) {
        var t = s(d);
        f = !0;

        for (var e = c.length; e;) {
          for (u = c, c = []; ++l < e;) {
            u && u[l].run();
          }

          l = -1, e = c.length;
        }

        u = null, f = !1, function (t) {
          if (n === clearTimeout) return clearTimeout(t);
          if ((n === a || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t);

          try {
            n(t);
          } catch (e) {
            try {
              return n.call(null, t);
            } catch (e) {
              return n.call(this, t);
            }
          }
        }(t);
      }
    }

    function p(t, e) {
      this.fun = t, this.array = e;
    }

    function g() {}

    i.nextTick = function (t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) {
        e[r - 1] = arguments[r];
      }
      c.push(new p(t, e)), 1 !== c.length || f || s(h);
    }, p.prototype.run = function () {
      this.fun.apply(null, this.array);
    }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function (t) {
      return [];
    }, i.binding = function (t) {
      throw new Error("process.binding is not supported");
    }, i.cwd = function () {
      return "/";
    }, i.chdir = function (t) {
      throw new Error("process.chdir is not supported");
    }, i.umask = function () {
      return 0;
    };
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return f;
    });
    var n = r(88),
        i = r.n(n),
        o = r(1),
        a = r(28),
        s = r(21),
        u = r(2);

    function c(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    var f =
    /*#__PURE__*/
    function () {
      function f() {
        _classCallCheck(this, f);
      }

      _createClass(f, null, [{
        key: "isIgnored",
        value: function isIgnored(_ref48) {
          var t = _ref48.fs,
              e = _ref48.dir,
              _ref48$gitdir = _ref48.gitdir,
              r = _ref48$gitdir === void 0 ? Object(u.a)(e, ".git") : _ref48$gitdir,
              n = _ref48.filepath;
          return (f =
          /*#__PURE__*/
          regeneratorRuntime.mark(function f() {
            var r, c, f, _t37, _r20, _n13, l, _i9, _c, _t38, _e22, _n14, _o9;

            return regeneratorRuntime.wrap(function f$(_context75) {
              while (1) {
                switch (_context75.prev = _context75.next) {
                  case 0:
                    r = new o.a(t);

                    if (!(".git" === Object(a.a)(n))) {
                      _context75.next = 3;
                      break;
                    }

                    return _context75.abrupt("return", !0);

                  case 3:
                    if (!("." === n)) {
                      _context75.next = 5;
                      break;
                    }

                    return _context75.abrupt("return", !1);

                  case 5:
                    c = [{
                      gitignore: Object(u.a)(e, ".gitignore"),
                      filepath: n
                    }], f = n.split("/");

                    for (_t37 = 1; _t37 < f.length; _t37++) {
                      _r20 = f.slice(0, _t37).join("/"), _n13 = f.slice(_t37).join("/");
                      c.push({
                        gitignore: Object(u.a)(e, _r20, ".gitignore"),
                        filepath: _n13
                      });
                    }

                    l = !1;
                    _i9 = 0, _c = c;

                  case 9:
                    if (!(_i9 < _c.length)) {
                      _context75.next = 29;
                      break;
                    }

                    _t38 = _c[_i9];
                    _e22 = void 0;
                    _context75.prev = 12;
                    _context75.next = 15;
                    return r.read(_t38.gitignore, "utf8");

                  case 15:
                    _e22 = _context75.sent;
                    _context75.next = 22;
                    break;

                  case 18:
                    _context75.prev = 18;
                    _context75.t0 = _context75["catch"](12);

                    if (!("NOENT" === _context75.t0.code)) {
                      _context75.next = 22;
                      break;
                    }

                    return _context75.abrupt("continue", 26);

                  case 22:
                    _n14 = i()().add(_e22), _o9 = Object(s.a)(_t38.filepath);

                    if (!("." !== _o9 && _n14.ignores(_o9))) {
                      _context75.next = 25;
                      break;
                    }

                    return _context75.abrupt("return", !0);

                  case 25:
                    l = l ? !_n14.test(_t38.filepath).unignored : _n14.test(_t38.filepath).ignored;

                  case 26:
                    _i9++;
                    _context75.next = 9;
                    break;

                  case 29:
                    return _context75.abrupt("return", l);

                  case 30:
                  case "end":
                    return _context75.stop();
                }
              }
            }, f, null, [[12, 18]]);
          }), function () {
            var t = this,
                e = arguments;
            return new Promise(function (r, n) {
              var i = f.apply(t, e);

              function o(t) {
                c(i, r, n, o, a, "next", t);
              }

              function a(t) {
                c(i, r, n, o, a, "throw", t);
              }

              o(void 0);
            });
          })();
          var f;
        }
      }]);

      return f;
    }();
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return c;
    });
    var n = r(14),
        i = r(7),
        o = r(0),
        a = r(11),
        s = r(5);

    function u(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function c(t) {
      return f.apply(this, arguments);
    }

    function f() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref49) {
        var t, e, r, _ref50, u, f;

        return regeneratorRuntime.wrap(function t$(_context76) {
          while (1) {
            switch (_context76.prev = _context76.next) {
              case 0:
                t = _ref49.fs, e = _ref49.gitdir, r = _ref49.oid;

                if (!("4b825dc642cb6eb9a060e54bf8d69288fbee4904" === r)) {
                  _context76.next = 3;
                  break;
                }

                return _context76.abrupt("return", {
                  tree: a.a.from([]),
                  oid: r
                });

              case 3:
                _context76.next = 5;
                return Object(s.a)({
                  fs: t,
                  gitdir: e,
                  oid: r
                });

              case 5:
                _ref50 = _context76.sent;
                u = _ref50.type;
                f = _ref50.object;

                if (!("tag" === u)) {
                  _context76.next = 10;
                  break;
                }

                return _context76.abrupt("return", c({
                  fs: t,
                  gitdir: e,
                  oid: r = n.a.from(f).parse().object
                }));

              case 10:
                if (!("commit" === u)) {
                  _context76.next = 12;
                  break;
                }

                return _context76.abrupt("return", c({
                  fs: t,
                  gitdir: e,
                  oid: r = i.a.from(f).parse().tree
                }));

              case 12:
                if (!("tree" !== u)) {
                  _context76.next = 14;
                  break;
                }

                throw new o.b(o.a.ResolveTreeError, {
                  oid: r
                });

              case 14:
                return _context76.abrupt("return", {
                  tree: a.a.from(f),
                  oid: r
                });

              case 15:
              case "end":
                return _context76.stop();
            }
          }
        }, t);
      }), (f = function f() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            u(o, n, i, a, s, "next", t);
          }

          function s(t) {
            u(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return i;
    });
    var n = r(0);

    function i(t, e) {
      switch (t) {
        case "github":
          return {
            username: e,
            password: "x-oauth-basic"
          };

        case "githubapp":
          return {
            username: "x-access-token",
            password: e
          };

        case "bitbucket":
          return {
            username: "x-token-auth",
            password: e
          };

        case "gitlab":
          return {
            username: "oauth2",
            password: e
          };

        default:
          throw new n.b(n.a.UnknownOauth2Format, {
            company: t
          });
      }
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return a;
    });
    var n = r(46),
        i = r(9);

    function o(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    var a =
    /*#__PURE__*/
    function () {
      function a() {
        _classCallCheck(this, a);
      }

      _createClass(a, null, [{
        key: "demux",
        value: function demux(t) {
          var e = i.a.streamReader(t),
              r = new n.a(),
              a = new n.a(),
              s = new n.a(),
              u = function () {
            var t,
                n = (t =
            /*#__PURE__*/
            regeneratorRuntime.mark(function t() {
              var t, _e23;

              return regeneratorRuntime.wrap(function t$(_context77) {
                while (1) {
                  switch (_context77.prev = _context77.next) {
                    case 0:
                      _context77.next = 2;
                      return e();

                    case 2:
                      t = _context77.sent;

                      if (!(null === t)) {
                        _context77.next = 5;
                        break;
                      }

                      return _context77.abrupt("return", u());

                    case 5:
                      if (!(!0 === t)) {
                        _context77.next = 7;
                        break;
                      }

                      return _context77.abrupt("return", (r.end(), s.end(), void a.end()));

                    case 7:
                      _context77.t0 = t[0];
                      _context77.next = _context77.t0 === 1 ? 10 : _context77.t0 === 2 ? 12 : _context77.t0 === 3 ? 14 : 16;
                      break;

                    case 10:
                      a.write(t.slice(1));
                      return _context77.abrupt("break", 17);

                    case 12:
                      s.write(t.slice(1));
                      return _context77.abrupt("break", 17);

                    case 14:
                      _e23 = t.slice(1);
                      return _context77.abrupt("return", (s.write(_e23), void a.destroy(new Error(_e23.toString("utf8")))));

                    case 16:
                      r.write(t.slice(0));

                    case 17:
                      u();

                    case 18:
                    case "end":
                      return _context77.stop();
                  }
                }
              }, t);
            }), function () {
              var e = this,
                  r = arguments;
              return new Promise(function (n, i) {
                var a = t.apply(e, r);

                function s(t) {
                  o(a, n, i, s, u, "next", t);
                }

                function u(t) {
                  o(a, n, i, s, u, "throw", t);
                }

                s(void 0);
              });
            });
            return function () {
              return n.apply(this, arguments);
            };
          }();

          return u(), {
            packetlines: r,
            packfile: a,
            progress: s
          };
        }
      }]);

      return a;
    }();
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return o;
    });
    var n = r(8),
        i = r(25);

    function o(t, e) {
      var r = Object(i.a)(t),
          o = Object(i.a)(e),
          s = r.mode !== o.mode || r.mtimeSeconds !== o.mtimeSeconds || r.ctimeSeconds !== o.ctimeSeconds || r.uid !== o.uid || r.gid !== o.gid || r.ino !== o.ino || r.size !== o.size;
      return s && n.a.enabled && console.table([a(r), a(o)]), s;
    }

    function a(t) {
      return {
        mode: t.mode,
        mtimeSeconds: t.mtimeSeconds,
        ctimeSeconds: t.ctimeSeconds,
        uid: t.uid,
        gid: t.gid,
        ino: t.ino,
        size: t.size
      };
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return i;
    });
    var n = r(0);

    var i =
    /*#__PURE__*/
    function () {
      function i(_ref51) {
        var t = _ref51.remotePath,
            e = _ref51.localPath,
            r = _ref51.force,
            n = _ref51.matchPrefix;

        _classCallCheck(this, i);

        Object.assign(this, {
          remotePath: t,
          localPath: e,
          force: r,
          matchPrefix: n
        });
      }

      _createClass(i, [{
        key: "translate",
        value: function translate(t) {
          if (this.matchPrefix) {
            if (t.startsWith(this.remotePath)) return this.localPath + t.replace(this.remotePath, "");
          } else if (t === this.remotePath) return this.localPath;

          return null;
        }
      }, {
        key: "reverseTranslate",
        value: function reverseTranslate(t) {
          if (this.matchPrefix) {
            if (t.startsWith(this.localPath)) return this.remotePath + t.replace(this.localPath, "");
          } else if (t === this.localPath) return this.remotePath;

          return null;
        }
      }], [{
        key: "from",
        value: function from(t) {
          var _t$match$slice = t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),
              _t$match$slice2 = _slicedToArray(_t$match$slice, 5),
              e = _t$match$slice2[0],
              r = _t$match$slice2[1],
              o = _t$match$slice2[2],
              a = _t$match$slice2[3],
              s = _t$match$slice2[4],
              u = "+" === e,
              c = "*" === o;

          if (c !== ("*" === s)) throw new n.b(n.a.InternalFail, {
            message: "Invalid refspec"
          });
          return new i({
            remotePath: r,
            localPath: a,
            force: u,
            matchPrefix: c
          });
        }
      }]);

      return i;
    }();
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return s;
    });
    var n = r(38);

    function i(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    var o = new Map();

    function a() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref52) {
        var t, e, r, i, o, a;
        return regeneratorRuntime.wrap(function t$(_context78) {
          while (1) {
            switch (_context78.prev = _context78.next) {
              case 0:
                t = _ref52.fs, e = _ref52.filename, r = _ref52.getExternalRefDelta, i = _ref52.emitter, o = _ref52.emitterPrefix;
                _context78.next = 3;
                return t.read(e);

              case 3:
                a = _context78.sent;
                return _context78.abrupt("return", n.a.fromIdx({
                  idx: a,
                  getExternalRefDelta: r
                }));

              case 5:
              case "end":
                return _context78.stop();
            }
          }
        }, t);
      }), (a = function a() {
        var e = this,
            r = arguments;
        return new Promise(function (n, o) {
          var a = t.apply(e, r);

          function s(t) {
            i(a, n, o, s, u, "next", t);
          }

          function u(t) {
            i(a, n, o, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }

    function s(_ref53) {
      var t = _ref53.fs,
          e = _ref53.filename,
          r = _ref53.getExternalRefDelta,
          n = _ref53.emitter,
          i = _ref53.emitterPrefix;
      var s = o.get(e);
      return s || (s = function (t) {
        return a.apply(this, arguments);
      }({
        fs: t,
        filename: e,
        getExternalRefDelta: r,
        emitter: n,
        emitterPrefix: i
      }), o.set(e, s)), s;
    }
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return a;
      });
      var n = r(56);

      function i(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function o(t) {
        return function () {
          var e = this,
              r = arguments;
          return new Promise(function (n, o) {
            var a = t.apply(e, r);

            function s(t) {
              i(a, n, o, s, u, "next", t);
            }

            function u(t) {
              i(a, n, o, s, u, "throw", t);
            }

            s(void 0);
          });
        };
      }

      var a =
      /*#__PURE__*/
      function () {
        function a(t) {
          _classCallCheck(this, a);

          this.stream = Object(n.a)(t), this.buffer = null, this.cursor = 0, this.undoCursor = 0, this.started = !1, this._ended = !1, this._discardedBytes = 0;
        }

        _createClass(a, [{
          key: "eof",
          value: function eof() {
            return this._ended && this.cursor === this.buffer.length;
          }
        }, {
          key: "tell",
          value: function tell() {
            return this._discardedBytes + this.cursor;
          }
        }, {
          key: "byte",
          value: function byte() {
            var t = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee66() {
              return regeneratorRuntime.wrap(function _callee66$(_context79) {
                while (1) {
                  switch (_context79.prev = _context79.next) {
                    case 0:
                      _context79.t0 = !t.eof();

                      if (!_context79.t0) {
                        _context79.next = 12;
                        break;
                      }

                      _context79.t1 = t.started;

                      if (_context79.t1) {
                        _context79.next = 6;
                        break;
                      }

                      _context79.next = 6;
                      return t._init();

                    case 6:
                      _context79.t2 = t.cursor !== t.buffer.length;

                      if (_context79.t2) {
                        _context79.next = 11;
                        break;
                      }

                      _context79.next = 10;
                      return t._loadnext();

                    case 10:
                      _context79.t2 = !t._ended;

                    case 11:
                      _context79.t0 = _context79.t2;

                    case 12:
                      if (!_context79.t0) {
                        _context79.next = 14;
                        break;
                      }

                      return _context79.abrupt("return", (t._moveCursor(1), t.buffer[t.undoCursor]));

                    case 14:
                    case "end":
                      return _context79.stop();
                  }
                }
              }, _callee66);
            }))();
          }
        }, {
          key: "chunk",
          value: function chunk() {
            var t = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee67() {
              return regeneratorRuntime.wrap(function _callee67$(_context80) {
                while (1) {
                  switch (_context80.prev = _context80.next) {
                    case 0:
                      _context80.t0 = !t.eof();

                      if (!_context80.t0) {
                        _context80.next = 12;
                        break;
                      }

                      _context80.t1 = t.started;

                      if (_context80.t1) {
                        _context80.next = 6;
                        break;
                      }

                      _context80.next = 6;
                      return t._init();

                    case 6:
                      _context80.t2 = t.cursor !== t.buffer.length;

                      if (_context80.t2) {
                        _context80.next = 11;
                        break;
                      }

                      _context80.next = 10;
                      return t._loadnext();

                    case 10:
                      _context80.t2 = !t._ended;

                    case 11:
                      _context80.t0 = _context80.t2;

                    case 12:
                      if (!_context80.t0) {
                        _context80.next = 14;
                        break;
                      }

                      return _context80.abrupt("return", (t._moveCursor(t.buffer.length), t.buffer.slice(t.undoCursor, t.cursor)));

                    case 14:
                    case "end":
                      return _context80.stop();
                  }
                }
              }, _callee67);
            }))();
          }
        }, {
          key: "read",
          value: function read(t) {
            var e = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee68() {
              return regeneratorRuntime.wrap(function _callee68$(_context81) {
                while (1) {
                  switch (_context81.prev = _context81.next) {
                    case 0:
                      if (e.eof()) {
                        _context81.next = 12;
                        break;
                      }

                      _context81.t0 = e.started;

                      if (_context81.t0) {
                        _context81.next = 5;
                        break;
                      }

                      _context81.next = 5;
                      return e._init();

                    case 5:
                      _context81.t1 = e.cursor + t > e.buffer.length;

                      if (!_context81.t1) {
                        _context81.next = 10;
                        break;
                      }

                      e._trim();

                      _context81.next = 10;
                      return e._accumulate(t);

                    case 10:
                      e._moveCursor(t);

                      return _context81.abrupt("return", e.buffer.slice(e.undoCursor, e.cursor));

                    case 12:
                    case "end":
                      return _context81.stop();
                  }
                }
              }, _callee68);
            }))();
          }
        }, {
          key: "skip",
          value: function skip(t) {
            var e = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee69() {
              return regeneratorRuntime.wrap(function _callee69$(_context82) {
                while (1) {
                  switch (_context82.prev = _context82.next) {
                    case 0:
                      _context82.t0 = e.eof();

                      if (_context82.t0) {
                        _context82.next = 12;
                        break;
                      }

                      _context82.t1 = e.started;

                      if (_context82.t1) {
                        _context82.next = 6;
                        break;
                      }

                      _context82.next = 6;
                      return e._init();

                    case 6:
                      _context82.t2 = e.cursor + t > e.buffer.length;

                      if (!_context82.t2) {
                        _context82.next = 11;
                        break;
                      }

                      e._trim();

                      _context82.next = 11;
                      return e._accumulate(t);

                    case 11:
                      e._moveCursor(t);

                    case 12:
                    case "end":
                      return _context82.stop();
                  }
                }
              }, _callee69);
            }))();
          }
        }, {
          key: "undo",
          value: function undo() {
            var t = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee70() {
              return regeneratorRuntime.wrap(function _callee70$(_context83) {
                while (1) {
                  switch (_context83.prev = _context83.next) {
                    case 0:
                      t.cursor = t.undoCursor;

                    case 1:
                    case "end":
                      return _context83.stop();
                  }
                }
              }, _callee70);
            }))();
          }
        }, {
          key: "_next",
          value: function _next() {
            var e = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee71() {
              var _ref54, r, n;

              return regeneratorRuntime.wrap(function _callee71$(_context84) {
                while (1) {
                  switch (_context84.prev = _context84.next) {
                    case 0:
                      e.started = !0;
                      _context84.next = 3;
                      return e.stream.next();

                    case 3:
                      _ref54 = _context84.sent;
                      r = _ref54.done;
                      n = _ref54.value;
                      return _context84.abrupt("return", (r && (e._ended = !0), n && (n = t.from(n)), n));

                    case 7:
                    case "end":
                      return _context84.stop();
                  }
                }
              }, _callee71);
            }))();
          }
        }, {
          key: "_trim",
          value: function _trim() {
            this.buffer = this.buffer.slice(this.undoCursor), this.cursor -= this.undoCursor, this._discardedBytes += this.undoCursor, this.undoCursor = 0;
          }
        }, {
          key: "_moveCursor",
          value: function _moveCursor(t) {
            this.undoCursor = this.cursor, this.cursor += t, this.cursor > this.buffer.length && (this.cursor = this.buffer.length);
          }
        }, {
          key: "_accumulate",
          value: function _accumulate(e) {
            var r = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee72() {
              var n, _t39;

              return regeneratorRuntime.wrap(function _callee72$(_context85) {
                while (1) {
                  switch (_context85.prev = _context85.next) {
                    case 0:
                      if (!r._ended) {
                        _context85.next = 2;
                        break;
                      }

                      return _context85.abrupt("return");

                    case 2:
                      n = [r.buffer];

                    case 3:
                      if (!(r.cursor + e > s(n))) {
                        _context85.next = 12;
                        break;
                      }

                      _context85.next = 6;
                      return r._next();

                    case 6:
                      _t39 = _context85.sent;

                      if (!r._ended) {
                        _context85.next = 9;
                        break;
                      }

                      return _context85.abrupt("break", 12);

                    case 9:
                      n.push(_t39);

                    case 10:
                      _context85.next = 3;
                      break;

                    case 12:
                      r.buffer = t.concat(n);

                    case 13:
                    case "end":
                      return _context85.stop();
                  }
                }
              }, _callee72);
            }))();
          }
        }, {
          key: "_loadnext",
          value: function _loadnext() {
            var t = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee73() {
              return regeneratorRuntime.wrap(function _callee73$(_context86) {
                while (1) {
                  switch (_context86.prev = _context86.next) {
                    case 0:
                      t._discardedBytes += t.buffer.length;
                      t.undoCursor = 0;
                      t.cursor = 0;
                      _context86.next = 5;
                      return t._next();

                    case 5:
                      t.buffer = _context86.sent;

                    case 6:
                    case "end":
                      return _context86.stop();
                  }
                }
              }, _callee73);
            }))();
          }
        }, {
          key: "_init",
          value: function _init() {
            var t = this;
            return o(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee74() {
              return regeneratorRuntime.wrap(function _callee74$(_context87) {
                while (1) {
                  switch (_context87.prev = _context87.next) {
                    case 0:
                      _context87.next = 2;
                      return t._next();

                    case 2:
                      t.buffer = _context87.sent;

                    case 3:
                    case "end":
                      return _context87.stop();
                  }
                }
              }, _callee74);
            }))();
          }
        }]);

        return a;
      }();

      function s(t) {
        return t.reduce(function (t, e) {
          return t + e.length;
        }, 0);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return i;
    });
    var n = r(57);

    function i(t) {
      return t[Symbol.asyncIterator] ? t[Symbol.asyncIterator]() : t[Symbol.iterator] ? t[Symbol.iterator]() : t.next ? t : Object(n.b)(t);
    }
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      if (t[Symbol.asyncIterator]) return t;
      var e = t.getReader();
      return _defineProperty({
        next: function next() {
          return e.read();
        },
        return: function _return() {
          return e.releaseLock(), {};
        }
      }, Symbol.asyncIterator, function () {
        return this;
      });
    }

    function i(t) {
      var e = [t];
      return _defineProperty({
        next: function next() {
          return Promise.resolve({
            done: 0 === e.length,
            value: e.pop()
          });
        },
        return: function _return() {
          return e = [], {};
        }
      }, Symbol.asyncIterator, function () {
        return this;
      });
    }

    r.d(e, "a", function () {
      return n;
    }), r.d(e, "b", function () {
      return i;
    });
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return a;
      });
      var n = r(57),
          i = r(35);

      function o(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function a(t) {
        return s.apply(this, arguments);
      }

      function s() {
        var e;
        return e =
        /*#__PURE__*/
        regeneratorRuntime.mark(function e(_ref57) {
          var e, r, o, a, _ref57$method, s, _ref57$headers, u, c, f, l, _iteratorNormalCompletion26, _didIteratorError26, _iteratorError26, _iterator26, _step26, _step26$value, _t40, _e24;

          return regeneratorRuntime.wrap(function e$(_context88) {
            while (1) {
              switch (_context88.prev = _context88.next) {
                case 0:
                  e = _ref57.core, r = _ref57.emitter, o = _ref57.emitterPrefix, a = _ref57.url, _ref57$method = _ref57.method, s = _ref57$method === void 0 ? "GET" : _ref57$method, _ref57$headers = _ref57.headers, u = _ref57$headers === void 0 ? {} : _ref57$headers, c = _ref57.body;
                  _context88.t0 = c;

                  if (!_context88.t0) {
                    _context88.next = 6;
                    break;
                  }

                  _context88.next = 5;
                  return Object(i.a)(c);

                case 5:
                  c = _context88.sent;

                case 6:
                  _context88.next = 8;
                  return t.fetch(a, {
                    method: s,
                    headers: u,
                    body: c
                  });

                case 8:
                  f = _context88.sent;

                  if (!(f.body && f.body.getReader)) {
                    _context88.next = 13;
                    break;
                  }

                  _context88.t1 = Object(n.a)(f.body);
                  _context88.next = 19;
                  break;

                case 13:
                  _context88.t2 = Uint8Array;
                  _context88.next = 16;
                  return f.arrayBuffer();

                case 16:
                  _context88.t3 = _context88.sent;
                  _context88.t4 = new _context88.t2(_context88.t3);
                  _context88.t1 = [_context88.t4];

                case 19:
                  l = _context88.t1;
                  u = {};
                  _iteratorNormalCompletion26 = true;
                  _didIteratorError26 = false;
                  _iteratorError26 = undefined;
                  _context88.prev = 24;

                  for (_iterator26 = f.headers.entries()[Symbol.iterator](); !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
                    _step26$value = _slicedToArray(_step26.value, 2), _t40 = _step26$value[0], _e24 = _step26$value[1];
                    u[_t40] = _e24;
                  }

                  _context88.next = 32;
                  break;

                case 28:
                  _context88.prev = 28;
                  _context88.t5 = _context88["catch"](24);
                  _didIteratorError26 = true;
                  _iteratorError26 = _context88.t5;

                case 32:
                  _context88.prev = 32;
                  _context88.prev = 33;

                  if (!_iteratorNormalCompletion26 && _iterator26.return != null) {
                    _iterator26.return();
                  }

                case 35:
                  _context88.prev = 35;

                  if (!_didIteratorError26) {
                    _context88.next = 38;
                    break;
                  }

                  throw _iteratorError26;

                case 38:
                  return _context88.finish(35);

                case 39:
                  return _context88.finish(32);

                case 40:
                  return _context88.abrupt("return", {
                    url: f.url,
                    method: f.method,
                    statusCode: f.status,
                    statusMessage: f.statusText,
                    body: l,
                    headers: u
                  });

                case 41:
                case "end":
                  return _context88.stop();
              }
            }
          }, e, null, [[24, 28, 32, 40], [33,, 35, 39]]);
        }), (s = function s() {
          var t = this,
              r = arguments;
          return new Promise(function (n, i) {
            var a = e.apply(t, r);

            function s(t) {
              o(a, n, i, s, u, "next", t);
            }

            function u(t) {
              o(a, n, i, s, u, "throw", t);
            }

            s(void 0);
          });
        }).apply(this, arguments);
      }
    }).call(this, r(72));
  }, function (t, e) {
    !function (e) {
      "use strict";

      var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      t.exports.toByteArray = function (t) {
        var e, n, i, o, a, s;
        if (t.length % 4 > 0) throw "Invalid string. Length must be a multiple of 4";

        for (s = [], i = (a = (a = t.indexOf("=")) > 0 ? t.length - a : 0) > 0 ? t.length - 4 : t.length, e = 0, n = 0; e < i; e += 4, n += 3) {
          o = r.indexOf(t[e]) << 18 | r.indexOf(t[e + 1]) << 12 | r.indexOf(t[e + 2]) << 6 | r.indexOf(t[e + 3]), s.push((16711680 & o) >> 16), s.push((65280 & o) >> 8), s.push(255 & o);
        }

        return 2 === a ? (o = r.indexOf(t[e]) << 2 | r.indexOf(t[e + 1]) >> 4, s.push(255 & o)) : 1 === a && (o = r.indexOf(t[e]) << 10 | r.indexOf(t[e + 1]) << 4 | r.indexOf(t[e + 2]) >> 2, s.push(o >> 8 & 255), s.push(255 & o)), s;
      }, t.exports.fromByteArray = function (t) {
        var e,
            n,
            i,
            o,
            a = t.length % 3,
            s = "";

        for (e = 0, i = t.length - a; e < i; e += 3) {
          n = (t[e] << 16) + (t[e + 1] << 8) + t[e + 2], s += r[(o = n) >> 18 & 63] + r[o >> 12 & 63] + r[o >> 6 & 63] + r[63 & o];
        }

        switch (a) {
          case 1:
            n = t[t.length - 1], s += r[n >> 2], s += r[n << 4 & 63], s += "==";
            break;

          case 2:
            n = (t[t.length - 2] << 8) + t[t.length - 1], s += r[n >> 10], s += r[n >> 4 & 63], s += r[n << 2 & 63], s += "=";
        }

        return s;
      };
    }();
  }, function (t, e, r) {
    "use strict";

    t.exports = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
    };
  }, function (t, e, r) {
    "use strict";

    function n(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function i(t) {
      return o.apply(this, arguments);
    }

    function o() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_t41) {
        return regeneratorRuntime.wrap(function t$(_context89) {
          while (1) {
            switch (_context89.prev = _context89.next) {
              case 0:
                return _context89.abrupt("return", new Promise(function (e, r) {
                  return setTimeout(e, _t41);
                }));

              case 1:
              case "end":
                return _context89.stop();
            }
          }
        }, t);
      }), (o = function o() {
        var e = this,
            r = arguments;
        return new Promise(function (i, o) {
          var a = t.apply(e, r);

          function s(t) {
            n(a, i, o, s, u, "next", t);
          }

          function u(t) {
            n(a, i, o, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }

    r.d(e, "a", function () {
      return i;
    });
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return u;
      });
      var n = r(19),
          i = r(37),
          o = r(25),
          a = r(12),
          s = r(0);

      var u =
      /*#__PURE__*/
      function () {
        function u(e) {
          _classCallCheck(this, u);

          if (this._dirty = !1, t.isBuffer(e)) this._entries = function (t) {
            var e = Object(a.a)(t.slice(0, -20)),
                r = t.slice(-20).toString("hex");
            if (r !== e) throw new s.b(s.a.InternalFail, {
              message: "Invalid checksum in GitIndex buffer: expected ".concat(r, " but saw ").concat(e)
            });
            var i = new n.a(t),
                o = new Map(),
                u = i.toString("utf8", 4);
            if ("DIRC" !== u) throw new s.b(s.a.InternalFail, {
              message: "Inavlid dircache magic file number: ".concat(u)
            });
            var c = i.readUInt32BE();
            if (2 !== c) throw new s.b(s.a.InternalFail, {
              message: "Unsupported dircache version: ".concat(c)
            });
            var f = i.readUInt32BE();
            var l = 0;

            for (; !i.eof() && l < f;) {
              var _e25 = {};
              _e25.ctimeSeconds = i.readUInt32BE(), _e25.ctimeNanoseconds = i.readUInt32BE(), _e25.mtimeSeconds = i.readUInt32BE(), _e25.mtimeNanoseconds = i.readUInt32BE(), _e25.dev = i.readUInt32BE(), _e25.ino = i.readUInt32BE(), _e25.mode = i.readUInt32BE(), _e25.uid = i.readUInt32BE(), _e25.gid = i.readUInt32BE(), _e25.size = i.readUInt32BE(), _e25.oid = i.slice(20).toString("hex");

              var _r21 = i.readUInt16BE();

              _e25.flags = (d = _r21, {
                assumeValid: Boolean(32768 & d),
                extended: Boolean(16384 & d),
                stage: (12288 & d) >> 12,
                nameLength: 4095 & d
              });

              var _n15 = t.indexOf(0, i.tell() + 1) - i.tell();

              if (_n15 < 1) throw new s.b(s.a.InternalFail, {
                message: "Got a path length of: ".concat(_n15)
              });
              _e25.path = i.toString("utf8", _n15);

              var _a2 = 8 - (i.tell() - 12) % 8;

              for (0 === _a2 && (_a2 = 8); _a2--;) {
                var _t42 = i.readUInt8();

                if (0 !== _t42) throw new s.b(s.a.InternalFail, {
                  message: "Expected 1-8 null characters but got '".concat(_t42, "' after ").concat(_e25.path)
                });
                if (i.eof()) throw new s.b(s.a.InternalFail, {
                  message: "Unexpected end of file"
                });
              }

              o.set(_e25.path, _e25), l++;
            }

            var d;
            return o;
          }(e);else {
            if (null !== e) throw new s.b(s.a.InternalFail, {
              message: "invalid type passed to GitIndex constructor"
            });
            this._entries = new Map();
          }
        }

        _createClass(u, [{
          key: Symbol.iterator,
          value:
          /*#__PURE__*/
          regeneratorRuntime.mark(function value() {
            var _iteratorNormalCompletion27, _didIteratorError27, _iteratorError27, _iterator27, _step27, _t43;

            return regeneratorRuntime.wrap(function value$(_context90) {
              while (1) {
                switch (_context90.prev = _context90.next) {
                  case 0:
                    _iteratorNormalCompletion27 = true;
                    _didIteratorError27 = false;
                    _iteratorError27 = undefined;
                    _context90.prev = 3;
                    _iterator27 = this.entries[Symbol.iterator]();

                  case 5:
                    if (_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done) {
                      _context90.next = 12;
                      break;
                    }

                    _t43 = _step27.value;
                    _context90.next = 9;
                    return _t43;

                  case 9:
                    _iteratorNormalCompletion27 = true;
                    _context90.next = 5;
                    break;

                  case 12:
                    _context90.next = 18;
                    break;

                  case 14:
                    _context90.prev = 14;
                    _context90.t0 = _context90["catch"](3);
                    _didIteratorError27 = true;
                    _iteratorError27 = _context90.t0;

                  case 18:
                    _context90.prev = 18;
                    _context90.prev = 19;

                    if (!_iteratorNormalCompletion27 && _iterator27.return != null) {
                      _iterator27.return();
                    }

                  case 21:
                    _context90.prev = 21;

                    if (!_didIteratorError27) {
                      _context90.next = 24;
                      break;
                    }

                    throw _iteratorError27;

                  case 24:
                    return _context90.finish(21);

                  case 25:
                    return _context90.finish(18);

                  case 26:
                  case "end":
                    return _context90.stop();
                }
              }
            }, value, this, [[3, 14, 18, 26], [19,, 21, 25]]);
          })
        }, {
          key: "insert",
          value: function insert(_ref58) {
            var e = _ref58.filepath,
                r = _ref58.stats,
                n = _ref58.oid;
            r = Object(o.a)(r);
            var i = t.from(e),
                a = {
              ctimeSeconds: r.ctimeSeconds,
              ctimeNanoseconds: r.ctimeNanoseconds,
              mtimeSeconds: r.mtimeSeconds,
              mtimeNanoseconds: r.mtimeNanoseconds,
              dev: r.dev,
              ino: r.ino,
              mode: r.mode || 33188,
              uid: r.uid,
              gid: r.gid,
              size: r.size,
              path: e,
              oid: n,
              flags: {
                assumeValid: !1,
                extended: !1,
                stage: 0,
                nameLength: i.length < 4095 ? i.length : 4095
              }
            };
            this._entries.set(a.path, a), this._dirty = !0;
          }
        }, {
          key: "delete",
          value: function _delete(_ref59) {
            var t = _ref59.filepath;
            if (this._entries.has(t)) this._entries.delete(t);else {
              var _iteratorNormalCompletion28 = true;
              var _didIteratorError28 = false;
              var _iteratorError28 = undefined;

              try {
                for (var _iterator28 = this._entries.keys()[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                  var _e26 = _step28.value;
                  _e26.startsWith(t + "/") && this._entries.delete(_e26);
                }
              } catch (err) {
                _didIteratorError28 = true;
                _iteratorError28 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion28 && _iterator28.return != null) {
                    _iterator28.return();
                  }
                } finally {
                  if (_didIteratorError28) {
                    throw _iteratorError28;
                  }
                }
              }
            }
            this._dirty = !0;
          }
        }, {
          key: "clear",
          value: function clear() {
            this._entries.clear(), this._dirty = !0;
          }
        }, {
          key: "render",
          value: function render() {
            return this.entries.map(function (t) {
              return "".concat(t.mode.toString(8), " ").concat(t.oid, "    ").concat(t.path);
            }).join("\n");
          }
        }, {
          key: "toObject",
          value: function toObject() {
            var e = t.alloc(12),
                r = new n.a(e);
            r.write("DIRC", 4, "utf8"), r.writeUInt32BE(2), r.writeUInt32BE(this.entries.length);
            var i = t.concat(this.entries.map(function (e) {
              var r = t.from(e.path),
                  i = 8 * Math.ceil((62 + r.length + 1) / 8),
                  a = t.alloc(i),
                  s = new n.a(a),
                  u = Object(o.a)(e);
              return s.writeUInt32BE(u.ctimeSeconds), s.writeUInt32BE(u.ctimeNanoseconds), s.writeUInt32BE(u.mtimeSeconds), s.writeUInt32BE(u.mtimeNanoseconds), s.writeUInt32BE(u.dev), s.writeUInt32BE(u.ino), s.writeUInt32BE(u.mode), s.writeUInt32BE(u.uid), s.writeUInt32BE(u.gid), s.writeUInt32BE(u.size), s.write(e.oid, 20, "hex"), s.writeUInt16BE(function (e) {
                var r = e.flags;
                return r.extended = !1, r.nameLength = Math.min(t.from(e.path).length, 4095), (r.assumeValid ? 32768 : 0) + (r.extended ? 16384 : 0) + ((3 & r.stage) << 12) + (4095 & r.nameLength);
              }(e)), s.write(e.path, r.length, "utf8"), a;
            })),
                s = t.concat([e, i]),
                u = Object(a.a)(s);
            return t.concat([s, t.from(u, "hex")]);
          }
        }, {
          key: "entries",
          get: function get() {
            return _toConsumableArray(this._entries.values()).sort(i.a);
          }
        }, {
          key: "entriesMap",
          get: function get() {
            return this._entries;
          }
        }], [{
          key: "from",
          value: function from(t) {
            return new u(t);
          }
        }]);

        return u;
      }();
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    function n(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function i(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (i, o) {
          var a = t.apply(e, r);

          function s(t) {
            n(a, i, o, s, u, "next", t);
          }

          function u(t) {
            n(a, i, o, s, u, "throw", t);
          }

          s(void 0);
        });
      };
    }

    r.d(e, "a", function () {
      return b;
    });

    var o = function o(t) {
      if ("true" === (t = t.trim().toLowerCase()) || "yes" === t || "on" === t) return !0;
      if ("false" === t || "no" === t || "off" === t) return !1;
      throw Error("Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ".concat(t));
    },
        a = {
      core: {
        filemode: o,
        bare: o,
        logallrefupdates: o,
        symlinks: o,
        ignorecase: o,
        bigFileThreshold: function bigFileThreshold(t) {
          t = t.toLowerCase();
          var e = parseInt(t);
          return t.endsWith("k") && (e *= 1024), t.endsWith("m") && (e *= 1048576), t.endsWith("g") && (e *= 1073741824), e;
        }
      }
    },
        s = /^\[([A-Za-z0-9_.]+)(?: "(.*)")?\]$/,
        u = /^[A-Za-z0-9_.]+$/,
        c = /^([A-Za-z]\w*)(?: *= *(.*))?$/,
        f = /^[A-Za-z]\w*$/,
        l = /^(.*?)( *[#;].*)$/,
        d = function d(t) {
      var e = s.exec(t);

      if (null != e) {
        var _e$slice = e.slice(1),
            _e$slice2 = _slicedToArray(_e$slice, 2),
            _t44 = _e$slice2[0],
            _r22 = _e$slice2[1];

        return [_t44, _r22];
      }

      return null;
    },
        h = function h(t) {
      var e = c.exec(t);

      if (null != e) {
        var _e$slice3 = e.slice(1),
            _e$slice4 = _slicedToArray(_e$slice3, 2),
            _t45 = _e$slice4[0],
            _e$slice4$ = _e$slice4[1],
            _r23 = _e$slice4$ === void 0 ? "true" : _e$slice4$,
            _n16 = p(_r23);

        return [_t45, m(_n16)];
      }

      return null;
    },
        p = function p(t) {
      var e = l.exec(t);
      if (null == e) return t;

      var _e$slice5 = e.slice(1),
          _e$slice6 = _slicedToArray(_e$slice5, 2),
          r = _e$slice6[0],
          n = _e$slice6[1];

      return g(r) && g(n) ? "".concat(r).concat(n) : r;
    },
        g = function g(t) {
      return (t.match(/(?:^|[^\\])"/g) || []).length % 2 != 0;
    },
        m = function m(t) {
      return t.split("").reduce(function (t, e, r, n) {
        var i = '"' === e && "\\" !== n[r - 1],
            o = "\\" === e && '"' === n[r + 1];
        return i || o ? t : t + e;
      }, "");
    },
        y = function y(t) {
      return null != t ? t.toLowerCase() : null;
    },
        v = function v(t, e, r) {
      return [y(t), e, y(r)].filter(function (t) {
        return null != t;
      }).join(".");
    },
        w = function w(t, e) {
      return t.reduce(function (t, r, n) {
        return e(r) ? n : t;
      }, -1);
    };

    var b =
    /*#__PURE__*/
    function () {
      function b(t) {
        _classCallCheck(this, b);

        var e = null,
            r = null;
        this.parsedConfig = t.split("\n").map(function (t) {
          var n = null,
              i = null;
          var o = t.trim(),
              a = d(o),
              s = null != a;

          if (s) {
            var _a3 = _slicedToArray(a, 2);

            e = _a3[0];
            r = _a3[1];
          } else {
            var _t47, _t48;

            var _t46 = h(o);

            null != _t46 && (_t47 = _t46, _t48 = _slicedToArray(_t47, 2), n = _t48[0], i = _t48[1], _t47);
          }

          var u = v(e, r, n);
          return {
            line: t,
            isSection: s,
            section: e,
            subsection: r,
            name: n,
            value: i,
            path: u
          };
        });
      }

      _createClass(b, [{
        key: "get",
        value: function get(t) {
          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
          var r = this;
          return i(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee75() {
            var n;
            return regeneratorRuntime.wrap(function _callee75$(_context91) {
              while (1) {
                switch (_context91.prev = _context91.next) {
                  case 0:
                    n = r.parsedConfig.filter(function (e) {
                      return e.path === t.toLowerCase();
                    }).map(function (_ref60) {
                      var t = _ref60.section,
                          e = _ref60.name,
                          r = _ref60.value;
                      var n = a[t] && a[t][e];
                      return n ? n(r) : r;
                    });
                    return _context91.abrupt("return", e ? n : n.pop());

                  case 2:
                  case "end":
                    return _context91.stop();
                }
              }
            }, _callee75);
          }))();
        }
      }, {
        key: "getall",
        value: function getall(t) {
          var e = this;
          return i(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee76() {
            return regeneratorRuntime.wrap(function _callee76$(_context92) {
              while (1) {
                switch (_context92.prev = _context92.next) {
                  case 0:
                    return _context92.abrupt("return", e.get(t, !0));

                  case 1:
                  case "end":
                    return _context92.stop();
                }
              }
            }, _callee76);
          }))();
        }
      }, {
        key: "getSubsections",
        value: function getSubsections(t) {
          var e = this;
          return i(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee77() {
            return regeneratorRuntime.wrap(function _callee77$(_context93) {
              while (1) {
                switch (_context93.prev = _context93.next) {
                  case 0:
                    return _context93.abrupt("return", e.parsedConfig.filter(function (e) {
                      return e.section === t && e.isSection;
                    }).map(function (t) {
                      return t.subsection;
                    }));

                  case 1:
                  case "end":
                    return _context93.stop();
                }
              }
            }, _callee77);
          }))();
        }
      }, {
        key: "deleteSection",
        value: function deleteSection(t, e) {
          var r = this;
          return i(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee78() {
            return regeneratorRuntime.wrap(function _callee78$(_context94) {
              while (1) {
                switch (_context94.prev = _context94.next) {
                  case 0:
                    r.parsedConfig = r.parsedConfig.filter(function (r) {
                      return !(r.section === t && r.subsection === e);
                    });

                  case 1:
                  case "end":
                    return _context94.stop();
                }
              }
            }, _callee78);
          }))();
        }
      }, {
        key: "append",
        value: function append(t, e) {
          var r = this;
          return i(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee79() {
            return regeneratorRuntime.wrap(function _callee79$(_context95) {
              while (1) {
                switch (_context95.prev = _context95.next) {
                  case 0:
                    return _context95.abrupt("return", r.set(t, e, !0));

                  case 1:
                  case "end":
                    return _context95.stop();
                }
              }
            }, _callee79);
          }))();
        }
      }, {
        key: "set",
        value: function set(t, e) {
          var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
          var n = this;
          return i(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee80() {
            var i, _t49, _o10, _r24, _i10, _r24$split, _r24$split2, _o11, _a4, _s5, _c2, _t50;

            return regeneratorRuntime.wrap(function _callee80$(_context96) {
              while (1) {
                switch (_context96.prev = _context96.next) {
                  case 0:
                    i = w(n.parsedConfig, function (e) {
                      return e.path === t.toLowerCase();
                    });
                    if (null == e) -1 !== i && n.parsedConfig.splice(i, 1);else if (-1 !== i) {
                      _t49 = n.parsedConfig[i], _o10 = Object.assign({}, _t49, {
                        value: e,
                        modified: !0
                      });
                      r ? n.parsedConfig.splice(i + 1, 0, _o10) : n.parsedConfig[i] = _o10;
                    } else {
                      _r24 = t.split(".").slice(0, -1).join(".").toLowerCase(), _i10 = n.parsedConfig.findIndex(function (t) {
                        return t.path === _r24;
                      }), _r24$split = _r24.split("."), _r24$split2 = _slicedToArray(_r24$split, 2), _o11 = _r24$split2[0], _a4 = _r24$split2[1], _s5 = t.split(".").pop(), _c2 = {
                        section: _o11,
                        subsection: _a4,
                        name: _s5,
                        value: e,
                        modified: !0,
                        path: v(_o11, _a4, _s5)
                      };
                      if (u.test(_o11) && f.test(_s5)) if (_i10 >= 0) n.parsedConfig.splice(_i10 + 1, 0, _c2);else {
                        _t50 = {
                          section: _o11,
                          subsection: _a4,
                          modified: !0,
                          path: v(_o11, _a4, null)
                        };
                        n.parsedConfig.push(_t50, _c2);
                      }
                    }

                  case 2:
                  case "end":
                    return _context96.stop();
                }
              }
            }, _callee80);
          }))();
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.parsedConfig.map(function (_ref61) {
            var t = _ref61.line,
                e = _ref61.section,
                r = _ref61.subsection,
                n = _ref61.name,
                i = _ref61.value,
                _ref61$modified = _ref61.modified,
                o = _ref61$modified === void 0 ? !1 : _ref61$modified;
            return o ? null != n && null != i ? "\t".concat(n, " = ").concat(i) : null != r ? "[".concat(e, " \"").concat(r, "\"]") : "[".concat(e, "]") : t;
          }).join("\n");
        }
      }], [{
        key: "from",
        value: function from(t) {
          return new b(t);
        }
      }]);

      return b;
    }();
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return i;
    });
    var n = r(53);

    var i =
    /*#__PURE__*/
    function () {
      function i() {
        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        _classCallCheck(this, i);

        this.rules = t;
      }

      _createClass(i, [{
        key: "add",
        value: function add(t) {
          var e = n.a.from(t);
          this.rules.push(e);
        }
      }, {
        key: "translate",
        value: function translate(t) {
          var e = [];
          var _iteratorNormalCompletion29 = true;
          var _didIteratorError29 = false;
          var _iteratorError29 = undefined;

          try {
            for (var _iterator29 = this.rules[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
              var _r25 = _step29.value;
              var _iteratorNormalCompletion30 = true;
              var _didIteratorError30 = false;
              var _iteratorError30 = undefined;

              try {
                for (var _iterator30 = t[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                  var _n17 = _step30.value;

                  var _t51 = _r25.translate(_n17);

                  _t51 && e.push([_n17, _t51]);
                }
              } catch (err) {
                _didIteratorError30 = true;
                _iteratorError30 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion30 && _iterator30.return != null) {
                    _iterator30.return();
                  }
                } finally {
                  if (_didIteratorError30) {
                    throw _iteratorError30;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError29 = true;
            _iteratorError29 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion29 && _iterator29.return != null) {
                _iterator29.return();
              }
            } finally {
              if (_didIteratorError29) {
                throw _iteratorError29;
              }
            }
          }

          return e;
        }
      }, {
        key: "translateOne",
        value: function translateOne(t) {
          var e = null;
          var _iteratorNormalCompletion31 = true;
          var _didIteratorError31 = false;
          var _iteratorError31 = undefined;

          try {
            for (var _iterator31 = this.rules[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
              var _r26 = _step31.value;

              var _n18 = _r26.translate(t);

              _n18 && (e = _n18);
            }
          } catch (err) {
            _didIteratorError31 = true;
            _iteratorError31 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion31 && _iterator31.return != null) {
                _iterator31.return();
              }
            } finally {
              if (_didIteratorError31) {
                throw _iteratorError31;
              }
            }
          }

          return e;
        }
      }, {
        key: "localNamespaces",
        value: function localNamespaces() {
          return this.rules.filter(function (t) {
            return t.matchPrefix;
          }).map(function (t) {
            return t.localPath.replace(/\/$/, "");
          });
        }
      }], [{
        key: "from",
        value: function from(t) {
          var e = [];
          var _iteratorNormalCompletion32 = true;
          var _didIteratorError32 = false;
          var _iteratorError32 = undefined;

          try {
            for (var _iterator32 = t[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
              var _r27 = _step32.value;
              e.push(n.a.from(_r27));
            }
          } catch (err) {
            _didIteratorError32 = true;
            _iteratorError32 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion32 && _iterator32.return != null) {
                _iterator32.return();
              }
            } finally {
              if (_didIteratorError32) {
                throw _iteratorError32;
              }
            }
          }

          return new i(e);
        }
      }]);

      return i;
    }();
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return o;
    });
    var n = r(0),
        i = r(41);

    var o =
    /*#__PURE__*/
    function () {
      function o() {
        _classCallCheck(this, o);
      }

      _createClass(o, null, [{
        key: "getRemoteHelperFor",
        value: function getRemoteHelperFor(_ref62) {
          var t = _ref62.url;
          var e = new Map();
          e.set("http", i.a), e.set("https", i.a);

          var r = function (_ref63) {
            var t = _ref63.url;
            var e = t.match(/(\w+)(:\/\/|::)(.*)/);
            if (null !== e) return "://" === e[2] ? {
              transport: e[1],
              address: e[0]
            } : "::" === e[2] ? {
              transport: e[1],
              address: e[3]
            } : void 0;
          }({
            url: t
          });

          if (!r) throw new n.b(n.a.RemoteUrlParseError, {
            url: t
          });
          if (e.has(r.transport)) return e.get(r.transport);
          throw new n.b(n.a.UnknownTransportError, {
            url: t,
            transport: r.transport
          });
        }
      }]);

      return o;
    }();
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return a;
    });
    var n = r(0),
        i = r(9);

    function o(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function a(t, e) {
      return s.apply(this, arguments);
    }

    function s() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_t54, _ref64) {
        var e, r, o, a, s, u, c, _c$toString$trim$spli, _c$toString$trim$spli2, f, l, _f$split, _f$split2, d, h, _t52, _t52$toString$trim$sp, _t52$toString$trim$sp2, _e27, _r28, _iteratorNormalCompletion33, _didIteratorError33, _iteratorError33, _iterator33, _step33, _t53, _e28;

        return regeneratorRuntime.wrap(function t$(_context97) {
          while (1) {
            switch (_context97.prev = _context97.next) {
              case 0:
                e = _ref64.service;
                r = new Set(), o = new Map(), a = new Map(), s = i.a.streamReader(_t54);
                _context97.next = 4;
                return s();

              case 4:
                u = _context97.sent;

              case 5:
                if (!(null === u)) {
                  _context97.next = 11;
                  break;
                }

                _context97.next = 8;
                return s();

              case 8:
                u = _context97.sent;

              case 9:
                _context97.next = 5;
                break;

              case 11:
                if (!(!0 === u)) {
                  _context97.next = 13;
                  break;
                }

                throw new n.b(n.a.EmptyServerResponseFail);

              case 13:
                if (!(u.toString("utf8").replace(/\n$/, "") !== "# service=".concat(e))) {
                  _context97.next = 15;
                  break;
                }

                throw new n.b(n.a.AssertServerResponseFail, {
                  expected: "# service=".concat(e, "\\n"),
                  actual: u.toString("utf8")
                });

              case 15:
                _context97.next = 17;
                return s();

              case 17:
                c = _context97.sent;

              case 18:
                if (!(null === c)) {
                  _context97.next = 24;
                  break;
                }

                _context97.next = 21;
                return s();

              case 21:
                c = _context97.sent;

              case 22:
                _context97.next = 18;
                break;

              case 24:
                if (!(!0 === c)) {
                  _context97.next = 26;
                  break;
                }

                return _context97.abrupt("return", {
                  capabilities: r,
                  refs: o,
                  symrefs: a
                });

              case 26:
                _c$toString$trim$spli = c.toString("utf8").trim().split("\0"), _c$toString$trim$spli2 = _slicedToArray(_c$toString$trim$spli, 2), f = _c$toString$trim$spli2[0], l = _c$toString$trim$spli2[1];
                l.split(" ").map(function (t) {
                  return r.add(t);
                });
                _f$split = f.split(" "), _f$split2 = _slicedToArray(_f$split, 2), d = _f$split2[0], h = _f$split2[1];
                o.set(h, d);

              case 30:
                _context97.next = 32;
                return s();

              case 32:
                _t52 = _context97.sent;

                if (!(!0 === _t52)) {
                  _context97.next = 35;
                  break;
                }

                return _context97.abrupt("break", 38);

              case 35:
                if (null !== _t52) {
                  _t52$toString$trim$sp = _t52.toString("utf8").trim().split(" "), _t52$toString$trim$sp2 = _slicedToArray(_t52$toString$trim$sp, 2), _e27 = _t52$toString$trim$sp2[0], _r28 = _t52$toString$trim$sp2[1];
                  o.set(_r28, _e27);
                }

              case 36:
                _context97.next = 30;
                break;

              case 38:
                _iteratorNormalCompletion33 = true;
                _didIteratorError33 = false;
                _iteratorError33 = undefined;
                _context97.prev = 41;

                for (_iterator33 = r[Symbol.iterator](); !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
                  _t53 = _step33.value;

                  if (_t53.startsWith("symref=")) {
                    _e28 = _t53.match(/symref=([^:]+):(.*)/);
                    3 === _e28.length && a.set(_e28[1], _e28[2]);
                  }
                }

                _context97.next = 49;
                break;

              case 45:
                _context97.prev = 45;
                _context97.t0 = _context97["catch"](41);
                _didIteratorError33 = true;
                _iteratorError33 = _context97.t0;

              case 49:
                _context97.prev = 49;
                _context97.prev = 50;

                if (!_iteratorNormalCompletion33 && _iterator33.return != null) {
                  _iterator33.return();
                }

              case 52:
                _context97.prev = 52;

                if (!_didIteratorError33) {
                  _context97.next = 55;
                  break;
                }

                throw _iteratorError33;

              case 55:
                return _context97.finish(52);

              case 56:
                return _context97.finish(49);

              case 57:
                return _context97.abrupt("return", {
                  capabilities: r,
                  refs: o,
                  symrefs: a
                });

              case 58:
              case "end":
                return _context97.stop();
            }
          }
        }, t, null, [[41, 45, 49, 57], [50,, 52, 56]]);
      }), (s = function s() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var a = t.apply(e, r);

          function s(t) {
            o(a, n, i, s, u, "next", t);
          }

          function u(t) {
            o(a, n, i, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return o;
    });
    var n = r(28),
        i = r(21);

    function o(t) {
      var e = new Map(),
          r = function r(t) {
        if (!e.has(t)) {
          var _o12 = {
            type: "tree",
            fullpath: t,
            basename: Object(n.a)(t),
            metadata: {},
            children: []
          };
          e.set(t, _o12), _o12.parent = r(Object(i.a)(t)), _o12.parent && _o12.parent !== _o12 && _o12.parent.children.push(_o12);
        }

        return e.get(t);
      },
          o = function o(t, _o13) {
        if (!e.has(t)) {
          var a = {
            type: "blob",
            fullpath: t,
            basename: Object(n.a)(t),
            metadata: _o13,
            parent: r(Object(i.a)(t)),
            children: []
          };
          a.parent && a.parent.children.push(a), e.set(t, a);
        }

        return e.get(t);
      };

      r(".");
      var _iteratorNormalCompletion34 = true;
      var _didIteratorError34 = false;
      var _iteratorError34 = undefined;

      try {
        for (var _iterator34 = t[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
          var _e29 = _step34.value;
          o(_e29.path, _e29);
        }
      } catch (err) {
        _didIteratorError34 = true;
        _iteratorError34 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion34 && _iterator34.return != null) {
            _iterator34.return();
          }
        } finally {
          if (_didIteratorError34) {
            throw _iteratorError34;
          }
        }
      }

      return e;
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return a;
    });
    var n = r(96),
        i = r.n(n);
    var o = /^.*(\r?\n|$)/gm;

    function a(_ref65) {
      var t = _ref65.ourContent,
          e = _ref65.baseContent,
          r = _ref65.theirContent,
          _ref65$ourName = _ref65.ourName,
          n = _ref65$ourName === void 0 ? "ours" : _ref65$ourName,
          _ref65$baseName = _ref65.baseName,
          a = _ref65$baseName === void 0 ? "base" : _ref65$baseName,
          _ref65$theirName = _ref65.theirName,
          s = _ref65$theirName === void 0 ? "theirs" : _ref65$theirName,
          _ref65$format = _ref65.format,
          u = _ref65$format === void 0 ? "diff" : _ref65$format,
          _ref65$markerSize = _ref65.markerSize,
          c = _ref65$markerSize === void 0 ? 7 : _ref65$markerSize;
      var f = t.match(o),
          l = e.match(o),
          d = r.match(o),
          h = i()(f, l, d);
      var p = "",
          g = !0;
      var _iteratorNormalCompletion35 = true;
      var _didIteratorError35 = false;
      var _iteratorError35 = undefined;

      try {
        for (var _iterator35 = h[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
          var _t55 = _step35.value;
          _t55.ok && (p += _t55.ok.join("")), _t55.conflict && (g = !1, p += "".concat("<".repeat(c), " ").concat(n, "\n"), p += _t55.conflict.a.join(""), "diff3" === u && (p += "".concat("|".repeat(c), " ").concat(a, "\n"), p += _t55.conflict.o.join("")), p += "".concat("=".repeat(c), "\n"), p += _t55.conflict.b.join(""), p += "".concat(">".repeat(c), " ").concat(s, "\n"));
        }
      } catch (err) {
        _didIteratorError35 = true;
        _iteratorError35 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion35 && _iterator35.return != null) {
            _iterator35.return();
          }
        } finally {
          if (_didIteratorError35) {
            throw _iteratorError35;
          }
        }
      }

      return {
        cleanMerge: g,
        mergedText: p
      };
    }
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return p;
      });
      var n = r(18),
          i = r.n(n),
          o = r(31),
          a = r.n(o),
          s = r(1),
          u = r(5),
          c = r(2),
          f = r(32),
          l = r(3),
          d = r(97);

      function h(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function p(t) {
        return g.apply(this, arguments);
      }

      function g() {
        var e;
        return e =
        /*#__PURE__*/
        regeneratorRuntime.mark(function e(_ref66) {
          var _ref66$core, e, r, _ref66$gitdir, n, _ref66$fs, o, h, p, g, m, y, v, _iteratorNormalCompletion36, _didIteratorError36, _iteratorError36, _iterator36, _step36, _t56, _ref68, _e30, _r29, w;

          return regeneratorRuntime.wrap(function e$(_context98) {
            while (1) {
              switch (_context98.prev = _context98.next) {
                case 0:
                  v = function _ref70(_ref67) {
                    var e = _ref67.stype,
                        r = _ref67.object;
                    var n = d.a[e];
                    var o = r.length,
                        a = o > 15 ? 128 : 0;
                    var s = 15 & o;
                    o >>>= 4;
                    var u = (a | n | s).toString(16);

                    for (y(u, "hex"); a;) {
                      u = (a = o > 127 ? 128 : 0) | 127 & o, y(Object(f.a)(2, u), "hex"), o >>>= 7;
                    }

                    y(t.from(i.a.deflate(r)));
                  };

                  y = function _ref69(e, r) {
                    var n = t.from(e, r);
                    m.push(n), g.update(n);
                  };

                  _ref66$core = _ref66.core, e = _ref66$core === void 0 ? "default" : _ref66$core, r = _ref66.dir, _ref66$gitdir = _ref66.gitdir, n = _ref66$gitdir === void 0 ? Object(c.a)(r, ".git") : _ref66$gitdir, _ref66$fs = _ref66.fs, o = _ref66$fs === void 0 ? l.a.get(e).get("fs") : _ref66$fs, h = _ref66.oids;
                  p = new s.a(o), g = new a.a(), m = [];
                  y("PACK"), y("00000002", "hex"), y(Object(f.a)(8, h.length), "hex");
                  _iteratorNormalCompletion36 = true;
                  _didIteratorError36 = false;
                  _iteratorError36 = undefined;
                  _context98.prev = 8;
                  _iterator36 = h[Symbol.iterator]();

                case 10:
                  if (_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done) {
                    _context98.next = 21;
                    break;
                  }

                  _t56 = _step36.value;
                  _context98.next = 14;
                  return Object(u.a)({
                    fs: p,
                    gitdir: n,
                    oid: _t56
                  });

                case 14:
                  _ref68 = _context98.sent;
                  _e30 = _ref68.type;
                  _r29 = _ref68.object;
                  v({
                    write: y,
                    object: _r29,
                    stype: _e30
                  });

                case 18:
                  _iteratorNormalCompletion36 = true;
                  _context98.next = 10;
                  break;

                case 21:
                  _context98.next = 27;
                  break;

                case 23:
                  _context98.prev = 23;
                  _context98.t0 = _context98["catch"](8);
                  _didIteratorError36 = true;
                  _iteratorError36 = _context98.t0;

                case 27:
                  _context98.prev = 27;
                  _context98.prev = 28;

                  if (!_iteratorNormalCompletion36 && _iterator36.return != null) {
                    _iterator36.return();
                  }

                case 30:
                  _context98.prev = 30;

                  if (!_didIteratorError36) {
                    _context98.next = 33;
                    break;
                  }

                  throw _iteratorError36;

                case 33:
                  return _context98.finish(30);

                case 34:
                  return _context98.finish(27);

                case 35:
                  w = g.digest();
                  return _context98.abrupt("return", (m.push(w), m));

                case 37:
                case "end":
                  return _context98.stop();
              }
            }
          }, e, null, [[8, 23, 27, 35], [28,, 30, 34]]);
        }), (g = function g() {
          var t = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = e.apply(t, r);

            function a(t) {
              h(o, n, i, a, s, "next", t);
            }

            function s(t) {
              h(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        }).apply(this, arguments);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return u;
    });
    var n = r(34),
        i = r(13),
        o = r(7);

    function a(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function s(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function s(t) {
            a(o, n, i, s, u, "next", t);
          }

          function u(t) {
            a(o, n, i, s, u, "throw", t);
          }

          s(void 0);
        });
      };
    }

    var u =
    /*#__PURE__*/
    function (_o$a) {
      _inherits(u, _o$a);

      function u() {
        _classCallCheck(this, u);

        return _possibleConstructorReturn(this, _getPrototypeOf(u).apply(this, arguments));
      }

      _createClass(u, [{
        key: "sign",
        value: function sign(t, e) {
          var r = this;
          return s(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee81() {
            var a, s, u, c, _ref71, f, l;

            return regeneratorRuntime.wrap(function _callee81$(_context99) {
              while (1) {
                switch (_context99.prev = _context99.next) {
                  case 0:
                    a = r.withoutSignature(), s = o.a.justHeaders(r._commit), u = o.a.justMessage(r._commit), c = t.key.readArmored(e).keys;
                    _context99.next = 3;
                    return t.sign({
                      data: t.util.str2Uint8Array(a),
                      privateKeys: c,
                      detached: !0,
                      armor: !0
                    });

                  case 3:
                    _ref71 = _context99.sent;
                    f = _ref71.signature;
                    f = Object(i.a)(f);
                    l = s + "\ngpgsig" + Object(n.a)(f) + "\n" + u;
                    return _context99.abrupt("return", o.a.from(l));

                  case 8:
                  case "end":
                    return _context99.stop();
                }
              }
            }, _callee81);
          }))();
        }
      }, {
        key: "listSigningKeys",
        value: function listSigningKeys(t) {
          var e = this;
          return s(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee82() {
            return regeneratorRuntime.wrap(function _callee82$(_context100) {
              while (1) {
                switch (_context100.prev = _context100.next) {
                  case 0:
                    return _context100.abrupt("return", t.message.readSignedContent(e.withoutSignature(), e.isolateSignature()).getSigningKeyIds().map(function (t) {
                      return t.toHex();
                    }));

                  case 1:
                  case "end":
                    return _context100.stop();
                }
              }
            }, _callee82);
          }))();
        }
      }, {
        key: "verify",
        value: function verify(t, e) {
          var r = this;
          return s(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee83() {
            var n;
            return regeneratorRuntime.wrap(function _callee83$(_context101) {
              while (1) {
                switch (_context101.prev = _context101.next) {
                  case 0:
                    n = t.key.readArmored(e).keys;
                    return _context101.abrupt("return", t.message.readSignedContent(r.withoutSignature(), r.isolateSignature()).verify(n).reduce(function (t, e) {
                      return t.valid && e.valid;
                    }, {
                      valid: !0
                    }));

                  case 2:
                  case "end":
                    return _context101.stop();
                }
              }
            }, _callee83);
          }))();
        }
      }], [{
        key: "from",
        value: function from(t) {
          return new u(t);
        }
      }]);

      return u;
    }(o.a);
  }, function (t, e, r) {
    (function (t) {
      function r(t, e) {
        for (var r = 0, n = t.length - 1; n >= 0; n--) {
          var i = t[n];
          "." === i ? t.splice(n, 1) : ".." === i ? (t.splice(n, 1), r++) : r && (t.splice(n, 1), r--);
        }

        if (e) for (; r--; r) {
          t.unshift("..");
        }
        return t;
      }

      function n(t, e) {
        if (t.filter) return t.filter(e);

        for (var r = [], n = 0; n < t.length; n++) {
          e(t[n], n, t) && r.push(t[n]);
        }

        return r;
      }

      e.resolve = function () {
        for (var e = "", i = !1, o = arguments.length - 1; o >= -1 && !i; o--) {
          var a = o >= 0 ? arguments[o] : t.cwd();
          if ("string" != typeof a) throw new TypeError("Arguments to path.resolve must be strings");
          a && (e = a + "/" + e, i = "/" === a.charAt(0));
        }

        return (i ? "/" : "") + (e = r(n(e.split("/"), function (t) {
          return !!t;
        }), !i).join("/")) || ".";
      }, e.normalize = function (t) {
        var o = e.isAbsolute(t),
            a = "/" === i(t, -1);
        return (t = r(n(t.split("/"), function (t) {
          return !!t;
        }), !o).join("/")) || o || (t = "."), t && a && (t += "/"), (o ? "/" : "") + t;
      }, e.isAbsolute = function (t) {
        return "/" === t.charAt(0);
      }, e.join = function () {
        var t = Array.prototype.slice.call(arguments, 0);
        return e.normalize(n(t, function (t, e) {
          if ("string" != typeof t) throw new TypeError("Arguments to path.join must be strings");
          return t;
        }).join("/"));
      }, e.relative = function (t, r) {
        function n(t) {
          for (var e = 0; e < t.length && "" === t[e]; e++) {
            ;
          }

          for (var r = t.length - 1; r >= 0 && "" === t[r]; r--) {
            ;
          }

          return e > r ? [] : t.slice(e, r - e + 1);
        }

        t = e.resolve(t).substr(1), r = e.resolve(r).substr(1);

        for (var i = n(t.split("/")), o = n(r.split("/")), a = Math.min(i.length, o.length), s = a, u = 0; u < a; u++) {
          if (i[u] !== o[u]) {
            s = u;
            break;
          }
        }

        var c = [];

        for (u = s; u < i.length; u++) {
          c.push("..");
        }

        return (c = c.concat(o.slice(s))).join("/");
      }, e.sep = "/", e.delimiter = ":", e.dirname = function (t) {
        if ("string" != typeof t && (t += ""), 0 === t.length) return ".";

        for (var e = t.charCodeAt(0), r = 47 === e, n = -1, i = !0, o = t.length - 1; o >= 1; --o) {
          if (47 === (e = t.charCodeAt(o))) {
            if (!i) {
              n = o;
              break;
            }
          } else i = !1;
        }

        return -1 === n ? r ? "/" : "." : r && 1 === n ? "/" : t.slice(0, n);
      }, e.basename = function (t, e) {
        var r = function (t) {
          "string" != typeof t && (t += "");
          var e,
              r = 0,
              n = -1,
              i = !0;

          for (e = t.length - 1; e >= 0; --e) {
            if (47 === t.charCodeAt(e)) {
              if (!i) {
                r = e + 1;
                break;
              }
            } else -1 === n && (i = !1, n = e + 1);
          }

          return -1 === n ? "" : t.slice(r, n);
        }(t);

        return e && r.substr(-1 * e.length) === e && (r = r.substr(0, r.length - e.length)), r;
      }, e.extname = function (t) {
        "string" != typeof t && (t += "");

        for (var e = -1, r = 0, n = -1, i = !0, o = 0, a = t.length - 1; a >= 0; --a) {
          var s = t.charCodeAt(a);
          if (47 !== s) -1 === n && (i = !1, n = a + 1), 46 === s ? -1 === e ? e = a : 1 !== o && (o = 1) : -1 !== e && (o = -1);else if (!i) {
            r = a + 1;
            break;
          }
        }

        return -1 === e || -1 === n || 0 === o || 1 === o && e === n - 1 && e === r + 1 ? "" : t.slice(e, n);
      };
      var i = "b" === "ab".substr(-1) ? function (t, e, r) {
        return t.substr(e, r);
      } : function (t, e, r) {
        return e < 0 && (e = t.length + e), t.substr(e, r);
      };
    }).call(this, r(47));
  }, function (t, e) {
    var r;

    r = function () {
      return this;
    }();

    try {
      r = r || new Function("return this")();
    } catch (t) {
      "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && (r = window);
    }

    t.exports = r;
  }, function (t, e, r) {
    var n = r(10),
        i = n.Buffer;

    function o(t, e) {
      for (var r in t) {
        e[r] = t[r];
      }
    }

    function a(t, e, r) {
      return i(t, e, r);
    }

    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = n : (o(n, e), e.Buffer = a), o(i, a), a.from = function (t, e, r) {
      if ("number" == typeof t) throw new TypeError("Argument must not be a number");
      return i(t, e, r);
    }, a.alloc = function (t, e, r) {
      if ("number" != typeof t) throw new TypeError("Argument must be a number");
      var n = i(t);
      return void 0 !== e ? "string" == typeof r ? n.fill(e, r) : n.fill(e) : n.fill(0), n;
    }, a.allocUnsafe = function (t) {
      if ("number" != typeof t) throw new TypeError("Argument must be a number");
      return i(t);
    }, a.allocUnsafeSlow = function (t) {
      if ("number" != typeof t) throw new TypeError("Argument must be a number");
      return n.SlowBuffer(t);
    };
  }, function (t, e, r) {
    "use strict";

    t.exports = function (t, e, r, n) {
      for (var i = 65535 & t | 0, o = t >>> 16 & 65535 | 0, a = 0; 0 !== r;) {
        r -= a = r > 2e3 ? 2e3 : r;

        do {
          o = o + (i = i + e[n++] | 0) | 0;
        } while (--a);

        i %= 65521, o %= 65521;
      }

      return i | o << 16 | 0;
    };
  }, function (t, e, r) {
    "use strict";

    var n = function () {
      for (var t, e = [], r = 0; r < 256; r++) {
        t = r;

        for (var n = 0; n < 8; n++) {
          t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
        }

        e[r] = t;
      }

      return e;
    }();

    t.exports = function (t, e, r, i) {
      var o = n,
          a = i + r;
      t ^= -1;

      for (var s = i; s < a; s++) {
        t = t >>> 8 ^ o[255 & (t ^ e[s])];
      }

      return -1 ^ t;
    };
  }, function (t, e, r) {
    "use strict";

    var n = r(23),
        i = !0,
        o = !0;

    try {
      String.fromCharCode.apply(null, [0]);
    } catch (t) {
      i = !1;
    }

    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (t) {
      o = !1;
    }

    for (var a = new n.Buf8(256), s = 0; s < 256; s++) {
      a[s] = s >= 252 ? 6 : s >= 248 ? 5 : s >= 240 ? 4 : s >= 224 ? 3 : s >= 192 ? 2 : 1;
    }

    function u(t, e) {
      if (e < 65534 && (t.subarray && o || !t.subarray && i)) return String.fromCharCode.apply(null, n.shrinkBuf(t, e));

      for (var r = "", a = 0; a < e; a++) {
        r += String.fromCharCode(t[a]);
      }

      return r;
    }

    a[254] = a[254] = 1, e.string2buf = function (t) {
      var e,
          r,
          i,
          o,
          a,
          s = t.length,
          u = 0;

      for (o = 0; o < s; o++) {
        55296 == (64512 & (r = t.charCodeAt(o))) && o + 1 < s && 56320 == (64512 & (i = t.charCodeAt(o + 1))) && (r = 65536 + (r - 55296 << 10) + (i - 56320), o++), u += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
      }

      for (e = new n.Buf8(u), a = 0, o = 0; a < u; o++) {
        55296 == (64512 & (r = t.charCodeAt(o))) && o + 1 < s && 56320 == (64512 & (i = t.charCodeAt(o + 1))) && (r = 65536 + (r - 55296 << 10) + (i - 56320), o++), r < 128 ? e[a++] = r : r < 2048 ? (e[a++] = 192 | r >>> 6, e[a++] = 128 | 63 & r) : r < 65536 ? (e[a++] = 224 | r >>> 12, e[a++] = 128 | r >>> 6 & 63, e[a++] = 128 | 63 & r) : (e[a++] = 240 | r >>> 18, e[a++] = 128 | r >>> 12 & 63, e[a++] = 128 | r >>> 6 & 63, e[a++] = 128 | 63 & r);
      }

      return e;
    }, e.buf2binstring = function (t) {
      return u(t, t.length);
    }, e.binstring2buf = function (t) {
      for (var e = new n.Buf8(t.length), r = 0, i = e.length; r < i; r++) {
        e[r] = t.charCodeAt(r);
      }

      return e;
    }, e.buf2string = function (t, e) {
      var r,
          n,
          i,
          o,
          s = e || t.length,
          c = new Array(2 * s);

      for (n = 0, r = 0; r < s;) {
        if ((i = t[r++]) < 128) c[n++] = i;else if ((o = a[i]) > 4) c[n++] = 65533, r += o - 1;else {
          for (i &= 2 === o ? 31 : 3 === o ? 15 : 7; o > 1 && r < s;) {
            i = i << 6 | 63 & t[r++], o--;
          }

          o > 1 ? c[n++] = 65533 : i < 65536 ? c[n++] = i : (i -= 65536, c[n++] = 55296 | i >> 10 & 1023, c[n++] = 56320 | 1023 & i);
        }
      }

      return u(c, n);
    }, e.utf8border = function (t, e) {
      var r;

      for ((e = e || t.length) > t.length && (e = t.length), r = e - 1; r >= 0 && 128 == (192 & t[r]);) {
        r--;
      }

      return r < 0 ? e : 0 === r ? e : r + a[t[r]] > e ? r : e;
    };
  }, function (t, e, r) {
    "use strict";

    t.exports = function () {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    };
  }, function (t, e, r) {
    "use strict";

    t.exports = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
    };
  }, function (t, e) {
    var r, n;
    t.exports = r = {}, n = "undefined" == typeof WeakMap ? null : new WeakMap(), r.get = n ? function (t) {
      var e = n.get(t.buffer);
      e || n.set(t.buffer, e = new DataView(t.buffer, 0));
      return e;
    } : function (t) {
      return new DataView(t.buffer, 0);
    };
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return i;
    });
    var n = r(9);

    function i(_ref72) {
      var _ref72$capabilities = _ref72.capabilities,
          t = _ref72$capabilities === void 0 ? [] : _ref72$capabilities,
          _ref72$wants = _ref72.wants,
          e = _ref72$wants === void 0 ? [] : _ref72$wants,
          _ref72$haves = _ref72.haves,
          r = _ref72$haves === void 0 ? [] : _ref72$haves,
          _ref72$shallows = _ref72.shallows,
          i = _ref72$shallows === void 0 ? [] : _ref72$shallows,
          _ref72$depth = _ref72.depth,
          o = _ref72$depth === void 0 ? null : _ref72$depth,
          _ref72$since = _ref72.since,
          a = _ref72$since === void 0 ? null : _ref72$since,
          _ref72$exclude = _ref72.exclude,
          s = _ref72$exclude === void 0 ? [] : _ref72$exclude;
      var u = [];
      e = _toConsumableArray(new Set(e));
      var c = " ".concat(t.join(" "));
      var _iteratorNormalCompletion37 = true;
      var _didIteratorError37 = false;
      var _iteratorError37 = undefined;

      try {
        for (var _iterator37 = e[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
          var _t57 = _step37.value;
          u.push(n.a.encode("want ".concat(_t57).concat(c, "\n"))), c = "";
        }
      } catch (err) {
        _didIteratorError37 = true;
        _iteratorError37 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion37 && _iterator37.return != null) {
            _iterator37.return();
          }
        } finally {
          if (_didIteratorError37) {
            throw _iteratorError37;
          }
        }
      }

      var _iteratorNormalCompletion38 = true;
      var _didIteratorError38 = false;
      var _iteratorError38 = undefined;

      try {
        for (var _iterator38 = i[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
          var _t58 = _step38.value;
          u.push(n.a.encode("shallow ".concat(_t58, "\n")));
        }
      } catch (err) {
        _didIteratorError38 = true;
        _iteratorError38 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion38 && _iterator38.return != null) {
            _iterator38.return();
          }
        } finally {
          if (_didIteratorError38) {
            throw _iteratorError38;
          }
        }
      }

      null !== o && u.push(n.a.encode("deepen ".concat(o, "\n"))), null !== a && u.push(n.a.encode("deepen-since ".concat(Math.floor(a.valueOf() / 1e3), "\n")));
      var _iteratorNormalCompletion39 = true;
      var _didIteratorError39 = false;
      var _iteratorError39 = undefined;

      try {
        for (var _iterator39 = s[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
          var _t59 = _step39.value;
          u.push(n.a.encode("deepen-not ".concat(_t59, "\n")));
        }
      } catch (err) {
        _didIteratorError39 = true;
        _iteratorError39 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion39 && _iterator39.return != null) {
            _iterator39.return();
          }
        } finally {
          if (_didIteratorError39) {
            throw _iteratorError39;
          }
        }
      }

      u.push(n.a.flush());
      var _iteratorNormalCompletion40 = true;
      var _didIteratorError40 = false;
      var _iteratorError40 = undefined;

      try {
        for (var _iterator40 = r[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
          var _t60 = _step40.value;
          u.push(n.a.encode("have ".concat(_t60, "\n")));
        }
      } catch (err) {
        _didIteratorError40 = true;
        _iteratorError40 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion40 && _iterator40.return != null) {
            _iterator40.return();
          }
        } finally {
          if (_didIteratorError40) {
            throw _iteratorError40;
          }
        }
      }

      return u.push(n.a.encode("done\n")), u;
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return s;
    });
    var n = r(0),
        i = r(51),
        o = r(27);

    function a(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function s(t) {
      return u.apply(this, arguments);
    }

    function u() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_t64) {
        var _i$a$demux, e, r, a, s, u, c, f, l;

        return regeneratorRuntime.wrap(function t$(_context102) {
          while (1) {
            switch (_context102.prev = _context102.next) {
              case 0:
                _i$a$demux = i.a.demux(_t64), e = _i$a$demux.packetlines, r = _i$a$demux.packfile, a = _i$a$demux.progress, s = [], u = [], c = [];
                f = !1, l = !1;
                return _context102.abrupt("return", new Promise(function (t, i) {
                  Object(o.a)(e, function (e) {
                    var o = e.toString("utf8").trim();

                    if (o.startsWith("shallow")) {
                      var _t61 = o.slice(-41).trim();

                      40 !== _t61.length && i(new n.b(n.a.CorruptShallowOidFail, {
                        oid: _t61
                      })), s.push(_t61);
                    } else if (o.startsWith("unshallow")) {
                      var _t62 = o.slice(-41).trim();

                      40 !== _t62.length && i(new n.b(n.a.CorruptShallowOidFail, {
                        oid: _t62
                      })), u.push(_t62);
                    } else if (o.startsWith("ACK")) {
                      var _o$split = o.split(" "),
                          _o$split2 = _slicedToArray(_o$split, 3),
                          _t63 = _o$split2[1],
                          _e31 = _o$split2[2];

                      c.push({
                        oid: _t63,
                        status: _e31
                      }), _e31 || (l = !0);
                    } else o.startsWith("NAK") && (f = !0, l = !0);

                    l && t({
                      shallows: s,
                      unshallows: u,
                      acks: c,
                      nak: f,
                      packfile: r,
                      progress: a
                    });
                  });
                }));

              case 3:
              case "end":
                return _context102.stop();
            }
          }
        }, t);
      }), (u = function u() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function s(t) {
            a(o, n, i, s, u, "next", t);
          }

          function u(t) {
            a(o, n, i, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return p;
      });
      var n = r(29),
          i = r(39),
          o = r(1),
          a = r(0),
          s = r(11),
          u = r(20),
          c = r(2),
          f = r(68),
          l = r(3);

      function d(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function h(t) {
        return function () {
          var e = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = t.apply(e, r);

            function a(t) {
              d(o, n, i, a, s, "next", t);
            }

            function s(t) {
              d(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        };
      }

      function p(t) {
        return g.apply(this, arguments);
      }

      function g() {
        return (g = h(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee86(_ref73) {
          var _ref73$core, t, e, _ref73$gitdir, r, _ref73$fs, f, d, p, g, _ref73$ourName, v, _ref73$baseName, w, _ref73$theirName, b, _ref73$dryRun, _, x, E, k, O, j, P;

          return regeneratorRuntime.wrap(function _callee86$(_context105) {
            while (1) {
              switch (_context105.prev = _context105.next) {
                case 0:
                  _ref73$core = _ref73.core, t = _ref73$core === void 0 ? "default" : _ref73$core, e = _ref73.dir, _ref73$gitdir = _ref73.gitdir, r = _ref73$gitdir === void 0 ? Object(c.a)(e, ".git") : _ref73$gitdir, _ref73$fs = _ref73.fs, f = _ref73$fs === void 0 ? l.a.get(t).get("fs") : _ref73$fs, d = _ref73.ourOid, p = _ref73.baseOid, g = _ref73.theirOid, _ref73$ourName = _ref73.ourName, v = _ref73$ourName === void 0 ? "ours" : _ref73$ourName, _ref73$baseName = _ref73.baseName, w = _ref73$baseName === void 0 ? "base" : _ref73$baseName, _ref73$theirName = _ref73.theirName, b = _ref73$theirName === void 0 ? "theirs" : _ref73$theirName, _ref73$dryRun = _ref73.dryRun, _ = _ref73$dryRun === void 0 ? !1 : _ref73$dryRun;
                  x = new o.a(f), E = Object(n.a)({
                    core: t,
                    dir: e,
                    gitdir: r,
                    fs: x,
                    ref: d
                  }), k = Object(n.a)({
                    core: t,
                    dir: e,
                    gitdir: r,
                    fs: x,
                    ref: p
                  }), O = Object(n.a)({
                    core: t,
                    dir: e,
                    gitdir: r,
                    fs: x,
                    ref: g
                  });
                  _context105.next = 4;
                  return Object(i.a)({
                    trees: [E, k, O],
                    map: (P = h(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee84(_ref74) {
                      var _ref75, t, e, n;

                      return regeneratorRuntime.wrap(function _callee84$(_context103) {
                        while (1) {
                          switch (_context103.prev = _context103.next) {
                            case 0:
                              _ref75 = _slicedToArray(_ref74, 3), t = _ref75[0], e = _ref75[1], n = _ref75[2];
                              _context103.next = 3;
                              return Promise.all([t.populateStat(), e.populateStat(), n.populateStat(), t.populateHash(), e.populateHash(), n.populateHash()]);

                            case 3:
                              _context103.t0 = "".concat(m(t, e), "-").concat(m(n, e));
                              _context103.next = _context103.t0 === "false-false" ? 6 : _context103.t0 === "false-true" ? 7 : _context103.t0 === "true-false" ? 8 : _context103.t0 === "true-true" ? 9 : 12;
                              break;

                            case 6:
                              return _context103.abrupt("return", {
                                mode: e.mode,
                                path: e.basename,
                                oid: e.oid,
                                type: e.type
                              });

                            case 7:
                              return _context103.abrupt("return", n.exists ? {
                                mode: n.mode,
                                path: n.basename,
                                oid: n.oid,
                                type: n.type
                              } : void 0);

                            case 8:
                              return _context103.abrupt("return", t.exists ? {
                                mode: t.mode,
                                path: t.basename,
                                oid: t.oid,
                                type: t.type
                              } : void 0);

                            case 9:
                              if (!("blob" === t.type && "blob" === e.type && "blob" === n.type)) {
                                _context103.next = 11;
                                break;
                              }

                              return _context103.abrupt("return", function (t) {
                                return y.apply(this, arguments);
                              }({
                                fs: x,
                                gitdir: r,
                                ours: t,
                                base: e,
                                theirs: n,
                                ourName: v,
                                baseName: w,
                                theirName: b
                              }));

                            case 11:
                              throw new a.b(a.a.MergeNotSupportedFail);

                            case 12:
                            case "end":
                              return _context103.stop();
                          }
                        }
                      }, _callee84);
                    })), function (t) {
                      return P.apply(this, arguments);
                    }),
                    reduce: (j = h(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee85(t, e) {
                      var n, _e32, _i11;

                      return regeneratorRuntime.wrap(function _callee85$(_context104) {
                        while (1) {
                          switch (_context104.prev = _context104.next) {
                            case 0:
                              n = e.filter(Boolean);

                              if (!(!t || "tree" !== t.type || 0 !== n.length)) {
                                _context104.next = 9;
                                break;
                              }

                              if (!(n.length > 0)) {
                                _context104.next = 8;
                                break;
                              }

                              _e32 = new s.a(n).toObject();
                              _context104.next = 6;
                              return Object(u.a)({
                                fs: x,
                                gitdir: r,
                                type: "tree",
                                object: _e32,
                                dryRun: _
                              });

                            case 6:
                              _i11 = _context104.sent;
                              t.oid = _i11;

                            case 8:
                              return _context104.abrupt("return", t);

                            case 9:
                            case "end":
                              return _context104.stop();
                          }
                        }
                      }, _callee85);
                    })), function (t, e) {
                      return j.apply(this, arguments);
                    })
                  });

                case 4:
                  return _context105.abrupt("return", _context105.sent.oid);

                case 5:
                case "end":
                  return _context105.stop();
              }
            }
          }, _callee86);
        }))).apply(this, arguments);
      }

      function m(t, e) {
        return !(!t.exists || e.exists) || !(t.exists || !e.exists) || ("tree" !== t.type || "tree" !== e.type) && (t.type !== e.type || t.mode !== e.mode || t.oid !== e.oid);
      }

      function y() {
        return (y = h(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee87(_ref76) {
          var e, r, n, i, o, s, c, l, d, h, p, g, m, _Object, y, v;

          return regeneratorRuntime.wrap(function _callee87$(_context106) {
            while (1) {
              switch (_context106.prev = _context106.next) {
                case 0:
                  e = _ref76.fs, r = _ref76.gitdir, n = _ref76.ours, i = _ref76.base, o = _ref76.theirs, s = _ref76.ourName, c = _ref76.theirName, l = _ref76.baseName, d = _ref76.format, h = _ref76.markerSize, p = _ref76.dryRun;
                  g = i.basename, m = i.mode === n.mode ? o.mode : n.mode;

                  if (!(n.oid === o.oid)) {
                    _context106.next = 4;
                    break;
                  }

                  return _context106.abrupt("return", {
                    mode: m,
                    path: g,
                    oid: n.oid,
                    type: "blob"
                  });

                case 4:
                  if (!(n.oid === i.oid)) {
                    _context106.next = 6;
                    break;
                  }

                  return _context106.abrupt("return", {
                    mode: m,
                    path: g,
                    oid: o.oid,
                    type: "blob"
                  });

                case 6:
                  if (!(o.oid === i.oid)) {
                    _context106.next = 8;
                    break;
                  }

                  return _context106.abrupt("return", {
                    mode: m,
                    path: g,
                    oid: n.oid,
                    type: "blob"
                  });

                case 8:
                  _context106.next = 10;
                  return Promise.all([n.populateContent(), i.populateContent(), o.populateContent()]);

                case 10:
                  _Object = Object(f.a)({
                    ourContent: n.content.toString("utf8"),
                    baseContent: i.content.toString("utf8"),
                    theirContent: o.content.toString("utf8"),
                    ourName: s,
                    theirName: c,
                    baseName: l,
                    format: d,
                    markerSize: h
                  }), y = _Object.mergedText, v = _Object.cleanMerge;

                  if (v) {
                    _context106.next = 13;
                    break;
                  }

                  throw new a.b(a.a.MergeNotSupportedFail);

                case 13:
                  _context106.t0 = m;
                  _context106.t1 = g;
                  _context106.next = 17;
                  return Object(u.a)({
                    fs: e,
                    gitdir: r,
                    type: "blob",
                    object: t.from(y, "utf8"),
                    dryRun: p
                  });

                case 17:
                  _context106.t2 = _context106.sent;
                  return _context106.abrupt("return", {
                    mode: _context106.t0,
                    path: _context106.t1,
                    oid: _context106.t2,
                    type: "blob"
                  });

                case 19:
                case "end":
                  return _context106.stop();
              }
            }
          }, _callee87);
        }))).apply(this, arguments);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return p;
    });
    var n = r(4),
        i = r(30),
        o = r(1),
        a = r(14),
        s = r(7),
        u = r(0),
        c = r(5),
        f = r(2),
        l = r(3);

    function d(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function h(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            d(o, n, i, a, s, "next", t);
          }

          function s(t) {
            d(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function p(t) {
      return g.apply(this, arguments);
    }

    function g() {
      return (g = h(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee89(_ref77) {
        var _ref77$core, t, e, _ref77$gitdir, r, _ref77$fs, d, p, g, m, y, v, w, _iteratorNormalCompletion41, _didIteratorError41, _iteratorError41, _iterator41, _step41, _t65, _iteratorNormalCompletion42, _didIteratorError42, _iteratorError42, _iterator42, _step42, _t66, _e34, b, _, x, _iteratorNormalCompletion44, _didIteratorError44, _iteratorError44, _iterator44, _step44, _t67;

        return regeneratorRuntime.wrap(function _callee89$(_context108) {
          while (1) {
            switch (_context108.prev = _context108.next) {
              case 0:
                x = function _ref80() {
                  return (x = h(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee88(t) {
                    var _ref78, e, n, _e33, _iteratorNormalCompletion43, _didIteratorError43, _iteratorError43, _iterator43, _step43;

                    return regeneratorRuntime.wrap(function _callee88$(_context107) {
                      while (1) {
                        switch (_context107.prev = _context107.next) {
                          case 0:
                            b.add(t);
                            _context107.next = 3;
                            return Object(c.a)({
                              fs: m,
                              gitdir: r,
                              oid: t
                            });

                          case 3:
                            _ref78 = _context107.sent;
                            e = _ref78.type;
                            n = _ref78.object;

                            if (!("tag" === e)) {
                              _context107.next = 8;
                              break;
                            }

                            return _context107.abrupt("return", _(a.a.from(n).headers().object));

                          case 8:
                            if (!("commit" !== e)) {
                              _context107.next = 10;
                              break;
                            }

                            throw new u.b(u.a.ObjectTypeAssertionFail, {
                              oid: t,
                              type: e,
                              expected: "commit"
                            });

                          case 10:
                            if (y.has(t)) {
                              _context107.next = 40;
                              break;
                            }

                            _e33 = s.a.from(n).headers().parent;
                            _iteratorNormalCompletion43 = true;
                            _didIteratorError43 = false;
                            _iteratorError43 = undefined;
                            _context107.prev = 15;
                            _iterator43 = _e33[Symbol.iterator]();

                          case 17:
                            if (_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done) {
                              _context107.next = 26;
                              break;
                            }

                            t = _step43.value;
                            _context107.t0 = w.has(t) || b.has(t);

                            if (_context107.t0) {
                              _context107.next = 23;
                              break;
                            }

                            _context107.next = 23;
                            return _(t);

                          case 23:
                            _iteratorNormalCompletion43 = true;
                            _context107.next = 17;
                            break;

                          case 26:
                            _context107.next = 32;
                            break;

                          case 28:
                            _context107.prev = 28;
                            _context107.t1 = _context107["catch"](15);
                            _didIteratorError43 = true;
                            _iteratorError43 = _context107.t1;

                          case 32:
                            _context107.prev = 32;
                            _context107.prev = 33;

                            if (!_iteratorNormalCompletion43 && _iterator43.return != null) {
                              _iterator43.return();
                            }

                          case 35:
                            _context107.prev = 35;

                            if (!_didIteratorError43) {
                              _context107.next = 38;
                              break;
                            }

                            throw _iteratorError43;

                          case 38:
                            return _context107.finish(35);

                          case 39:
                            return _context107.finish(32);

                          case 40:
                          case "end":
                            return _context107.stop();
                        }
                      }
                    }, _callee88, null, [[15, 28, 32, 40], [33,, 35, 39]]);
                  }))).apply(this, arguments);
                };

                _ = function _ref79(t) {
                  return x.apply(this, arguments);
                };

                _ref77$core = _ref77.core, t = _ref77$core === void 0 ? "default" : _ref77$core, e = _ref77.dir, _ref77$gitdir = _ref77.gitdir, r = _ref77$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref77$gitdir, _ref77$fs = _ref77.fs, d = _ref77$fs === void 0 ? l.a.get(t).get("fs") : _ref77$fs, p = _ref77.start, g = _ref77.finish;
                m = new o.a(d);
                _context108.next = 6;
                return i.a.read({
                  fs: m,
                  gitdir: r
                });

              case 6:
                y = _context108.sent;
                v = new Set();
                w = new Set();
                _iteratorNormalCompletion41 = true;
                _didIteratorError41 = false;
                _iteratorError41 = undefined;
                _context108.prev = 12;
                _iterator41 = p[Symbol.iterator]();

              case 14:
                if (_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done) {
                  _context108.next = 24;
                  break;
                }

                _t65 = _step41.value;
                _context108.t0 = v;
                _context108.next = 19;
                return n.a.resolve({
                  fs: m,
                  gitdir: r,
                  ref: _t65
                });

              case 19:
                _context108.t1 = _context108.sent;

                _context108.t0.add.call(_context108.t0, _context108.t1);

              case 21:
                _iteratorNormalCompletion41 = true;
                _context108.next = 14;
                break;

              case 24:
                _context108.next = 30;
                break;

              case 26:
                _context108.prev = 26;
                _context108.t2 = _context108["catch"](12);
                _didIteratorError41 = true;
                _iteratorError41 = _context108.t2;

              case 30:
                _context108.prev = 30;
                _context108.prev = 31;

                if (!_iteratorNormalCompletion41 && _iterator41.return != null) {
                  _iterator41.return();
                }

              case 33:
                _context108.prev = 33;

                if (!_didIteratorError41) {
                  _context108.next = 36;
                  break;
                }

                throw _iteratorError41;

              case 36:
                return _context108.finish(33);

              case 37:
                return _context108.finish(30);

              case 38:
                _iteratorNormalCompletion42 = true;
                _didIteratorError42 = false;
                _iteratorError42 = undefined;
                _context108.prev = 41;
                _iterator42 = g[Symbol.iterator]();

              case 43:
                if (_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done) {
                  _context108.next = 57;
                  break;
                }

                _t66 = _step42.value;
                _context108.prev = 45;
                _context108.next = 48;
                return n.a.resolve({
                  fs: m,
                  gitdir: r,
                  ref: _t66
                });

              case 48:
                _e34 = _context108.sent;
                w.add(_e34);
                _context108.next = 54;
                break;

              case 52:
                _context108.prev = 52;
                _context108.t3 = _context108["catch"](45);

              case 54:
                _iteratorNormalCompletion42 = true;
                _context108.next = 43;
                break;

              case 57:
                _context108.next = 63;
                break;

              case 59:
                _context108.prev = 59;
                _context108.t4 = _context108["catch"](41);
                _didIteratorError42 = true;
                _iteratorError42 = _context108.t4;

              case 63:
                _context108.prev = 63;
                _context108.prev = 64;

                if (!_iteratorNormalCompletion42 && _iterator42.return != null) {
                  _iterator42.return();
                }

              case 66:
                _context108.prev = 66;

                if (!_didIteratorError42) {
                  _context108.next = 69;
                  break;
                }

                throw _iteratorError42;

              case 69:
                return _context108.finish(66);

              case 70:
                return _context108.finish(63);

              case 71:
                b = new Set();
                _iteratorNormalCompletion44 = true;
                _didIteratorError44 = false;
                _iteratorError44 = undefined;
                _context108.prev = 75;
                _iterator44 = v[Symbol.iterator]();

              case 77:
                if (_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done) {
                  _context108.next = 84;
                  break;
                }

                _t67 = _step44.value;
                _context108.next = 81;
                return _(_t67);

              case 81:
                _iteratorNormalCompletion44 = true;
                _context108.next = 77;
                break;

              case 84:
                _context108.next = 90;
                break;

              case 86:
                _context108.prev = 86;
                _context108.t5 = _context108["catch"](75);
                _didIteratorError44 = true;
                _iteratorError44 = _context108.t5;

              case 90:
                _context108.prev = 90;
                _context108.prev = 91;

                if (!_iteratorNormalCompletion44 && _iterator44.return != null) {
                  _iterator44.return();
                }

              case 93:
                _context108.prev = 93;

                if (!_didIteratorError44) {
                  _context108.next = 96;
                  break;
                }

                throw _iteratorError44;

              case 96:
                return _context108.finish(93);

              case 97:
                return _context108.finish(90);

              case 98:
                return _context108.abrupt("return", b);

              case 99:
              case "end":
                return _context108.stop();
            }
          }
        }, _callee89, null, [[12, 26, 30, 38], [31,, 33, 37], [41, 59, 63, 71], [45, 52], [64,, 66, 70], [75, 86, 90, 98], [91,, 93, 97]]);
      }))).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return d;
    });
    var n = r(1),
        i = r(14),
        o = r(7),
        a = r(11),
        s = r(5),
        u = r(2),
        c = r(3);

    function f(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function l(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            f(o, n, i, a, s, "next", t);
          }

          function s(t) {
            f(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function d(t) {
      return h.apply(this, arguments);
    }

    function h() {
      return (h = l(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee91(_ref81) {
        var _ref81$core, t, e, _ref81$gitdir, r, _ref81$fs, f, d, h, p, g, m, _iteratorNormalCompletion46, _didIteratorError46, _iteratorError46, _iterator46, _step46, _t71;

        return regeneratorRuntime.wrap(function _callee91$(_context110) {
          while (1) {
            switch (_context110.prev = _context110.next) {
              case 0:
                m = function _ref84() {
                  return (m = l(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee90(t) {
                    var _ref82, e, n, _t68, _t69, _t70, _iteratorNormalCompletion45, _didIteratorError45, _iteratorError45, _iterator45, _step45, _e35;

                    return regeneratorRuntime.wrap(function _callee90$(_context109) {
                      while (1) {
                        switch (_context109.prev = _context109.next) {
                          case 0:
                            p.add(t);
                            _context109.next = 3;
                            return Object(s.a)({
                              fs: h,
                              gitdir: r,
                              oid: t
                            });

                          case 3:
                            _ref82 = _context109.sent;
                            e = _ref82.type;
                            n = _ref82.object;

                            if (!("tag" === e)) {
                              _context109.next = 12;
                              break;
                            }

                            _t68 = i.a.from(n).headers().object;
                            _context109.next = 10;
                            return g(_t68);

                          case 10:
                            _context109.next = 49;
                            break;

                          case 12:
                            if (!("commit" === e)) {
                              _context109.next = 18;
                              break;
                            }

                            _t69 = o.a.from(n).headers().tree;
                            _context109.next = 16;
                            return g(_t69);

                          case 16:
                            _context109.next = 49;
                            break;

                          case 18:
                            if (!("tree" === e)) {
                              _context109.next = 49;
                              break;
                            }

                            _t70 = a.a.from(n);
                            _iteratorNormalCompletion45 = true;
                            _didIteratorError45 = false;
                            _iteratorError45 = undefined;
                            _context109.prev = 23;
                            _iterator45 = _t70[Symbol.iterator]();

                          case 25:
                            if (_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done) {
                              _context109.next = 35;
                              break;
                            }

                            _e35 = _step45.value;
                            "blob" !== _e35.type && "tree" !== _e35.type || p.add(_e35.oid);
                            _context109.t0 = "tree" === _e35.type;

                            if (!_context109.t0) {
                              _context109.next = 32;
                              break;
                            }

                            _context109.next = 32;
                            return g(_e35.oid);

                          case 32:
                            _iteratorNormalCompletion45 = true;
                            _context109.next = 25;
                            break;

                          case 35:
                            _context109.next = 41;
                            break;

                          case 37:
                            _context109.prev = 37;
                            _context109.t1 = _context109["catch"](23);
                            _didIteratorError45 = true;
                            _iteratorError45 = _context109.t1;

                          case 41:
                            _context109.prev = 41;
                            _context109.prev = 42;

                            if (!_iteratorNormalCompletion45 && _iterator45.return != null) {
                              _iterator45.return();
                            }

                          case 44:
                            _context109.prev = 44;

                            if (!_didIteratorError45) {
                              _context109.next = 47;
                              break;
                            }

                            throw _iteratorError45;

                          case 47:
                            return _context109.finish(44);

                          case 48:
                            return _context109.finish(41);

                          case 49:
                          case "end":
                            return _context109.stop();
                        }
                      }
                    }, _callee90, null, [[23, 37, 41, 49], [42,, 44, 48]]);
                  }))).apply(this, arguments);
                };

                g = function _ref83(t) {
                  return m.apply(this, arguments);
                };

                _ref81$core = _ref81.core, t = _ref81$core === void 0 ? "default" : _ref81$core, e = _ref81.dir, _ref81$gitdir = _ref81.gitdir, r = _ref81$gitdir === void 0 ? Object(u.a)(e, ".git") : _ref81$gitdir, _ref81$fs = _ref81.fs, f = _ref81$fs === void 0 ? c.a.get(t).get("fs") : _ref81$fs, d = _ref81.oids;
                h = new n.a(f), p = new Set();
                _iteratorNormalCompletion46 = true;
                _didIteratorError46 = false;
                _iteratorError46 = undefined;
                _context110.prev = 7;
                _iterator46 = d[Symbol.iterator]();

              case 9:
                if (_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done) {
                  _context110.next = 16;
                  break;
                }

                _t71 = _step46.value;
                _context110.next = 13;
                return g(_t71);

              case 13:
                _iteratorNormalCompletion46 = true;
                _context110.next = 9;
                break;

              case 16:
                _context110.next = 22;
                break;

              case 18:
                _context110.prev = 18;
                _context110.t0 = _context110["catch"](7);
                _didIteratorError46 = true;
                _iteratorError46 = _context110.t0;

              case 22:
                _context110.prev = 22;
                _context110.prev = 23;

                if (!_iteratorNormalCompletion46 && _iterator46.return != null) {
                  _iterator46.return();
                }

              case 25:
                _context110.prev = 25;

                if (!_didIteratorError46) {
                  _context110.next = 28;
                  break;
                }

                throw _iteratorError46;

              case 28:
                return _context110.finish(25);

              case 29:
                return _context110.finish(22);

              case 30:
                return _context110.abrupt("return", p);

              case 31:
              case "end":
                return _context110.stop();
            }
          }
        }, _callee91, null, [[7, 18, 22, 30], [23,, 25, 29]]);
      }))).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return o;
    });
    var n = r(9);

    function i(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function o(t) {
      return a.apply(this, arguments);
    }

    function a() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref85) {
        var _ref85$capabilities, t, _ref85$triplets, e, r, i, _iteratorNormalCompletion47, _didIteratorError47, _iteratorError47, _iterator47, _step47, _t72;

        return regeneratorRuntime.wrap(function t$(_context111) {
          while (1) {
            switch (_context111.prev = _context111.next) {
              case 0:
                _ref85$capabilities = _ref85.capabilities, t = _ref85$capabilities === void 0 ? [] : _ref85$capabilities, _ref85$triplets = _ref85.triplets, e = _ref85$triplets === void 0 ? [] : _ref85$triplets;
                r = [];
                i = "\0 ".concat(t.join(" "));
                _iteratorNormalCompletion47 = true;
                _didIteratorError47 = false;
                _iteratorError47 = undefined;
                _context111.prev = 6;

                for (_iterator47 = e[Symbol.iterator](); !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {
                  _t72 = _step47.value;
                  r.push(n.a.encode("".concat(_t72.oldoid, " ").concat(_t72.oid, " ").concat(_t72.fullRef).concat(i, "\n"))), i = "";
                }

                _context111.next = 14;
                break;

              case 10:
                _context111.prev = 10;
                _context111.t0 = _context111["catch"](6);
                _didIteratorError47 = true;
                _iteratorError47 = _context111.t0;

              case 14:
                _context111.prev = 14;
                _context111.prev = 15;

                if (!_iteratorNormalCompletion47 && _iterator47.return != null) {
                  _iterator47.return();
                }

              case 17:
                _context111.prev = 17;

                if (!_didIteratorError47) {
                  _context111.next = 20;
                  break;
                }

                throw _iteratorError47;

              case 20:
                return _context111.finish(17);

              case 21:
                return _context111.finish(14);

              case 22:
                return _context111.abrupt("return", (r.push(n.a.flush()), r));

              case 23:
              case "end":
                return _context111.stop();
            }
          }
        }, t, null, [[6, 10, 14, 22], [15,, 17, 21]]);
      }), (a = function a() {
        var e = this,
            r = arguments;
        return new Promise(function (n, o) {
          var a = t.apply(e, r);

          function s(t) {
            i(a, n, o, s, u, "next", t);
          }

          function u(t) {
            i(a, n, o, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return a;
    });
    var n = r(0),
        i = r(9);

    function o(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function a(t) {
      return s.apply(this, arguments);
    }

    function s() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_t74) {
        var e, r, o, a, s, _iteratorNormalCompletion48, _didIteratorError48, _iteratorError48, _iterator48, _step48, _t73, _r30, _n19;

        return regeneratorRuntime.wrap(function t$(_context112) {
          while (1) {
            switch (_context112.prev = _context112.next) {
              case 0:
                e = {};
                r = "";
                o = i.a.streamReader(_t74);
                _context112.next = 5;
                return o();

              case 5:
                a = _context112.sent;

              case 6:
                if (!(!0 !== a)) {
                  _context112.next = 13;
                  break;
                }

                null !== a && (r += a.toString("utf8") + "\n");
                _context112.next = 10;
                return o();

              case 10:
                a = _context112.sent;

              case 11:
                _context112.next = 6;
                break;

              case 13:
                s = r.toString("utf8").split("\n");

                if ((a = s.shift()).startsWith("unpack ")) {
                  _context112.next = 16;
                  break;
                }

                throw new n.b(n.a.UnparseableServerResponseFail, {
                  line: a
                });

              case 16:
                "unpack ok" === a ? e.ok = ["unpack"] : e.errors = [a.trim()];
                _iteratorNormalCompletion48 = true;
                _didIteratorError48 = false;
                _iteratorError48 = undefined;
                _context112.prev = 20;

                for (_iterator48 = s[Symbol.iterator](); !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {
                  _t73 = _step48.value;
                  _r30 = _t73.slice(0, 2), _n19 = _t73.slice(3);
                  "ok" === _r30 ? (e.ok = e.ok || [], e.ok.push(_n19)) : "ng" === _r30 && (e.errors = e.errors || [], e.errors.push(_n19));
                }

                _context112.next = 28;
                break;

              case 24:
                _context112.prev = 24;
                _context112.t0 = _context112["catch"](20);
                _didIteratorError48 = true;
                _iteratorError48 = _context112.t0;

              case 28:
                _context112.prev = 28;
                _context112.prev = 29;

                if (!_iteratorNormalCompletion48 && _iterator48.return != null) {
                  _iterator48.return();
                }

              case 31:
                _context112.prev = 31;

                if (!_didIteratorError48) {
                  _context112.next = 34;
                  break;
                }

                throw _iteratorError48;

              case 34:
                return _context112.finish(31);

              case 35:
                return _context112.finish(28);

              case 36:
                return _context112.abrupt("return", e);

              case 37:
              case "end":
                return _context112.stop();
            }
          }
        }, t, null, [[20, 24, 28, 36], [29,, 31, 35]]);
      }), (s = function s() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var a = t.apply(e, r);

          function s(t) {
            o(a, n, i, s, u, "next", t);
          }

          function u(t) {
            o(a, n, i, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    function n(t, e) {
      if (void 0 === e) {
        var _r31 = t.indexOf(":");

        _r31 > -1 ? (e = t.slice(_r31 + 1), t = t.slice(0, _r31)) : e = "";
      }

      return {
        username: t,
        password: e
      };
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    (function (e) {
      function r(t) {
        return Array.isArray(t) ? t : [t];
      }

      var n = /^\s+$/,
          i = /^\\!/,
          o = /^\\#/,
          a = /\r?\n/g,
          s = /^\.*\/|^\.+$/,
          u = "/",
          c = "undefined" != typeof Symbol ? Symbol.for("node-ignore") : "node-ignore",
          f = function f(t, e, r) {
        return Object.defineProperty(t, e, {
          value: r
        });
      },
          l = /([0-z])-([0-z])/g,
          d = [[/\\?\s+$/, function (t) {
        return 0 === t.indexOf("\\") ? " " : "";
      }], [/\\\s/g, function () {
        return " ";
      }], [/[\\^$.|*+(){]/g, function (t) {
        return "\\".concat(t);
      }], [/\[([^\]\/]*)($|\])/g, function (t, e, r) {
        return "]" === r ? "[".concat(function (t) {
          return t.replace(l, function (t, e, r) {
            return e.charCodeAt(0) <= r.charCodeAt(0) ? t : "";
          });
        }(e), "]") : "\\".concat(t);
      }], [/(?!\\)\?/g, function () {
        return "[^/]";
      }], [/^\//, function () {
        return "^";
      }], [/\//g, function () {
        return "\\/";
      }], [/^\^*\\\*\\\*\\\//, function () {
        return "^(?:.*\\/)?";
      }], [/(?:[^*])$/, function (t) {
        return /\/$/.test(t) ? "".concat(t, "$") : "".concat(t, "(?=$|\\/$)");
      }], [/^(?=[^^])/, function () {
        return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
      }], [/\\\/\\\*\\\*(?=\\\/|$)/g, function (t, e, r) {
        return e + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+";
      }], [/(^|[^\\]+)\\\*(?=.+)/g, function (t, e) {
        return "".concat(e, "[^\\/]*");
      }], [/(\^|\\\/)?\\\*$/, function (t, e) {
        return "".concat(e ? "".concat(e, "[^/]+") : "[^/]*", "(?=$|\\/$)");
      }], [/\\\\\\/g, function () {
        return "\\";
      }]],
          h = Object.create(null),
          p = function p(t) {
        return "string" == typeof t;
      },
          g = function g(t) {
        return t && p(t) && !n.test(t) && 0 !== t.indexOf("#");
      },
          m = function m(t) {
        return t.split(a);
      };

      var y = function y(t, e, r, n) {
        _classCallCheck(this, y);

        this.origin = t, this.pattern = e, this.negative = r, this.regex = n;
      };

      var v = function v(t, e) {
        var r = t;
        var n = !1;
        0 === t.indexOf("!") && (n = !0, t = t.substr(1));

        var a = function (t, e, r) {
          var n = h[t];
          if (n) return n;
          var i = d.reduce(function (e, r) {
            return e.replace(r[0], r[1].bind(t));
          }, t);
          return h[t] = r ? new RegExp(i, "i") : new RegExp(i);
        }(t = t.replace(i, "!").replace(o, "#"), 0, e);

        return new y(r, t, n, a);
      },
          w = function w(t, e) {
        throw new e(t);
      },
          b = function b(t, e, r) {
        if (!p(t)) return r("path must be a string, but got `".concat(e, "`"), TypeError);
        if (!t) return r("path must not be empty", TypeError);

        if (b.isNotRelative(t)) {
          return r("path should be a ".concat("`path.relative()`d", " string, but got \"", e, "\""), RangeError);
        }

        return !0;
      },
          _ = function _(t) {
        return s.test(t);
      };

      b.isNotRelative = _, b.convert = function (t) {
        return t;
      };

      var x =
      /*#__PURE__*/
      function () {
        function x() {
          var _ref86 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref86$ignorecase = _ref86.ignorecase,
              t = _ref86$ignorecase === void 0 ? !0 : _ref86$ignorecase;

          _classCallCheck(this, x);

          this._rules = [], this._ignorecase = t, f(this, c, !0), this._initCache();
        }

        _createClass(x, [{
          key: "_initCache",
          value: function _initCache() {
            this._ignoreCache = Object.create(null), this._testCache = Object.create(null);
          }
        }, {
          key: "_addPattern",
          value: function _addPattern(t) {
            if (t && t[c]) return this._rules = this._rules.concat(t._rules), void (this._added = !0);

            if (g(t)) {
              var _e36 = v(t, this._ignorecase);

              this._added = !0, this._rules.push(_e36);
            }
          }
        }, {
          key: "add",
          value: function add(t) {
            return this._added = !1, r(p(t) ? m(t) : t).forEach(this._addPattern, this), this._added && this._initCache(), this;
          }
        }, {
          key: "addPattern",
          value: function addPattern(t) {
            return this.add(t);
          }
        }, {
          key: "_testOne",
          value: function _testOne(t, e) {
            var r = !1,
                n = !1;
            return this._rules.forEach(function (i) {
              var o = i.negative;
              n === o && r !== n || o && !r && !n && !e || i.regex.test(t) && (r = !o, n = o);
            }), {
              ignored: r,
              unignored: n
            };
          }
        }, {
          key: "_test",
          value: function _test(t, e, r, n) {
            var i = t && b.convert(t);
            return b(i, t, w), this._t(i, e, r, n);
          }
        }, {
          key: "_t",
          value: function _t(t, e, r, n) {
            if (t in e) return e[t];
            if (n || (n = t.split(u)), n.pop(), !n.length) return e[t] = this._testOne(t, r);

            var i = this._t(n.join(u) + u, e, r, n);

            return e[t] = i.ignored ? i : this._testOne(t, r);
          }
        }, {
          key: "ignores",
          value: function ignores(t) {
            return this._test(t, this._ignoreCache, !1).ignored;
          }
        }, {
          key: "createFilter",
          value: function createFilter() {
            var _this4 = this;

            return function (t) {
              return !_this4.ignores(t);
            };
          }
        }, {
          key: "filter",
          value: function filter(t) {
            return r(t).filter(this.createFilter());
          }
        }, {
          key: "test",
          value: function test(t) {
            return this._test(t, this._testCache, !0);
          }
        }]);

        return x;
      }();

      var E = function E(t) {
        return new x(t);
      },
          k = function k() {
        return !1;
      };

      if (E.isPathValid = function (t) {
        return b(t && b.convert(t), t, k);
      }, E.default = E, t.exports = E, void 0 !== e && (e.env && e.env.IGNORE_TEST_WIN32 || "win32" === e.platform)) {
        var _t75 = function _t75(t) {
          return /^\\\\\?\\/.test(t) || /[\0-\x1F"<>\|]+/.test(t) ? t : t.replace(/\\/g, "/");
        };

        b.convert = _t75;
        var _e37 = /^[a-z]:\//i;

        b.isNotRelative = function (t) {
          return _e37.test(t) || _(t);
        };
      }
    }).call(this, r(47));
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return a;
    });
    var n = r(1),
        i = r(0);

    function o(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function a(t) {
      return s.apply(this, arguments);
    }

    function s() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref87) {
        var t, e, r, o, a, s, u, c;
        return regeneratorRuntime.wrap(function t$(_context113) {
          while (1) {
            switch (_context113.prev = _context113.next) {
              case 0:
                t = _ref87.fs, e = _ref87.gitdir, r = _ref87.type, o = _ref87.object, a = _ref87.format, s = _ref87.oid;
                u = new n.a(t);

                if (!("deflated" !== a)) {
                  _context113.next = 4;
                  break;
                }

                throw new i.b(i.a.InternalFail, {
                  message: "GitObjectStoreLoose expects objects to write to be in deflated format"
                });

              case 4:
                c = "".concat(e, "/", "objects/".concat(s.slice(0, 2), "/").concat(s.slice(2)));
                _context113.next = 7;
                return u.exists(c);

              case 7:
                _context113.t0 = _context113.sent;

                if (_context113.t0) {
                  _context113.next = 11;
                  break;
                }

                _context113.next = 11;
                return u.write(c, o);

              case 11:
              case "end":
                return _context113.stop();
            }
          }
        }, t);
      }), (s = function s() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var a = t.apply(e, r);

          function s(t) {
            o(a, n, i, s, u, "next", t);
          }

          function u(t) {
            o(a, n, i, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return o;
    });
    var n = r(1);

    function i(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function o(t) {
      return a.apply(this, arguments);
    }

    function a() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref88) {
        var t, e, r, i, o, a;
        return regeneratorRuntime.wrap(function t$(_context114) {
          while (1) {
            switch (_context114.prev = _context114.next) {
              case 0:
                t = _ref88.fs, e = _ref88.gitdir, r = _ref88.oid;
                i = new n.a(t);
                o = "objects/".concat(r.slice(0, 2), "/").concat(r.slice(2));
                _context114.next = 5;
                return i.read("".concat(e, "/").concat(o));

              case 5:
                a = _context114.sent;
                return _context114.abrupt("return", a ? {
                  object: a,
                  format: "deflated",
                  source: o
                } : null);

              case 7:
              case "end":
                return _context114.stop();
            }
          }
        }, t);
      }), (a = function a() {
        var e = this,
            r = arguments;
        return new Promise(function (n, o) {
          var a = t.apply(e, r);

          function s(t) {
            i(a, n, o, s, u, "next", t);
          }

          function u(t) {
            i(a, n, o, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return u;
    });
    var n = r(1),
        i = r(0),
        o = r(54),
        a = r(2);

    function s(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function u(t) {
      return c.apply(this, arguments);
    }

    function c() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref89) {
        var t, e, r, _ref89$format, s, u, c, f, _iteratorNormalCompletion49, _didIteratorError49, _iteratorError49, _iterator49, _step49, _t76, _n20, _a5, _t77, _e38;

        return regeneratorRuntime.wrap(function t$(_context115) {
          while (1) {
            switch (_context115.prev = _context115.next) {
              case 0:
                t = _ref89.fs, e = _ref89.gitdir, r = _ref89.oid, _ref89$format = _ref89.format, s = _ref89$format === void 0 ? "content" : _ref89$format, u = _ref89.getExternalRefDelta;
                c = new n.a(t);
                _context115.next = 4;
                return c.readdir(Object(a.a)(e, "objects/pack"));

              case 4:
                f = _context115.sent;
                f = f.filter(function (t) {
                  return t.endsWith(".idx");
                });
                _iteratorNormalCompletion49 = true;
                _didIteratorError49 = false;
                _iteratorError49 = undefined;
                _context115.prev = 9;
                _iterator49 = f[Symbol.iterator]();

              case 11:
                if (_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done) {
                  _context115.next = 28;
                  break;
                }

                _t76 = _step49.value;
                _n20 = "".concat(e, "/objects/pack/").concat(_t76);
                _context115.next = 16;
                return Object(o.a)({
                  fs: c,
                  filename: _n20,
                  getExternalRefDelta: u
                });

              case 16:
                _a5 = _context115.sent;

                if (!_a5.error) {
                  _context115.next = 19;
                  break;
                }

                throw new i.b(i.a.InternalFail, {
                  message: _a5.error
                });

              case 19:
                if (!_a5.offsets.has(r)) {
                  _context115.next = 25;
                  break;
                }

                if (!_a5.pack) {
                  _t77 = _n20.replace(/idx$/, "pack");
                  _a5.pack = c.read(_t77);
                }

                _context115.next = 23;
                return _a5.read({
                  oid: r,
                  getExternalRefDelta: u
                });

              case 23:
                _e38 = _context115.sent;
                return _context115.abrupt("return", (_e38.format = "content", _e38.source = "objects/pack/".concat(_t76.replace(/idx$/, "pack")), _e38));

              case 25:
                _iteratorNormalCompletion49 = true;
                _context115.next = 11;
                break;

              case 28:
                _context115.next = 34;
                break;

              case 30:
                _context115.prev = 30;
                _context115.t0 = _context115["catch"](9);
                _didIteratorError49 = true;
                _iteratorError49 = _context115.t0;

              case 34:
                _context115.prev = 34;
                _context115.prev = 35;

                if (!_iteratorNormalCompletion49 && _iterator49.return != null) {
                  _iterator49.return();
                }

              case 37:
                _context115.prev = 37;

                if (!_didIteratorError49) {
                  _context115.next = 40;
                  break;
                }

                throw _iteratorError49;

              case 40:
                return _context115.finish(37);

              case 41:
                return _context115.finish(34);

              case 42:
                return _context115.abrupt("return", null);

              case 43:
              case "end":
                return _context115.stop();
            }
          }
        }, t, null, [[9, 30, 34, 42], [35,, 37, 41]]);
      }), (c = function c() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            s(o, n, i, a, u, "next", t);
          }

          function u(t) {
            s(o, n, i, a, u, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    var n;
    n = function n(t) {
      t.version = "1.2.0";

      var e = function () {
        for (var t = 0, e = new Array(256), r = 0; 256 != r; ++r) {
          t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = r) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1, e[r] = t;
        }

        return "undefined" != typeof Int32Array ? new Int32Array(e) : e;
      }();

      t.table = e, t.bstr = function (t, r) {
        for (var n = -1 ^ r, i = t.length - 1, o = 0; o < i;) {
          n = (n = n >>> 8 ^ e[255 & (n ^ t.charCodeAt(o++))]) >>> 8 ^ e[255 & (n ^ t.charCodeAt(o++))];
        }

        return o === i && (n = n >>> 8 ^ e[255 & (n ^ t.charCodeAt(o))]), -1 ^ n;
      }, t.buf = function (t, r) {
        if (t.length > 1e4) return function (t, r) {
          for (var n = -1 ^ r, i = t.length - 7, o = 0; o < i;) {
            n = (n = (n = (n = (n = (n = (n = (n = n >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])];
          }

          for (; o < i + 7;) {
            n = n >>> 8 ^ e[255 & (n ^ t[o++])];
          }

          return -1 ^ n;
        }(t, r);

        for (var n = -1 ^ r, i = t.length - 3, o = 0; o < i;) {
          n = (n = (n = (n = n >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])]) >>> 8 ^ e[255 & (n ^ t[o++])];
        }

        for (; o < i + 3;) {
          n = n >>> 8 ^ e[255 & (n ^ t[o++])];
        }

        return -1 ^ n;
      }, t.str = function (t, r) {
        for (var n, i, o = -1 ^ r, a = 0, s = t.length; a < s;) {
          (n = t.charCodeAt(a++)) < 128 ? o = o >>> 8 ^ e[255 & (o ^ n)] : n < 2048 ? o = (o = o >>> 8 ^ e[255 & (o ^ (192 | n >> 6 & 31))]) >>> 8 ^ e[255 & (o ^ (128 | 63 & n))] : n >= 55296 && n < 57344 ? (n = 64 + (1023 & n), i = 1023 & t.charCodeAt(a++), o = (o = (o = (o = o >>> 8 ^ e[255 & (o ^ (240 | n >> 8 & 7))]) >>> 8 ^ e[255 & (o ^ (128 | n >> 2 & 63))]) >>> 8 ^ e[255 & (o ^ (128 | i >> 6 & 15 | (3 & n) << 4))]) >>> 8 ^ e[255 & (o ^ (128 | 63 & i))]) : o = (o = (o = o >>> 8 ^ e[255 & (o ^ (224 | n >> 12 & 15))]) >>> 8 ^ e[255 & (o ^ (128 | n >> 6 & 63))]) >>> 8 ^ e[255 & (o ^ (128 | 63 & n))];
        }

        return -1 ^ o;
      };
    }, "undefined" == typeof DO_NOT_EXPORT_CRC ? n(e) : n({});
  }, function (t, e, r) {
    t.exports = function (t, e) {
      var r,
          i,
          u,
          c,
          f,
          l = {
        size: null,
        buffer: null
      },
          d = {
        size: null,
        buffer: null
      };
      s(t, l), s(l.buffer, d), t = d.buffer, f = i = 0, r = n.create(d.size), c = t.length;

      for (; f < c;) {
        128 & (u = t[f++]) ? h() : p();
      }

      return r;

      function h() {
        n.writeUInt32LE(o, 0, 0), n.writeUInt32LE(a, 0, 0);

        for (var s, c, l = 1, d = 0; d < 4; ++d) {
          u & l && (o[3 - d] = t[f++]), l <<= 1;
        }

        for (d = 0; d < 3; ++d) {
          u & l && (a[3 - d] = t[f++]), l <<= 1;
        }

        a[0] = 0, s = n.readUInt32BE(a, 0) || 65536, c = n.readUInt32BE(o, 0), n.copy(e, r, i, c, c + s), i += s;
      }

      function p() {
        n.copy(t, r, i, f, u + f), f += u, i += u;
      }
    };

    var n = r(112),
        i = new (r(123))(),
        o = n.create(4),
        a = n.create(4);

    function s(t, e) {
      var r = !1,
          o = 0,
          a = 0;

      i.ondata = function (t) {
        a = t, r = !0;
      };

      do {
        i.write(t[o++]);
      } while (!r);

      e.size = a, e.buffer = n.subarray(t, o);
    }
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return l;
      });
      var n = r(18),
          i = r.n(n),
          o = r(31),
          a = r.n(o),
          s = r(0),
          u = r(55);

      function c(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function f(t) {
        return function () {
          var e = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = t.apply(e, r);

            function a(t) {
              c(o, n, i, a, s, "next", t);
            }

            function s(t) {
              c(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        };
      }

      function l(t, e) {
        return d.apply(this, arguments);
      }

      function d() {
        return (d = f(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee92(t, e) {
          var r, n, o, c, f, _t78, _ref90, _o14, _a6, _u2, _c3, _l2, _i12, _d2, _h;

          return regeneratorRuntime.wrap(function _callee92$(_context116) {
            while (1) {
              switch (_context116.prev = _context116.next) {
                case 0:
                  r = new u.a(t), n = new a.a();
                  _context116.next = 3;
                  return r.read(4);

                case 3:
                  o = _context116.sent;

                  if (!(n.update(o), "PACK" !== (o = o.toString("utf8")))) {
                    _context116.next = 6;
                    break;
                  }

                  throw new s.b(s.a.InternalFail, {
                    message: "Invalid PACK header '".concat(o, "'")
                  });

                case 6:
                  _context116.next = 8;
                  return r.read(4);

                case 8:
                  c = _context116.sent;

                  if (!(n.update(c), 2 !== (c = c.readUInt32BE(0)))) {
                    _context116.next = 11;
                    break;
                  }

                  throw new s.b(s.a.InternalFail, {
                    message: "Invalid packfile version: ".concat(c)
                  });

                case 11:
                  _context116.next = 13;
                  return r.read(4);

                case 13:
                  f = _context116.sent;

                  if (!(n.update(f), !((f = f.readUInt32BE(0)) < 1))) {
                    _context116.next = 51;
                    break;
                  }

                case 15:
                  if (!(!r.eof() && f--)) {
                    _context116.next = 51;
                    break;
                  }

                  _t78 = r.tell();
                  _context116.next = 19;
                  return h(r, n);

                case 19:
                  _ref90 = _context116.sent;
                  _o14 = _ref90.type;
                  _a6 = _ref90.length;
                  _u2 = _ref90.ofs;
                  _c3 = _ref90.reference;
                  _l2 = new i.a.Inflate();

                case 25:
                  if (_l2.result) {
                    _context116.next = 49;
                    break;
                  }

                  _context116.next = 28;
                  return r.chunk();

                case 28:
                  _i12 = _context116.sent;

                  if (!r.ended) {
                    _context116.next = 31;
                    break;
                  }

                  return _context116.abrupt("break", 49);

                case 31:
                  if (!(_l2.push(_i12, !1), _l2.err)) {
                    _context116.next = 33;
                    break;
                  }

                  throw new s.b(s.a.InternalFail, {
                    message: "Pako error: ".concat(_l2.msg)
                  });

                case 33:
                  if (!_l2.result) {
                    _context116.next = 46;
                    break;
                  }

                  if (!(_l2.result.length !== _a6)) {
                    _context116.next = 36;
                    break;
                  }

                  throw new s.b(s.a.InternalFail, {
                    message: "Inflated object size is different from that stated in packfile."
                  });

                case 36:
                  _context116.next = 38;
                  return r.undo();

                case 38:
                  _context116.next = 40;
                  return r.read(_i12.length - _l2.strm.avail_in);

                case 40:
                  _d2 = _context116.sent;
                  n.update(_d2);
                  _h = r.tell();
                  e({
                    data: _l2.result,
                    type: _o14,
                    num: f,
                    offset: _t78,
                    end: _h,
                    reference: _c3,
                    ofs: _u2
                  });
                  _context116.next = 47;
                  break;

                case 46:
                  n.update(_i12);

                case 47:
                  _context116.next = 25;
                  break;

                case 49:
                  _context116.next = 15;
                  break;

                case 51:
                case "end":
                  return _context116.stop();
              }
            }
          }, _callee92);
        }))).apply(this, arguments);
      }

      function h(t, e) {
        return p.apply(this, arguments);
      }

      function p() {
        return (p = f(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee93(e, r) {
          var n, i, o, a, s, _i13, _i14, _s6, _t79;

          return regeneratorRuntime.wrap(function _callee93$(_context117) {
            while (1) {
              switch (_context117.prev = _context117.next) {
                case 0:
                  _context117.next = 2;
                  return e.byte();

                case 2:
                  n = _context117.sent;
                  r.update(t.from([n]));
                  i = n >> 4 & 7;
                  s = 15 & n;

                  if (!(128 & n)) {
                    _context117.next = 15;
                    break;
                  }

                  _i13 = 4;

                case 8:
                  _context117.next = 10;
                  return e.byte();

                case 10:
                  n = _context117.sent;
                  r.update(t.from([n]));
                  s |= (127 & n) << _i13;
                  _i13 += 7;

                case 14:
                  if (128 & n) {
                    _context117.next = 8;
                    break;
                  }

                case 15:
                  if (!(6 === i)) {
                    _context117.next = 28;
                    break;
                  }

                  _i14 = 0;
                  o = 0;
                  _s6 = [];

                case 19:
                  _context117.next = 21;
                  return e.byte();

                case 21:
                  n = _context117.sent;
                  r.update(t.from([n]));
                  o |= (127 & n) << _i14;
                  _i14 += 7;

                  _s6.push(n);

                case 26:
                  if (128 & n) {
                    _context117.next = 19;
                    break;
                  }

                case 27:
                  a = t.from(_s6);

                case 28:
                  if (!(7 === i)) {
                    _context117.next = 33;
                    break;
                  }

                  _context117.next = 31;
                  return e.read(20);

                case 31:
                  _t79 = _context117.sent;
                  r.update(_t79), a = _t79;

                case 33:
                  return _context117.abrupt("return", {
                    type: i,
                    length: s,
                    ofs: o,
                    reference: a
                  });

                case 34:
                case "end":
                  return _context117.stop();
              }
            }
          }, _callee93);
        }))).apply(this, arguments);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    function n(t) {
      return t.split("\n").map(function (t) {
        return t.replace(/^ /, "");
      }).join("\n");
    }

    r.d(e, "a", function () {
      return n;
    });
  }, function (t, e, r) {
    var n = r(124);

    function i(t, e) {
      for (var r = [], i = t.length, o = e.length, a = function (t, e) {
        var r = new n(t, e);
        r.compose();

        for (var i, o, a = r.getses(), s = t.length - 1, u = e.length - 1, c = a.length - 1; c >= 0; --c) {
          a[c].t === r.SES_COMMON ? (o ? (o.chain = {
            file1index: s,
            file2index: u,
            chain: null
          }, o = o.chain) : o = i = {
            file1index: s,
            file2index: u,
            chain: null
          }, s--, u--) : a[c].t === r.SES_DELETE ? s-- : a[c].t === r.SES_ADD && u--;
        }

        var f = {
          file1index: -1,
          file2index: -1,
          chain: null
        };
        return o ? (o.chain = f, i) : f;
      }(t, e); null !== a; a = a.chain) {
        var s = i - a.file1index - 1,
            u = o - a.file2index - 1;
        i = a.file1index, o = a.file2index, (s || u) && r.push({
          file1: [i + 1, s],
          file2: [o + 1, u]
        });
      }

      return r.reverse(), r;
    }

    t.exports = function (t, e, r) {
      var n = [],
          o = [t, e, r],
          a = function (t, e, r) {
        var n,
            o = i(e, t),
            a = i(e, r),
            s = [];

        function u(t, e) {
          s.push([t.file1[0], e, t.file1[1], t.file2[0], t.file2[1]]);
        }

        for (n = 0; n < o.length; n++) {
          u(o[n], 0);
        }

        for (n = 0; n < a.length; n++) {
          u(a[n], 2);
        }

        s.sort(function (t, e) {
          return t[0] - e[0];
        });
        var c = [],
            f = 0;

        function l(t) {
          t > f && (c.push([1, f, t - f]), f = t);
        }

        for (var d = 0; d < s.length; d++) {
          for (var h = d, p = s[d], g = p[0], m = g + p[2]; d < s.length - 1;) {
            var y = s[d + 1],
                v = y[0];
            if (v > m) break;
            m = Math.max(m, v + y[2]), d++;
          }

          if (l(g), h == d) p[4] > 0 && c.push([p[1], p[3], p[4]]);else {
            var w = {
              0: [t.length, -1, e.length, -1],
              2: [r.length, -1, e.length, -1]
            };

            for (n = h; n <= d; n++) {
              var b = w[(p = s[n])[1]],
                  _ = p[0],
                  x = _ + p[2],
                  E = p[3],
                  k = E + p[4];
              b[0] = Math.min(E, b[0]), b[1] = Math.max(k, b[1]), b[2] = Math.min(_, b[2]), b[3] = Math.max(x, b[3]);
            }

            var O = w[0][0] + (g - w[0][2]),
                j = w[0][1] + (m - w[0][3]),
                P = w[2][0] + (g - w[2][2]),
                S = w[2][1] + (m - w[2][3]);
            c.push([-1, O, j - O, g, m - g, P, S - P]);
          }
          f = m;
        }

        return l(e.length), c;
      }(t, e, r),
          s = [];

      function u() {
        s.length && n.push({
          ok: s
        }), s = [];
      }

      function c(t) {
        for (var e = 0; e < t.length; e++) {
          s.push(t[e]);
        }
      }

      function f(e) {
        if (e[2] != e[6]) return !0;

        for (var n = e[1], i = e[5], o = 0; o < e[2]; o++) {
          if (t[o + n] != r[o + i]) return !0;
        }

        return !1;
      }

      for (var l = 0; l < a.length; l++) {
        var d = a[l],
            h = d[0];
        -1 == h ? f(d) ? (u(), n.push({
          conflict: {
            a: t.slice(d[1], d[1] + d[2]),
            aIndex: d[1],
            o: e.slice(d[3], d[3] + d[4]),
            oIndex: d[3],
            b: r.slice(d[5], d[5] + d[6]),
            bIndex: d[5]
          }
        })) : c(o[0].slice(d[1], d[1] + d[2])) : c(o[h].slice(d[1], d[1] + d[2]));
      }

      return u(), n;
    };
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return n;
    });
    var n = {
      commit: 16,
      tree: 32,
      blob: 48,
      tag: 64,
      ofs_delta: 96,
      ref_delta: 112
    };
  }, function (t, e, r) {
    (function (e) {
      var r = "win32" === e.platform,
          n = r ? "\\\\+" : "\\/",
          i = r ? "\\\\" : "/",
          o = "((?:[^/]*(?:/|$))*)",
          a = "([^/]*)",
          s = "((?:[^".concat(i, "]*(?:").concat(i, "|$))*)"),
          u = "([^".concat(i, "]*)");

      t.exports = function (t) {
        var _ref91 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref91$extended = _ref91.extended,
            e = _ref91$extended === void 0 ? !1 : _ref91$extended,
            _ref91$globstar = _ref91.globstar,
            r = _ref91$globstar === void 0 ? !1 : _ref91$globstar,
            _ref91$strict = _ref91.strict,
            i = _ref91$strict === void 0 ? !1 : _ref91$strict,
            _ref91$filepath = _ref91.filepath,
            c = _ref91$filepath === void 0 ? !1 : _ref91$filepath,
            _ref91$flags = _ref91.flags,
            f = _ref91$flags === void 0 ? "" : _ref91$flags;

        var l = "",
            d = "",
            h = {
          regex: "",
          segments: []
        },
            p = !1,
            g = !1;
        var m = [];

        function y(t) {
          var _ref92 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              e = _ref92.split,
              r = _ref92.last,
              i = _ref92.only;

          "path" !== i && (l += t), c && "regex" !== i && (h.regex += "\\/" === t ? n : t, e ? (r && (d += t), "" !== d && (f.includes("g") || (d = "^".concat(d, "$")), h.segments.push(new RegExp(d, f))), d = "") : d += t);
        }

        var v, w;

        for (var _n21 = 0; _n21 < t.length; _n21++) {
          if (v = t[_n21], w = t[_n21 + 1], ["\\", "$", "^", ".", "="].includes(v)) y("\\".concat(v));else if ("/" !== v) {
            if ("(" !== v) {
              if (")" !== v) {
                if ("|" !== v) {
                  if ("+" !== v) {
                    if ("@" === v && e && "(" === w) m.push(v);else if ("!" !== v) {
                      if ("?" !== v) {
                        if ("[" !== v) {
                          if ("]" !== v) {
                            if ("{" !== v) {
                              if ("}" !== v) {
                                if ("," !== v) {
                                  if ("*" !== v) y(v);else {
                                    if ("(" === w && e) {
                                      m.push(v);
                                      continue;
                                    }

                                    var _i15 = t[_n21 - 1],
                                        _c4 = 1;

                                    for (; "*" === t[_n21 + 1];) {
                                      _c4++, _n21++;
                                    }

                                    var _f2 = t[_n21 + 1];

                                    if (r) {
                                      _c4 > 1 && ("/" === _i15 || void 0 === _i15) && ("/" === _f2 || void 0 === _f2) ? (y(o, {
                                        only: "regex"
                                      }), y(s, {
                                        only: "path",
                                        last: !0,
                                        split: !0
                                      }), _n21++) : (y(a, {
                                        only: "regex"
                                      }), y(u, {
                                        only: "path"
                                      }));
                                    } else y(".*");
                                  }
                                } else {
                                  if (p) {
                                    y("|");
                                    continue;
                                  }

                                  y("\\".concat(v));
                                }
                              } else {
                                if (e) {
                                  p = !1, y(")");
                                  continue;
                                }

                                y("\\".concat(v));
                              }
                            } else {
                              if (e) {
                                p = !0, y("(");
                                continue;
                              }

                              y("\\".concat(v));
                            }
                          } else {
                            if (e) {
                              g = !1, y(v);
                              continue;
                            }

                            y("\\".concat(v));
                          }
                        } else {
                          if (g && ":" === w) {
                            _n21++;
                            var _e39 = "";

                            for (; ":" !== t[++_n21];) {
                              _e39 += t[_n21];
                            }

                            "alnum" === _e39 ? y("(\\w|\\d)") : "space" === _e39 ? y("\\s") : "digit" === _e39 && y("\\d"), _n21++;
                            continue;
                          }

                          if (e) {
                            g = !0, y(v);
                            continue;
                          }

                          y("\\".concat(v));
                        }
                      } else {
                        if (e) {
                          "(" === w ? m.push(v) : y(".");
                          continue;
                        }

                        y("\\".concat(v));
                      }
                    } else {
                      if (e) {
                        if (g) {
                          y("^");
                          continue;
                        }

                        if ("(" === w) {
                          m.push(v), y("(?!"), _n21++;
                          continue;
                        }

                        y("\\".concat(v));
                        continue;
                      }

                      y("\\".concat(v));
                    }
                  } else {
                    if ("(" === w && e) {
                      m.push(v);
                      continue;
                    }

                    y("\\".concat(v));
                  }
                } else {
                  if (m.length) {
                    y(v);
                    continue;
                  }

                  y("\\".concat(v));
                }
              } else {
                if (m.length) {
                  y(v);

                  var _t80 = m.pop();

                  y("@" === _t80 ? "{1}" : "!" === _t80 ? "([^/]*)" : _t80);
                  continue;
                }

                y("\\".concat(v));
              }
            } else {
              if (m.length) {
                y(v);
                continue;
              }

              y("\\".concat(v));
            }
          } else y("\\".concat(v), {
            split: !0
          }), "/" !== w || i || (l += "?");
        }

        f.includes("g") || (l = "^".concat(l, "$"), d = "^".concat(d, "$"), c && (h.regex = "^".concat(h.regex, "$")));
        var b = {
          regex: new RegExp(l, f)
        };
        return c && (h.segments.push(new RegExp(d, f)), h.regex = new RegExp(h.regex, f), h.globstar = new RegExp(f.includes("g") ? s : "^".concat(s, "$"), f), b.path = h), b;
      };
    }).call(this, r(47));
  }, function (t, e) {
    e.read = function (t, e, r, n, i) {
      var o,
          a,
          s = 8 * i - n - 1,
          u = (1 << s) - 1,
          c = u >> 1,
          f = -7,
          l = r ? i - 1 : 0,
          d = r ? -1 : 1,
          h = t[e + l];

      for (l += d, o = h & (1 << -f) - 1, h >>= -f, f += s; f > 0; o = 256 * o + t[e + l], l += d, f -= 8) {
        ;
      }

      for (a = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; a = 256 * a + t[e + l], l += d, f -= 8) {
        ;
      }

      if (0 === o) o = 1 - c;else {
        if (o === u) return a ? NaN : 1 / 0 * (h ? -1 : 1);
        a += Math.pow(2, n), o -= c;
      }
      return (h ? -1 : 1) * a * Math.pow(2, o - n);
    }, e.write = function (t, e, r, n, i, o) {
      var a,
          s,
          u,
          c = 8 * o - i - 1,
          f = (1 << c) - 1,
          l = f >> 1,
          d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          h = n ? 0 : o - 1,
          p = n ? 1 : -1,
          g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;

      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, a = f) : (a = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), (e += a + l >= 1 ? d / u : d * Math.pow(2, 1 - l)) * u >= 2 && (a++, u /= 2), a + l >= f ? (s = 0, a = f) : a + l >= 1 ? (s = (e * u - 1) * Math.pow(2, i), a += l) : (s = e * Math.pow(2, l - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + h] = 255 & s, h += p, s /= 256, i -= 8) {
        ;
      }

      for (a = a << i | s, c += i; c > 0; t[r + h] = 255 & a, h += p, a /= 256, c -= 8) {
        ;
      }

      t[r + h - p] |= 128 * g;
    };
  }, function (t, e) {
    var r = {}.toString;

    t.exports = Array.isArray || function (t) {
      return "[object Array]" == r.call(t);
    };
  }, function (t, e, r) {
    "use strict";

    (function (e) {
      var r = function r(t) {
        t = t || {}, this.Promise = t.Promise || Promise, this.queues = {}, this.domains = {}, this.domainReentrant = t.domainReentrant || !1, this.timeout = t.timeout || r.DEFAULT_TIMEOUT, this.maxPending = t.maxPending || r.DEFAULT_MAX_PENDING;
      };

      r.DEFAULT_TIMEOUT = 0, r.DEFAULT_MAX_PENDING = 1e3, r.prototype.acquire = function (t, r, n, i) {
        if (Array.isArray(t)) return this._acquireBatch(t, r, n, i);
        if ("function" != typeof r) throw new Error("You must pass a function to execute");
        var o = null,
            a = null,
            s = null;
        "function" != typeof n && (i = n, n = null, s = new this.Promise(function (t, e) {
          o = t, a = e;
        })), i = i || {};

        var u = !1,
            c = null,
            f = this,
            l = function l(e, r, i) {
          e && (0 === f.queues[t].length && delete f.queues[t], delete f.domains[t]), u || (s ? r ? a(r) : o(i) : "function" == typeof n && n(r, i), u = !0), e && f.queues[t] && f.queues[t].length > 0 && f.queues[t].shift()();
        },
            d = function d(n) {
          if (u) return l(n);

          if (c && (clearTimeout(c), c = null), n && (f.domains[t] = e.domain), 1 === r.length) {
            var i = !1;
            r(function (t, e) {
              i || (i = !0, l(n, t, e));
            });
          } else f._promiseTry(function () {
            return r();
          }).then(function (t) {
            l(n, void 0, t);
          }, function (t) {
            l(n, t);
          });
        };

        if (e.domain && (d = e.domain.bind(d)), f.queues[t]) {
          if (f.domainReentrant && e.domain && e.domain === f.domains[t]) d(!1);else if (f.queues[t].length >= f.maxPending) l(!1, new Error("Too much pending tasks"));else {
            var h = function h() {
              d(!0);
            };

            i.skipQueue ? f.queues[t].unshift(h) : f.queues[t].push(h);
            var p = i.timeout || f.timeout;
            p && (c = setTimeout(function () {
              c = null, l(!1, new Error("async-lock timed out"));
            }, p));
          }
        } else f.queues[t] = [], d(!0);
        return s || void 0;
      }, r.prototype._acquireBatch = function (t, e, r, n) {
        "function" != typeof r && (n = r, r = null);
        var i = this,
            o = e;
        if (t.reverse().forEach(function (t) {
          o = function (t, e) {
            return function (r) {
              i.acquire(t, e, r, n);
            };
          }(t, o);
        }), "function" != typeof r) return new this.Promise(function (t, e) {
          1 === o.length ? o(function (r, n) {
            r ? e(r) : t(n);
          }) : t(o());
        });
        o(r);
      }, r.prototype.isBusy = function (t) {
        return t ? !!this.queues[t] : Object.keys(this.queues).length > 0;
      }, r.prototype._promiseTry = function (t) {
        try {
          return this.Promise.resolve(t());
        } catch (t) {
          return this.Promise.reject(t);
        }
      }, t.exports = r;
    }).call(this, r(47));
  }, function (t, e) {
    "function" == typeof Object.create ? t.exports = function (t, e) {
      t.super_ = e, t.prototype = Object.create(e.prototype, {
        constructor: {
          value: t,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
    } : t.exports = function (t, e) {
      t.super_ = e;

      var r = function r() {};

      r.prototype = e.prototype, t.prototype = new r(), t.prototype.constructor = t;
    };
  }, function (t, e, r) {
    var n = r(73).Buffer;

    function i(t, e) {
      this._block = n.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }

    i.prototype.update = function (t, e) {
      "string" == typeof t && (e = e || "utf8", t = n.from(t, e));

      for (var r = this._block, i = this._blockSize, o = t.length, a = this._len, s = 0; s < o;) {
        for (var u = a % i, c = Math.min(o - s, i - u), f = 0; f < c; f++) {
          r[u + f] = t[s + f];
        }

        s += c, (a += c) % i == 0 && this._update(r);
      }

      return this._len += o, this;
    }, i.prototype.digest = function (t) {
      var e = this._len % this._blockSize;
      this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = 8 * this._len;
      if (r <= 4294967295) this._block.writeUInt32BE(r, this._blockSize - 4);else {
        var n = (4294967295 & r) >>> 0,
            i = (r - n) / 4294967296;
        this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
      }

      this._update(this._block);

      var o = this._hash();

      return t ? o.toString(t) : o;
    }, i.prototype._update = function () {
      throw new Error("_update must be implemented by subclass");
    }, t.exports = i;
  }, function (t, e, r) {
    "use strict";

    var n = r(105),
        i = r(23),
        o = r(76),
        a = r(60),
        s = r(77),
        u = Object.prototype.toString,
        c = 0,
        f = -1,
        l = 0,
        d = 8;

    function h(t) {
      if (!(this instanceof h)) return new h(t);
      this.options = i.assign({
        level: f,
        method: d,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: l,
        to: ""
      }, t || {});
      var e = this.options;
      e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
      var r = n.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
      if (r !== c) throw new Error(a[r]);

      if (e.header && n.deflateSetHeader(this.strm, e.header), e.dictionary) {
        var p;
        if (p = "string" == typeof e.dictionary ? o.string2buf(e.dictionary) : "[object ArrayBuffer]" === u.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (r = n.deflateSetDictionary(this.strm, p)) !== c) throw new Error(a[r]);
        this._dict_set = !0;
      }
    }

    function p(t, e) {
      var r = new h(e);
      if (r.push(t, !0), r.err) throw r.msg || a[r.err];
      return r.result;
    }

    h.prototype.push = function (t, e) {
      var r,
          a,
          s = this.strm,
          f = this.options.chunkSize;
      if (this.ended) return !1;
      a = e === ~~e ? e : !0 === e ? 4 : 0, "string" == typeof t ? s.input = o.string2buf(t) : "[object ArrayBuffer]" === u.call(t) ? s.input = new Uint8Array(t) : s.input = t, s.next_in = 0, s.avail_in = s.input.length;

      do {
        if (0 === s.avail_out && (s.output = new i.Buf8(f), s.next_out = 0, s.avail_out = f), 1 !== (r = n.deflate(s, a)) && r !== c) return this.onEnd(r), this.ended = !0, !1;
        0 !== s.avail_out && (0 !== s.avail_in || 4 !== a && 2 !== a) || ("string" === this.options.to ? this.onData(o.buf2binstring(i.shrinkBuf(s.output, s.next_out))) : this.onData(i.shrinkBuf(s.output, s.next_out)));
      } while ((s.avail_in > 0 || 0 === s.avail_out) && 1 !== r);

      return 4 === a ? (r = n.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === c) : 2 !== a || (this.onEnd(c), s.avail_out = 0, !0);
    }, h.prototype.onData = function (t) {
      this.chunks.push(t);
    }, h.prototype.onEnd = function (t) {
      t === c && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
    }, e.Deflate = h, e.deflate = p, e.deflateRaw = function (t, e) {
      return (e = e || {}).raw = !0, p(t, e);
    }, e.gzip = function (t, e) {
      return (e = e || {}).gzip = !0, p(t, e);
    };
  }, function (t, e, r) {
    "use strict";

    var n,
        i = r(23),
        o = r(106),
        a = r(74),
        s = r(75),
        u = r(60),
        c = 0,
        f = 1,
        l = 3,
        d = 4,
        h = 5,
        p = 0,
        g = 1,
        m = -2,
        y = -3,
        v = -5,
        w = -1,
        b = 1,
        _ = 2,
        x = 3,
        E = 4,
        k = 0,
        O = 2,
        j = 8,
        P = 9,
        S = 15,
        R = 8,
        A = 286,
        $ = 30,
        T = 19,
        I = 2 * A + 1,
        B = 15,
        F = 3,
        U = 258,
        M = U + F + 1,
        C = 32,
        D = 42,
        N = 69,
        z = 73,
        H = 91,
        L = 103,
        G = 113,
        q = 666,
        W = 1,
        Y = 2,
        Z = 3,
        K = 4,
        V = 3;

    function X(t, e) {
      return t.msg = u[e], e;
    }

    function J(t) {
      return (t << 1) - (t > 4 ? 9 : 0);
    }

    function Q(t) {
      for (var e = t.length; --e >= 0;) {
        t[e] = 0;
      }
    }

    function tt(t) {
      var e = t.state,
          r = e.pending;
      r > t.avail_out && (r = t.avail_out), 0 !== r && (i.arraySet(t.output, e.pending_buf, e.pending_out, r, t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0));
    }

    function et(t, e) {
      o._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, tt(t.strm);
    }

    function rt(t, e) {
      t.pending_buf[t.pending++] = e;
    }

    function nt(t, e) {
      t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e;
    }

    function it(t, e) {
      var r,
          n,
          i = t.max_chain_length,
          o = t.strstart,
          a = t.prev_length,
          s = t.nice_match,
          u = t.strstart > t.w_size - M ? t.strstart - (t.w_size - M) : 0,
          c = t.window,
          f = t.w_mask,
          l = t.prev,
          d = t.strstart + U,
          h = c[o + a - 1],
          p = c[o + a];
      t.prev_length >= t.good_match && (i >>= 2), s > t.lookahead && (s = t.lookahead);

      do {
        if (c[(r = e) + a] === p && c[r + a - 1] === h && c[r] === c[o] && c[++r] === c[o + 1]) {
          o += 2, r++;

          do {} while (c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && o < d);

          if (n = U - (d - o), o = d - U, n > a) {
            if (t.match_start = e, a = n, n >= s) break;
            h = c[o + a - 1], p = c[o + a];
          }
        }
      } while ((e = l[e & f]) > u && 0 != --i);

      return a <= t.lookahead ? a : t.lookahead;
    }

    function ot(t) {
      var e,
          r,
          n,
          o,
          u,
          c,
          f,
          l,
          d,
          h,
          p = t.w_size;

      do {
        if (o = t.window_size - t.lookahead - t.strstart, t.strstart >= p + (p - M)) {
          i.arraySet(t.window, t.window, p, p, 0), t.match_start -= p, t.strstart -= p, t.block_start -= p, e = r = t.hash_size;

          do {
            n = t.head[--e], t.head[e] = n >= p ? n - p : 0;
          } while (--r);

          e = r = p;

          do {
            n = t.prev[--e], t.prev[e] = n >= p ? n - p : 0;
          } while (--r);

          o += p;
        }

        if (0 === t.strm.avail_in) break;
        if (c = t.strm, f = t.window, l = t.strstart + t.lookahead, d = o, h = void 0, (h = c.avail_in) > d && (h = d), r = 0 === h ? 0 : (c.avail_in -= h, i.arraySet(f, c.input, c.next_in, h, l), 1 === c.state.wrap ? c.adler = a(c.adler, f, h, l) : 2 === c.state.wrap && (c.adler = s(c.adler, f, h, l)), c.next_in += h, c.total_in += h, h), t.lookahead += r, t.lookahead + t.insert >= F) for (u = t.strstart - t.insert, t.ins_h = t.window[u], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[u + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[u + F - 1]) & t.hash_mask, t.prev[u & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = u, u++, t.insert--, !(t.lookahead + t.insert < F));) {
          ;
        }
      } while (t.lookahead < M && 0 !== t.strm.avail_in);
    }

    function at(t, e) {
      for (var r, n;;) {
        if (t.lookahead < M) {
          if (ot(t), t.lookahead < M && e === c) return W;
          if (0 === t.lookahead) break;
        }

        if (r = 0, t.lookahead >= F && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + F - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - M && (t.match_length = it(t, r)), t.match_length >= F) {
          if (n = o._tr_tally(t, t.strstart - t.match_start, t.match_length - F), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= F) {
            t.match_length--;

            do {
              t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + F - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;
            } while (0 != --t.match_length);

            t.strstart++;
          } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
        } else n = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
        if (n && (et(t, !1), 0 === t.strm.avail_out)) return W;
      }

      return t.insert = t.strstart < F - 1 ? t.strstart : F - 1, e === d ? (et(t, !0), 0 === t.strm.avail_out ? Z : K) : t.last_lit && (et(t, !1), 0 === t.strm.avail_out) ? W : Y;
    }

    function st(t, e) {
      for (var r, n, i;;) {
        if (t.lookahead < M) {
          if (ot(t), t.lookahead < M && e === c) return W;
          if (0 === t.lookahead) break;
        }

        if (r = 0, t.lookahead >= F && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + F - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = F - 1, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - M && (t.match_length = it(t, r), t.match_length <= 5 && (t.strategy === b || t.match_length === F && t.strstart - t.match_start > 4096) && (t.match_length = F - 1)), t.prev_length >= F && t.match_length <= t.prev_length) {
          i = t.strstart + t.lookahead - F, n = o._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - F), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;

          do {
            ++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + F - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);
          } while (0 != --t.prev_length);

          if (t.match_available = 0, t.match_length = F - 1, t.strstart++, n && (et(t, !1), 0 === t.strm.avail_out)) return W;
        } else if (t.match_available) {
          if ((n = o._tr_tally(t, 0, t.window[t.strstart - 1])) && et(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return W;
        } else t.match_available = 1, t.strstart++, t.lookahead--;
      }

      return t.match_available && (n = o._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < F - 1 ? t.strstart : F - 1, e === d ? (et(t, !0), 0 === t.strm.avail_out ? Z : K) : t.last_lit && (et(t, !1), 0 === t.strm.avail_out) ? W : Y;
    }

    function ut(t, e, r, n, i) {
      this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = n, this.func = i;
    }

    function ct() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = j, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(2 * I), this.dyn_dtree = new i.Buf16(2 * (2 * $ + 1)), this.bl_tree = new i.Buf16(2 * (2 * T + 1)), Q(this.dyn_ltree), Q(this.dyn_dtree), Q(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(B + 1), this.heap = new i.Buf16(2 * A + 1), Q(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(2 * A + 1), Q(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }

    function ft(t) {
      var e;
      return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = O, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? D : G, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = c, o._tr_init(e), p) : X(t, m);
    }

    function lt(t) {
      var e,
          r = ft(t);
      return r === p && ((e = t.state).window_size = 2 * e.w_size, Q(e.head), e.max_lazy_match = n[e.level].max_lazy, e.good_match = n[e.level].good_length, e.nice_match = n[e.level].nice_length, e.max_chain_length = n[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = F - 1, e.match_available = 0, e.ins_h = 0), r;
    }

    function dt(t, e, r, n, o, a) {
      if (!t) return m;
      var s = 1;
      if (e === w && (e = 6), n < 0 ? (s = 0, n = -n) : n > 15 && (s = 2, n -= 16), o < 1 || o > P || r !== j || n < 8 || n > 15 || e < 0 || e > 9 || a < 0 || a > E) return X(t, m);
      8 === n && (n = 9);
      var u = new ct();
      return t.state = u, u.strm = t, u.wrap = s, u.gzhead = null, u.w_bits = n, u.w_size = 1 << u.w_bits, u.w_mask = u.w_size - 1, u.hash_bits = o + 7, u.hash_size = 1 << u.hash_bits, u.hash_mask = u.hash_size - 1, u.hash_shift = ~~((u.hash_bits + F - 1) / F), u.window = new i.Buf8(2 * u.w_size), u.head = new i.Buf16(u.hash_size), u.prev = new i.Buf16(u.w_size), u.lit_bufsize = 1 << o + 6, u.pending_buf_size = 4 * u.lit_bufsize, u.pending_buf = new i.Buf8(u.pending_buf_size), u.d_buf = 1 * u.lit_bufsize, u.l_buf = 3 * u.lit_bufsize, u.level = e, u.strategy = a, u.method = r, lt(t);
    }

    n = [new ut(0, 0, 0, 0, function (t, e) {
      var r = 65535;

      for (r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5);;) {
        if (t.lookahead <= 1) {
          if (ot(t), 0 === t.lookahead && e === c) return W;
          if (0 === t.lookahead) break;
        }

        t.strstart += t.lookahead, t.lookahead = 0;
        var n = t.block_start + r;
        if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, et(t, !1), 0 === t.strm.avail_out)) return W;
        if (t.strstart - t.block_start >= t.w_size - M && (et(t, !1), 0 === t.strm.avail_out)) return W;
      }

      return t.insert = 0, e === d ? (et(t, !0), 0 === t.strm.avail_out ? Z : K) : (t.strstart > t.block_start && (et(t, !1), t.strm.avail_out), W);
    }), new ut(4, 4, 8, 4, at), new ut(4, 5, 16, 8, at), new ut(4, 6, 32, 32, at), new ut(4, 4, 16, 16, st), new ut(8, 16, 32, 32, st), new ut(8, 16, 128, 128, st), new ut(8, 32, 128, 256, st), new ut(32, 128, 258, 1024, st), new ut(32, 258, 258, 4096, st)], e.deflateInit = function (t, e) {
      return dt(t, e, j, S, R, k);
    }, e.deflateInit2 = dt, e.deflateReset = lt, e.deflateResetKeep = ft, e.deflateSetHeader = function (t, e) {
      return t && t.state ? 2 !== t.state.wrap ? m : (t.state.gzhead = e, p) : m;
    }, e.deflate = function (t, e) {
      var r, i, a, u;
      if (!t || !t.state || e > h || e < 0) return t ? X(t, m) : m;
      if (i = t.state, !t.output || !t.input && 0 !== t.avail_in || i.status === q && e !== d) return X(t, 0 === t.avail_out ? v : m);
      if (i.strm = t, r = i.last_flush, i.last_flush = e, i.status === D) if (2 === i.wrap) t.adler = 0, rt(i, 31), rt(i, 139), rt(i, 8), i.gzhead ? (rt(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), rt(i, 255 & i.gzhead.time), rt(i, i.gzhead.time >> 8 & 255), rt(i, i.gzhead.time >> 16 & 255), rt(i, i.gzhead.time >> 24 & 255), rt(i, 9 === i.level ? 2 : i.strategy >= _ || i.level < 2 ? 4 : 0), rt(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (rt(i, 255 & i.gzhead.extra.length), rt(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = s(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = N) : (rt(i, 0), rt(i, 0), rt(i, 0), rt(i, 0), rt(i, 0), rt(i, 9 === i.level ? 2 : i.strategy >= _ || i.level < 2 ? 4 : 0), rt(i, V), i.status = G);else {
        var y = j + (i.w_bits - 8 << 4) << 8;
        y |= (i.strategy >= _ || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3) << 6, 0 !== i.strstart && (y |= C), y += 31 - y % 31, i.status = G, nt(i, y), 0 !== i.strstart && (nt(i, t.adler >>> 16), nt(i, 65535 & t.adler)), t.adler = 1;
      }
      if (i.status === N) if (i.gzhead.extra) {
        for (a = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), tt(t), a = i.pending, i.pending !== i.pending_buf_size));) {
          rt(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++;
        }

        i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = z);
      } else i.status = z;
      if (i.status === z) if (i.gzhead.name) {
        a = i.pending;

        do {
          if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), tt(t), a = i.pending, i.pending === i.pending_buf_size)) {
            u = 1;
            break;
          }

          u = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, rt(i, u);
        } while (0 !== u);

        i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), 0 === u && (i.gzindex = 0, i.status = H);
      } else i.status = H;
      if (i.status === H) if (i.gzhead.comment) {
        a = i.pending;

        do {
          if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), tt(t), a = i.pending, i.pending === i.pending_buf_size)) {
            u = 1;
            break;
          }

          u = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, rt(i, u);
        } while (0 !== u);

        i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), 0 === u && (i.status = L);
      } else i.status = L;

      if (i.status === L && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && tt(t), i.pending + 2 <= i.pending_buf_size && (rt(i, 255 & t.adler), rt(i, t.adler >> 8 & 255), t.adler = 0, i.status = G)) : i.status = G), 0 !== i.pending) {
        if (tt(t), 0 === t.avail_out) return i.last_flush = -1, p;
      } else if (0 === t.avail_in && J(e) <= J(r) && e !== d) return X(t, v);

      if (i.status === q && 0 !== t.avail_in) return X(t, v);

      if (0 !== t.avail_in || 0 !== i.lookahead || e !== c && i.status !== q) {
        var w = i.strategy === _ ? function (t, e) {
          for (var r;;) {
            if (0 === t.lookahead && (ot(t), 0 === t.lookahead)) {
              if (e === c) return W;
              break;
            }

            if (t.match_length = 0, r = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (et(t, !1), 0 === t.strm.avail_out)) return W;
          }

          return t.insert = 0, e === d ? (et(t, !0), 0 === t.strm.avail_out ? Z : K) : t.last_lit && (et(t, !1), 0 === t.strm.avail_out) ? W : Y;
        }(i, e) : i.strategy === x ? function (t, e) {
          for (var r, n, i, a, s = t.window;;) {
            if (t.lookahead <= U) {
              if (ot(t), t.lookahead <= U && e === c) return W;
              if (0 === t.lookahead) break;
            }

            if (t.match_length = 0, t.lookahead >= F && t.strstart > 0 && (n = s[i = t.strstart - 1]) === s[++i] && n === s[++i] && n === s[++i]) {
              a = t.strstart + U;

              do {} while (n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && i < a);

              t.match_length = U - (a - i), t.match_length > t.lookahead && (t.match_length = t.lookahead);
            }

            if (t.match_length >= F ? (r = o._tr_tally(t, 1, t.match_length - F), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && (et(t, !1), 0 === t.strm.avail_out)) return W;
          }

          return t.insert = 0, e === d ? (et(t, !0), 0 === t.strm.avail_out ? Z : K) : t.last_lit && (et(t, !1), 0 === t.strm.avail_out) ? W : Y;
        }(i, e) : n[i.level].func(i, e);
        if (w !== Z && w !== K || (i.status = q), w === W || w === Z) return 0 === t.avail_out && (i.last_flush = -1), p;
        if (w === Y && (e === f ? o._tr_align(i) : e !== h && (o._tr_stored_block(i, 0, 0, !1), e === l && (Q(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), tt(t), 0 === t.avail_out)) return i.last_flush = -1, p;
      }

      return e !== d ? p : i.wrap <= 0 ? g : (2 === i.wrap ? (rt(i, 255 & t.adler), rt(i, t.adler >> 8 & 255), rt(i, t.adler >> 16 & 255), rt(i, t.adler >> 24 & 255), rt(i, 255 & t.total_in), rt(i, t.total_in >> 8 & 255), rt(i, t.total_in >> 16 & 255), rt(i, t.total_in >> 24 & 255)) : (nt(i, t.adler >>> 16), nt(i, 65535 & t.adler)), tt(t), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? p : g);
    }, e.deflateEnd = function (t) {
      var e;
      return t && t.state ? (e = t.state.status) !== D && e !== N && e !== z && e !== H && e !== L && e !== G && e !== q ? X(t, m) : (t.state = null, e === G ? X(t, y) : p) : m;
    }, e.deflateSetDictionary = function (t, e) {
      var r,
          n,
          o,
          s,
          u,
          c,
          f,
          l,
          d = e.length;
      if (!t || !t.state) return m;
      if (2 === (s = (r = t.state).wrap) || 1 === s && r.status !== D || r.lookahead) return m;

      for (1 === s && (t.adler = a(t.adler, e, d, 0)), r.wrap = 0, d >= r.w_size && (0 === s && (Q(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), l = new i.Buf8(r.w_size), i.arraySet(l, e, d - r.w_size, r.w_size, 0), e = l, d = r.w_size), u = t.avail_in, c = t.next_in, f = t.input, t.avail_in = d, t.next_in = 0, t.input = e, ot(r); r.lookahead >= F;) {
        n = r.strstart, o = r.lookahead - (F - 1);

        do {
          r.ins_h = (r.ins_h << r.hash_shift ^ r.window[n + F - 1]) & r.hash_mask, r.prev[n & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = n, n++;
        } while (--o);

        r.strstart = n, r.lookahead = F - 1, ot(r);
      }

      return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = F - 1, r.match_available = 0, t.next_in = c, t.input = f, t.avail_in = u, r.wrap = s, p;
    }, e.deflateInfo = "pako deflate (from Nodeca project)";
  }, function (t, e, r) {
    "use strict";

    var n = r(23),
        i = 4,
        o = 0,
        a = 1,
        s = 2;

    function u(t) {
      for (var e = t.length; --e >= 0;) {
        t[e] = 0;
      }
    }

    var c = 0,
        f = 1,
        l = 2,
        d = 29,
        h = 256,
        p = h + 1 + d,
        g = 30,
        m = 19,
        y = 2 * p + 1,
        v = 15,
        w = 16,
        b = 7,
        _ = 256,
        x = 16,
        E = 17,
        k = 18,
        O = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
        j = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
        P = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
        S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
        R = new Array(2 * (p + 2));
    u(R);
    var A = new Array(2 * g);
    u(A);
    var $ = new Array(512);
    u($);
    var T = new Array(256);
    u(T);
    var I = new Array(d);
    u(I);
    var B,
        F,
        U,
        M = new Array(g);

    function C(t, e, r, n, i) {
      this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = t && t.length;
    }

    function D(t, e) {
      this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;
    }

    function N(t) {
      return t < 256 ? $[t] : $[256 + (t >>> 7)];
    }

    function z(t, e) {
      t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255;
    }

    function H(t, e, r) {
      t.bi_valid > w - r ? (t.bi_buf |= e << t.bi_valid & 65535, z(t, t.bi_buf), t.bi_buf = e >> w - t.bi_valid, t.bi_valid += r - w) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r);
    }

    function L(t, e, r) {
      H(t, r[2 * e], r[2 * e + 1]);
    }

    function G(t, e) {
      var r = 0;

      do {
        r |= 1 & t, t >>>= 1, r <<= 1;
      } while (--e > 0);

      return r >>> 1;
    }

    function q(t, e, r) {
      var n,
          i,
          o = new Array(v + 1),
          a = 0;

      for (n = 1; n <= v; n++) {
        o[n] = a = a + r[n - 1] << 1;
      }

      for (i = 0; i <= e; i++) {
        var s = t[2 * i + 1];
        0 !== s && (t[2 * i] = G(o[s]++, s));
      }
    }

    function W(t) {
      var e;

      for (e = 0; e < p; e++) {
        t.dyn_ltree[2 * e] = 0;
      }

      for (e = 0; e < g; e++) {
        t.dyn_dtree[2 * e] = 0;
      }

      for (e = 0; e < m; e++) {
        t.bl_tree[2 * e] = 0;
      }

      t.dyn_ltree[2 * _] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0;
    }

    function Y(t) {
      t.bi_valid > 8 ? z(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;
    }

    function Z(t, e, r, n) {
      var i = 2 * e,
          o = 2 * r;
      return t[i] < t[o] || t[i] === t[o] && n[e] <= n[r];
    }

    function K(t, e, r) {
      for (var n = t.heap[r], i = r << 1; i <= t.heap_len && (i < t.heap_len && Z(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !Z(e, n, t.heap[i], t.depth));) {
        t.heap[r] = t.heap[i], r = i, i <<= 1;
      }

      t.heap[r] = n;
    }

    function V(t, e, r) {
      var n,
          i,
          o,
          a,
          s = 0;
      if (0 !== t.last_lit) do {
        n = t.pending_buf[t.d_buf + 2 * s] << 8 | t.pending_buf[t.d_buf + 2 * s + 1], i = t.pending_buf[t.l_buf + s], s++, 0 === n ? L(t, i, e) : (L(t, (o = T[i]) + h + 1, e), 0 !== (a = O[o]) && H(t, i -= I[o], a), L(t, o = N(--n), r), 0 !== (a = j[o]) && H(t, n -= M[o], a));
      } while (s < t.last_lit);
      L(t, _, e);
    }

    function X(t, e) {
      var r,
          n,
          i,
          o = e.dyn_tree,
          a = e.stat_desc.static_tree,
          s = e.stat_desc.has_stree,
          u = e.stat_desc.elems,
          c = -1;

      for (t.heap_len = 0, t.heap_max = y, r = 0; r < u; r++) {
        0 !== o[2 * r] ? (t.heap[++t.heap_len] = c = r, t.depth[r] = 0) : o[2 * r + 1] = 0;
      }

      for (; t.heap_len < 2;) {
        o[2 * (i = t.heap[++t.heap_len] = c < 2 ? ++c : 0)] = 1, t.depth[i] = 0, t.opt_len--, s && (t.static_len -= a[2 * i + 1]);
      }

      for (e.max_code = c, r = t.heap_len >> 1; r >= 1; r--) {
        K(t, o, r);
      }

      i = u;

      do {
        r = t.heap[1], t.heap[1] = t.heap[t.heap_len--], K(t, o, 1), n = t.heap[1], t.heap[--t.heap_max] = r, t.heap[--t.heap_max] = n, o[2 * i] = o[2 * r] + o[2 * n], t.depth[i] = (t.depth[r] >= t.depth[n] ? t.depth[r] : t.depth[n]) + 1, o[2 * r + 1] = o[2 * n + 1] = i, t.heap[1] = i++, K(t, o, 1);
      } while (t.heap_len >= 2);

      t.heap[--t.heap_max] = t.heap[1], function (t, e) {
        var r,
            n,
            i,
            o,
            a,
            s,
            u = e.dyn_tree,
            c = e.max_code,
            f = e.stat_desc.static_tree,
            l = e.stat_desc.has_stree,
            d = e.stat_desc.extra_bits,
            h = e.stat_desc.extra_base,
            p = e.stat_desc.max_length,
            g = 0;

        for (o = 0; o <= v; o++) {
          t.bl_count[o] = 0;
        }

        for (u[2 * t.heap[t.heap_max] + 1] = 0, r = t.heap_max + 1; r < y; r++) {
          (o = u[2 * u[2 * (n = t.heap[r]) + 1] + 1] + 1) > p && (o = p, g++), u[2 * n + 1] = o, n > c || (t.bl_count[o]++, a = 0, n >= h && (a = d[n - h]), s = u[2 * n], t.opt_len += s * (o + a), l && (t.static_len += s * (f[2 * n + 1] + a)));
        }

        if (0 !== g) {
          do {
            for (o = p - 1; 0 === t.bl_count[o];) {
              o--;
            }

            t.bl_count[o]--, t.bl_count[o + 1] += 2, t.bl_count[p]--, g -= 2;
          } while (g > 0);

          for (o = p; 0 !== o; o--) {
            for (n = t.bl_count[o]; 0 !== n;) {
              (i = t.heap[--r]) > c || (u[2 * i + 1] !== o && (t.opt_len += (o - u[2 * i + 1]) * u[2 * i], u[2 * i + 1] = o), n--);
            }
          }
        }
      }(t, e), q(o, c, t.bl_count);
    }

    function J(t, e, r) {
      var n,
          i,
          o = -1,
          a = e[1],
          s = 0,
          u = 7,
          c = 4;

      for (0 === a && (u = 138, c = 3), e[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++) {
        i = a, a = e[2 * (n + 1) + 1], ++s < u && i === a || (s < c ? t.bl_tree[2 * i] += s : 0 !== i ? (i !== o && t.bl_tree[2 * i]++, t.bl_tree[2 * x]++) : s <= 10 ? t.bl_tree[2 * E]++ : t.bl_tree[2 * k]++, s = 0, o = i, 0 === a ? (u = 138, c = 3) : i === a ? (u = 6, c = 3) : (u = 7, c = 4));
      }
    }

    function Q(t, e, r) {
      var n,
          i,
          o = -1,
          a = e[1],
          s = 0,
          u = 7,
          c = 4;

      for (0 === a && (u = 138, c = 3), n = 0; n <= r; n++) {
        if (i = a, a = e[2 * (n + 1) + 1], !(++s < u && i === a)) {
          if (s < c) do {
            L(t, i, t.bl_tree);
          } while (0 != --s);else 0 !== i ? (i !== o && (L(t, i, t.bl_tree), s--), L(t, x, t.bl_tree), H(t, s - 3, 2)) : s <= 10 ? (L(t, E, t.bl_tree), H(t, s - 3, 3)) : (L(t, k, t.bl_tree), H(t, s - 11, 7));
          s = 0, o = i, 0 === a ? (u = 138, c = 3) : i === a ? (u = 6, c = 3) : (u = 7, c = 4);
        }
      }
    }

    u(M);
    var tt = !1;

    function et(t, e, r, i) {
      H(t, (c << 1) + (i ? 1 : 0), 3), function (t, e, r, i) {
        Y(t), i && (z(t, r), z(t, ~r)), n.arraySet(t.pending_buf, t.window, e, r, t.pending), t.pending += r;
      }(t, e, r, !0);
    }

    e._tr_init = function (t) {
      tt || (!function () {
        var t,
            e,
            r,
            n,
            i,
            o = new Array(v + 1);

        for (r = 0, n = 0; n < d - 1; n++) {
          for (I[n] = r, t = 0; t < 1 << O[n]; t++) {
            T[r++] = n;
          }
        }

        for (T[r - 1] = n, i = 0, n = 0; n < 16; n++) {
          for (M[n] = i, t = 0; t < 1 << j[n]; t++) {
            $[i++] = n;
          }
        }

        for (i >>= 7; n < g; n++) {
          for (M[n] = i << 7, t = 0; t < 1 << j[n] - 7; t++) {
            $[256 + i++] = n;
          }
        }

        for (e = 0; e <= v; e++) {
          o[e] = 0;
        }

        for (t = 0; t <= 143;) {
          R[2 * t + 1] = 8, t++, o[8]++;
        }

        for (; t <= 255;) {
          R[2 * t + 1] = 9, t++, o[9]++;
        }

        for (; t <= 279;) {
          R[2 * t + 1] = 7, t++, o[7]++;
        }

        for (; t <= 287;) {
          R[2 * t + 1] = 8, t++, o[8]++;
        }

        for (q(R, p + 1, o), t = 0; t < g; t++) {
          A[2 * t + 1] = 5, A[2 * t] = G(t, 5);
        }

        B = new C(R, O, h + 1, p, v), F = new C(A, j, 0, g, v), U = new C(new Array(0), P, 0, m, b);
      }(), tt = !0), t.l_desc = new D(t.dyn_ltree, B), t.d_desc = new D(t.dyn_dtree, F), t.bl_desc = new D(t.bl_tree, U), t.bi_buf = 0, t.bi_valid = 0, W(t);
    }, e._tr_stored_block = et, e._tr_flush_block = function (t, e, r, n) {
      var u,
          c,
          d = 0;
      t.level > 0 ? (t.strm.data_type === s && (t.strm.data_type = function (t) {
        var e,
            r = 4093624447;

        for (e = 0; e <= 31; e++, r >>>= 1) {
          if (1 & r && 0 !== t.dyn_ltree[2 * e]) return o;
        }

        if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return a;

        for (e = 32; e < h; e++) {
          if (0 !== t.dyn_ltree[2 * e]) return a;
        }

        return o;
      }(t)), X(t, t.l_desc), X(t, t.d_desc), d = function (t) {
        var e;

        for (J(t, t.dyn_ltree, t.l_desc.max_code), J(t, t.dyn_dtree, t.d_desc.max_code), X(t, t.bl_desc), e = m - 1; e >= 3 && 0 === t.bl_tree[2 * S[e] + 1]; e--) {
          ;
        }

        return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
      }(t), u = t.opt_len + 3 + 7 >>> 3, (c = t.static_len + 3 + 7 >>> 3) <= u && (u = c)) : u = c = r + 5, r + 4 <= u && -1 !== e ? et(t, e, r, n) : t.strategy === i || c === u ? (H(t, (f << 1) + (n ? 1 : 0), 3), V(t, R, A)) : (H(t, (l << 1) + (n ? 1 : 0), 3), function (t, e, r, n) {
        var i;

        for (H(t, e - 257, 5), H(t, r - 1, 5), H(t, n - 4, 4), i = 0; i < n; i++) {
          H(t, t.bl_tree[2 * S[i] + 1], 3);
        }

        Q(t, t.dyn_ltree, e - 1), Q(t, t.dyn_dtree, r - 1);
      }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, d + 1), V(t, t.dyn_ltree, t.dyn_dtree)), W(t), n && Y(t);
    }, e._tr_tally = function (t, e, r) {
      return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & r, t.last_lit++, 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++, e--, t.dyn_ltree[2 * (T[r] + h + 1)]++, t.dyn_dtree[2 * N(e)]++), t.last_lit === t.lit_bufsize - 1;
    }, e._tr_align = function (t) {
      H(t, f << 1, 3), L(t, _, R), function (t) {
        16 === t.bi_valid ? (z(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8);
      }(t);
    };
  }, function (t, e, r) {
    "use strict";

    var n = r(108),
        i = r(23),
        o = r(76),
        a = r(78),
        s = r(60),
        u = r(77),
        c = r(111),
        f = Object.prototype.toString;

    function l(t) {
      if (!(this instanceof l)) return new l(t);
      this.options = i.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, t || {});
      var e = this.options;
      e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
      var r = n.inflateInit2(this.strm, e.windowBits);
      if (r !== a.Z_OK) throw new Error(s[r]);
      if (this.header = new c(), n.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = o.string2buf(e.dictionary) : "[object ArrayBuffer]" === f.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (r = n.inflateSetDictionary(this.strm, e.dictionary)) !== a.Z_OK)) throw new Error(s[r]);
    }

    function d(t, e) {
      var r = new l(e);
      if (r.push(t, !0), r.err) throw r.msg || s[r.err];
      return r.result;
    }

    l.prototype.push = function (t, e) {
      var r,
          s,
          u,
          c,
          l,
          d = this.strm,
          h = this.options.chunkSize,
          p = this.options.dictionary,
          g = !1;
      if (this.ended) return !1;
      s = e === ~~e ? e : !0 === e ? a.Z_FINISH : a.Z_NO_FLUSH, "string" == typeof t ? d.input = o.binstring2buf(t) : "[object ArrayBuffer]" === f.call(t) ? d.input = new Uint8Array(t) : d.input = t, d.next_in = 0, d.avail_in = d.input.length;

      do {
        if (0 === d.avail_out && (d.output = new i.Buf8(h), d.next_out = 0, d.avail_out = h), (r = n.inflate(d, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && p && (r = n.inflateSetDictionary(this.strm, p)), r === a.Z_BUF_ERROR && !0 === g && (r = a.Z_OK, g = !1), r !== a.Z_STREAM_END && r !== a.Z_OK) return this.onEnd(r), this.ended = !0, !1;
        d.next_out && (0 !== d.avail_out && r !== a.Z_STREAM_END && (0 !== d.avail_in || s !== a.Z_FINISH && s !== a.Z_SYNC_FLUSH) || ("string" === this.options.to ? (u = o.utf8border(d.output, d.next_out), c = d.next_out - u, l = o.buf2string(d.output, u), d.next_out = c, d.avail_out = h - c, c && i.arraySet(d.output, d.output, u, c, 0), this.onData(l)) : this.onData(i.shrinkBuf(d.output, d.next_out)))), 0 === d.avail_in && 0 === d.avail_out && (g = !0);
      } while ((d.avail_in > 0 || 0 === d.avail_out) && r !== a.Z_STREAM_END);

      return r === a.Z_STREAM_END && (s = a.Z_FINISH), s === a.Z_FINISH ? (r = n.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === a.Z_OK) : s !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), d.avail_out = 0, !0);
    }, l.prototype.onData = function (t) {
      this.chunks.push(t);
    }, l.prototype.onEnd = function (t) {
      t === a.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
    }, e.Inflate = l, e.inflate = d, e.inflateRaw = function (t, e) {
      return (e = e || {}).raw = !0, d(t, e);
    }, e.ungzip = d;
  }, function (t, e, r) {
    "use strict";

    var n = r(23),
        i = r(74),
        o = r(75),
        a = r(109),
        s = r(110),
        u = 0,
        c = 1,
        f = 2,
        l = 4,
        d = 5,
        h = 6,
        p = 0,
        g = 1,
        m = 2,
        y = -2,
        v = -3,
        w = -4,
        b = -5,
        _ = 8,
        x = 1,
        E = 2,
        k = 3,
        O = 4,
        j = 5,
        P = 6,
        S = 7,
        R = 8,
        A = 9,
        $ = 10,
        T = 11,
        I = 12,
        B = 13,
        F = 14,
        U = 15,
        M = 16,
        C = 17,
        D = 18,
        N = 19,
        z = 20,
        H = 21,
        L = 22,
        G = 23,
        q = 24,
        W = 25,
        Y = 26,
        Z = 27,
        K = 28,
        V = 29,
        X = 30,
        J = 31,
        Q = 32,
        tt = 852,
        et = 592,
        rt = 15;

    function nt(t) {
      return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);
    }

    function it() {
      this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }

    function ot(t) {
      var e;
      return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = x, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new n.Buf32(tt), e.distcode = e.distdyn = new n.Buf32(et), e.sane = 1, e.back = -1, p) : y;
    }

    function at(t) {
      var e;
      return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, ot(t)) : y;
    }

    function st(t, e) {
      var r, n;
      return t && t.state ? (n = t.state, e < 0 ? (r = 0, e = -e) : (r = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? y : (null !== n.window && n.wbits !== e && (n.window = null), n.wrap = r, n.wbits = e, at(t))) : y;
    }

    function ut(t, e) {
      var r, n;
      return t ? (n = new it(), t.state = n, n.window = null, (r = st(t, e)) !== p && (t.state = null), r) : y;
    }

    var ct,
        ft,
        lt = !0;

    function dt(t) {
      if (lt) {
        var e;

        for (ct = new n.Buf32(512), ft = new n.Buf32(32), e = 0; e < 144;) {
          t.lens[e++] = 8;
        }

        for (; e < 256;) {
          t.lens[e++] = 9;
        }

        for (; e < 280;) {
          t.lens[e++] = 7;
        }

        for (; e < 288;) {
          t.lens[e++] = 8;
        }

        for (s(c, t.lens, 0, 288, ct, 0, t.work, {
          bits: 9
        }), e = 0; e < 32;) {
          t.lens[e++] = 5;
        }

        s(f, t.lens, 0, 32, ft, 0, t.work, {
          bits: 5
        }), lt = !1;
      }

      t.lencode = ct, t.lenbits = 9, t.distcode = ft, t.distbits = 5;
    }

    function ht(t, e, r, i) {
      var o,
          a = t.state;
      return null === a.window && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new n.Buf8(a.wsize)), i >= a.wsize ? (n.arraySet(a.window, e, r - a.wsize, a.wsize, 0), a.wnext = 0, a.whave = a.wsize) : ((o = a.wsize - a.wnext) > i && (o = i), n.arraySet(a.window, e, r - i, o, a.wnext), (i -= o) ? (n.arraySet(a.window, e, r - i, i, 0), a.wnext = i, a.whave = a.wsize) : (a.wnext += o, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += o))), 0;
    }

    e.inflateReset = at, e.inflateReset2 = st, e.inflateResetKeep = ot, e.inflateInit = function (t) {
      return ut(t, rt);
    }, e.inflateInit2 = ut, e.inflate = function (t, e) {
      var r,
          tt,
          et,
          rt,
          it,
          ot,
          at,
          st,
          ut,
          ct,
          ft,
          lt,
          pt,
          gt,
          mt,
          yt,
          vt,
          wt,
          bt,
          _t,
          xt,
          Et,
          kt,
          Ot,
          jt = 0,
          Pt = new n.Buf8(4),
          St = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

      if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return y;
      (r = t.state).mode === I && (r.mode = B), it = t.next_out, et = t.output, at = t.avail_out, rt = t.next_in, tt = t.input, ot = t.avail_in, st = r.hold, ut = r.bits, ct = ot, ft = at, Et = p;

      t: for (;;) {
        switch (r.mode) {
          case x:
            if (0 === r.wrap) {
              r.mode = B;
              break;
            }

            for (; ut < 16;) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            if (2 & r.wrap && 35615 === st) {
              r.check = 0, Pt[0] = 255 & st, Pt[1] = st >>> 8 & 255, r.check = o(r.check, Pt, 2, 0), st = 0, ut = 0, r.mode = E;
              break;
            }

            if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & st) << 8) + (st >> 8)) % 31) {
              t.msg = "incorrect header check", r.mode = X;
              break;
            }

            if ((15 & st) !== _) {
              t.msg = "unknown compression method", r.mode = X;
              break;
            }

            if (ut -= 4, xt = 8 + (15 & (st >>>= 4)), 0 === r.wbits) r.wbits = xt;else if (xt > r.wbits) {
              t.msg = "invalid window size", r.mode = X;
              break;
            }
            r.dmax = 1 << xt, t.adler = r.check = 1, r.mode = 512 & st ? $ : I, st = 0, ut = 0;
            break;

          case E:
            for (; ut < 16;) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            if (r.flags = st, (255 & r.flags) !== _) {
              t.msg = "unknown compression method", r.mode = X;
              break;
            }

            if (57344 & r.flags) {
              t.msg = "unknown header flags set", r.mode = X;
              break;
            }

            r.head && (r.head.text = st >> 8 & 1), 512 & r.flags && (Pt[0] = 255 & st, Pt[1] = st >>> 8 & 255, r.check = o(r.check, Pt, 2, 0)), st = 0, ut = 0, r.mode = k;

          case k:
            for (; ut < 32;) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            r.head && (r.head.time = st), 512 & r.flags && (Pt[0] = 255 & st, Pt[1] = st >>> 8 & 255, Pt[2] = st >>> 16 & 255, Pt[3] = st >>> 24 & 255, r.check = o(r.check, Pt, 4, 0)), st = 0, ut = 0, r.mode = O;

          case O:
            for (; ut < 16;) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            r.head && (r.head.xflags = 255 & st, r.head.os = st >> 8), 512 & r.flags && (Pt[0] = 255 & st, Pt[1] = st >>> 8 & 255, r.check = o(r.check, Pt, 2, 0)), st = 0, ut = 0, r.mode = j;

          case j:
            if (1024 & r.flags) {
              for (; ut < 16;) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              r.length = st, r.head && (r.head.extra_len = st), 512 & r.flags && (Pt[0] = 255 & st, Pt[1] = st >>> 8 & 255, r.check = o(r.check, Pt, 2, 0)), st = 0, ut = 0;
            } else r.head && (r.head.extra = null);

            r.mode = P;

          case P:
            if (1024 & r.flags && ((lt = r.length) > ot && (lt = ot), lt && (r.head && (xt = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), n.arraySet(r.head.extra, tt, rt, lt, xt)), 512 & r.flags && (r.check = o(r.check, tt, lt, rt)), ot -= lt, rt += lt, r.length -= lt), r.length)) break t;
            r.length = 0, r.mode = S;

          case S:
            if (2048 & r.flags) {
              if (0 === ot) break t;
              lt = 0;

              do {
                xt = tt[rt + lt++], r.head && xt && r.length < 65536 && (r.head.name += String.fromCharCode(xt));
              } while (xt && lt < ot);

              if (512 & r.flags && (r.check = o(r.check, tt, lt, rt)), ot -= lt, rt += lt, xt) break t;
            } else r.head && (r.head.name = null);

            r.length = 0, r.mode = R;

          case R:
            if (4096 & r.flags) {
              if (0 === ot) break t;
              lt = 0;

              do {
                xt = tt[rt + lt++], r.head && xt && r.length < 65536 && (r.head.comment += String.fromCharCode(xt));
              } while (xt && lt < ot);

              if (512 & r.flags && (r.check = o(r.check, tt, lt, rt)), ot -= lt, rt += lt, xt) break t;
            } else r.head && (r.head.comment = null);

            r.mode = A;

          case A:
            if (512 & r.flags) {
              for (; ut < 16;) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              if (st !== (65535 & r.check)) {
                t.msg = "header crc mismatch", r.mode = X;
                break;
              }

              st = 0, ut = 0;
            }

            r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = I;
            break;

          case $:
            for (; ut < 32;) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            t.adler = r.check = nt(st), st = 0, ut = 0, r.mode = T;

          case T:
            if (0 === r.havedict) return t.next_out = it, t.avail_out = at, t.next_in = rt, t.avail_in = ot, r.hold = st, r.bits = ut, m;
            t.adler = r.check = 1, r.mode = I;

          case I:
            if (e === d || e === h) break t;

          case B:
            if (r.last) {
              st >>>= 7 & ut, ut -= 7 & ut, r.mode = Z;
              break;
            }

            for (; ut < 3;) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            switch (r.last = 1 & st, ut -= 1, 3 & (st >>>= 1)) {
              case 0:
                r.mode = F;
                break;

              case 1:
                if (dt(r), r.mode = z, e === h) {
                  st >>>= 2, ut -= 2;
                  break t;
                }

                break;

              case 2:
                r.mode = C;
                break;

              case 3:
                t.msg = "invalid block type", r.mode = X;
            }

            st >>>= 2, ut -= 2;
            break;

          case F:
            for (st >>>= 7 & ut, ut -= 7 & ut; ut < 32;) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            if ((65535 & st) != (st >>> 16 ^ 65535)) {
              t.msg = "invalid stored block lengths", r.mode = X;
              break;
            }

            if (r.length = 65535 & st, st = 0, ut = 0, r.mode = U, e === h) break t;

          case U:
            r.mode = M;

          case M:
            if (lt = r.length) {
              if (lt > ot && (lt = ot), lt > at && (lt = at), 0 === lt) break t;
              n.arraySet(et, tt, rt, lt, it), ot -= lt, rt += lt, at -= lt, it += lt, r.length -= lt;
              break;
            }

            r.mode = I;
            break;

          case C:
            for (; ut < 14;) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            if (r.nlen = 257 + (31 & st), st >>>= 5, ut -= 5, r.ndist = 1 + (31 & st), st >>>= 5, ut -= 5, r.ncode = 4 + (15 & st), st >>>= 4, ut -= 4, r.nlen > 286 || r.ndist > 30) {
              t.msg = "too many length or distance symbols", r.mode = X;
              break;
            }

            r.have = 0, r.mode = D;

          case D:
            for (; r.have < r.ncode;) {
              for (; ut < 3;) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              r.lens[St[r.have++]] = 7 & st, st >>>= 3, ut -= 3;
            }

            for (; r.have < 19;) {
              r.lens[St[r.have++]] = 0;
            }

            if (r.lencode = r.lendyn, r.lenbits = 7, kt = {
              bits: r.lenbits
            }, Et = s(u, r.lens, 0, 19, r.lencode, 0, r.work, kt), r.lenbits = kt.bits, Et) {
              t.msg = "invalid code lengths set", r.mode = X;
              break;
            }

            r.have = 0, r.mode = N;

          case N:
            for (; r.have < r.nlen + r.ndist;) {
              for (; yt = (jt = r.lencode[st & (1 << r.lenbits) - 1]) >>> 16 & 255, vt = 65535 & jt, !((mt = jt >>> 24) <= ut);) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              if (vt < 16) st >>>= mt, ut -= mt, r.lens[r.have++] = vt;else {
                if (16 === vt) {
                  for (Ot = mt + 2; ut < Ot;) {
                    if (0 === ot) break t;
                    ot--, st += tt[rt++] << ut, ut += 8;
                  }

                  if (st >>>= mt, ut -= mt, 0 === r.have) {
                    t.msg = "invalid bit length repeat", r.mode = X;
                    break;
                  }

                  xt = r.lens[r.have - 1], lt = 3 + (3 & st), st >>>= 2, ut -= 2;
                } else if (17 === vt) {
                  for (Ot = mt + 3; ut < Ot;) {
                    if (0 === ot) break t;
                    ot--, st += tt[rt++] << ut, ut += 8;
                  }

                  ut -= mt, xt = 0, lt = 3 + (7 & (st >>>= mt)), st >>>= 3, ut -= 3;
                } else {
                  for (Ot = mt + 7; ut < Ot;) {
                    if (0 === ot) break t;
                    ot--, st += tt[rt++] << ut, ut += 8;
                  }

                  ut -= mt, xt = 0, lt = 11 + (127 & (st >>>= mt)), st >>>= 7, ut -= 7;
                }

                if (r.have + lt > r.nlen + r.ndist) {
                  t.msg = "invalid bit length repeat", r.mode = X;
                  break;
                }

                for (; lt--;) {
                  r.lens[r.have++] = xt;
                }
              }
            }

            if (r.mode === X) break;

            if (0 === r.lens[256]) {
              t.msg = "invalid code -- missing end-of-block", r.mode = X;
              break;
            }

            if (r.lenbits = 9, kt = {
              bits: r.lenbits
            }, Et = s(c, r.lens, 0, r.nlen, r.lencode, 0, r.work, kt), r.lenbits = kt.bits, Et) {
              t.msg = "invalid literal/lengths set", r.mode = X;
              break;
            }

            if (r.distbits = 6, r.distcode = r.distdyn, kt = {
              bits: r.distbits
            }, Et = s(f, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, kt), r.distbits = kt.bits, Et) {
              t.msg = "invalid distances set", r.mode = X;
              break;
            }

            if (r.mode = z, e === h) break t;

          case z:
            r.mode = H;

          case H:
            if (ot >= 6 && at >= 258) {
              t.next_out = it, t.avail_out = at, t.next_in = rt, t.avail_in = ot, r.hold = st, r.bits = ut, a(t, ft), it = t.next_out, et = t.output, at = t.avail_out, rt = t.next_in, tt = t.input, ot = t.avail_in, st = r.hold, ut = r.bits, r.mode === I && (r.back = -1);
              break;
            }

            for (r.back = 0; yt = (jt = r.lencode[st & (1 << r.lenbits) - 1]) >>> 16 & 255, vt = 65535 & jt, !((mt = jt >>> 24) <= ut);) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            if (yt && 0 == (240 & yt)) {
              for (wt = mt, bt = yt, _t = vt; yt = (jt = r.lencode[_t + ((st & (1 << wt + bt) - 1) >> wt)]) >>> 16 & 255, vt = 65535 & jt, !(wt + (mt = jt >>> 24) <= ut);) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              st >>>= wt, ut -= wt, r.back += wt;
            }

            if (st >>>= mt, ut -= mt, r.back += mt, r.length = vt, 0 === yt) {
              r.mode = Y;
              break;
            }

            if (32 & yt) {
              r.back = -1, r.mode = I;
              break;
            }

            if (64 & yt) {
              t.msg = "invalid literal/length code", r.mode = X;
              break;
            }

            r.extra = 15 & yt, r.mode = L;

          case L:
            if (r.extra) {
              for (Ot = r.extra; ut < Ot;) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              r.length += st & (1 << r.extra) - 1, st >>>= r.extra, ut -= r.extra, r.back += r.extra;
            }

            r.was = r.length, r.mode = G;

          case G:
            for (; yt = (jt = r.distcode[st & (1 << r.distbits) - 1]) >>> 16 & 255, vt = 65535 & jt, !((mt = jt >>> 24) <= ut);) {
              if (0 === ot) break t;
              ot--, st += tt[rt++] << ut, ut += 8;
            }

            if (0 == (240 & yt)) {
              for (wt = mt, bt = yt, _t = vt; yt = (jt = r.distcode[_t + ((st & (1 << wt + bt) - 1) >> wt)]) >>> 16 & 255, vt = 65535 & jt, !(wt + (mt = jt >>> 24) <= ut);) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              st >>>= wt, ut -= wt, r.back += wt;
            }

            if (st >>>= mt, ut -= mt, r.back += mt, 64 & yt) {
              t.msg = "invalid distance code", r.mode = X;
              break;
            }

            r.offset = vt, r.extra = 15 & yt, r.mode = q;

          case q:
            if (r.extra) {
              for (Ot = r.extra; ut < Ot;) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              r.offset += st & (1 << r.extra) - 1, st >>>= r.extra, ut -= r.extra, r.back += r.extra;
            }

            if (r.offset > r.dmax) {
              t.msg = "invalid distance too far back", r.mode = X;
              break;
            }

            r.mode = W;

          case W:
            if (0 === at) break t;

            if (lt = ft - at, r.offset > lt) {
              if ((lt = r.offset - lt) > r.whave && r.sane) {
                t.msg = "invalid distance too far back", r.mode = X;
                break;
              }

              lt > r.wnext ? (lt -= r.wnext, pt = r.wsize - lt) : pt = r.wnext - lt, lt > r.length && (lt = r.length), gt = r.window;
            } else gt = et, pt = it - r.offset, lt = r.length;

            lt > at && (lt = at), at -= lt, r.length -= lt;

            do {
              et[it++] = gt[pt++];
            } while (--lt);

            0 === r.length && (r.mode = H);
            break;

          case Y:
            if (0 === at) break t;
            et[it++] = r.length, at--, r.mode = H;
            break;

          case Z:
            if (r.wrap) {
              for (; ut < 32;) {
                if (0 === ot) break t;
                ot--, st |= tt[rt++] << ut, ut += 8;
              }

              if (ft -= at, t.total_out += ft, r.total += ft, ft && (t.adler = r.check = r.flags ? o(r.check, et, ft, it - ft) : i(r.check, et, ft, it - ft)), ft = at, (r.flags ? st : nt(st)) !== r.check) {
                t.msg = "incorrect data check", r.mode = X;
                break;
              }

              st = 0, ut = 0;
            }

            r.mode = K;

          case K:
            if (r.wrap && r.flags) {
              for (; ut < 32;) {
                if (0 === ot) break t;
                ot--, st += tt[rt++] << ut, ut += 8;
              }

              if (st !== (4294967295 & r.total)) {
                t.msg = "incorrect length check", r.mode = X;
                break;
              }

              st = 0, ut = 0;
            }

            r.mode = V;

          case V:
            Et = g;
            break t;

          case X:
            Et = v;
            break t;

          case J:
            return w;

          case Q:
          default:
            return y;
        }
      }

      return t.next_out = it, t.avail_out = at, t.next_in = rt, t.avail_in = ot, r.hold = st, r.bits = ut, (r.wsize || ft !== t.avail_out && r.mode < X && (r.mode < Z || e !== l)) && ht(t, t.output, t.next_out, ft - t.avail_out) ? (r.mode = J, w) : (ct -= t.avail_in, ft -= t.avail_out, t.total_in += ct, t.total_out += ft, r.total += ft, r.wrap && ft && (t.adler = r.check = r.flags ? o(r.check, et, ft, t.next_out - ft) : i(r.check, et, ft, t.next_out - ft)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === I ? 128 : 0) + (r.mode === z || r.mode === U ? 256 : 0), (0 === ct && 0 === ft || e === l) && Et === p && (Et = b), Et);
    }, e.inflateEnd = function (t) {
      if (!t || !t.state) return y;
      var e = t.state;
      return e.window && (e.window = null), t.state = null, p;
    }, e.inflateGetHeader = function (t, e) {
      var r;
      return t && t.state ? 0 == (2 & (r = t.state).wrap) ? y : (r.head = e, e.done = !1, p) : y;
    }, e.inflateSetDictionary = function (t, e) {
      var r,
          n = e.length;
      return t && t.state ? 0 !== (r = t.state).wrap && r.mode !== T ? y : r.mode === T && i(1, e, n, 0) !== r.check ? v : ht(t, e, n, n) ? (r.mode = J, w) : (r.havedict = 1, p) : y;
    }, e.inflateInfo = "pako inflate (from Nodeca project)";
  }, function (t, e, r) {
    "use strict";

    t.exports = function (t, e) {
      var r, n, i, o, a, s, u, c, f, l, d, h, p, g, m, y, v, w, b, _, x, E, k, O, j;

      r = t.state, n = t.next_in, O = t.input, i = n + (t.avail_in - 5), o = t.next_out, j = t.output, a = o - (e - t.avail_out), s = o + (t.avail_out - 257), u = r.dmax, c = r.wsize, f = r.whave, l = r.wnext, d = r.window, h = r.hold, p = r.bits, g = r.lencode, m = r.distcode, y = (1 << r.lenbits) - 1, v = (1 << r.distbits) - 1;

      t: do {
        p < 15 && (h += O[n++] << p, p += 8, h += O[n++] << p, p += 8), w = g[h & y];

        e: for (;;) {
          if (h >>>= b = w >>> 24, p -= b, 0 === (b = w >>> 16 & 255)) j[o++] = 65535 & w;else {
            if (!(16 & b)) {
              if (0 == (64 & b)) {
                w = g[(65535 & w) + (h & (1 << b) - 1)];
                continue e;
              }

              if (32 & b) {
                r.mode = 12;
                break t;
              }

              t.msg = "invalid literal/length code", r.mode = 30;
              break t;
            }

            _ = 65535 & w, (b &= 15) && (p < b && (h += O[n++] << p, p += 8), _ += h & (1 << b) - 1, h >>>= b, p -= b), p < 15 && (h += O[n++] << p, p += 8, h += O[n++] << p, p += 8), w = m[h & v];

            r: for (;;) {
              if (h >>>= b = w >>> 24, p -= b, !(16 & (b = w >>> 16 & 255))) {
                if (0 == (64 & b)) {
                  w = m[(65535 & w) + (h & (1 << b) - 1)];
                  continue r;
                }

                t.msg = "invalid distance code", r.mode = 30;
                break t;
              }

              if (x = 65535 & w, p < (b &= 15) && (h += O[n++] << p, (p += 8) < b && (h += O[n++] << p, p += 8)), (x += h & (1 << b) - 1) > u) {
                t.msg = "invalid distance too far back", r.mode = 30;
                break t;
              }

              if (h >>>= b, p -= b, x > (b = o - a)) {
                if ((b = x - b) > f && r.sane) {
                  t.msg = "invalid distance too far back", r.mode = 30;
                  break t;
                }

                if (E = 0, k = d, 0 === l) {
                  if (E += c - b, b < _) {
                    _ -= b;

                    do {
                      j[o++] = d[E++];
                    } while (--b);

                    E = o - x, k = j;
                  }
                } else if (l < b) {
                  if (E += c + l - b, (b -= l) < _) {
                    _ -= b;

                    do {
                      j[o++] = d[E++];
                    } while (--b);

                    if (E = 0, l < _) {
                      _ -= b = l;

                      do {
                        j[o++] = d[E++];
                      } while (--b);

                      E = o - x, k = j;
                    }
                  }
                } else if (E += l - b, b < _) {
                  _ -= b;

                  do {
                    j[o++] = d[E++];
                  } while (--b);

                  E = o - x, k = j;
                }

                for (; _ > 2;) {
                  j[o++] = k[E++], j[o++] = k[E++], j[o++] = k[E++], _ -= 3;
                }

                _ && (j[o++] = k[E++], _ > 1 && (j[o++] = k[E++]));
              } else {
                E = o - x;

                do {
                  j[o++] = j[E++], j[o++] = j[E++], j[o++] = j[E++], _ -= 3;
                } while (_ > 2);

                _ && (j[o++] = j[E++], _ > 1 && (j[o++] = j[E++]));
              }

              break;
            }
          }
          break;
        }
      } while (n < i && o < s);

      n -= _ = p >> 3, h &= (1 << (p -= _ << 3)) - 1, t.next_in = n, t.next_out = o, t.avail_in = n < i ? i - n + 5 : 5 - (n - i), t.avail_out = o < s ? s - o + 257 : 257 - (o - s), r.hold = h, r.bits = p;
    };
  }, function (t, e, r) {
    "use strict";

    var n = r(23),
        i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
        o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
        a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
        s = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

    t.exports = function (t, e, r, u, c, f, l, d) {
      var h,
          p,
          g,
          m,
          y,
          v,
          w,
          b,
          _,
          x = d.bits,
          E = 0,
          k = 0,
          O = 0,
          j = 0,
          P = 0,
          S = 0,
          R = 0,
          A = 0,
          $ = 0,
          T = 0,
          I = null,
          B = 0,
          F = new n.Buf16(16),
          U = new n.Buf16(16),
          M = null,
          C = 0;

      for (E = 0; E <= 15; E++) {
        F[E] = 0;
      }

      for (k = 0; k < u; k++) {
        F[e[r + k]]++;
      }

      for (P = x, j = 15; j >= 1 && 0 === F[j]; j--) {
        ;
      }

      if (P > j && (P = j), 0 === j) return c[f++] = 20971520, c[f++] = 20971520, d.bits = 1, 0;

      for (O = 1; O < j && 0 === F[O]; O++) {
        ;
      }

      for (P < O && (P = O), A = 1, E = 1; E <= 15; E++) {
        if (A <<= 1, (A -= F[E]) < 0) return -1;
      }

      if (A > 0 && (0 === t || 1 !== j)) return -1;

      for (U[1] = 0, E = 1; E < 15; E++) {
        U[E + 1] = U[E] + F[E];
      }

      for (k = 0; k < u; k++) {
        0 !== e[r + k] && (l[U[e[r + k]]++] = k);
      }

      if (0 === t ? (I = M = l, v = 19) : 1 === t ? (I = i, B -= 257, M = o, C -= 257, v = 256) : (I = a, M = s, v = -1), T = 0, k = 0, E = O, y = f, S = P, R = 0, g = -1, m = ($ = 1 << P) - 1, 1 === t && $ > 852 || 2 === t && $ > 592) return 1;

      for (;;) {
        w = E - R, l[k] < v ? (b = 0, _ = l[k]) : l[k] > v ? (b = M[C + l[k]], _ = I[B + l[k]]) : (b = 96, _ = 0), h = 1 << E - R, O = p = 1 << S;

        do {
          c[y + (T >> R) + (p -= h)] = w << 24 | b << 16 | _ | 0;
        } while (0 !== p);

        for (h = 1 << E - 1; T & h;) {
          h >>= 1;
        }

        if (0 !== h ? (T &= h - 1, T += h) : T = 0, k++, 0 == --F[E]) {
          if (E === j) break;
          E = e[r + l[k]];
        }

        if (E > P && (T & m) !== g) {
          for (0 === R && (R = P), y += O, A = 1 << (S = E - R); S + R < j && !((A -= F[S + R]) <= 0);) {
            S++, A <<= 1;
          }

          if ($ += 1 << S, 1 === t && $ > 852 || 2 === t && $ > 592) return 1;
          c[g = T & m] = P << 24 | S << 16 | y - f | 0;
        }
      }

      return 0 !== T && (c[y + T] = E - R << 24 | 64 << 16 | 0), d.bits = P, 0;
    };
  }, function (t, e, r) {
    "use strict";

    t.exports = function () {
      this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
    };
  }, function (t, e, r) {
    var n = {};

    function i(t, e) {
      for (var r in t) {
        e[r] = t[r];
      }
    }

    t.exports = n, n.from = r(113), n.to = r(114), n.is = r(116), n.subarray = r(117), n.join = r(118), n.copy = r(119), n.create = r(120), i(r(121), n), i(r(122), n);
  }, function (t, e, r) {
    t.exports = function (t, e) {
      if (Array.isArray(t)) return new Uint8Array(t);
      return i[e || "utf8"](t);
    };

    var n = r(59),
        i = {
      hex: function hex(t) {
        for (var e = t.length / 2, r = new Uint8Array(e), n = "", i = 0, o = t.length; i < o; ++i) {
          n += t.charAt(i), i > 0 && i % 2 == 1 && (r[i >>> 1] = parseInt(n, 16), n = "");
        }

        return r;
      },
      utf8: function utf8(t) {
        for (var e, r, n = [], i = 0, o = t.length; i < o; ++i) {
          if (128 & (r = t.charCodeAt(i))) {
            e = encodeURIComponent(t.charAt(i)).substr(1).split("%");

            for (var a = 0, s = e.length; a < s; ++a) {
              n[n.length] = parseInt(e[a], 16);
            }
          } else n[n.length] = r;
        }

        return new Uint8Array(n);
      },
      base64: function base64(t) {
        return new Uint8Array(n.toByteArray(t));
      }
    };
  }, function (t, e, r) {
    t.exports = function (t, e) {
      return o[e || "utf8"](t);
    };

    var n = r(59),
        i = r(115),
        o = {
      hex: function hex(t) {
        for (var e, r = "", n = 0, i = t.length; n < i; ++n) {
          e = t[n], r += ((240 & e) >>> 4).toString(16), r += (15 & e).toString(16);
        }

        return r;
      },
      utf8: function utf8(t) {
        return i(t);
      },
      base64: function base64(t) {
        return n.fromByteArray(t);
      }
    };
  }, function (t, e) {
    t.exports = function (t, e, o) {
      e = void 0 === e ? 0 : e, o = void 0 === o ? t.length : o;
      var c,
          f,
          l = 0,
          d = 0;
      n.length = r.length = 0;

      for (; l < t.length;) {
        f = t[l], !d && 128 & f ? (c = s(f), d += c, c < 8 && (n[n.length] = f & a[6 - c])) : d ? (n[n.length] = f & a[6], ! --d && n.length && (r[r.length] = i(u(n)), n.length = 0)) : r[r.length] = i(f), ++l;
      }

      n.length && !d && (r[r.length] = i(u(n)), n.length = 0);
      return r.join("");
    };

    var r = [],
        n = [],
        i = String.fromCharCode,
        o = [64, 32, 16, 8, 4, 2, 1],
        a = [0, 1, 3, 7, 15, 31, 63, 127];

    function s(t) {
      for (var e = 0; e < 7 && t & o[e]; ++e) {
        ;
      }

      return e;
    }

    function u(t) {
      for (var e = 0, r = 0, n = t.length; r < n; ++r) {
        e |= t[r] << 6 * (n - r - 1);
      }

      return e;
    }
  }, function (t, e) {
    t.exports = function (t) {
      return t instanceof Uint8Array;
    };
  }, function (t, e) {
    t.exports = function (t, e, r) {
      return t.subarray(e || 0, r || t.length);
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      if (!t.length) return new Uint8Array(0);
      var r = void 0 !== e ? e : function (t) {
        for (var e = 0, r = 0, n = t.length; r < n; ++r) {
          e += t[r].byteLength;
        }

        return e;
      }(t),
          n = new Uint8Array(r),
          i = t[0],
          o = i.length,
          a = 0,
          s = 0,
          u = 0;

      for (; u < r;) {
        s !== o ? n[u++] = i[s++] : (s = 0, i = t[++a], o = i && i.length);
      }

      return n;
    };
  }, function (t, e) {
    t.exports = function (t, e, n, i, o) {
      if (n = arguments.length < 3 ? 0 : n, i = arguments.length < 4 ? 0 : i, (o = arguments.length < 5 ? t.length : o) === i) return;
      if (0 === e.length || 0 === t.length) return;
      o > t.length && (o = t.length);
      e.length - n < o - i && (o = e.length - n + i);
      if (t.buffer !== e.buffer) return function (t, e, r, n, i) {
        for (var o = i - n + r, a = r, s = n; a < o; ++a, ++s) {
          e[a] = t[s];
        }
      }(t, e, n, i, o);
      return function (t, e, n, i, o) {
        for (var a = o + i, s = new Uint8Array(r.call(t, i, a)), u = 0; i < a; ++i, ++u) {
          e[n++] = s[u];
        }
      }(t, e, n, i, o);
    };

    var r = [].slice;
  }, function (t, e) {
    t.exports = function (t) {
      return new Uint8Array(t);
    };
  }, function (t, e, r) {
    t.exports = {
      readUInt8: function readUInt8(t, e) {
        return t[e];
      },
      readInt8: function readInt8(t, e) {
        var r = t[e];
        return r < 128 ? r : r - 256;
      },
      readUInt16LE: function readUInt16LE(t, e) {
        return n.get(t).getUint16(e + t.byteOffset, !0);
      },
      readUInt32LE: function readUInt32LE(t, e) {
        return n.get(t).getUint32(e + t.byteOffset, !0);
      },
      readInt16LE: function readInt16LE(t, e) {
        return n.get(t).getInt16(e + t.byteOffset, !0);
      },
      readInt32LE: function readInt32LE(t, e) {
        return n.get(t).getInt32(e + t.byteOffset, !0);
      },
      readFloatLE: function readFloatLE(t, e) {
        return n.get(t).getFloat32(e + t.byteOffset, !0);
      },
      readDoubleLE: function readDoubleLE(t, e) {
        return n.get(t).getFloat64(e + t.byteOffset, !0);
      },
      readUInt16BE: function readUInt16BE(t, e) {
        return n.get(t).getUint16(e + t.byteOffset, !1);
      },
      readUInt32BE: function readUInt32BE(t, e) {
        return n.get(t).getUint32(e + t.byteOffset, !1);
      },
      readInt16BE: function readInt16BE(t, e) {
        return n.get(t).getInt16(e + t.byteOffset, !1);
      },
      readInt32BE: function readInt32BE(t, e) {
        return n.get(t).getInt32(e + t.byteOffset, !1);
      },
      readFloatBE: function readFloatBE(t, e) {
        return n.get(t).getFloat32(e + t.byteOffset, !1);
      },
      readDoubleBE: function readDoubleBE(t, e) {
        return n.get(t).getFloat64(e + t.byteOffset, !1);
      }
    };
    var n = r(79);
  }, function (t, e, r) {
    t.exports = {
      writeUInt8: function writeUInt8(t, e, r) {
        return t[r] = e;
      },
      writeInt8: function writeInt8(t, e, r) {
        return t[r] = e < 0 ? e + 256 : e;
      },
      writeUInt16LE: function writeUInt16LE(t, e, r) {
        return n.get(t).setUint16(r + t.byteOffset, e, !0);
      },
      writeUInt32LE: function writeUInt32LE(t, e, r) {
        return n.get(t).setUint32(r + t.byteOffset, e, !0);
      },
      writeInt16LE: function writeInt16LE(t, e, r) {
        return n.get(t).setInt16(r + t.byteOffset, e, !0);
      },
      writeInt32LE: function writeInt32LE(t, e, r) {
        return n.get(t).setInt32(r + t.byteOffset, e, !0);
      },
      writeFloatLE: function writeFloatLE(t, e, r) {
        return n.get(t).setFloat32(r + t.byteOffset, e, !0);
      },
      writeDoubleLE: function writeDoubleLE(t, e, r) {
        return n.get(t).setFloat64(r + t.byteOffset, e, !0);
      },
      writeUInt16BE: function writeUInt16BE(t, e, r) {
        return n.get(t).setUint16(r + t.byteOffset, e, !1);
      },
      writeUInt32BE: function writeUInt32BE(t, e, r) {
        return n.get(t).setUint32(r + t.byteOffset, e, !1);
      },
      writeInt16BE: function writeInt16BE(t, e, r) {
        return n.get(t).setInt16(r + t.byteOffset, e, !1);
      },
      writeInt32BE: function writeInt32BE(t, e, r) {
        return n.get(t).setInt32(r + t.byteOffset, e, !1);
      },
      writeFloatBE: function writeFloatBE(t, e, r) {
        return n.get(t).setFloat32(r + t.byteOffset, e, !1);
      },
      writeDoubleBE: function writeDoubleBE(t, e, r) {
        return n.get(t).setFloat64(r + t.byteOffset, e, !1);
      }
    };
    var n = r(79);
  }, function (t, e) {
    t.exports = i;
    var r = 128,
        n = 127;

    function i() {
      this.accum = [];
    }

    i.prototype.write = function (t) {
      var e,
          i,
          o = t & r,
          a = this.accum;
      if (a[a.length] = t & n, o) return;
      e = a.length, i = 0;

      for (var s = 0; s < e; ++s) {
        i |= a[s] << 7 * s;
      }

      return a.length = 0, void this.ondata(i);
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      var r,
          n,
          i = t,
          o = e,
          a = i.length,
          s = o.length,
          u = !1,
          c = null,
          f = a + 1,
          l = [],
          d = [],
          h = [],
          p = "",
          g = function g(t, e, r) {
        return {
          x: t,
          y: e,
          k: r
        };
      },
          m = function m(t, e) {
        return {
          elem: t,
          t: e
        };
      },
          y = function y(t, e, r) {
        var n, u, c;

        for (n = e > r ? l[t - 1 + f] : l[t + 1 + f], u = (c = Math.max(e, r)) - t; u < a && c < s && i[u] === o[c];) {
          ++u, ++c;
        }

        return l[t + f] = d.length, d[d.length] = new g(u, c, n), c;
      };

      return a >= s && (r = i, n = a, i = o, o = r, a = s, s = n, u = !0, f = a + 1), {
        SES_DELETE: -1,
        SES_COMMON: 0,
        SES_ADD: 1,
        editdistance: function editdistance() {
          return c;
        },
        getlcs: function getlcs() {
          return p;
        },
        getses: function getses() {
          return h;
        },
        compose: function compose() {
          var t, e, r, n, v, w, b, _;

          for (t = s - a, e = a + s + 3, r = {}, b = 0; b < e; ++b) {
            r[b] = -1, l[b] = -1;
          }

          n = -1;

          do {
            for (_ = -++n; _ <= t - 1; ++_) {
              r[_ + f] = y(_, r[_ - 1 + f] + 1, r[_ + 1 + f]);
            }

            for (_ = t + n; _ >= t + 1; --_) {
              r[_ + f] = y(_, r[_ - 1 + f] + 1, r[_ + 1 + f]);
            }

            r[t + f] = y(t, r[t - 1 + f] + 1, r[t + 1 + f]);
          } while (r[t + f] !== s);

          for (c = t + 2 * n, v = l[t + f], w = []; -1 !== v;) {
            w[w.length] = new g(d[v].x, d[v].y, null), v = d[v].k;
          }

          !function (t) {
            var e, r, n;

            for (1, e = r = 0, n = t.length - 1; n >= 0; --n) {
              for (; e < t[n].x || r < t[n].y;) {
                t[n].y - t[n].x > r - e ? (h[h.length] = new m(o[r], u ? -1 : 1), 0, ++r) : t[n].y - t[n].x < r - e ? (h[h.length] = new m(i[e], u ? 1 : -1), 0, ++e) : (h[h.length] = new m(i[e], 0), p += i[e], 0, 0, ++e, ++r);
              }
            }
          }(w);
        }
      };
    };
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return o;
      });
      var n = r(128);

      function i(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function o(t) {
        return a.apply(this, arguments);
      }

      function a() {
        var e;
        return e =
        /*#__PURE__*/
        regeneratorRuntime.mark(function e(_ref93) {
          var _ref93$core, e, r, _e40, _ref94, _i16, _o15;

          return regeneratorRuntime.wrap(function e$(_context118) {
            while (1) {
              switch (_context118.prev = _context118.next) {
                case 0:
                  _ref93$core = _ref93.core, e = _ref93$core === void 0 ? "default" : _ref93$core, r = _ref93.object;
                  _context118.prev = 1;
                  "string" == typeof r && (r = t.from(r, "utf8"));
                  _e40 = "blob";
                  _context118.next = 6;
                  return Object(n.a)({
                    type: "blob",
                    format: "content",
                    object: r
                  });

                case 6:
                  _ref94 = _context118.sent;
                  _i16 = _ref94.oid;
                  _o15 = _ref94.object;
                  return _context118.abrupt("return", {
                    oid: _i16,
                    type: _e40,
                    object: _o15,
                    format: "wrapped"
                  });

                case 12:
                  _context118.prev = 12;
                  _context118.t0 = _context118["catch"](1);
                  throw _context118.t0.caller = "git.hashBlob", _context118.t0;

                case 15:
                case "end":
                  return _context118.stop();
              }
            }
          }, e, null, [[1, 12]]);
        }), (a = function a() {
          var t = this,
              r = arguments;
          return new Promise(function (n, o) {
            var a = e.apply(t, r);

            function s(t) {
              i(a, n, o, s, u, "next", t);
            }

            function u(t) {
              i(a, n, o, s, u, "throw", t);
            }

            s(void 0);
          });
        }).apply(this, arguments);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    "use strict";

    (function (t) {
      r.d(e, "a", function () {
        return d;
      });
      var n = r(1),
          i = r(14),
          o = r(7),
          a = r(0),
          s = r(11),
          u = r(20),
          c = r(2),
          f = r(3);

      function l(t, e, r, n, i, o, a) {
        try {
          var s = t[o](a),
              u = s.value;
        } catch (t) {
          return void r(t);
        }

        s.done ? e(u) : Promise.resolve(u).then(n, i);
      }

      function d(t) {
        return h.apply(this, arguments);
      }

      function h() {
        var e;
        return e =
        /*#__PURE__*/
        regeneratorRuntime.mark(function e(_ref95) {
          var _ref95$core, e, r, _ref95$gitdir, l, _ref95$fs, d, h, p, _ref95$format, g, m, y, _e41, _r32;

          return regeneratorRuntime.wrap(function e$(_context119) {
            while (1) {
              switch (_context119.prev = _context119.next) {
                case 0:
                  _ref95$core = _ref95.core, e = _ref95$core === void 0 ? "default" : _ref95$core, r = _ref95.dir, _ref95$gitdir = _ref95.gitdir, l = _ref95$gitdir === void 0 ? Object(c.a)(r, ".git") : _ref95$gitdir, _ref95$fs = _ref95.fs, d = _ref95$fs === void 0 ? f.a.get(e).get("fs") : _ref95$fs, h = _ref95.type, p = _ref95.object, _ref95$format = _ref95.format, g = _ref95$format === void 0 ? "parsed" : _ref95$format, m = _ref95.oid, y = _ref95.encoding;
                  _context119.prev = 1;
                  _e41 = new n.a(d);

                  if (!("parsed" === g)) {
                    _context119.next = 16;
                    break;
                  }

                  _context119.t0 = h;
                  _context119.next = _context119.t0 === "commit" ? 7 : _context119.t0 === "tree" ? 9 : _context119.t0 === "blob" ? 11 : _context119.t0 === "tag" ? 13 : 15;
                  break;

                case 7:
                  p = o.a.from(p).toObject();
                  return _context119.abrupt("break", 16);

                case 9:
                  p = s.a.from(p.entries).toObject();
                  return _context119.abrupt("break", 16);

                case 11:
                  p = t.from(p, y);
                  return _context119.abrupt("break", 16);

                case 13:
                  p = i.a.from(p).toObject();
                  return _context119.abrupt("break", 16);

                case 15:
                  throw new a.b(a.a.ObjectTypeUnknownFail, {
                    type: h
                  });

                case 16:
                  _r32 = "parsed" === g ? "content" : g;
                  _context119.next = 19;
                  return Object(u.a)({
                    fs: _e41,
                    gitdir: l,
                    type: h,
                    object: p,
                    oid: m,
                    format: _r32
                  });

                case 19:
                  return _context119.abrupt("return", m = _context119.sent);

                case 22:
                  _context119.prev = 22;
                  _context119.t1 = _context119["catch"](1);
                  throw _context119.t1.caller = "git.writeObject", _context119.t1;

                case 25:
                case "end":
                  return _context119.stop();
              }
            }
          }, e, null, [[1, 22]]);
        }), (h = function h() {
          var t = this,
              r = arguments;
          return new Promise(function (n, i) {
            var o = e.apply(t, r);

            function a(t) {
              l(o, n, i, a, s, "next", t);
            }

            function s(t) {
              l(o, n, i, a, s, "throw", t);
            }

            a(void 0);
          });
        }).apply(this, arguments);
      }
    }).call(this, r(10).Buffer);
  }, function (t, e, r) {
    var n = r(71),
        i = {
      "{": "}",
      "(": ")",
      "[": "]"
    },
        o = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\)|(\\).|([@?!+*]\(.*\)))/,
        a = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

    function s(t) {
      var _ref96 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref96$strict = _ref96.strict,
          e = _ref96$strict === void 0 ? !0 : _ref96$strict;

      if ("" === t) return !1;
      var r,
          n = e ? o : a;

      for (; r = n.exec(t);) {
        if (r[2]) return !0;

        var _e42 = r.index + r[0].length,
            _n22 = r[1],
            _o16 = _n22 ? i[_n22] : null;

        if (_n22 && _o16) {
          var _r33 = t.indexOf(_o16, _e42);

          -1 !== _r33 && (_e42 = _r33 + 1);
        }

        t = t.slice(_e42);
      }

      return !1;
    }

    t.exports = function (t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var r,
          i = function (t) {
        var _ref97 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref97$strict = _ref97.strict,
            e = _ref97$strict === void 0 ? !1 : _ref97$strict;

        t = n.normalize(t).replace(/\/|\\/, "/"), /[\{\[].*[\/]*.*[\}\]]$/.test(t) && (t += "/"), t += "a";

        do {
          t = n.dirname(t);
        } while (s(t, {
          strict: e
        }) || /(^|[^\\])([\{\[]|\([^\)]+$)/.test(t));

        return t.replace(/\\([\*\?\|\[\]\(\)\{\}])/g, "$1");
      }(t, e),
          o = s(t, e);

      return "." != i ? (r = t.substr(i.length)).startsWith("/") && (r = r.substr(1)) : r = t, o || (r = "." !== (i = n.dirname(t)) ? t.substr(i.length) : t), r.startsWith("./") && (r = r.substr(2)), r.startsWith("/") && (r = r.substr(1)), {
        base: i,
        glob: r,
        isGlob: o
      };
    };
  }, function (t, e, r) {
    "use strict";

    r.d(e, "a", function () {
      return a;
    });
    var n = r(17),
        i = r(12);

    function o(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function a(t) {
      return s.apply(this, arguments);
    }

    function s() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref98) {
        var t, e, _ref98$format, r, o;

        return regeneratorRuntime.wrap(function t$(_context120) {
          while (1) {
            switch (_context120.prev = _context120.next) {
              case 0:
                t = _ref98.type, e = _ref98.object, _ref98$format = _ref98.format, r = _ref98$format === void 0 ? "content" : _ref98$format, o = _ref98.oid;
                return _context120.abrupt("return", ("deflated" !== r && ("wrapped" !== r && (e = n.a.wrap({
                  type: t,
                  object: e
                })), o = Object(i.a)(e)), {
                  oid: o,
                  object: e
                }));

              case 2:
              case "end":
                return _context120.stop();
            }
          }
        }, t);
      }), (s = function s() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var a = t.apply(e, r);

          function s(t) {
            o(a, n, i, s, u, "next", t);
          }

          function u(t) {
            o(a, n, i, s, u, "throw", t);
          }

          s(void 0);
        });
      }).apply(this, arguments);
    }
  }, function (t, e, r) {
    "use strict";

    r.r(e);
    var n = r(87),
        i = r(50),
        o = r(48),
        a = r(16),
        s = r(1),
        u = r(0),
        c = r(20),
        f = r(2),
        l = r(3);

    function d(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function h(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            d(o, n, i, a, s, "next", t);
          }

          function s(t) {
            d(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function p(t) {
      return g.apply(this, arguments);
    }

    function g() {
      return (g = h(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee95(_ref99) {
        var _ref99$core, t, e, _ref99$gitdir, r, _ref99$fs, n, i, _t81;

        return regeneratorRuntime.wrap(function _callee95$(_context122) {
          while (1) {
            switch (_context122.prev = _context122.next) {
              case 0:
                _ref99$core = _ref99.core, t = _ref99$core === void 0 ? "default" : _ref99$core, e = _ref99.dir, _ref99$gitdir = _ref99.gitdir, r = _ref99$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref99$gitdir, _ref99$fs = _ref99.fs, n = _ref99$fs === void 0 ? l.a.get(t).get("fs") : _ref99$fs, i = _ref99.filepath;
                _context122.prev = 1;
                _t81 = new s.a(n);
                _context122.next = 5;
                return a.a.acquire({
                  fs: _t81,
                  filepath: "".concat(r, "/index")
                }, function () {
                  var n = h(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee94(n) {
                    return regeneratorRuntime.wrap(function _callee94$(_context121) {
                      while (1) {
                        switch (_context121.prev = _context121.next) {
                          case 0:
                            _context121.next = 2;
                            return m({
                              dir: e,
                              gitdir: r,
                              fs: _t81,
                              filepath: i,
                              index: n
                            });

                          case 2:
                          case "end":
                            return _context121.stop();
                        }
                      }
                    }, _callee94);
                  }));
                  return function (t) {
                    return n.apply(this, arguments);
                  };
                }());

              case 5:
                _context122.next = 10;
                break;

              case 7:
                _context122.prev = 7;
                _context122.t0 = _context122["catch"](1);
                throw _context122.t0.caller = "git.add", _context122.t0;

              case 10:
              case "end":
                return _context122.stop();
            }
          }
        }, _callee95, null, [[1, 7]]);
      }))).apply(this, arguments);
    }

    function m(t) {
      return y.apply(this, arguments);
    }

    function y() {
      return (y = h(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee96(_ref100) {
        var t, e, r, n, i, a, _o17, _o18, _s7;

        return regeneratorRuntime.wrap(function _callee96$(_context123) {
          while (1) {
            switch (_context123.prev = _context123.next) {
              case 0:
                t = _ref100.dir, e = _ref100.gitdir, r = _ref100.fs, n = _ref100.filepath, i = _ref100.index;
                _context123.next = 3;
                return o.a.isIgnored({
                  fs: r,
                  dir: t,
                  gitdir: e,
                  filepath: n
                });

              case 3:
                if (!_context123.sent) {
                  _context123.next = 5;
                  break;
                }

                return _context123.abrupt("return");

              case 5:
                _context123.next = 7;
                return r.lstat(Object(f.a)(t, n));

              case 7:
                a = _context123.sent;

                if (a) {
                  _context123.next = 10;
                  break;
                }

                throw new u.b(u.a.FileReadError, {
                  filepath: n
                });

              case 10:
                if (!a.isDirectory()) {
                  _context123.next = 19;
                  break;
                }

                _context123.next = 13;
                return r.readdir(Object(f.a)(t, n));

              case 13:
                _context123.t0 = function (o) {
                  return m({
                    dir: t,
                    gitdir: e,
                    fs: r,
                    filepath: Object(f.a)(n, o),
                    index: i
                  });
                };

                _o17 = _context123.sent.map(_context123.t0);
                _context123.next = 17;
                return Promise.all(_o17);

              case 17:
                _context123.next = 35;
                break;

              case 19:
                if (!a.isSymbolicLink()) {
                  _context123.next = 25;
                  break;
                }

                _context123.next = 22;
                return r.readlink(Object(f.a)(t, n));

              case 22:
                _context123.t1 = _context123.sent;
                _context123.next = 28;
                break;

              case 25:
                _context123.next = 27;
                return r.read(Object(f.a)(t, n));

              case 27:
                _context123.t1 = _context123.sent;

              case 28:
                _o18 = _context123.t1;

                if (!(null === _o18)) {
                  _context123.next = 31;
                  break;
                }

                throw new u.b(u.a.FileReadError, {
                  filepath: n
                });

              case 31:
                _context123.next = 33;
                return Object(c.a)({
                  fs: r,
                  gitdir: e,
                  type: "blob",
                  object: _o18
                });

              case 33:
                _s7 = _context123.sent;
                i.insert({
                  filepath: n,
                  stats: a,
                  oid: _s7
                });

              case 35:
              case "end":
                return _context123.stop();
            }
          }
        }, _callee96);
      }))).apply(this, arguments);
    }

    var v = r(36),
        w = r.n(v),
        b = r(22);

    function _(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function x(t) {
      return E.apply(this, arguments);
    }

    function E() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref101) {
        var _ref101$core, t, e, _ref101$gitdir, r, _ref101$fs, n, i, o, _ref101$force, a, _t82, _e43;

        return regeneratorRuntime.wrap(function t$(_context124) {
          while (1) {
            switch (_context124.prev = _context124.next) {
              case 0:
                _ref101$core = _ref101.core, t = _ref101$core === void 0 ? "default" : _ref101$core, e = _ref101.dir, _ref101$gitdir = _ref101.gitdir, r = _ref101$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref101$gitdir, _ref101$fs = _ref101.fs, n = _ref101$fs === void 0 ? l.a.get(t).get("fs") : _ref101$fs, i = _ref101.remote, o = _ref101.url, _ref101$force = _ref101.force, a = _ref101$force === void 0 ? !1 : _ref101$force;
                _context124.prev = 1;
                _t82 = new s.a(n);

                if (!(void 0 === i)) {
                  _context124.next = 5;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "addRemote",
                  parameter: "remote"
                });

              case 5:
                if (!(void 0 === o)) {
                  _context124.next = 7;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "addRemote",
                  parameter: "url"
                });

              case 7:
                if (!(i !== w.a.clean(i))) {
                  _context124.next = 9;
                  break;
                }

                throw new u.b(u.a.InvalidRefNameError, {
                  verb: "add",
                  noun: "remote",
                  ref: i,
                  suggestion: w.a.clean(i)
                });

              case 9:
                _context124.next = 11;
                return b.a.get({
                  fs: _t82,
                  gitdir: r
                });

              case 11:
                _e43 = _context124.sent;
                _context124.t1 = !a;

                if (!_context124.t1) {
                  _context124.next = 18;
                  break;
                }

                _context124.next = 16;
                return _e43.getSubsections("remote");

              case 16:
                _context124.t2 = i;
                _context124.t1 = _context124.sent.includes(_context124.t2);

              case 18:
                _context124.t0 = _context124.t1;

                if (!_context124.t0) {
                  _context124.next = 25;
                  break;
                }

                _context124.t3 = o;
                _context124.next = 23;
                return _e43.get("remote.".concat(i, ".url"));

              case 23:
                _context124.t4 = _context124.sent;
                _context124.t0 = _context124.t3 !== _context124.t4;

              case 25:
                if (!_context124.t0) {
                  _context124.next = 27;
                  break;
                }

                throw new u.b(u.a.AddingRemoteWouldOverwrite, {
                  remote: i
                });

              case 27:
                _context124.next = 29;
                return _e43.set("remote.".concat(i, ".url"), o);

              case 29:
                _context124.next = 31;
                return _e43.set("remote.".concat(i, ".fetch"), "+refs/heads/*:refs/remotes/".concat(i, "/*"));

              case 31:
                _context124.next = 33;
                return b.a.save({
                  fs: _t82,
                  gitdir: r,
                  config: _e43
                });

              case 33:
                _context124.next = 38;
                break;

              case 35:
                _context124.prev = 35;
                _context124.t5 = _context124["catch"](1);
                throw _context124.t5.caller = "git.addRemote", _context124.t5;

              case 38:
              case "end":
                return _context124.stop();
            }
          }
        }, t, null, [[1, 35]]);
      }), (E = function E() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            _(o, n, i, a, s, "next", t);
          }

          function s(t) {
            _(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var k = r(4),
        O = r(14),
        j = r(5);

    function P(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function S(t) {
      return R.apply(this, arguments);
    }

    function R() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_t83) {
        var _t$core, e, r, _t$gitdir, n, _t$fs, i, _t$all, o, _t$append, a, u, c, _e44, _r34;

        return regeneratorRuntime.wrap(function t$(_context125) {
          while (1) {
            switch (_context125.prev = _context125.next) {
              case 0:
                _t$core = _t83.core, e = _t$core === void 0 ? "default" : _t$core, r = _t83.dir, _t$gitdir = _t83.gitdir, n = _t$gitdir === void 0 ? Object(f.a)(r, ".git") : _t$gitdir, _t$fs = _t83.fs, i = _t$fs === void 0 ? l.a.get(e).get("fs") : _t$fs, _t$all = _t83.all, o = _t$all === void 0 ? !1 : _t$all, _t$append = _t83.append, a = _t$append === void 0 ? !1 : _t$append, u = _t83.path, c = _t83.value;
                _context125.prev = 1;
                _e44 = new s.a(i);
                _context125.next = 5;
                return b.a.get({
                  fs: _e44,
                  gitdir: n
                });

              case 5:
                _r34 = _context125.sent;

                if (!(void 0 === c && !Object.prototype.hasOwnProperty.call(_t83, "value"))) {
                  _context125.next = 8;
                  break;
                }

                return _context125.abrupt("return", o ? _r34.getall(u) : _r34.get(u));

              case 8:
                if (!a) {
                  _context125.next = 13;
                  break;
                }

                _context125.next = 11;
                return _r34.append(u, c);

              case 11:
                _context125.next = 15;
                break;

              case 13:
                _context125.next = 15;
                return _r34.set(u, c);

              case 15:
                _context125.next = 17;
                return b.a.save({
                  fs: _e44,
                  gitdir: n,
                  config: _r34
                });

              case 17:
                _context125.next = 22;
                break;

              case 19:
                _context125.prev = 19;
                _context125.t0 = _context125["catch"](1);
                throw _context125.t0.caller = "git.config", _context125.t0;

              case 22:
              case "end":
                return _context125.stop();
            }
          }
        }, t, null, [[1, 19]]);
      }), (R = function R() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            P(o, n, i, a, s, "next", t);
          }

          function s(t) {
            P(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function A(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function $(t) {
      return T.apply(this, arguments);
    }

    function T() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref102) {
        var t, e, _ref102$author, r, n, i, o, a, s;

        return regeneratorRuntime.wrap(function t$(_context126) {
          while (1) {
            switch (_context126.prev = _context126.next) {
              case 0:
                t = _ref102.fs, e = _ref102.gitdir, _ref102$author = _ref102.author, r = _ref102$author === void 0 ? {} : _ref102$author;
                n = r.name, i = r.email, o = r.date, a = r.timestamp, s = r.timezoneOffset;
                _context126.t0 = n;

                if (_context126.t0) {
                  _context126.next = 7;
                  break;
                }

                _context126.next = 6;
                return S({
                  fs: t,
                  gitdir: e,
                  path: "user.name"
                });

              case 6:
                _context126.t0 = _context126.sent;

              case 7:
                n = _context126.t0;
                _context126.t1 = i;

                if (_context126.t1) {
                  _context126.next = 13;
                  break;
                }

                _context126.next = 12;
                return S({
                  fs: t,
                  gitdir: e,
                  path: "user.email"
                });

              case 12:
                _context126.t1 = _context126.sent;

              case 13:
                i = _context126.t1;

                if (!(void 0 !== n && void 0 !== i)) {
                  _context126.next = 16;
                  break;
                }

                return _context126.abrupt("return", (o = o || new Date(), a = null != a ? a : Math.floor(o.valueOf() / 1e3), s = null != s ? s : o.getTimezoneOffset(), {
                  name: n,
                  email: i,
                  date: o,
                  timestamp: a,
                  timezoneOffset: s
                }));

              case 16:
              case "end":
                return _context126.stop();
            }
          }
        }, t);
      }), (T = function T() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            A(o, n, i, a, s, "next", t);
          }

          function s(t) {
            A(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function I(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function B(t) {
      return F.apply(this, arguments);
    }

    function F() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref103) {
        var _ref103$core, t, e, _ref103$gitdir, r, _ref103$fs, n, i, o, _ref103$message, a, d, h, p, _ref103$force, g, _e45, _f3, _ref104, _m, _y, _e46, _v;

        return regeneratorRuntime.wrap(function t$(_context127) {
          while (1) {
            switch (_context127.prev = _context127.next) {
              case 0:
                _ref103$core = _ref103.core, t = _ref103$core === void 0 ? "default" : _ref103$core, e = _ref103.dir, _ref103$gitdir = _ref103.gitdir, r = _ref103$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref103$gitdir, _ref103$fs = _ref103.fs, n = _ref103$fs === void 0 ? l.a.get(t).get("fs") : _ref103$fs, i = _ref103.ref, o = _ref103.tagger, _ref103$message = _ref103.message, a = _ref103$message === void 0 ? i : _ref103$message, d = _ref103.signature, h = _ref103.object, p = _ref103.signingKey, _ref103$force = _ref103.force, g = _ref103$force === void 0 ? !1 : _ref103$force;
                _context127.prev = 1;
                _e45 = new s.a(n);

                if (!(void 0 === i)) {
                  _context127.next = 5;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "annotatedTag",
                  parameter: "ref"
                });

              case 5:
                i = i.startsWith("refs/tags/") ? i : "refs/tags/".concat(i);
                _context127.t0 = !g;

                if (!_context127.t0) {
                  _context127.next = 11;
                  break;
                }

                _context127.next = 10;
                return k.a.exists({
                  fs: _e45,
                  gitdir: r,
                  ref: i
                });

              case 10:
                _context127.t0 = _context127.sent;

              case 11:
                if (!_context127.t0) {
                  _context127.next = 13;
                  break;
                }

                throw new u.b(u.a.RefExistsError, {
                  noun: "tag",
                  ref: i
                });

              case 13:
                _context127.next = 15;
                return k.a.resolve({
                  fs: _e45,
                  gitdir: r,
                  ref: h || "HEAD"
                });

              case 15:
                _f3 = _context127.sent;

                if (!(d && p)) {
                  _context127.next = 18;
                  break;
                }

                throw new u.b(u.a.InvalidParameterCombinationError, {
                  function: "annotatedTag",
                  parameters: ["signature", "signingKey"]
                });

              case 18:
                _context127.t1 = void 0;
                _context127.next = 21;
                return $({
                  fs: _e45,
                  gitdir: r,
                  author: o
                });

              case 21:
                _context127.t2 = o = _context127.sent;

                if (!(_context127.t1 === _context127.t2)) {
                  _context127.next = 24;
                  break;
                }

                throw new u.b(u.a.MissingTaggerError);

              case 24:
                _context127.next = 26;
                return Object(j.a)({
                  fs: _e45,
                  gitdir: r,
                  oid: _f3
                });

              case 26:
                _ref104 = _context127.sent;
                _m = _ref104.type;
                _y = O.a.from({
                  object: _f3,
                  type: _m,
                  tag: i.replace("refs/tags/", ""),
                  tagger: o,
                  message: a,
                  signature: d
                });

                if (!p) {
                  _context127.next = 34;
                  break;
                }

                _e46 = l.a.get(t).get("pgp");
                _context127.next = 33;
                return O.a.sign(_y, _e46, p);

              case 33:
                _y = _context127.sent;

              case 34:
                _context127.next = 36;
                return Object(c.a)({
                  fs: _e45,
                  gitdir: r,
                  type: "tag",
                  object: _y.toObject()
                });

              case 36:
                _v = _context127.sent;
                _context127.next = 39;
                return k.a.writeRef({
                  fs: _e45,
                  gitdir: r,
                  ref: i,
                  value: _v
                });

              case 39:
                _context127.next = 44;
                break;

              case 41:
                _context127.prev = 41;
                _context127.t3 = _context127["catch"](1);
                throw _context127.t3.caller = "git.annotatedTag", _context127.t3;

              case 44:
              case "end":
                return _context127.stop();
            }
          }
        }, t, null, [[1, 41]]);
      }), (F = function F() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            I(o, n, i, a, s, "next", t);
          }

          function s(t) {
            I(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function U(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function M(t) {
      return C.apply(this, arguments);
    }

    function C() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref105) {
        var _ref105$core, t, e, _ref105$gitdir, r, _ref105$fs, n, i, _ref105$checkout, o, _t84, _e47, _a7;

        return regeneratorRuntime.wrap(function t$(_context128) {
          while (1) {
            switch (_context128.prev = _context128.next) {
              case 0:
                _ref105$core = _ref105.core, t = _ref105$core === void 0 ? "default" : _ref105$core, e = _ref105.dir, _ref105$gitdir = _ref105.gitdir, r = _ref105$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref105$gitdir, _ref105$fs = _ref105.fs, n = _ref105$fs === void 0 ? l.a.get(t).get("fs") : _ref105$fs, i = _ref105.ref, _ref105$checkout = _ref105.checkout, o = _ref105$checkout === void 0 ? !1 : _ref105$checkout;
                _context128.prev = 1;
                _t84 = new s.a(n);

                if (!(void 0 === i)) {
                  _context128.next = 5;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "branch",
                  parameter: "ref"
                });

              case 5:
                if (!(i !== w.a.clean(i))) {
                  _context128.next = 7;
                  break;
                }

                throw new u.b(u.a.InvalidRefNameError, {
                  verb: "create",
                  noun: "branch",
                  ref: i,
                  suggestion: w.a.clean(i)
                });

              case 7:
                _e47 = "refs/heads/".concat(i);
                _context128.next = 10;
                return k.a.exists({
                  fs: _t84,
                  gitdir: r,
                  ref: _e47
                });

              case 10:
                if (!_context128.sent) {
                  _context128.next = 12;
                  break;
                }

                throw new u.b(u.a.RefExistsError, {
                  noun: "branch",
                  ref: i
                });

              case 12:
                _context128.prev = 12;
                _context128.next = 15;
                return k.a.resolve({
                  fs: _t84,
                  gitdir: r,
                  ref: "HEAD"
                });

              case 15:
                _a7 = _context128.sent;
                _context128.next = 20;
                break;

              case 18:
                _context128.prev = 18;
                _context128.t0 = _context128["catch"](12);

              case 20:
                _context128.t1 = _a7;

                if (!_context128.t1) {
                  _context128.next = 24;
                  break;
                }

                _context128.next = 24;
                return k.a.writeRef({
                  fs: _t84,
                  gitdir: r,
                  ref: _e47,
                  value: _a7
                });

              case 24:
                _context128.t2 = o;

                if (!_context128.t2) {
                  _context128.next = 28;
                  break;
                }

                _context128.next = 28;
                return k.a.writeSymbolicRef({
                  fs: _t84,
                  gitdir: r,
                  ref: "HEAD",
                  value: _e47
                });

              case 28:
                _context128.next = 33;
                break;

              case 30:
                _context128.prev = 30;
                _context128.t3 = _context128["catch"](1);
                throw _context128.t3.caller = "git.branch", _context128.t3;

              case 33:
              case "end":
                return _context128.stop();
            }
          }
        }, t, null, [[1, 30], [12, 18]]);
      }), (C = function C() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            U(o, n, i, a, s, "next", t);
          }

          function s(t) {
            U(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var D = r(98),
        N = r.n(D),
        z = r(127),
        H = r.n(z);

    var L = function L(t) {
      var e = H()(t).base;
      return "." === e ? "" : e;
    },
        G = function G(t, e) {
      return "." === t || null == e || 0 === e.length || "." === e || (e.length >= t.length ? e.startsWith(t) : t.startsWith(e));
    };

    var q = r(29),
        W = r(52),
        Y = r(8),
        Z = r(25),
        K = r(12),
        V = r(17);

    function X(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function J(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            X(o, n, i, a, s, "next", t);
          }

          function s(t) {
            X(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    var Q =
    /*#__PURE__*/
    function () {
      function Q(_ref106) {
        var t = _ref106.fs,
            e = _ref106.dir,
            r = _ref106.gitdir;

        _classCallCheck(this, Q);

        var n = new s.a(t);
        this.fs = n, this.dir = e, this.gitdir = r;
        var i = this;

        this.ConstructEntry =
        /*#__PURE__*/
        function () {
          function _class3(t) {
            _classCallCheck(this, _class3);

            Object.assign(this, t);
          }

          _createClass(_class3, [{
            key: "populateStat",
            value: function populateStat() {
              var t = this;
              return J(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee97() {
                return regeneratorRuntime.wrap(function _callee97$(_context129) {
                  while (1) {
                    switch (_context129.prev = _context129.next) {
                      case 0:
                        _context129.t0 = t.exists;

                        if (!_context129.t0) {
                          _context129.next = 4;
                          break;
                        }

                        _context129.next = 4;
                        return i.populateStat(t);

                      case 4:
                      case "end":
                        return _context129.stop();
                    }
                  }
                }, _callee97);
              }))();
            }
          }, {
            key: "populateContent",
            value: function populateContent() {
              var t = this;
              return J(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee98() {
                return regeneratorRuntime.wrap(function _callee98$(_context130) {
                  while (1) {
                    switch (_context130.prev = _context130.next) {
                      case 0:
                        _context130.t0 = t.exists;

                        if (!_context130.t0) {
                          _context130.next = 4;
                          break;
                        }

                        _context130.next = 4;
                        return i.populateContent(t);

                      case 4:
                      case "end":
                        return _context130.stop();
                    }
                  }
                }, _callee98);
              }))();
            }
          }, {
            key: "populateHash",
            value: function populateHash() {
              var t = this;
              return J(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee99() {
                return regeneratorRuntime.wrap(function _callee99$(_context131) {
                  while (1) {
                    switch (_context131.prev = _context131.next) {
                      case 0:
                        _context131.t0 = t.exists;

                        if (!_context131.t0) {
                          _context131.next = 4;
                          break;
                        }

                        _context131.next = 4;
                        return i.populateHash(t);

                      case 4:
                      case "end":
                        return _context131.stop();
                    }
                  }
                }, _callee99);
              }))();
            }
          }]);

          return _class3;
        }();
      }

      _createClass(Q, [{
        key: "readdir",
        value: function readdir(t) {
          var e = this;
          return J(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee100() {
            var r, n, i, o;
            return regeneratorRuntime.wrap(function _callee100$(_context132) {
              while (1) {
                switch (_context132.prev = _context132.next) {
                  case 0:
                    if (t.exists) {
                      _context132.next = 2;
                      break;
                    }

                    return _context132.abrupt("return", []);

                  case 2:
                    r = t.fullpath;
                    n = e.fs;
                    i = e.dir;
                    _context132.next = 7;
                    return n.readdir(Object(f.a)(i, r));

                  case 7:
                    o = _context132.sent;
                    return _context132.abrupt("return", null === o ? null : o.map(function (t) {
                      return {
                        fullpath: Object(f.a)(r, t),
                        basename: t,
                        exists: !0
                      };
                    }));

                  case 9:
                  case "end":
                    return _context132.stop();
                }
              }
            }, _callee100);
          }))();
        }
      }, {
        key: "populateStat",
        value: function populateStat(t) {
          var e = this;
          return J(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee101() {
            var r, n, i, o;
            return regeneratorRuntime.wrap(function _callee101$(_context133) {
              while (1) {
                switch (_context133.prev = _context133.next) {
                  case 0:
                    if (t.exists) {
                      _context133.next = 2;
                      break;
                    }

                    return _context133.abrupt("return");

                  case 2:
                    r = e.fs, n = e.dir;
                    _context133.next = 5;
                    return r.lstat("".concat(n, "/").concat(t.fullpath));

                  case 5:
                    i = _context133.sent;
                    o = i.isDirectory() ? "tree" : "blob";

                    if (!("blob" !== o || i.isFile() || i.isSymbolicLink() || (o = "special"), !i)) {
                      _context133.next = 9;
                      break;
                    }

                    throw new Error("ENOENT: no such file or directory, lstat '".concat(t.fullpath, "'"));

                  case 9:
                    i = Object(Z.a)(i), Object.assign(t, {
                      type: o
                    }, i);

                  case 10:
                  case "end":
                    return _context133.stop();
                }
              }
            }, _callee101);
          }))();
        }
      }, {
        key: "populateContent",
        value: function populateContent(t) {
          var e = this;
          return J(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee102() {
            var r, n, i;
            return regeneratorRuntime.wrap(function _callee102$(_context134) {
              while (1) {
                switch (_context134.prev = _context134.next) {
                  case 0:
                    if (t.exists) {
                      _context134.next = 2;
                      break;
                    }

                    return _context134.abrupt("return");

                  case 2:
                    r = e.fs;
                    n = e.dir;
                    _context134.next = 6;
                    return r.read("".concat(n, "/").concat(t.fullpath));

                  case 6:
                    i = _context134.sent;
                    -1 === t.size && (t.size = i.length), Object.assign(t, {
                      content: i
                    });

                  case 8:
                  case "end":
                    return _context134.stop();
                }
              }
            }, _callee102);
          }))();
        }
      }, {
        key: "populateHash",
        value: function populateHash(t) {
          var e = this;
          return J(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee104() {
            var r, n, i;
            return regeneratorRuntime.wrap(function _callee104$(_context136) {
              while (1) {
                switch (_context136.prev = _context136.next) {
                  case 0:
                    if (t.exists) {
                      _context136.next = 2;
                      break;
                    }

                    return _context136.abrupt("return");

                  case 2:
                    r = e.fs, n = e.gitdir;
                    _context136.next = 5;
                    return a.a.acquire({
                      fs: r,
                      filepath: "".concat(n, "/index")
                    }, function () {
                      var e = J(
                      /*#__PURE__*/
                      regeneratorRuntime.mark(function _callee103(e) {
                        var r;
                        return regeneratorRuntime.wrap(function _callee103$(_context135) {
                          while (1) {
                            switch (_context135.prev = _context135.next) {
                              case 0:
                                r = e.entriesMap.get(t.fullpath);

                                if (!(!r || Object(W.a)(t, r))) {
                                  _context135.next = 11;
                                  break;
                                }

                                Object(Y.a)("INDEX CACHE MISS: calculating SHA for ".concat(t.fullpath));
                                _context135.t0 = t.content;

                                if (_context135.t0) {
                                  _context135.next = 7;
                                  break;
                                }

                                _context135.next = 7;
                                return t.populateContent();

                              case 7:
                                i = Object(K.a)(V.a.wrap({
                                  type: "blob",
                                  object: t.content
                                }));
                                r && i === r.oid && e.insert({
                                  filepath: t.fullpath,
                                  stats: t,
                                  oid: i
                                });
                                _context135.next = 12;
                                break;

                              case 11:
                                i = r.oid;

                              case 12:
                              case "end":
                                return _context135.stop();
                            }
                          }
                        }, _callee103);
                      }));
                      return function (t) {
                        return e.apply(this, arguments);
                      };
                    }());

                  case 5:
                    Object.assign(t, {
                      oid: i
                    });

                  case 6:
                  case "end":
                    return _context136.stop();
                }
              }
            }, _callee104);
          }))();
        }
      }]);

      return Q;
    }();

    var tt = r(26);

    function et(_ref107) {
      var _ref107$core = _ref107.core,
          t = _ref107$core === void 0 ? "default" : _ref107$core,
          e = _ref107.dir,
          _ref107$gitdir = _ref107.gitdir,
          r = _ref107$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref107$gitdir,
          _ref107$fs = _ref107.fs,
          n = _ref107$fs === void 0 ? l.a.get(t).get("fs") : _ref107$fs;
      var i = new s.a(n),
          o = Object.create(null);
      return Object.defineProperty(o, tt.a, {
        value: function value() {
          return new Q({
            fs: i,
            dir: e,
            gitdir: r
          });
        }
      }), Object.freeze(o), o;
    }

    var rt = r(39);

    function nt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function it(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            nt(o, n, i, a, s, "next", t);
          }

          function s(t) {
            nt(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function ot(t) {
      return at.apply(this, arguments);
    }

    function at() {
      return (at = it(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee108(_ref108) {
        var _ref108$core, t, e, _ref108$gitdir, r, _ref108$fs, n, _ref108$emitter, i, _ref108$emitterPrefix, o, _ref108$remote, c, d, _ref108$filepaths, h, _ref108$pattern, p, _ref108$noCheckout, g, _t85, _l3, _m2, _y2, _v2, _n23, _w, _n24, _b;

        return regeneratorRuntime.wrap(function _callee108$(_context140) {
          while (1) {
            switch (_context140.prev = _context140.next) {
              case 0:
                _ref108$core = _ref108.core, t = _ref108$core === void 0 ? "default" : _ref108$core, e = _ref108.dir, _ref108$gitdir = _ref108.gitdir, r = _ref108$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref108$gitdir, _ref108$fs = _ref108.fs, n = _ref108$fs === void 0 ? l.a.get(t).get("fs") : _ref108$fs, _ref108$emitter = _ref108.emitter, i = _ref108$emitter === void 0 ? l.a.get(t).get("emitter") : _ref108$emitter, _ref108$emitterPrefix = _ref108.emitterPrefix, o = _ref108$emitterPrefix === void 0 ? "" : _ref108$emitterPrefix, _ref108$remote = _ref108.remote, c = _ref108$remote === void 0 ? "origin" : _ref108$remote, d = _ref108.ref, _ref108$filepaths = _ref108.filepaths, h = _ref108$filepaths === void 0 ? ["."] : _ref108$filepaths, _ref108$pattern = _ref108.pattern, p = _ref108$pattern === void 0 ? null : _ref108$pattern, _ref108$noCheckout = _ref108.noCheckout, g = _ref108$noCheckout === void 0 ? !1 : _ref108$noCheckout;
                _context140.prev = 1;
                _t85 = new s.a(n);

                if (!(void 0 === d)) {
                  _context140.next = 5;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "checkout",
                  parameter: "ref"
                });

              case 5:
                _m2 = "";
                p && ((_m2 = L(p)) && (p = p.replace(_m2 + "/", "")), _l3 = N()(p, {
                  globstar: !0,
                  extended: !0
                }));
                _y2 = h.map(function (t) {
                  return Object(f.a)(t, _m2);
                });
                _context140.prev = 8;
                _context140.next = 11;
                return k.a.resolve({
                  fs: _t85,
                  gitdir: r,
                  ref: d
                });

              case 11:
                _v2 = _context140.sent;
                _context140.next = 26;
                break;

              case 14:
                _context140.prev = 14;
                _context140.t0 = _context140["catch"](8);
                _n23 = "".concat(c, "/").concat(d);
                _context140.next = 19;
                return k.a.resolve({
                  fs: _t85,
                  gitdir: r,
                  ref: _n23
                });

              case 19:
                _v2 = _context140.sent;
                _context140.next = 22;
                return S({
                  gitdir: r,
                  fs: _t85,
                  path: "branch.".concat(d, ".remote"),
                  value: "".concat(c)
                });

              case 22:
                _context140.next = 24;
                return S({
                  gitdir: r,
                  fs: _t85,
                  path: "branch.".concat(d, ".merge"),
                  value: "refs/heads/".concat(d)
                });

              case 24:
                _context140.next = 26;
                return _t85.write("".concat(r, "/refs/heads/").concat(d), _v2 + "\n");

              case 26:
                _context140.next = 28;
                return k.a.expand({
                  fs: _t85,
                  gitdir: r,
                  ref: d
                });

              case 28:
                _w = _context140.sent;

                if (g) {
                  _context140.next = 33;
                  break;
                }

                _n24 = 0;
                _context140.next = 33;
                return a.a.acquire({
                  fs: _t85,
                  filepath: "".concat(r, "/index")
                }, function () {
                  var a = it(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee107(a) {
                    var _iteratorNormalCompletion50, _didIteratorError50, _iteratorError50, _iterator50, _step50, _r35, s, c;

                    return regeneratorRuntime.wrap(function _callee107$(_context139) {
                      while (1) {
                        switch (_context139.prev = _context139.next) {
                          case 0:
                            _iteratorNormalCompletion50 = true;
                            _didIteratorError50 = false;
                            _iteratorError50 = undefined;
                            _context139.prev = 3;
                            _iterator50 = a[Symbol.iterator]();

                          case 5:
                            if (_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done) {
                              _context139.next = 18;
                              break;
                            }

                            _r35 = _step50.value;
                            _context139.prev = 7;
                            _context139.next = 10;
                            return _t85.rm(Object(f.a)(e, _r35.path));

                          case 10:
                            i && i.emit("".concat(o, "progress"), {
                              phase: "Updating workdir",
                              loaded: ++_n24,
                              lengthComputable: !1
                            });
                            _context139.next = 15;
                            break;

                          case 13:
                            _context139.prev = 13;
                            _context139.t0 = _context139["catch"](7);

                          case 15:
                            _iteratorNormalCompletion50 = true;
                            _context139.next = 5;
                            break;

                          case 18:
                            _context139.next = 24;
                            break;

                          case 20:
                            _context139.prev = 20;
                            _context139.t1 = _context139["catch"](3);
                            _didIteratorError50 = true;
                            _iteratorError50 = _context139.t1;

                          case 24:
                            _context139.prev = 24;
                            _context139.prev = 25;

                            if (!_iteratorNormalCompletion50 && _iterator50.return != null) {
                              _iterator50.return();
                            }

                          case 27:
                            _context139.prev = 27;

                            if (!_didIteratorError50) {
                              _context139.next = 30;
                              break;
                            }

                            throw _iteratorError50;

                          case 30:
                            return _context139.finish(27);

                          case 31:
                            return _context139.finish(24);

                          case 32:
                            a.clear();
                            _context139.prev = 33;
                            _context139.next = 36;
                            return Object(rt.a)({
                              trees: [Object(q.a)({
                                fs: _t85,
                                gitdir: r,
                                ref: d
                              }), et({
                                fs: _t85,
                                dir: e,
                                gitdir: r
                              })],
                              filter: (c = it(
                              /*#__PURE__*/
                              regeneratorRuntime.mark(function _callee105(_ref109) {
                                var _ref110, t, e;

                                return regeneratorRuntime.wrap(function _callee105$(_context137) {
                                  while (1) {
                                    switch (_context137.prev = _context137.next) {
                                      case 0:
                                        _ref110 = _slicedToArray(_ref109, 2), t = _ref110[0], e = _ref110[1];
                                        return _context137.abrupt("return", _y2.some(function (e) {
                                          return G(t.fullpath, e);
                                        }));

                                      case 2:
                                      case "end":
                                        return _context137.stop();
                                    }
                                  }
                                }, _callee105);
                              })), function (t) {
                                return c.apply(this, arguments);
                              }),
                              map: (s = it(
                              /*#__PURE__*/
                              regeneratorRuntime.mark(function _callee106(_ref111) {
                                var _ref112, r, s, _t86, _iteratorNormalCompletion51, _didIteratorError51, _iteratorError51, _iterator51, _step51, _e48, _n25, c, _e49;

                                return regeneratorRuntime.wrap(function _callee106$(_context138) {
                                  while (1) {
                                    switch (_context138.prev = _context138.next) {
                                      case 0:
                                        _ref112 = _slicedToArray(_ref111, 2), r = _ref112[0], s = _ref112[1];

                                        if (!("." === r.fullpath)) {
                                          _context138.next = 3;
                                          break;
                                        }

                                        return _context138.abrupt("return");

                                      case 3:
                                        if (r.exists) {
                                          _context138.next = 5;
                                          break;
                                        }

                                        return _context138.abrupt("return");

                                      case 5:
                                        if (!_l3) {
                                          _context138.next = 37;
                                          break;
                                        }

                                        _t86 = !1;
                                        _iteratorNormalCompletion51 = true;
                                        _didIteratorError51 = false;
                                        _iteratorError51 = undefined;
                                        _context138.prev = 10;
                                        _iterator51 = _y2[Symbol.iterator]();

                                      case 12:
                                        if (_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done) {
                                          _context138.next = 21;
                                          break;
                                        }

                                        _e48 = _step51.value;
                                        _n25 = r.fullpath.replace(_e48 + "/", "");

                                        if (!_l3.regex.test(_n25)) {
                                          _context138.next = 18;
                                          break;
                                        }

                                        _t86 = !0;
                                        return _context138.abrupt("break", 21);

                                      case 18:
                                        _iteratorNormalCompletion51 = true;
                                        _context138.next = 12;
                                        break;

                                      case 21:
                                        _context138.next = 27;
                                        break;

                                      case 23:
                                        _context138.prev = 23;
                                        _context138.t0 = _context138["catch"](10);
                                        _didIteratorError51 = true;
                                        _iteratorError51 = _context138.t0;

                                      case 27:
                                        _context138.prev = 27;
                                        _context138.prev = 28;

                                        if (!_iteratorNormalCompletion51 && _iterator51.return != null) {
                                          _iterator51.return();
                                        }

                                      case 30:
                                        _context138.prev = 30;

                                        if (!_didIteratorError51) {
                                          _context138.next = 33;
                                          break;
                                        }

                                        throw _iteratorError51;

                                      case 33:
                                        return _context138.finish(30);

                                      case 34:
                                        return _context138.finish(27);

                                      case 35:
                                        if (_t86) {
                                          _context138.next = 37;
                                          break;
                                        }

                                        return _context138.abrupt("return");

                                      case 37:
                                        _context138.next = 39;
                                        return r.populateStat();

                                      case 39:
                                        c = "".concat(e, "/").concat(r.fullpath);
                                        _context138.t1 = r.type;
                                        _context138.next = _context138.t1 === "tree" ? 43 : _context138.t1 === "commit" ? 48 : _context138.t1 === "blob" ? 50 : 73;
                                        break;

                                      case 43:
                                        _context138.t2 = s.exists;

                                        if (_context138.t2) {
                                          _context138.next = 47;
                                          break;
                                        }

                                        _context138.next = 47;
                                        return _t85.mkdir(c);

                                      case 47:
                                        return _context138.abrupt("break", 74);

                                      case 48:
                                        console.log(new u.b(u.a.NotImplementedFail, {
                                          thing: "submodule support"
                                        }));
                                        return _context138.abrupt("break", 74);

                                      case 50:
                                        _context138.next = 52;
                                        return r.populateContent();

                                      case 52:
                                        _context138.next = 54;
                                        return r.populateHash();

                                      case 54:
                                        if (!("100644" === r.mode)) {
                                          _context138.next = 59;
                                          break;
                                        }

                                        _context138.next = 57;
                                        return _t85.write(c, r.content);

                                      case 57:
                                        _context138.next = 68;
                                        break;

                                      case 59:
                                        if (!("100755" === r.mode)) {
                                          _context138.next = 64;
                                          break;
                                        }

                                        _context138.next = 62;
                                        return _t85.write(c, r.content, {
                                          mode: 511
                                        });

                                      case 62:
                                        _context138.next = 68;
                                        break;

                                      case 64:
                                        if (!("120000" !== r.mode)) {
                                          _context138.next = 66;
                                          break;
                                        }

                                        throw new u.b(u.a.InternalFail, {
                                          message: "Invalid mode \"".concat(r.mode, "\" detected in blob ").concat(r.oid)
                                        });

                                      case 66:
                                        _context138.next = 68;
                                        return _t85.writelink(c, r.content);

                                      case 68:
                                        _context138.next = 70;
                                        return _t85.lstat(c);

                                      case 70:
                                        _e49 = _context138.sent;
                                        "100755" === r.mode && (_e49.mode = 493), a.insert({
                                          filepath: r.fullpath,
                                          stats: _e49,
                                          oid: r.oid
                                        }), i && i.emit("".concat(o, "progress"), {
                                          phase: "Updating workdir",
                                          loaded: ++_n24,
                                          lengthComputable: !1
                                        });
                                        return _context138.abrupt("break", 74);

                                      case 73:
                                        throw new u.b(u.a.ObjectTypeAssertionInTreeFail, {
                                          type: r.type,
                                          oid: r.oid,
                                          entrypath: r.fullpath
                                        });

                                      case 74:
                                      case "end":
                                        return _context138.stop();
                                    }
                                  }
                                }, _callee106, null, [[10, 23, 27, 35], [28,, 30, 34]]);
                              })), function (t) {
                                return s.apply(this, arguments);
                              })
                            });

                          case 36:
                            _context139.next = 41;
                            break;

                          case 38:
                            _context139.prev = 38;
                            _context139.t2 = _context139["catch"](33);
                            throw _context139.t2.code === u.a.ReadObjectFail && _context139.t2.data.oid === _v2 ? new u.b(u.a.CommitNotFetchedError, {
                              ref: d,
                              oid: _v2
                            }) : _context139.t2;

                          case 41:
                          case "end":
                            return _context139.stop();
                        }
                      }
                    }, _callee107, null, [[3, 20, 24, 32], [7, 13], [25,, 27, 31], [33, 38]]);
                  }));
                  return function (t) {
                    return a.apply(this, arguments);
                  };
                }());

              case 33:
                _b = _w.startsWith("refs/heads") ? "ref: ".concat(_w) : _v2;
                _context140.next = 36;
                return _t85.write("".concat(r, "/HEAD"), "".concat(_b, "\n"));

              case 36:
                _context140.next = 41;
                break;

              case 38:
                _context140.prev = 38;
                _context140.t1 = _context140["catch"](1);
                throw _context140.t1.caller = "git.checkout", _context140.t1;

              case 41:
              case "end":
                return _context140.stop();
            }
          }
        }, _callee108, null, [[1, 38], [8, 14]]);
      }))).apply(this, arguments);
    }

    var st = r(65),
        ut = r(30),
        ct = r(7),
        ft = r(38);

    function lt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function dt() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref113) {
        var t, e, r, n, i;
        return regeneratorRuntime.wrap(function t$(_context141) {
          while (1) {
            switch (_context141.prev = _context141.next) {
              case 0:
                t = _ref113.fs, e = _ref113.gitdir, r = _ref113.oid;
                n = new s.a(t), i = "objects/".concat(r.slice(0, 2), "/").concat(r.slice(2));
                return _context141.abrupt("return", n.exists("".concat(e, "/").concat(i)));

              case 3:
              case "end":
                return _context141.stop();
            }
          }
        }, t);
      }), (dt = function dt() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            lt(o, n, i, a, s, "next", t);
          }

          function s(t) {
            lt(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var ht = r(54);

    function pt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function gt() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref114) {
        var t, e, r, n, i, o, _iteratorNormalCompletion52, _didIteratorError52, _iteratorError52, _iterator52, _step52, _t87, _o19, _a8;

        return regeneratorRuntime.wrap(function t$(_context142) {
          while (1) {
            switch (_context142.prev = _context142.next) {
              case 0:
                t = _ref114.fs, e = _ref114.gitdir, r = _ref114.oid, n = _ref114.getExternalRefDelta;
                i = new s.a(t);
                _context142.next = 4;
                return i.readdir(Object(f.a)(e, "objects/pack"));

              case 4:
                o = _context142.sent;
                o = o.filter(function (t) {
                  return t.endsWith(".idx");
                });
                _iteratorNormalCompletion52 = true;
                _didIteratorError52 = false;
                _iteratorError52 = undefined;
                _context142.prev = 9;
                _iterator52 = o[Symbol.iterator]();

              case 11:
                if (_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done) {
                  _context142.next = 24;
                  break;
                }

                _t87 = _step52.value;
                _o19 = "".concat(e, "/objects/pack/").concat(_t87);
                _context142.next = 16;
                return Object(ht.a)({
                  fs: i,
                  filename: _o19,
                  getExternalRefDelta: n
                });

              case 16:
                _a8 = _context142.sent;

                if (!_a8.error) {
                  _context142.next = 19;
                  break;
                }

                throw new u.b(u.a.InternalFail, {
                  message: _a8.error
                });

              case 19:
                if (!_a8.offsets.has(r)) {
                  _context142.next = 21;
                  break;
                }

                return _context142.abrupt("return", !0);

              case 21:
                _iteratorNormalCompletion52 = true;
                _context142.next = 11;
                break;

              case 24:
                _context142.next = 30;
                break;

              case 26:
                _context142.prev = 26;
                _context142.t0 = _context142["catch"](9);
                _didIteratorError52 = true;
                _iteratorError52 = _context142.t0;

              case 30:
                _context142.prev = 30;
                _context142.prev = 31;

                if (!_iteratorNormalCompletion52 && _iterator52.return != null) {
                  _iterator52.return();
                }

              case 33:
                _context142.prev = 33;

                if (!_didIteratorError52) {
                  _context142.next = 36;
                  break;
                }

                throw _iteratorError52;

              case 36:
                return _context142.finish(33);

              case 37:
                return _context142.finish(30);

              case 38:
                return _context142.abrupt("return", !1);

              case 39:
              case "end":
                return _context142.stop();
            }
          }
        }, t, null, [[9, 26, 30, 38], [31,, 33, 37]]);
      }), (gt = function gt() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            pt(o, n, i, a, s, "next", t);
          }

          function s(t) {
            pt(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function mt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function yt(t) {
      return vt.apply(this, arguments);
    }

    function vt() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref115) {
        var t, e, r, _ref115$format, n, i, o, a;

        return regeneratorRuntime.wrap(function t$(_context143) {
          while (1) {
            switch (_context143.prev = _context143.next) {
              case 0:
                t = _ref115.fs, e = _ref115.gitdir, r = _ref115.oid, _ref115$format = _ref115.format, n = _ref115$format === void 0 ? "content" : _ref115$format;
                i = new s.a(t), o = function o(t) {
                  return Object(j.a)({
                    fs: i,
                    gitdir: e,
                    oid: t
                  });
                };
                _context143.next = 4;
                return function (t) {
                  return dt.apply(this, arguments);
                }({
                  fs: i,
                  gitdir: e,
                  oid: r
                });

              case 4:
                a = _context143.sent;
                _context143.t0 = a;

                if (_context143.t0) {
                  _context143.next = 10;
                  break;
                }

                _context143.next = 9;
                return function (t) {
                  return gt.apply(this, arguments);
                }({
                  fs: i,
                  gitdir: e,
                  oid: r,
                  getExternalRefDelta: o
                });

              case 9:
                a = _context143.sent;

              case 10:
                return _context143.abrupt("return", a);

              case 11:
              case "end":
                return _context143.stop();
            }
          }
        }, t);
      }), (vt = function vt() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            mt(o, n, i, a, s, "next", t);
          }

          function s(t) {
            mt(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var wt = new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");

    function bt(t) {
      var e = wt.exec(t);
      return e ? "remotes/" === e[1] && t.endsWith("/HEAD") ? e[2].slice(0, -5) : e[2] : t;
    }

    var _t = r(35);

    function xt(t, e) {
      var r = t.map(function (t) {
        return t.split("=", 1)[0];
      });
      return e.filter(function (t) {
        var e = t.split("=", 1)[0];
        return r.includes(e);
      });
    }

    var Et = r(27),
        kt = r(24),
        Ot = r(46);

    function jt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Pt(t) {
      var e = t.indexOf("\r"),
          r = t.indexOf("\n");
      return -1 === e && -1 === r ? -1 : -1 === e ? r + 1 : -1 === r ? e + 1 : r === e + 1 ? r + 1 : Math.min(e, r) + 1;
    }

    function St(t) {
      var e = new Ot.a();
      var r = "";
      var n;
      return (n =
      /*#__PURE__*/
      regeneratorRuntime.mark(function n() {
        return regeneratorRuntime.wrap(function n$(_context144) {
          while (1) {
            switch (_context144.prev = _context144.next) {
              case 0:
                _context144.next = 2;
                return Object(Et.a)(t, function (t) {
                  for (t = t.toString("utf8"), r += t;;) {
                    var _t88 = Pt(r);

                    if (-1 === _t88) break;
                    e.write(r.slice(0, _t88)), r = r.slice(_t88);
                  }
                });

              case 2:
                r.length > 0 && e.write(r);
                e.end();

              case 4:
              case "end":
                return _context144.stop();
            }
          }
        }, n);
      }), function () {
        var t = this,
            e = arguments;
        return new Promise(function (r, i) {
          var o = n.apply(t, e);

          function a(t) {
            jt(o, r, i, a, s, "next", t);
          }

          function s(t) {
            jt(o, r, i, a, s, "throw", t);
          }

          a(void 0);
        });
      })(), e;
    }

    var Rt = r(81),
        At = r(80);

    function $t(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Tt(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            $t(o, n, i, a, s, "next", t);
          }

          function s(t) {
            $t(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function It(t) {
      return Bt.apply(this, arguments);
    }

    function Bt() {
      return (Bt = Tt(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee109(_ref116) {
        var _ref116$core, t, e, _ref116$gitdir, r, _ref116$fs, n, _ref116$emitter, i, _ref116$emitterPrefix, o, _ref116$ref, a, u, c, d, _ref116$noGitSuffix, h, p, g, m, _ref116$username, y, _ref116$password, v, w, b, _ref116$depth, _, _ref116$since, x, _ref116$exclude, E, _ref116$relative, k, _ref116$tags, O, _ref116$singleBranch, P, _ref116$headers, S, _ref116$prune, R, _ref116$pruneTags, A, $, _e50, _l4, _t89, _g, _m3, _T, _t90, _n26, _a9;

        return regeneratorRuntime.wrap(function _callee109$(_context145) {
          while (1) {
            switch (_context145.prev = _context145.next) {
              case 0:
                _ref116$core = _ref116.core, t = _ref116$core === void 0 ? "default" : _ref116$core, e = _ref116.dir, _ref116$gitdir = _ref116.gitdir, r = _ref116$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref116$gitdir, _ref116$fs = _ref116.fs, n = _ref116$fs === void 0 ? l.a.get(t).get("fs") : _ref116$fs, _ref116$emitter = _ref116.emitter, i = _ref116$emitter === void 0 ? l.a.get(t).get("emitter") : _ref116$emitter, _ref116$emitterPrefix = _ref116.emitterPrefix, o = _ref116$emitterPrefix === void 0 ? "" : _ref116$emitterPrefix, _ref116$ref = _ref116.ref, a = _ref116$ref === void 0 ? "HEAD" : _ref116$ref, u = _ref116.refs, c = _ref116.remote, d = _ref116.url, _ref116$noGitSuffix = _ref116.noGitSuffix, h = _ref116$noGitSuffix === void 0 ? !1 : _ref116$noGitSuffix, p = _ref116.corsProxy, g = _ref116.authUsername, m = _ref116.authPassword, _ref116$username = _ref116.username, y = _ref116$username === void 0 ? g : _ref116$username, _ref116$password = _ref116.password, v = _ref116$password === void 0 ? m : _ref116$password, w = _ref116.token, b = _ref116.oauth2format, _ref116$depth = _ref116.depth, _ = _ref116$depth === void 0 ? null : _ref116$depth, _ref116$since = _ref116.since, x = _ref116$since === void 0 ? null : _ref116$since, _ref116$exclude = _ref116.exclude, E = _ref116$exclude === void 0 ? [] : _ref116$exclude, _ref116$relative = _ref116.relative, k = _ref116$relative === void 0 ? !1 : _ref116$relative, _ref116$tags = _ref116.tags, O = _ref116$tags === void 0 ? !1 : _ref116$tags, _ref116$singleBranch = _ref116.singleBranch, P = _ref116$singleBranch === void 0 ? !1 : _ref116$singleBranch, _ref116$headers = _ref116.headers, S = _ref116$headers === void 0 ? {} : _ref116$headers, _ref116$prune = _ref116.prune, R = _ref116$prune === void 0 ? !1 : _ref116$prune, _ref116$pruneTags = _ref116.pruneTags, A = _ref116$pruneTags === void 0 ? !1 : _ref116$pruneTags, $ = _ref116.onprogress;
                _context145.prev = 1;
                void 0 !== $ && console.warn("The `onprogress` callback has been deprecated. Please use the more generic `emitter` EventEmitter argument instead.");
                _e50 = new s.a(n);
                _context145.next = 6;
                return function (t) {
                  return Ft.apply(this, arguments);
                }({
                  core: t,
                  gitdir: r,
                  fs: _e50,
                  emitter: i,
                  emitterPrefix: o,
                  ref: a,
                  refs: u,
                  remote: c,
                  url: d,
                  noGitSuffix: h,
                  corsProxy: p,
                  username: y,
                  password: v,
                  token: w,
                  oauth2format: b,
                  depth: _,
                  since: x,
                  exclude: E,
                  relative: k,
                  tags: O,
                  singleBranch: P,
                  headers: S,
                  prune: R,
                  pruneTags: A
                });

              case 6:
                _l4 = _context145.sent;

                if (!(null === _l4)) {
                  _context145.next = 9;
                  break;
                }

                return _context145.abrupt("return", {
                  defaultBranch: null,
                  fetchHead: null,
                  fetchHeadDescription: null
                });

              case 9:
                if (i) {
                  _t89 = St(_l4.progress);
                  Object(Et.a)(_t89, function (t) {
                    i.emit("".concat(o, "message"), t.trim()), i.emit("".concat(o, "rawmessage"), t);
                    var e = t.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
                    e && i.emit("".concat(o, "progress"), {
                      phase: e[1].trim(),
                      loaded: parseInt(e[2], 10),
                      total: parseInt(e[3], 10),
                      lengthComputable: !0
                    });
                  });
                }

                _context145.next = 12;
                return Object(_t.a)(_l4.packfile);

              case 12:
                _g = _context145.sent;
                _m3 = _g.slice(-20).toString("hex");
                _T = {
                  defaultBranch: _l4.HEAD,
                  fetchHead: _l4.FETCH_HEAD.oid,
                  fetchHeadDescription: _l4.FETCH_HEAD.description
                };

                if (!(_l4.headers && (_T.headers = _l4.headers), R && (_T.pruned = _l4.pruned), "" !== _m3 && "5041434b0000000200000000" !== _g.slice(0, 12).toString("hex"))) {
                  _context145.next = 26;
                  break;
                }

                _T.packfile = "objects/pack/pack-".concat(_m3, ".pack");
                _t90 = Object(f.a)(r, _T.packfile);
                _context145.next = 20;
                return _e50.write(_t90, _g);

              case 20:
                _n26 = function _n26(t) {
                  return Object(j.a)({
                    fs: _e50,
                    gitdir: r,
                    oid: t
                  });
                };

                _context145.next = 23;
                return ft.a.fromPack({
                  pack: _g,
                  getExternalRefDelta: _n26,
                  emitter: i,
                  emitterPrefix: o
                });

              case 23:
                _a9 = _context145.sent;
                _context145.next = 26;
                return _e50.write(_t90.replace(/\.pack$/, ".idx"), _a9.toBuffer());

              case 26:
                return _context145.abrupt("return", _T);

              case 29:
                _context145.prev = 29;
                _context145.t0 = _context145["catch"](1);
                throw _context145.t0.caller = "git.fetch", _context145.t0;

              case 32:
              case "end":
                return _context145.stop();
            }
          }
        }, _callee109, null, [[1, 29]]);
      }))).apply(this, arguments);
    }

    function Ft() {
      return (Ft = Tt(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee110(_ref117) {
        var t, e, r, n, i, o, _ref117$refs, a, c, f, l, d, h, p, g, m, y, v, w, b, _, x, E, O, P, R, A, $, T, I, _k$a$resolveAgainstMa, B, F, _iteratorNormalCompletion53, _didIteratorError53, _iteratorError53, _iterator53, _step53, _t95, U, M, C, D, _iteratorNormalCompletion54, _didIteratorError54, _iteratorError54, _iterator54, _step54, _t96, _r38, N, z, H, L, G, q, _iteratorNormalCompletion55, _didIteratorError55, _iteratorError55, _iterator55, _step55, _t97, _ref120, _r39, _n28, _i18, _iteratorNormalCompletion56, _didIteratorError56, _iteratorError56, _iterator56, _step56, _t98, _t91, _r36, _n27, _i17, _t92, _ref118, _o20, _ref119, _t93, _k$a$resolveAgainstMa2, _t94, _iteratorNormalCompletion57, _didIteratorError57, _iteratorError57, _iterator57, _step57, _step57$value, _e51, _r37, W;

        return regeneratorRuntime.wrap(function _callee110$(_context146) {
          while (1) {
            switch (_context146.prev = _context146.next) {
              case 0:
                t = _ref117.core, e = _ref117.gitdir, r = _ref117.fs, n = _ref117.emitter, i = _ref117.emitterPrefix, o = _ref117.ref, _ref117$refs = _ref117.refs, a = _ref117$refs === void 0 ? [o] : _ref117$refs, c = _ref117.remote, f = _ref117.url, l = _ref117.noGitSuffix, d = _ref117.corsProxy, h = _ref117.username, p = _ref117.password, g = _ref117.token, m = _ref117.oauth2format, y = _ref117.depth, v = _ref117.since, w = _ref117.exclude, b = _ref117.relative, _ = _ref117.tags, x = _ref117.singleBranch, E = _ref117.headers, O = _ref117.prune, P = _ref117.pruneTags;
                R = new s.a(r);

                if (!(null !== y)) {
                  _context146.next = 6;
                  break;
                }

                if (!Number.isNaN(parseInt(y))) {
                  _context146.next = 5;
                  break;
                }

                throw new u.b(u.a.InvalidDepthParameterError, {
                  depth: y
                });

              case 5:
                y = parseInt(y);

              case 6:
                c = c || "origin";
                _context146.t0 = void 0 === f;

                if (!_context146.t0) {
                  _context146.next = 12;
                  break;
                }

                _context146.next = 11;
                return S({
                  fs: R,
                  gitdir: e,
                  path: "remote.".concat(c, ".url")
                });

              case 11:
                f = _context146.sent;

              case 12:
                _context146.t1 = void 0 === d;

                if (!_context146.t1) {
                  _context146.next = 17;
                  break;
                }

                _context146.next = 16;
                return S({
                  fs: R,
                  gitdir: e,
                  path: "http.corsProxy"
                });

              case 16:
                d = _context146.sent;

              case 17:
                A = {
                  username: h,
                  password: p,
                  token: g,
                  oauth2format: m
                };
                $ = st.a.getRemoteHelperFor({
                  url: f
                });
                _context146.next = 21;
                return $.discover({
                  core: t,
                  corsProxy: d,
                  service: "git-upload-pack",
                  url: f,
                  noGitSuffix: l,
                  auth: A,
                  headers: E
                });

              case 21:
                T = _context146.sent;
                A = T.auth;
                I = T.refs;

                if (!(0 === I.size)) {
                  _context146.next = 26;
                  break;
                }

                return _context146.abrupt("return", null);

              case 26:
                if (!(null !== y && !T.capabilities.has("shallow"))) {
                  _context146.next = 28;
                  break;
                }

                throw new u.b(u.a.RemoteDoesNotSupportShallowFail);

              case 28:
                if (!(null !== v && !T.capabilities.has("deepen-since"))) {
                  _context146.next = 30;
                  break;
                }

                throw new u.b(u.a.RemoteDoesNotSupportDeepenSinceFail);

              case 30:
                if (!(w.length > 0 && !T.capabilities.has("deepen-not"))) {
                  _context146.next = 32;
                  break;
                }

                throw new u.b(u.a.RemoteDoesNotSupportDeepenNotFail);

              case 32:
                if (!(!0 === b && !T.capabilities.has("deepen-relative"))) {
                  _context146.next = 34;
                  break;
                }

                throw new u.b(u.a.RemoteDoesNotSupportDeepenRelativeFail);

              case 34:
                _k$a$resolveAgainstMa = k.a.resolveAgainstMap({
                  ref: o,
                  map: I
                }), B = _k$a$resolveAgainstMa.oid, F = _k$a$resolveAgainstMa.fullref;
                _iteratorNormalCompletion53 = true;
                _didIteratorError53 = false;
                _iteratorError53 = undefined;
                _context146.prev = 38;

                for (_iterator53 = I.keys()[Symbol.iterator](); !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
                  _t95 = _step53.value;
                  _t95 === F || "HEAD" === _t95 || _t95.startsWith("refs/heads/") || _ && _t95.startsWith("refs/tags/") || I.delete(_t95);
                }

                _context146.next = 46;
                break;

              case 42:
                _context146.prev = 42;
                _context146.t2 = _context146["catch"](38);
                _didIteratorError53 = true;
                _iteratorError53 = _context146.t2;

              case 46:
                _context146.prev = 46;
                _context146.prev = 47;

                if (!_iteratorNormalCompletion53 && _iterator53.return != null) {
                  _iterator53.return();
                }

              case 49:
                _context146.prev = 49;

                if (!_didIteratorError53) {
                  _context146.next = 52;
                  break;
                }

                throw _iteratorError53;

              case 52:
                return _context146.finish(49);

              case 53:
                return _context146.finish(46);

              case 54:
                U = xt(_toConsumableArray(T.capabilities), ["multi_ack_detailed", "no-done", "side-band-64k", "thin-pack", "ofs-delta", "agent=".concat(kt.a.agent)]);
                b && U.push("deepen-relative");
                M = x ? [B] : I.values();

                if (!x) {
                  _context146.next = 61;
                  break;
                }

                _context146.t3 = a;
                _context146.next = 64;
                break;

              case 61:
                _context146.next = 63;
                return k.a.listRefs({
                  fs: R,
                  gitdir: e,
                  filepath: "refs"
                });

              case 63:
                _context146.t3 = _context146.sent;

              case 64:
                C = _context146.t3;
                D = [];
                _iteratorNormalCompletion54 = true;
                _didIteratorError54 = false;
                _iteratorError54 = undefined;
                _context146.prev = 69;
                _iterator54 = C[Symbol.iterator]();

              case 71:
                if (_iteratorNormalCompletion54 = (_step54 = _iterator54.next()).done) {
                  _context146.next = 92;
                  break;
                }

                _t96 = _step54.value;
                _context146.prev = 73;
                _context146.next = 76;
                return k.a.expand({
                  fs: R,
                  gitdir: e,
                  ref: _t96
                });

              case 76:
                _t96 = _context146.sent;
                _context146.next = 79;
                return k.a.resolve({
                  fs: R,
                  gitdir: e,
                  ref: _t96
                });

              case 79:
                _r38 = _context146.sent;
                _context146.next = 82;
                return yt({
                  fs: R,
                  gitdir: e,
                  oid: _r38
                });

              case 82:
                _context146.t4 = _context146.sent;

                if (!_context146.t4) {
                  _context146.next = 85;
                  break;
                }

                D.push(_r38);

              case 85:
                _context146.next = 89;
                break;

              case 87:
                _context146.prev = 87;
                _context146.t5 = _context146["catch"](73);

              case 89:
                _iteratorNormalCompletion54 = true;
                _context146.next = 71;
                break;

              case 92:
                _context146.next = 98;
                break;

              case 94:
                _context146.prev = 94;
                _context146.t6 = _context146["catch"](69);
                _didIteratorError54 = true;
                _iteratorError54 = _context146.t6;

              case 98:
                _context146.prev = 98;
                _context146.prev = 99;

                if (!_iteratorNormalCompletion54 && _iterator54.return != null) {
                  _iterator54.return();
                }

              case 101:
                _context146.prev = 101;

                if (!_didIteratorError54) {
                  _context146.next = 104;
                  break;
                }

                throw _iteratorError54;

              case 104:
                return _context146.finish(101);

              case 105:
                return _context146.finish(98);

              case 106:
                D = _toConsumableArray(new Set(D));
                _context146.next = 109;
                return ut.a.read({
                  fs: R,
                  gitdir: e
                });

              case 109:
                N = _context146.sent;
                z = T.capabilities.has("shallow") ? _toConsumableArray(N) : [];
                H = Object(At.a)({
                  capabilities: U,
                  wants: M,
                  haves: D,
                  shallows: z,
                  depth: y,
                  since: v,
                  exclude: w
                });
                _context146.next = 114;
                return Object(_t.a)(H);

              case 114:
                L = _context146.sent;
                _context146.next = 117;
                return $.connect({
                  core: t,
                  emitter: n,
                  emitterPrefix: i,
                  corsProxy: d,
                  service: "git-upload-pack",
                  url: f,
                  noGitSuffix: l,
                  auth: A,
                  body: [L],
                  headers: E
                });

              case 117:
                G = _context146.sent;
                _context146.next = 120;
                return Object(Rt.a)(G.body);

              case 120:
                q = _context146.sent;
                G.headers && (q.headers = G.headers);
                _iteratorNormalCompletion55 = true;
                _didIteratorError55 = false;
                _iteratorError55 = undefined;
                _context146.prev = 125;
                _iterator55 = q.shallows[Symbol.iterator]();

              case 127:
                if (_iteratorNormalCompletion55 = (_step55 = _iterator55.next()).done) {
                  _context146.next = 148;
                  break;
                }

                _t97 = _step55.value;

                if (N.has(_t97)) {
                  _context146.next = 145;
                  break;
                }

                _context146.prev = 130;
                _context146.next = 133;
                return Object(j.a)({
                  fs: R,
                  gitdir: e,
                  oid: _t97
                });

              case 133:
                _ref120 = _context146.sent;
                _r39 = _ref120.object;
                _n28 = new ct.a(_r39);
                _context146.next = 138;
                return Promise.all(_n28.headers().parent.map(function (t) {
                  return yt({
                    fs: R,
                    gitdir: e,
                    oid: t
                  });
                }));

              case 138:
                _i18 = _context146.sent;
                0 === _i18.length || _i18.every(function (t) {
                  return t;
                }) || N.add(_t97);
                _context146.next = 145;
                break;

              case 142:
                _context146.prev = 142;
                _context146.t7 = _context146["catch"](130);
                N.add(_t97);

              case 145:
                _iteratorNormalCompletion55 = true;
                _context146.next = 127;
                break;

              case 148:
                _context146.next = 154;
                break;

              case 150:
                _context146.prev = 150;
                _context146.t8 = _context146["catch"](125);
                _didIteratorError55 = true;
                _iteratorError55 = _context146.t8;

              case 154:
                _context146.prev = 154;
                _context146.prev = 155;

                if (!_iteratorNormalCompletion55 && _iterator55.return != null) {
                  _iterator55.return();
                }

              case 157:
                _context146.prev = 157;

                if (!_didIteratorError55) {
                  _context146.next = 160;
                  break;
                }

                throw _iteratorError55;

              case 160:
                return _context146.finish(157);

              case 161:
                return _context146.finish(154);

              case 162:
                _iteratorNormalCompletion56 = true;
                _didIteratorError56 = false;
                _iteratorError56 = undefined;
                _context146.prev = 165;

                for (_iterator56 = q.unshallows[Symbol.iterator](); !(_iteratorNormalCompletion56 = (_step56 = _iterator56.next()).done); _iteratorNormalCompletion56 = true) {
                  _t98 = _step56.value;
                  N.delete(_t98);
                }

                _context146.next = 173;
                break;

              case 169:
                _context146.prev = 169;
                _context146.t9 = _context146["catch"](165);
                _didIteratorError56 = true;
                _iteratorError56 = _context146.t9;

              case 173:
                _context146.prev = 173;
                _context146.prev = 174;

                if (!_iteratorNormalCompletion56 && _iterator56.return != null) {
                  _iterator56.return();
                }

              case 176:
                _context146.prev = 176;

                if (!_didIteratorError56) {
                  _context146.next = 179;
                  break;
                }

                throw _iteratorError56;

              case 179:
                return _context146.finish(176);

              case 180:
                return _context146.finish(173);

              case 181:
                _context146.next = 183;
                return ut.a.write({
                  fs: R,
                  gitdir: e,
                  oids: N
                });

              case 183:
                if (!x) {
                  _context146.next = 201;
                  break;
                }

                _t91 = new Map([[F, B]]), _r36 = new Map();
                _n27 = 10, _i17 = F;

              case 186:
                if (!_n27--) {
                  _context146.next = 193;
                  break;
                }

                _t92 = T.symrefs.get(_i17);

                if (!(void 0 === _t92)) {
                  _context146.next = 190;
                  break;
                }

                return _context146.abrupt("break", 193);

              case 190:
                _r36.set(_i17, _t92), _i17 = _t92;

              case 191:
                _context146.next = 186;
                break;

              case 193:
                _t91.set(_i17, I.get(_i17));

                _context146.next = 196;
                return k.a.updateRemoteRefs({
                  fs: R,
                  gitdir: e,
                  remote: c,
                  refs: _t91,
                  symrefs: _r36,
                  tags: _,
                  prune: O
                });

              case 196:
                _ref118 = _context146.sent;
                _o20 = _ref118.pruned;
                O && (q.pruned = _o20);
                _context146.next = 206;
                break;

              case 201:
                _context146.next = 203;
                return k.a.updateRemoteRefs({
                  fs: R,
                  gitdir: e,
                  remote: c,
                  refs: I,
                  symrefs: T.symrefs,
                  tags: _,
                  prune: O,
                  pruneTags: P
                });

              case 203:
                _ref119 = _context146.sent;
                _t93 = _ref119.pruned;
                O && (q.pruned = _t93);

              case 206:
                if (!(q.HEAD = T.symrefs.get("HEAD"), void 0 === q.HEAD)) {
                  _context146.next = 235;
                  break;
                }

                _k$a$resolveAgainstMa2 = k.a.resolveAgainstMap({
                  ref: "HEAD",
                  map: I
                }), _t94 = _k$a$resolveAgainstMa2.oid;
                _iteratorNormalCompletion57 = true;
                _didIteratorError57 = false;
                _iteratorError57 = undefined;
                _context146.prev = 211;
                _iterator57 = I.entries()[Symbol.iterator]();

              case 213:
                if (_iteratorNormalCompletion57 = (_step57 = _iterator57.next()).done) {
                  _context146.next = 221;
                  break;
                }

                _step57$value = _slicedToArray(_step57.value, 2), _e51 = _step57$value[0], _r37 = _step57$value[1];

                if (!("HEAD" !== _e51 && _r37 === _t94)) {
                  _context146.next = 218;
                  break;
                }

                q.HEAD = _e51;
                return _context146.abrupt("break", 221);

              case 218:
                _iteratorNormalCompletion57 = true;
                _context146.next = 213;
                break;

              case 221:
                _context146.next = 227;
                break;

              case 223:
                _context146.prev = 223;
                _context146.t10 = _context146["catch"](211);
                _didIteratorError57 = true;
                _iteratorError57 = _context146.t10;

              case 227:
                _context146.prev = 227;
                _context146.prev = 228;

                if (!_iteratorNormalCompletion57 && _iterator57.return != null) {
                  _iterator57.return();
                }

              case 230:
                _context146.prev = 230;

                if (!_didIteratorError57) {
                  _context146.next = 233;
                  break;
                }

                throw _iteratorError57;

              case 233:
                return _context146.finish(230);

              case 234:
                return _context146.finish(227);

              case 235:
                W = F.startsWith("refs/tags") ? "tag" : "branch";
                return _context146.abrupt("return", (q.FETCH_HEAD = {
                  oid: B,
                  description: "".concat(W, " '").concat(bt(F), "' of ").concat(f)
                }, q));

              case 237:
              case "end":
                return _context146.stop();
            }
          }
        }, _callee110, null, [[38, 42, 46, 54], [47,, 49, 53], [69, 94, 98, 106], [73, 87], [99,, 101, 105], [125, 150, 154, 162], [130, 142], [155,, 157, 161], [165, 169, 173, 181], [174,, 176, 180], [211, 223, 227, 235], [228,, 230, 234]]);
      }))).apply(this, arguments);
    }

    function Ut(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Mt(t) {
      return Ct.apply(this, arguments);
    }

    function Ct() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref121) {
        var _ref121$core, t, _ref121$bare, e, r, _ref121$gitdir, n, _ref121$fs, i, _t99, _r40, _iteratorNormalCompletion58, _didIteratorError58, _iteratorError58, _iterator58, _step58, _e52;

        return regeneratorRuntime.wrap(function t$(_context147) {
          while (1) {
            switch (_context147.prev = _context147.next) {
              case 0:
                _ref121$core = _ref121.core, t = _ref121$core === void 0 ? "default" : _ref121$core, _ref121$bare = _ref121.bare, e = _ref121$bare === void 0 ? !1 : _ref121$bare, r = _ref121.dir, _ref121$gitdir = _ref121.gitdir, n = _ref121$gitdir === void 0 ? e ? r : Object(f.a)(r, ".git") : _ref121$gitdir, _ref121$fs = _ref121.fs, i = _ref121$fs === void 0 ? l.a.get(t).get("fs") : _ref121$fs;
                _context147.prev = 1;
                _t99 = new s.a(i);
                _r40 = ["hooks", "info", "objects/info", "objects/pack", "refs/heads", "refs/tags"];
                _r40 = _r40.map(function (t) {
                  return n + "/" + t;
                });
                _iteratorNormalCompletion58 = true;
                _didIteratorError58 = false;
                _iteratorError58 = undefined;
                _context147.prev = 8;
                _iterator58 = _r40[Symbol.iterator]();

              case 10:
                if (_iteratorNormalCompletion58 = (_step58 = _iterator58.next()).done) {
                  _context147.next = 17;
                  break;
                }

                _e52 = _step58.value;
                _context147.next = 14;
                return _t99.mkdir(_e52);

              case 14:
                _iteratorNormalCompletion58 = true;
                _context147.next = 10;
                break;

              case 17:
                _context147.next = 23;
                break;

              case 19:
                _context147.prev = 19;
                _context147.t0 = _context147["catch"](8);
                _didIteratorError58 = true;
                _iteratorError58 = _context147.t0;

              case 23:
                _context147.prev = 23;
                _context147.prev = 24;

                if (!_iteratorNormalCompletion58 && _iterator58.return != null) {
                  _iterator58.return();
                }

              case 26:
                _context147.prev = 26;

                if (!_didIteratorError58) {
                  _context147.next = 29;
                  break;
                }

                throw _iteratorError58;

              case 29:
                return _context147.finish(26);

              case 30:
                return _context147.finish(23);

              case 31:
                _context147.next = 33;
                return _t99.write(n + "/config", "[core]\n\trepositoryformatversion = 0\n\tfilemode = false\n" + "\tbare = ".concat(e, "\n") + (e ? "" : "\tlogallrefupdates = true\n") + "\tsymlinks = false\n\tignorecase = true\n");

              case 33:
                _context147.next = 35;
                return _t99.write(n + "/HEAD", "ref: refs/heads/master\n");

              case 35:
                _context147.next = 40;
                break;

              case 37:
                _context147.prev = 37;
                _context147.t1 = _context147["catch"](1);
                throw _context147.t1.caller = "git.init", _context147.t1;

              case 40:
              case "end":
                return _context147.stop();
            }
          }
        }, t, null, [[1, 37], [8, 19, 23, 31], [24,, 26, 30]]);
      }), (Ct = function Ct() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Ut(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Ut(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function Dt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Nt(t) {
      return zt.apply(this, arguments);
    }

    function zt() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref122) {
        var _ref122$core, t, e, _ref122$gitdir, r, _ref122$fs, n, _ref122$emitter, i, _ref122$emitterPrefix, o, a, _ref122$noGitSuffix, u, c, d, _ref122$remote, h, p, g, m, y, v, w, b, _, _ref122$exclude, x, _ref122$relative, E, _ref122$singleBranch, k, _ref122$noCheckout, O, _ref122$noTags, j, _ref122$headers, P, R, _f4, _ref123, _l5, _A;

        return regeneratorRuntime.wrap(function t$(_context148) {
          while (1) {
            switch (_context148.prev = _context148.next) {
              case 0:
                _ref122$core = _ref122.core, t = _ref122$core === void 0 ? "default" : _ref122$core, e = _ref122.dir, _ref122$gitdir = _ref122.gitdir, r = _ref122$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref122$gitdir, _ref122$fs = _ref122.fs, n = _ref122$fs === void 0 ? l.a.get(t).get("fs") : _ref122$fs, _ref122$emitter = _ref122.emitter, i = _ref122$emitter === void 0 ? l.a.get(t).get("emitter") : _ref122$emitter, _ref122$emitterPrefix = _ref122.emitterPrefix, o = _ref122$emitterPrefix === void 0 ? "" : _ref122$emitterPrefix, a = _ref122.url, _ref122$noGitSuffix = _ref122.noGitSuffix, u = _ref122$noGitSuffix === void 0 ? !1 : _ref122$noGitSuffix, c = _ref122.corsProxy, d = _ref122.ref, _ref122$remote = _ref122.remote, h = _ref122$remote === void 0 ? "origin" : _ref122$remote, p = _ref122.authUsername, g = _ref122.authPassword, m = _ref122.username, y = _ref122.password, v = _ref122.token, w = _ref122.oauth2format, b = _ref122.depth, _ = _ref122.since, _ref122$exclude = _ref122.exclude, x = _ref122$exclude === void 0 ? [] : _ref122$exclude, _ref122$relative = _ref122.relative, E = _ref122$relative === void 0 ? !1 : _ref122$relative, _ref122$singleBranch = _ref122.singleBranch, k = _ref122$singleBranch === void 0 ? !1 : _ref122$singleBranch, _ref122$noCheckout = _ref122.noCheckout, O = _ref122$noCheckout === void 0 ? !1 : _ref122$noCheckout, _ref122$noTags = _ref122.noTags, j = _ref122$noTags === void 0 ? !1 : _ref122$noTags, _ref122$headers = _ref122.headers, P = _ref122$headers === void 0 ? {} : _ref122$headers, R = _ref122.onprogress;
                _context148.prev = 1;
                void 0 !== R && console.warn("The `onprogress` callback has been deprecated. Please use the more generic `emitter` EventEmitter argument instead.");
                _f4 = new s.a(n);
                m = void 0 === m ? p : m;
                y = void 0 === y ? g : y;
                _context148.next = 8;
                return Mt({
                  gitdir: r,
                  fs: _f4
                });

              case 8:
                _context148.next = 10;
                return S({
                  gitdir: r,
                  fs: _f4,
                  path: "remote.".concat(h, ".url"),
                  value: a
                });

              case 10:
                _context148.next = 12;
                return S({
                  gitdir: r,
                  fs: _f4,
                  path: "remote.".concat(h, ".fetch"),
                  value: "+refs/heads/*:refs/remotes/".concat(h, "/*")
                });

              case 12:
                _context148.t0 = c;

                if (!_context148.t0) {
                  _context148.next = 16;
                  break;
                }

                _context148.next = 16;
                return S({
                  gitdir: r,
                  fs: _f4,
                  path: "http.corsProxy",
                  value: c
                });

              case 16:
                _context148.next = 18;
                return It({
                  core: t,
                  gitdir: r,
                  fs: _f4,
                  emitter: i,
                  emitterPrefix: o,
                  noGitSuffix: u,
                  ref: d,
                  remote: h,
                  username: m,
                  password: y,
                  token: v,
                  oauth2format: w,
                  depth: b,
                  since: _,
                  exclude: x,
                  relative: E,
                  singleBranch: k,
                  headers: P,
                  tags: !j
                });

              case 18:
                _ref123 = _context148.sent;
                _l5 = _ref123.defaultBranch;
                _A = _ref123.fetchHead;

                if (!(null === _A)) {
                  _context148.next = 23;
                  break;
                }

                return _context148.abrupt("return");

              case 23:
                d = (d = d || _l5).replace("refs/heads/", "");
                _context148.next = 26;
                return ot({
                  dir: e,
                  gitdir: r,
                  fs: _f4,
                  emitter: i,
                  emitterPrefix: o,
                  ref: d,
                  remote: h,
                  noCheckout: O
                });

              case 26:
                _context148.next = 31;
                break;

              case 28:
                _context148.prev = 28;
                _context148.t1 = _context148["catch"](1);
                throw _context148.t1.caller = "git.clone", _context148.t1;

              case 31:
              case "end":
                return _context148.stop();
            }
          }
        }, t, null, [[1, 28]]);
      }), (zt = function zt() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Dt(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Dt(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var Ht = r(11),
        Lt = r(67);

    function Gt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function qt(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Gt(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Gt(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function Wt(t) {
      return Yt.apply(this, arguments);
    }

    function Yt() {
      return (Yt = qt(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee112(_ref124) {
        var _ref124$core, t, e, _ref124$gitdir, r, _ref124$fs, n, i, o, d, h, _ref124$dryRun, p, _ref124$noUpdateBranc, g, m, y, v, _e53, _f5;

        return regeneratorRuntime.wrap(function _callee112$(_context150) {
          while (1) {
            switch (_context150.prev = _context150.next) {
              case 0:
                _ref124$core = _ref124.core, t = _ref124$core === void 0 ? "default" : _ref124$core, e = _ref124.dir, _ref124$gitdir = _ref124.gitdir, r = _ref124$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref124$gitdir, _ref124$fs = _ref124.fs, n = _ref124$fs === void 0 ? l.a.get(t).get("fs") : _ref124$fs, i = _ref124.message, o = _ref124.author, d = _ref124.committer, h = _ref124.signingKey, _ref124$dryRun = _ref124.dryRun, p = _ref124$dryRun === void 0 ? !1 : _ref124$dryRun, _ref124$noUpdateBranc = _ref124.noUpdateBranch, g = _ref124$noUpdateBranc === void 0 ? !1 : _ref124$noUpdateBranc, m = _ref124.ref, y = _ref124.parent, v = _ref124.tree;
                _context150.prev = 1;
                _e53 = new s.a(n);
                _context150.t0 = m;

                if (_context150.t0) {
                  _context150.next = 8;
                  break;
                }

                _context150.next = 7;
                return k.a.resolve({
                  fs: _e53,
                  gitdir: r,
                  ref: "HEAD",
                  depth: 2
                });

              case 7:
                m = _context150.sent;

              case 8:
                if (!(void 0 === i)) {
                  _context150.next = 10;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "commit",
                  parameter: "message"
                });

              case 10:
                _context150.t1 = void 0;
                _context150.next = 13;
                return $({
                  fs: _e53,
                  gitdir: r,
                  author: o
                });

              case 13:
                _context150.t2 = o = _context150.sent;

                if (!(_context150.t1 === _context150.t2)) {
                  _context150.next = 16;
                  break;
                }

                throw new u.b(u.a.MissingAuthorError);

              case 16:
                (d = Object.assign({}, d || o)).date = d.date || o.date;
                _context150.t3 = void 0;
                _context150.next = 20;
                return $({
                  fs: _e53,
                  gitdir: r,
                  author: d
                });

              case 20:
                _context150.t4 = d = _context150.sent;

                if (!(_context150.t3 === _context150.t4)) {
                  _context150.next = 23;
                  break;
                }

                throw new u.b(u.a.MissingCommitterError);

              case 23:
                _context150.next = 25;
                return a.a.acquire({
                  fs: _e53,
                  filepath: "".concat(r, "/index")
                }, function () {
                  var n = qt(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee111(n) {
                    var a, s, _e54;

                    return regeneratorRuntime.wrap(function _callee111$(_context149) {
                      while (1) {
                        switch (_context149.prev = _context149.next) {
                          case 0:
                            a = Object(Lt.a)(n.entries).get(".");
                            _context149.t0 = v;

                            if (_context149.t0) {
                              _context149.next = 6;
                              break;
                            }

                            _context149.next = 5;
                            return Zt({
                              fs: _e53,
                              gitdir: r,
                              inode: a,
                              dryRun: p
                            });

                          case 5:
                            v = _context149.sent;

                          case 6:
                            if (y) {
                              _context149.next = 17;
                              break;
                            }

                            _context149.prev = 7;
                            _context149.next = 10;
                            return k.a.resolve({
                              fs: _e53,
                              gitdir: r,
                              ref: m
                            });

                          case 10:
                            _context149.t1 = _context149.sent;
                            y = [_context149.t1];
                            _context149.next = 17;
                            break;

                          case 14:
                            _context149.prev = 14;
                            _context149.t2 = _context149["catch"](7);
                            y = [];

                          case 17:
                            s = ct.a.from({
                              tree: v,
                              parent: y,
                              author: o,
                              committer: d,
                              message: i
                            });

                            if (!h) {
                              _context149.next = 23;
                              break;
                            }

                            _e54 = l.a.get(t).get("pgp");
                            _context149.next = 22;
                            return ct.a.sign(s, _e54, h);

                          case 22:
                            s = _context149.sent;

                          case 23:
                            _context149.next = 25;
                            return Object(c.a)({
                              fs: _e53,
                              gitdir: r,
                              type: "commit",
                              object: s.toObject(),
                              dryRun: p
                            });

                          case 25:
                            _f5 = _context149.sent;
                            _context149.t3 = g || p;

                            if (_context149.t3) {
                              _context149.next = 30;
                              break;
                            }

                            _context149.next = 30;
                            return k.a.writeRef({
                              fs: _e53,
                              gitdir: r,
                              ref: m,
                              value: _f5
                            });

                          case 30:
                          case "end":
                            return _context149.stop();
                        }
                      }
                    }, _callee111, null, [[7, 14]]);
                  }));
                  return function (t) {
                    return n.apply(this, arguments);
                  };
                }());

              case 25:
                return _context150.abrupt("return", _f5);

              case 28:
                _context150.prev = 28;
                _context150.t5 = _context150["catch"](1);
                throw _context150.t5.caller = "git.commit", _context150.t5;

              case 31:
              case "end":
                return _context150.stop();
            }
          }
        }, _callee112, null, [[1, 28]]);
      }))).apply(this, arguments);
    }

    function Zt(t) {
      return Kt.apply(this, arguments);
    }

    function Kt() {
      return (Kt = qt(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee113(_ref125) {
        var t, e, r, n, i, _iteratorNormalCompletion59, _didIteratorError59, _iteratorError59, _iterator59, _step59, _r41, o, a;

        return regeneratorRuntime.wrap(function _callee113$(_context151) {
          while (1) {
            switch (_context151.prev = _context151.next) {
              case 0:
                t = _ref125.fs, e = _ref125.gitdir, r = _ref125.inode, n = _ref125.dryRun;
                i = r.children;
                _iteratorNormalCompletion59 = true;
                _didIteratorError59 = false;
                _iteratorError59 = undefined;
                _context151.prev = 5;
                _iterator59 = i[Symbol.iterator]();

              case 7:
                if (_iteratorNormalCompletion59 = (_step59 = _iterator59.next()).done) {
                  _context151.next = 18;
                  break;
                }

                _r41 = _step59.value;
                _context151.t0 = "tree" === _r41.type;

                if (!_context151.t0) {
                  _context151.next = 15;
                  break;
                }

                _r41.metadata.mode = "040000";
                _context151.next = 14;
                return Zt({
                  fs: t,
                  gitdir: e,
                  inode: _r41,
                  dryRun: n
                });

              case 14:
                _r41.metadata.oid = _context151.sent;

              case 15:
                _iteratorNormalCompletion59 = true;
                _context151.next = 7;
                break;

              case 18:
                _context151.next = 24;
                break;

              case 20:
                _context151.prev = 20;
                _context151.t1 = _context151["catch"](5);
                _didIteratorError59 = true;
                _iteratorError59 = _context151.t1;

              case 24:
                _context151.prev = 24;
                _context151.prev = 25;

                if (!_iteratorNormalCompletion59 && _iterator59.return != null) {
                  _iterator59.return();
                }

              case 27:
                _context151.prev = 27;

                if (!_didIteratorError59) {
                  _context151.next = 30;
                  break;
                }

                throw _iteratorError59;

              case 30:
                return _context151.finish(27);

              case 31:
                return _context151.finish(24);

              case 32:
                o = i.map(function (t) {
                  return {
                    mode: t.metadata.mode,
                    path: t.basename,
                    oid: t.metadata.oid,
                    type: t.type
                  };
                }), a = Ht.a.from(o);
                _context151.next = 35;
                return Object(c.a)({
                  fs: t,
                  gitdir: e,
                  type: "tree",
                  object: a.toObject(),
                  dryRun: n
                });

              case 35:
                return _context151.abrupt("return", _context151.sent);

              case 36:
              case "end":
                return _context151.stop();
            }
          }
        }, _callee113, null, [[5, 20, 24, 32], [25,, 27, 31]]);
      }))).apply(this, arguments);
    }

    function Vt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Xt(t) {
      return Jt.apply(this, arguments);
    }

    function Jt() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref126) {
        var _ref126$core, t, e, _ref126$gitdir, r, _ref126$fs, n, _ref126$fullname, i, _t100, _e55;

        return regeneratorRuntime.wrap(function t$(_context152) {
          while (1) {
            switch (_context152.prev = _context152.next) {
              case 0:
                _ref126$core = _ref126.core, t = _ref126$core === void 0 ? "default" : _ref126$core, e = _ref126.dir, _ref126$gitdir = _ref126.gitdir, r = _ref126$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref126$gitdir, _ref126$fs = _ref126.fs, n = _ref126$fs === void 0 ? l.a.get(t).get("fs") : _ref126$fs, _ref126$fullname = _ref126.fullname, i = _ref126$fullname === void 0 ? !1 : _ref126$fullname;
                _context152.prev = 1;
                _t100 = new s.a(n);
                _context152.next = 5;
                return k.a.resolve({
                  fs: _t100,
                  gitdir: r,
                  ref: "HEAD",
                  depth: 2
                });

              case 5:
                _e55 = _context152.sent;

                if (_e55.startsWith("refs/")) {
                  _context152.next = 8;
                  break;
                }

                return _context152.abrupt("return");

              case 8:
                return _context152.abrupt("return", i ? _e55 : bt(_e55));

              case 11:
                _context152.prev = 11;
                _context152.t0 = _context152["catch"](1);
                throw _context152.t0.caller = "git.currentBranch", _context152.t0;

              case 14:
              case "end":
                return _context152.stop();
            }
          }
        }, t, null, [[1, 11]]);
      }), (Jt = function Jt() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Vt(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Vt(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function Qt(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function te(t) {
      return ee.apply(this, arguments);
    }

    function ee() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref127) {
        var _ref127$core, t, e, _ref127$gitdir, r, _ref127$fs, n, i, _t101;

        return regeneratorRuntime.wrap(function t$(_context153) {
          while (1) {
            switch (_context153.prev = _context153.next) {
              case 0:
                _ref127$core = _ref127.core, t = _ref127$core === void 0 ? "default" : _ref127$core, e = _ref127.dir, _ref127$gitdir = _ref127.gitdir, r = _ref127$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref127$gitdir, _ref127$fs = _ref127.fs, n = _ref127$fs === void 0 ? l.a.get(t).get("fs") : _ref127$fs, i = _ref127.ref;
                _context153.prev = 1;
                _t101 = new s.a(n);

                if (!(void 0 === i)) {
                  _context153.next = 5;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "deleteBranch",
                  parameter: "ref"
                });

              case 5:
                if (!(i !== w.a.clean(i))) {
                  _context153.next = 7;
                  break;
                }

                throw new u.b(u.a.InvalidRefNameError, {
                  verb: "delete",
                  noun: "branch",
                  ref: i,
                  suggestion: w.a.clean(i)
                });

              case 7:
                _context153.next = 9;
                return _t101.exists("".concat(r, "/refs/heads/").concat(i));

              case 9:
                if (_context153.sent) {
                  _context153.next = 11;
                  break;
                }

                throw new u.b(u.a.RefNotExistsError, {
                  verb: "delete",
                  noun: "branch",
                  ref: i
                });

              case 11:
                _context153.t0 = i;
                _context153.next = 14;
                return Xt({
                  fs: _t101,
                  gitdir: r
                });

              case 14:
                _context153.t1 = _context153.sent;

                if (!(_context153.t0 === _context153.t1)) {
                  _context153.next = 17;
                  break;
                }

                throw new u.b(u.a.BranchDeleteError, {
                  ref: i
                });

              case 17:
                _context153.next = 19;
                return _t101.rm("".concat(r, "/refs/heads/").concat(i));

              case 19:
                _context153.next = 24;
                break;

              case 21:
                _context153.prev = 21;
                _context153.t2 = _context153["catch"](1);
                throw _context153.t2.caller = "git.deleteBranch", _context153.t2;

              case 24:
              case "end":
                return _context153.stop();
            }
          }
        }, t, null, [[1, 21]]);
      }), (ee = function ee() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Qt(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Qt(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function re(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function ne(t) {
      return ie.apply(this, arguments);
    }

    function ie() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref128) {
        var _ref128$core, t, e, _ref128$gitdir, r, _ref128$fs, n, i, _t102;

        return regeneratorRuntime.wrap(function t$(_context154) {
          while (1) {
            switch (_context154.prev = _context154.next) {
              case 0:
                _ref128$core = _ref128.core, t = _ref128$core === void 0 ? "default" : _ref128$core, e = _ref128.dir, _ref128$gitdir = _ref128.gitdir, r = _ref128$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref128$gitdir, _ref128$fs = _ref128.fs, n = _ref128$fs === void 0 ? l.a.get(t).get("fs") : _ref128$fs, i = _ref128.ref;
                _context154.prev = 1;
                _t102 = new s.a(n);
                _context154.next = 5;
                return k.a.deleteRef({
                  fs: _t102,
                  gitdir: r,
                  ref: i
                });

              case 5:
                _context154.next = 10;
                break;

              case 7:
                _context154.prev = 7;
                _context154.t0 = _context154["catch"](1);
                throw _context154.t0.caller = "git.deleteRef", _context154.t0;

              case 10:
              case "end":
                return _context154.stop();
            }
          }
        }, t, null, [[1, 7]]);
      }), (ie = function ie() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            re(o, n, i, a, s, "next", t);
          }

          function s(t) {
            re(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function oe(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function ae(t) {
      return se.apply(this, arguments);
    }

    function se() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref129) {
        var _ref129$core, t, e, _ref129$gitdir, r, _ref129$fs, n, i, _t103, _e56;

        return regeneratorRuntime.wrap(function t$(_context155) {
          while (1) {
            switch (_context155.prev = _context155.next) {
              case 0:
                _ref129$core = _ref129.core, t = _ref129$core === void 0 ? "default" : _ref129$core, e = _ref129.dir, _ref129$gitdir = _ref129.gitdir, r = _ref129$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref129$gitdir, _ref129$fs = _ref129.fs, n = _ref129$fs === void 0 ? l.a.get(t).get("fs") : _ref129$fs, i = _ref129.remote;
                _context155.prev = 1;
                _t103 = new s.a(n);

                if (!(void 0 === i)) {
                  _context155.next = 5;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "deleteRemote",
                  parameter: "remote"
                });

              case 5:
                _context155.next = 7;
                return b.a.get({
                  fs: _t103,
                  gitdir: r
                });

              case 7:
                _e56 = _context155.sent;
                _context155.next = 10;
                return _e56.deleteSection("remote", i);

              case 10:
                _context155.next = 12;
                return b.a.save({
                  fs: _t103,
                  gitdir: r,
                  config: _e56
                });

              case 12:
                _context155.next = 17;
                break;

              case 14:
                _context155.prev = 14;
                _context155.t0 = _context155["catch"](1);
                throw _context155.t0.caller = "git.deleteRemote", _context155.t0;

              case 17:
              case "end":
                return _context155.stop();
            }
          }
        }, t, null, [[1, 14]]);
      }), (se = function se() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            oe(o, n, i, a, s, "next", t);
          }

          function s(t) {
            oe(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function ue(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function ce(t) {
      return fe.apply(this, arguments);
    }

    function fe() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref130) {
        var _ref130$core, t, e, _ref130$gitdir, r, _ref130$fs, n, i, _t104;

        return regeneratorRuntime.wrap(function t$(_context156) {
          while (1) {
            switch (_context156.prev = _context156.next) {
              case 0:
                _ref130$core = _ref130.core, t = _ref130$core === void 0 ? "default" : _ref130$core, e = _ref130.dir, _ref130$gitdir = _ref130.gitdir, r = _ref130$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref130$gitdir, _ref130$fs = _ref130.fs, n = _ref130$fs === void 0 ? l.a.get(t).get("fs") : _ref130$fs, i = _ref130.ref;
                _context156.prev = 1;
                _t104 = new s.a(n);

                if (!(void 0 === i)) {
                  _context156.next = 5;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "deleteTag",
                  parameter: "ref"
                });

              case 5:
                i = i.startsWith("refs/tags/") ? i : "refs/tags/".concat(i);
                _context156.next = 8;
                return ne({
                  fs: _t104,
                  gitdir: r,
                  ref: i
                });

              case 8:
                _context156.next = 13;
                break;

              case 10:
                _context156.prev = 10;
                _context156.t0 = _context156["catch"](1);
                throw _context156.t0.caller = "git.deleteTag", _context156.t0;

              case 13:
              case "end":
                return _context156.stop();
            }
          }
        }, t, null, [[1, 10]]);
      }), (fe = function fe() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            ue(o, n, i, a, s, "next", t);
          }

          function s(t) {
            ue(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function le(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function de() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref131) {
        var t, e, r, n, i;
        return regeneratorRuntime.wrap(function t$(_context157) {
          while (1) {
            switch (_context157.prev = _context157.next) {
              case 0:
                t = _ref131.fs, e = _ref131.gitdir, r = _ref131.oid;
                n = new s.a(t), i = r.slice(0, 2);
                _context157.next = 4;
                return n.readdir("".concat(e, "/objects/").concat(i));

              case 4:
                _context157.t0 = function (t) {
                  return "".concat(i).concat(t);
                };

                _context157.t1 = function (t) {
                  return t.startsWith(r);
                };

                return _context157.abrupt("return", _context157.sent.map(_context157.t0).filter(_context157.t1));

              case 7:
              case "end":
                return _context157.stop();
            }
          }
        }, t);
      }), (de = function de() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            le(o, n, i, a, s, "next", t);
          }

          function s(t) {
            le(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function he(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function pe() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref132) {
        var t, e, r, n, i, o, a, _iteratorNormalCompletion60, _didIteratorError60, _iteratorError60, _iterator60, _step60, _t105, _a10, _s8, _iteratorNormalCompletion61, _didIteratorError61, _iteratorError61, _iterator61, _step61, _t106;

        return regeneratorRuntime.wrap(function t$(_context158) {
          while (1) {
            switch (_context158.prev = _context158.next) {
              case 0:
                t = _ref132.fs, e = _ref132.gitdir, r = _ref132.oid, n = _ref132.getExternalRefDelta;
                i = new s.a(t), o = [];
                _context158.next = 4;
                return i.readdir(Object(f.a)(e, "objects/pack"));

              case 4:
                a = _context158.sent;
                a = a.filter(function (t) {
                  return t.endsWith(".idx");
                });
                _iteratorNormalCompletion60 = true;
                _didIteratorError60 = false;
                _iteratorError60 = undefined;
                _context158.prev = 9;
                _iterator60 = a[Symbol.iterator]();

              case 11:
                if (_iteratorNormalCompletion60 = (_step60 = _iterator60.next()).done) {
                  _context158.next = 41;
                  break;
                }

                _t105 = _step60.value;
                _a10 = "".concat(e, "/objects/pack/").concat(_t105);
                _context158.next = 16;
                return Object(ht.a)({
                  fs: i,
                  filename: _a10,
                  getExternalRefDelta: n
                });

              case 16:
                _s8 = _context158.sent;

                if (!_s8.error) {
                  _context158.next = 19;
                  break;
                }

                throw new u.b(u.a.InternalFail, {
                  message: _s8.error
                });

              case 19:
                _iteratorNormalCompletion61 = true;
                _didIteratorError61 = false;
                _iteratorError61 = undefined;
                _context158.prev = 22;

                for (_iterator61 = _s8.offsets.keys()[Symbol.iterator](); !(_iteratorNormalCompletion61 = (_step61 = _iterator61.next()).done); _iteratorNormalCompletion61 = true) {
                  _t106 = _step61.value;
                  _t106.startsWith(r) && o.push(_t106);
                }

                _context158.next = 30;
                break;

              case 26:
                _context158.prev = 26;
                _context158.t0 = _context158["catch"](22);
                _didIteratorError61 = true;
                _iteratorError61 = _context158.t0;

              case 30:
                _context158.prev = 30;
                _context158.prev = 31;

                if (!_iteratorNormalCompletion61 && _iterator61.return != null) {
                  _iterator61.return();
                }

              case 33:
                _context158.prev = 33;

                if (!_didIteratorError61) {
                  _context158.next = 36;
                  break;
                }

                throw _iteratorError61;

              case 36:
                return _context158.finish(33);

              case 37:
                return _context158.finish(30);

              case 38:
                _iteratorNormalCompletion60 = true;
                _context158.next = 11;
                break;

              case 41:
                _context158.next = 47;
                break;

              case 43:
                _context158.prev = 43;
                _context158.t1 = _context158["catch"](9);
                _didIteratorError60 = true;
                _iteratorError60 = _context158.t1;

              case 47:
                _context158.prev = 47;
                _context158.prev = 48;

                if (!_iteratorNormalCompletion60 && _iterator60.return != null) {
                  _iterator60.return();
                }

              case 50:
                _context158.prev = 50;

                if (!_didIteratorError60) {
                  _context158.next = 53;
                  break;
                }

                throw _iteratorError60;

              case 53:
                return _context158.finish(50);

              case 54:
                return _context158.finish(47);

              case 55:
                return _context158.abrupt("return", o);

              case 56:
              case "end":
                return _context158.stop();
            }
          }
        }, t, null, [[9, 43, 47, 55], [22, 26, 30, 38], [31,, 33, 37], [48,, 50, 54]]);
      }), (pe = function pe() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            he(o, n, i, a, s, "next", t);
          }

          function s(t) {
            he(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function ge(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function me() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref133) {
        var t, e, r, n, i, o, a;
        return regeneratorRuntime.wrap(function t$(_context159) {
          while (1) {
            switch (_context159.prev = _context159.next) {
              case 0:
                t = _ref133.fs, e = _ref133.gitdir, r = _ref133.oid;
                n = new s.a(t);
                _context159.next = 4;
                return function (t) {
                  return de.apply(this, arguments);
                }({
                  fs: n,
                  gitdir: e,
                  oid: r
                });

              case 4:
                i = _context159.sent;
                _context159.next = 7;
                return function (t) {
                  return pe.apply(this, arguments);
                }({
                  fs: n,
                  gitdir: e,
                  oid: r,
                  getExternalRefDelta: function getExternalRefDelta(r) {
                    return Object(j.a)({
                      fs: t,
                      gitdir: e,
                      oid: r
                    });
                  }
                });

              case 7:
                o = _context159.sent;
                a = i.concat(o);

                if (!(1 === a.length)) {
                  _context159.next = 11;
                  break;
                }

                return _context159.abrupt("return", a[0]);

              case 11:
                if (!(a.length > 1)) {
                  _context159.next = 13;
                  break;
                }

                throw new u.b(u.a.AmbiguousShortOid, {
                  short: r,
                  matches: a.join(", ")
                });

              case 13:
                throw new u.b(u.a.ShortOidNotFound, {
                  short: r
                });

              case 14:
              case "end":
                return _context159.stop();
            }
          }
        }, t);
      }), (me = function me() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            ge(o, n, i, a, s, "next", t);
          }

          function s(t) {
            ge(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function ye(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function ve(t) {
      return we.apply(this, arguments);
    }

    function we() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref134) {
        var _ref134$core, t, e, _ref134$gitdir, r, _ref134$fs, n, i, _t107;

        return regeneratorRuntime.wrap(function t$(_context160) {
          while (1) {
            switch (_context160.prev = _context160.next) {
              case 0:
                _ref134$core = _ref134.core, t = _ref134$core === void 0 ? "default" : _ref134$core, e = _ref134.dir, _ref134$gitdir = _ref134.gitdir, r = _ref134$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref134$gitdir, _ref134$fs = _ref134.fs, n = _ref134$fs === void 0 ? l.a.get(t).get("fs") : _ref134$fs, i = _ref134.oid;
                _context160.prev = 1;
                _t107 = new s.a(n);
                _context160.next = 5;
                return function (t) {
                  return me.apply(this, arguments);
                }({
                  fs: _t107,
                  gitdir: r,
                  oid: i
                });

              case 5:
                return _context160.abrupt("return", _context160.sent);

              case 8:
                _context160.prev = 8;
                _context160.t0 = _context160["catch"](1);
                throw _context160.t0.caller = "git.expandOid", _context160.t0;

              case 11:
              case "end":
                return _context160.stop();
            }
          }
        }, t, null, [[1, 8]]);
      }), (we = function we() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            ye(o, n, i, a, s, "next", t);
          }

          function s(t) {
            ye(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function be(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function _e(t) {
      return xe.apply(this, arguments);
    }

    function xe() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref135) {
        var _ref135$core, t, e, _ref135$gitdir, r, _ref135$fs, n, i, _t108;

        return regeneratorRuntime.wrap(function t$(_context161) {
          while (1) {
            switch (_context161.prev = _context161.next) {
              case 0:
                _ref135$core = _ref135.core, t = _ref135$core === void 0 ? "default" : _ref135$core, e = _ref135.dir, _ref135$gitdir = _ref135.gitdir, r = _ref135$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref135$gitdir, _ref135$fs = _ref135.fs, n = _ref135$fs === void 0 ? l.a.get(t).get("fs") : _ref135$fs, i = _ref135.ref;
                _context161.prev = 1;
                _t108 = new s.a(n);
                _context161.next = 5;
                return k.a.expand({
                  fs: _t108,
                  gitdir: r,
                  ref: i
                });

              case 5:
                return _context161.abrupt("return", _context161.sent);

              case 8:
                _context161.prev = 8;
                _context161.t0 = _context161["catch"](1);
                throw _context161.t0.caller = "git.expandRef", _context161.t0;

              case 11:
              case "end":
                return _context161.stop();
            }
          }
        }, t, null, [[1, 8]]);
      }), (xe = function xe() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            be(o, n, i, a, s, "next", t);
          }

          function s(t) {
            be(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function Ee(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function ke(t) {
      return Oe.apply(this, arguments);
    }

    function Oe() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref136) {
        var _ref136$core, t, e, _ref136$gitdir, r, _ref136$fs, n, i, _t109, _e57, _o21, _a11, _n29, _iteratorNormalCompletion62, _didIteratorError62, _iteratorError62, _iterator62, _step62, _t110, _r42, _i20, _i19, _iteratorNormalCompletion63, _didIteratorError63, _iteratorError63, _iterator63, _step63, _e58, _n30, _o22, _ref137, _e59, _a12, _a12$parseHeaders, _s9, _iteratorNormalCompletion64, _didIteratorError64, _iteratorError64, _iterator64, _step64, _t111;

        return regeneratorRuntime.wrap(function t$(_context162) {
          while (1) {
            switch (_context162.prev = _context162.next) {
              case 0:
                _ref136$core = _ref136.core, t = _ref136$core === void 0 ? "default" : _ref136$core, e = _ref136.dir, _ref136$gitdir = _ref136.gitdir, r = _ref136$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref136$gitdir, _ref136$fs = _ref136.fs, n = _ref136$fs === void 0 ? l.a.get(t).get("fs") : _ref136$fs, i = _ref136.oids;
                _context162.prev = 1;
                _t109 = new s.a(n), _e57 = {}, _o21 = i.length;
                _a11 = i.map(function (t, e) {
                  return {
                    index: e,
                    oid: t
                  };
                });

              case 4:
                if (!_a11.length) {
                  _context162.next = 87;
                  break;
                }

                _n29 = new Set();
                _iteratorNormalCompletion62 = true;
                _didIteratorError62 = false;
                _iteratorError62 = undefined;
                _context162.prev = 9;

                for (_iterator62 = _a11[Symbol.iterator](); !(_iteratorNormalCompletion62 = (_step62 = _iterator62.next()).done); _iteratorNormalCompletion62 = true) {
                  _t110 = _step62.value;
                  _r42 = _t110.oid, _i20 = _t110.index;
                  _e57[_r42] || (_e57[_r42] = new Set()), _e57[_r42].add(_i20), _e57[_r42].size === _o21 && _n29.add(_r42);
                }

                _context162.next = 17;
                break;

              case 13:
                _context162.prev = 13;
                _context162.t0 = _context162["catch"](9);
                _didIteratorError62 = true;
                _iteratorError62 = _context162.t0;

              case 17:
                _context162.prev = 17;
                _context162.prev = 18;

                if (!_iteratorNormalCompletion62 && _iterator62.return != null) {
                  _iterator62.return();
                }

              case 20:
                _context162.prev = 20;

                if (!_didIteratorError62) {
                  _context162.next = 23;
                  break;
                }

                throw _iteratorError62;

              case 23:
                return _context162.finish(20);

              case 24:
                return _context162.finish(17);

              case 25:
                if (!(_n29.size > 0)) {
                  _context162.next = 27;
                  break;
                }

                return _context162.abrupt("return", _toConsumableArray(_n29));

              case 27:
                _i19 = [];
                _iteratorNormalCompletion63 = true;
                _didIteratorError63 = false;
                _iteratorError63 = undefined;
                _context162.prev = 31;
                _iterator63 = _a11[Symbol.iterator]();

              case 33:
                if (_iteratorNormalCompletion63 = (_step63 = _iterator63.next()).done) {
                  _context162.next = 70;
                  break;
                }

                _e58 = _step63.value;
                _n30 = _e58.oid, _o22 = _e58.index;
                _context162.prev = 36;
                _context162.next = 39;
                return Object(j.a)({
                  fs: _t109,
                  gitdir: r,
                  oid: _n30
                });

              case 39:
                _ref137 = _context162.sent;
                _e59 = _ref137.object;
                _a12 = ct.a.from(_e59);
                _a12$parseHeaders = _a12.parseHeaders();
                _s9 = _a12$parseHeaders.parent;
                _iteratorNormalCompletion64 = true;
                _didIteratorError64 = false;
                _iteratorError64 = undefined;
                _context162.prev = 47;

                for (_iterator64 = _s9[Symbol.iterator](); !(_iteratorNormalCompletion64 = (_step64 = _iterator64.next()).done); _iteratorNormalCompletion64 = true) {
                  _t111 = _step64.value;

                  _i19.push({
                    oid: _t111,
                    index: _o22
                  });
                }

                _context162.next = 55;
                break;

              case 51:
                _context162.prev = 51;
                _context162.t1 = _context162["catch"](47);
                _didIteratorError64 = true;
                _iteratorError64 = _context162.t1;

              case 55:
                _context162.prev = 55;
                _context162.prev = 56;

                if (!_iteratorNormalCompletion64 && _iterator64.return != null) {
                  _iterator64.return();
                }

              case 58:
                _context162.prev = 58;

                if (!_didIteratorError64) {
                  _context162.next = 61;
                  break;
                }

                throw _iteratorError64;

              case 61:
                return _context162.finish(58);

              case 62:
                return _context162.finish(55);

              case 63:
                _context162.next = 67;
                break;

              case 65:
                _context162.prev = 65;
                _context162.t2 = _context162["catch"](36);

              case 67:
                _iteratorNormalCompletion63 = true;
                _context162.next = 33;
                break;

              case 70:
                _context162.next = 76;
                break;

              case 72:
                _context162.prev = 72;
                _context162.t3 = _context162["catch"](31);
                _didIteratorError63 = true;
                _iteratorError63 = _context162.t3;

              case 76:
                _context162.prev = 76;
                _context162.prev = 77;

                if (!_iteratorNormalCompletion63 && _iterator63.return != null) {
                  _iterator63.return();
                }

              case 79:
                _context162.prev = 79;

                if (!_didIteratorError63) {
                  _context162.next = 82;
                  break;
                }

                throw _iteratorError63;

              case 82:
                return _context162.finish(79);

              case 83:
                return _context162.finish(76);

              case 84:
                _a11 = _i19;

              case 85:
                _context162.next = 4;
                break;

              case 87:
                return _context162.abrupt("return", []);

              case 90:
                _context162.prev = 90;
                _context162.t4 = _context162["catch"](1);
                throw _context162.t4.caller = "git.findMergeBase", _context162.t4;

              case 93:
              case "end":
                return _context162.stop();
            }
          }
        }, t, null, [[1, 90], [9, 13, 17, 25], [18,, 20, 24], [31, 72, 76, 84], [36, 65], [47, 51, 55, 63], [56,, 58, 62], [77,, 79, 83]]);
      }), (Oe = function Oe() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Ee(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Ee(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var je = r(21);

    function Pe(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Se(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Pe(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Pe(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function Re(t) {
      return Ae.apply(this, arguments);
    }

    function Ae() {
      return (Ae = Se(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee114(_ref138) {
        var _ref138$core, t, _ref138$fs, e, r;

        return regeneratorRuntime.wrap(function _callee114$(_context163) {
          while (1) {
            switch (_context163.prev = _context163.next) {
              case 0:
                _ref138$core = _ref138.core, t = _ref138$core === void 0 ? "default" : _ref138$core, _ref138$fs = _ref138.fs, e = _ref138$fs === void 0 ? l.a.get(t).get("fs") : _ref138$fs, r = _ref138.filepath;
                _context163.prev = 1;
                return _context163.abrupt("return", $e(new s.a(e), r));

              case 5:
                _context163.prev = 5;
                _context163.t0 = _context163["catch"](1);
                throw _context163.t0.caller = "git.findRoot", _context163.t0;

              case 8:
              case "end":
                return _context163.stop();
            }
          }
        }, _callee114, null, [[1, 5]]);
      }))).apply(this, arguments);
    }

    function $e(t, e) {
      return Te.apply(this, arguments);
    }

    function Te() {
      return (Te = Se(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee115(t, e) {
        var _r43;

        return regeneratorRuntime.wrap(function _callee115$(_context164) {
          while (1) {
            switch (_context164.prev = _context164.next) {
              case 0:
                _context164.next = 2;
                return t.exists(Object(f.a)(e, ".git"));

              case 2:
                if (!_context164.sent) {
                  _context164.next = 4;
                  break;
                }

                return _context164.abrupt("return", e);

              case 4:
                _r43 = Object(je.a)(e);

                if (!(_r43 === e)) {
                  _context164.next = 7;
                  break;
                }

                throw new u.b(u.a.GitRootNotFoundError, {
                  filepath: e
                });

              case 7:
                return _context164.abrupt("return", $e(t, _r43));

              case 8:
              case "end":
                return _context164.stop();
            }
          }
        }, _callee115);
      }))).apply(this, arguments);
    }

    var Ie = r(41);

    function Be(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Fe(t) {
      return Ue.apply(this, arguments);
    }

    function Ue() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref139) {
        var _ref139$core, t, e, r, n, i, _ref139$noGitSuffix, o, _ref139$username, a, _ref139$password, s, u, c, _ref139$headers, f, _ref139$forPush, l, _n31, _i21, _d3, _iteratorNormalCompletion65, _didIteratorError65, _iteratorError65, _iterator65, _step65, _step65$value, _t112, _e60, _r44, _n32, _i22, _iteratorNormalCompletion67, _didIteratorError67, _iteratorError67, _iterator67, _step67, _t113, _iteratorNormalCompletion66, _didIteratorError66, _iteratorError66, _iterator66, _step66, _step66$value, _t114, _e61, _r45, _n33, _i23, _iteratorNormalCompletion68, _didIteratorError68, _iteratorError68, _iterator68, _step68, _t115;

        return regeneratorRuntime.wrap(function t$(_context165) {
          while (1) {
            switch (_context165.prev = _context165.next) {
              case 0:
                _ref139$core = _ref139.core, t = _ref139$core === void 0 ? "default" : _ref139$core, e = _ref139.corsProxy, r = _ref139.url, n = _ref139.authUsername, i = _ref139.authPassword, _ref139$noGitSuffix = _ref139.noGitSuffix, o = _ref139$noGitSuffix === void 0 ? !1 : _ref139$noGitSuffix, _ref139$username = _ref139.username, a = _ref139$username === void 0 ? n : _ref139$username, _ref139$password = _ref139.password, s = _ref139$password === void 0 ? i : _ref139$password, u = _ref139.token, c = _ref139.oauth2format, _ref139$headers = _ref139.headers, f = _ref139$headers === void 0 ? {} : _ref139$headers, _ref139$forPush = _ref139.forPush, l = _ref139$forPush === void 0 ? !1 : _ref139$forPush;
                _context165.prev = 1;
                _n31 = {
                  username: a,
                  password: s,
                  token: u,
                  oauth2format: c
                };
                _context165.next = 5;
                return Ie.a.discover({
                  core: t,
                  corsProxy: e,
                  service: l ? "git-receive-pack" : "git-upload-pack",
                  url: r,
                  noGitSuffix: o,
                  auth: _n31,
                  headers: f
                });

              case 5:
                _i21 = _context165.sent;
                _n31 = _i21.auth;
                _d3 = {
                  capabilities: _toConsumableArray(_i21.capabilities)
                };
                _iteratorNormalCompletion65 = true;
                _didIteratorError65 = false;
                _iteratorError65 = undefined;
                _context165.prev = 11;
                _iterator65 = _i21.refs[Symbol.iterator]();

              case 13:
                if (_iteratorNormalCompletion65 = (_step65 = _iterator65.next()).done) {
                  _context165.next = 40;
                  break;
                }

                _step65$value = _slicedToArray(_step65.value, 2), _t112 = _step65$value[0], _e60 = _step65$value[1];
                _r44 = _t112.split("/"), _n32 = _r44.pop();
                _i22 = _d3;
                _iteratorNormalCompletion67 = true;
                _didIteratorError67 = false;
                _iteratorError67 = undefined;
                _context165.prev = 20;

                for (_iterator67 = _r44[Symbol.iterator](); !(_iteratorNormalCompletion67 = (_step67 = _iterator67.next()).done); _iteratorNormalCompletion67 = true) {
                  _t113 = _step67.value;
                  _i22[_t113] = _i22[_t113] || {}, _i22 = _i22[_t113];
                }

                _context165.next = 28;
                break;

              case 24:
                _context165.prev = 24;
                _context165.t0 = _context165["catch"](20);
                _didIteratorError67 = true;
                _iteratorError67 = _context165.t0;

              case 28:
                _context165.prev = 28;
                _context165.prev = 29;

                if (!_iteratorNormalCompletion67 && _iterator67.return != null) {
                  _iterator67.return();
                }

              case 31:
                _context165.prev = 31;

                if (!_didIteratorError67) {
                  _context165.next = 34;
                  break;
                }

                throw _iteratorError67;

              case 34:
                return _context165.finish(31);

              case 35:
                return _context165.finish(28);

              case 36:
                _i22[_n32] = _e60;

              case 37:
                _iteratorNormalCompletion65 = true;
                _context165.next = 13;
                break;

              case 40:
                _context165.next = 46;
                break;

              case 42:
                _context165.prev = 42;
                _context165.t1 = _context165["catch"](11);
                _didIteratorError65 = true;
                _iteratorError65 = _context165.t1;

              case 46:
                _context165.prev = 46;
                _context165.prev = 47;

                if (!_iteratorNormalCompletion65 && _iterator65.return != null) {
                  _iterator65.return();
                }

              case 49:
                _context165.prev = 49;

                if (!_didIteratorError65) {
                  _context165.next = 52;
                  break;
                }

                throw _iteratorError65;

              case 52:
                return _context165.finish(49);

              case 53:
                return _context165.finish(46);

              case 54:
                _iteratorNormalCompletion66 = true;
                _didIteratorError66 = false;
                _iteratorError66 = undefined;
                _context165.prev = 57;
                _iterator66 = _i21.symrefs[Symbol.iterator]();

              case 59:
                if (_iteratorNormalCompletion66 = (_step66 = _iterator66.next()).done) {
                  _context165.next = 86;
                  break;
                }

                _step66$value = _slicedToArray(_step66.value, 2), _t114 = _step66$value[0], _e61 = _step66$value[1];
                _r45 = _t114.split("/"), _n33 = _r45.pop();
                _i23 = _d3;
                _iteratorNormalCompletion68 = true;
                _didIteratorError68 = false;
                _iteratorError68 = undefined;
                _context165.prev = 66;

                for (_iterator68 = _r45[Symbol.iterator](); !(_iteratorNormalCompletion68 = (_step68 = _iterator68.next()).done); _iteratorNormalCompletion68 = true) {
                  _t115 = _step68.value;
                  _i23[_t115] = _i23[_t115] || {}, _i23 = _i23[_t115];
                }

                _context165.next = 74;
                break;

              case 70:
                _context165.prev = 70;
                _context165.t2 = _context165["catch"](66);
                _didIteratorError68 = true;
                _iteratorError68 = _context165.t2;

              case 74:
                _context165.prev = 74;
                _context165.prev = 75;

                if (!_iteratorNormalCompletion68 && _iterator68.return != null) {
                  _iterator68.return();
                }

              case 77:
                _context165.prev = 77;

                if (!_didIteratorError68) {
                  _context165.next = 80;
                  break;
                }

                throw _iteratorError68;

              case 80:
                return _context165.finish(77);

              case 81:
                return _context165.finish(74);

              case 82:
                _i23[_n33] = _e61;

              case 83:
                _iteratorNormalCompletion66 = true;
                _context165.next = 59;
                break;

              case 86:
                _context165.next = 92;
                break;

              case 88:
                _context165.prev = 88;
                _context165.t3 = _context165["catch"](57);
                _didIteratorError66 = true;
                _iteratorError66 = _context165.t3;

              case 92:
                _context165.prev = 92;
                _context165.prev = 93;

                if (!_iteratorNormalCompletion66 && _iterator66.return != null) {
                  _iterator66.return();
                }

              case 95:
                _context165.prev = 95;

                if (!_didIteratorError66) {
                  _context165.next = 98;
                  break;
                }

                throw _iteratorError66;

              case 98:
                return _context165.finish(95);

              case 99:
                return _context165.finish(92);

              case 100:
                return _context165.abrupt("return", _d3);

              case 103:
                _context165.prev = 103;
                _context165.t4 = _context165["catch"](1);
                throw _context165.t4.caller = "git.getRemoteInfo", _context165.t4;

              case 106:
              case "end":
                return _context165.stop();
            }
          }
        }, t, null, [[1, 103], [11, 42, 46, 54], [20, 24, 28, 36], [29,, 31, 35], [47,, 49, 53], [57, 88, 92, 100], [66, 70, 74, 82], [75,, 77, 81], [93,, 95, 99]]);
      }), (Ue = function Ue() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Be(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Be(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var Me = r(125);

    function Ce(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function De(t) {
      return Ne.apply(this, arguments);
    }

    function Ne() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref140) {
        var _ref140$core, t, e, _ref140$gitdir, r, _ref140$fs, n, _ref140$emitter, i, _ref140$emitterPrefix, o, a, _t116, _u3, _c5, _l6;

        return regeneratorRuntime.wrap(function t$(_context166) {
          while (1) {
            switch (_context166.prev = _context166.next) {
              case 0:
                _ref140$core = _ref140.core, t = _ref140$core === void 0 ? "default" : _ref140$core, e = _ref140.dir, _ref140$gitdir = _ref140.gitdir, r = _ref140$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref140$gitdir, _ref140$fs = _ref140.fs, n = _ref140$fs === void 0 ? l.a.get(t).get("fs") : _ref140$fs, _ref140$emitter = _ref140.emitter, i = _ref140$emitter === void 0 ? l.a.get(t).get("emitter") : _ref140$emitter, _ref140$emitterPrefix = _ref140.emitterPrefix, o = _ref140$emitterPrefix === void 0 ? "" : _ref140$emitterPrefix, a = _ref140.filepath;
                _context166.prev = 1;
                _t116 = new s.a(n);
                a = Object(f.a)(e, a);
                _context166.next = 6;
                return _t116.read(a);

              case 6:
                _u3 = _context166.sent;

                _c5 = function _c5(e) {
                  return Object(j.a)({
                    fs: _t116,
                    gitdir: r,
                    oid: e
                  });
                };

                _context166.next = 10;
                return ft.a.fromPack({
                  pack: _u3,
                  getExternalRefDelta: _c5,
                  emitter: i,
                  emitterPrefix: o
                });

              case 10:
                _l6 = _context166.sent;
                _context166.next = 13;
                return _t116.write(a.replace(/\.pack$/, ".idx"), _l6.toBuffer());

              case 13:
                _context166.next = 18;
                break;

              case 15:
                _context166.prev = 15;
                _context166.t0 = _context166["catch"](1);
                throw _context166.t0.caller = "git.indexPack", _context166.t0;

              case 18:
              case "end":
                return _context166.stop();
            }
          }
        }, t, null, [[1, 15]]);
      }), (Ne = function Ne() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Ce(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Ce(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function ze(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function He(t) {
      return Le.apply(this, arguments);
    }

    function Le() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref141) {
        var _ref141$core, t, e, _ref141$gitdir, r, _ref141$fs, n, i, o, _ref141$depth, a, _t117, _e62, _c6, _f6, _l7, _n34, _ref142, _i24, _s10, _d4, _iteratorNormalCompletion69, _didIteratorError69, _iteratorError69, _iterator69, _step69, _t119, _iteratorNormalCompletion70, _didIteratorError70, _iteratorError70, _iterator70, _step70, _t118;

        return regeneratorRuntime.wrap(function t$(_context167) {
          while (1) {
            switch (_context167.prev = _context167.next) {
              case 0:
                _ref141$core = _ref141.core, t = _ref141$core === void 0 ? "default" : _ref141$core, e = _ref141.dir, _ref141$gitdir = _ref141.gitdir, r = _ref141$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref141$gitdir, _ref141$fs = _ref141.fs, n = _ref141$fs === void 0 ? l.a.get(t).get("fs") : _ref141$fs, i = _ref141.oid, o = _ref141.ancestor, _ref141$depth = _ref141.depth, a = _ref141$depth === void 0 ? -1 : _ref141$depth;
                _context167.prev = 1;
                _t117 = new s.a(n);
                _context167.next = 5;
                return ut.a.read({
                  fs: _t117,
                  gitdir: r
                });

              case 5:
                _e62 = _context167.sent;

                if (i) {
                  _context167.next = 8;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "isDescendent",
                  parameter: "oid"
                });

              case 8:
                if (o) {
                  _context167.next = 10;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "isDescendent",
                  parameter: "ancestor"
                });

              case 10:
                if (!(i === o)) {
                  _context167.next = 12;
                  break;
                }

                return _context167.abrupt("return", !1);

              case 12:
                _c6 = [i], _f6 = new Set();
                _l7 = 0;

              case 14:
                if (!_c6.length) {
                  _context167.next = 74;
                  break;
                }

                if (!(_l7++ === a)) {
                  _context167.next = 17;
                  break;
                }

                throw new u.b(u.a.MaxSearchDepthExceeded, {
                  depth: a
                });

              case 17:
                _n34 = _c6.shift();
                _context167.next = 20;
                return Object(j.a)({
                  fs: _t117,
                  gitdir: r,
                  oid: _n34
                });

              case 20:
                _ref142 = _context167.sent;
                _i24 = _ref142.type;
                _s10 = _ref142.object;

                if (!("commit" !== _i24)) {
                  _context167.next = 25;
                  break;
                }

                throw new u.b(u.a.ResolveCommitError, {
                  oid: _n34
                });

              case 25:
                _d4 = ct.a.from(_s10).parse();
                _iteratorNormalCompletion69 = true;
                _didIteratorError69 = false;
                _iteratorError69 = undefined;
                _context167.prev = 29;
                _iterator69 = _d4.parent[Symbol.iterator]();

              case 31:
                if (_iteratorNormalCompletion69 = (_step69 = _iterator69.next()).done) {
                  _context167.next = 38;
                  break;
                }

                _t119 = _step69.value;

                if (!(_t119 === o)) {
                  _context167.next = 35;
                  break;
                }

                return _context167.abrupt("return", !0);

              case 35:
                _iteratorNormalCompletion69 = true;
                _context167.next = 31;
                break;

              case 38:
                _context167.next = 44;
                break;

              case 40:
                _context167.prev = 40;
                _context167.t0 = _context167["catch"](29);
                _didIteratorError69 = true;
                _iteratorError69 = _context167.t0;

              case 44:
                _context167.prev = 44;
                _context167.prev = 45;

                if (!_iteratorNormalCompletion69 && _iterator69.return != null) {
                  _iterator69.return();
                }

              case 47:
                _context167.prev = 47;

                if (!_didIteratorError69) {
                  _context167.next = 50;
                  break;
                }

                throw _iteratorError69;

              case 50:
                return _context167.finish(47);

              case 51:
                return _context167.finish(44);

              case 52:
                if (_e62.has(_n34)) {
                  _context167.next = 72;
                  break;
                }

                _iteratorNormalCompletion70 = true;
                _didIteratorError70 = false;
                _iteratorError70 = undefined;
                _context167.prev = 56;

                for (_iterator70 = _d4.parent[Symbol.iterator](); !(_iteratorNormalCompletion70 = (_step70 = _iterator70.next()).done); _iteratorNormalCompletion70 = true) {
                  _t118 = _step70.value;
                  _f6.has(_t118) || (_c6.push(_t118), _f6.add(_t118));
                }

                _context167.next = 64;
                break;

              case 60:
                _context167.prev = 60;
                _context167.t1 = _context167["catch"](56);
                _didIteratorError70 = true;
                _iteratorError70 = _context167.t1;

              case 64:
                _context167.prev = 64;
                _context167.prev = 65;

                if (!_iteratorNormalCompletion70 && _iterator70.return != null) {
                  _iterator70.return();
                }

              case 67:
                _context167.prev = 67;

                if (!_didIteratorError70) {
                  _context167.next = 70;
                  break;
                }

                throw _iteratorError70;

              case 70:
                return _context167.finish(67);

              case 71:
                return _context167.finish(64);

              case 72:
                _context167.next = 14;
                break;

              case 74:
                return _context167.abrupt("return", !1);

              case 77:
                _context167.prev = 77;
                _context167.t2 = _context167["catch"](1);
                throw _context167.t2.caller = "git.isDescendent", _context167.t2;

              case 80:
              case "end":
                return _context167.stop();
            }
          }
        }, t, null, [[1, 77], [29, 40, 44, 52], [45,, 47, 51], [56, 60, 64, 72], [65,, 67, 71]]);
      }), (Le = function Le() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            ze(o, n, i, a, s, "next", t);
          }

          function s(t) {
            ze(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function Ge(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function qe(t) {
      return We.apply(this, arguments);
    }

    function We() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref143) {
        var _ref143$core, t, e, _ref143$gitdir, r, _ref143$fs, n, i, _t120;

        return regeneratorRuntime.wrap(function t$(_context168) {
          while (1) {
            switch (_context168.prev = _context168.next) {
              case 0:
                _ref143$core = _ref143.core, t = _ref143$core === void 0 ? "default" : _ref143$core, e = _ref143.dir, _ref143$gitdir = _ref143.gitdir, r = _ref143$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref143$gitdir, _ref143$fs = _ref143.fs, n = _ref143$fs === void 0 ? l.a.get(t).get("fs") : _ref143$fs, i = _ref143.remote;
                _context168.prev = 1;
                _t120 = new s.a(n);
                return _context168.abrupt("return", k.a.listBranches({
                  fs: _t120,
                  gitdir: r,
                  remote: i
                }));

              case 6:
                _context168.prev = 6;
                _context168.t0 = _context168["catch"](1);
                throw _context168.t0.caller = "git.listBranches", _context168.t0;

              case 9:
              case "end":
                return _context168.stop();
            }
          }
        }, t, null, [[1, 6]]);
      }), (We = function We() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Ge(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Ge(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var Ye = r(49);

    function Ze(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Ke(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Ze(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Ze(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function Ve(t) {
      return Xe.apply(this, arguments);
    }

    function Xe() {
      return (Xe = Ke(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee116(_ref144) {
        var _ref144$core, t, e, _ref144$gitdir, r, _ref144$fs, n, i, _ref144$format, o, a, c, _t121, _e64, _n35, _o23, _n36, _e63, _f7;

        return regeneratorRuntime.wrap(function _callee116$(_context169) {
          while (1) {
            switch (_context169.prev = _context169.next) {
              case 0:
                _ref144$core = _ref144.core, t = _ref144$core === void 0 ? "default" : _ref144$core, e = _ref144.dir, _ref144$gitdir = _ref144.gitdir, r = _ref144$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref144$gitdir, _ref144$fs = _ref144.fs, n = _ref144$fs === void 0 ? l.a.get(t).get("fs") : _ref144$fs, i = _ref144.oid, _ref144$format = _ref144.format, o = _ref144$format === void 0 ? "parsed" : _ref144$format, a = _ref144.filepath, c = _ref144.encoding;
                _context169.prev = 1;
                _t121 = new s.a(n);

                if (!(void 0 !== a)) {
                  _context169.next = 19;
                  break;
                }

                if (!(a.startsWith("/") || a.endsWith("/"))) {
                  _context169.next = 6;
                  break;
                }

                throw new u.b(u.a.DirectorySeparatorsError);

              case 6:
                _e64 = i;
                _context169.next = 9;
                return Object(Ye.a)({
                  fs: _t121,
                  gitdir: r,
                  oid: i
                });

              case 9:
                _n35 = _context169.sent;
                _o23 = _n35.tree;

                if (!("" === a)) {
                  _context169.next = 15;
                  break;
                }

                i = _n35.oid;
                _context169.next = 19;
                break;

              case 15:
                _n36 = a.split("/");
                _context169.next = 18;
                return Je({
                  fs: _t121,
                  gitdir: r,
                  tree: _o23,
                  pathArray: _n36,
                  oid: _e64,
                  filepath: a
                });

              case 18:
                i = _context169.sent;

              case 19:
                _e63 = "parsed" === o ? "content" : o;
                _context169.next = 22;
                return Object(j.a)({
                  fs: _t121,
                  gitdir: r,
                  oid: i,
                  format: _e63
                });

              case 22:
                _f7 = _context169.sent;

                if (!(_f7.oid = i, "parsed" === o)) {
                  _context169.next = 36;
                  break;
                }

                _context169.t0 = (_f7.format = "parsed", _f7.type);
                _context169.next = _context169.t0 === "commit" ? 27 : _context169.t0 === "tree" ? 29 : _context169.t0 === "blob" ? 31 : _context169.t0 === "tag" ? 33 : 35;
                break;

              case 27:
                _f7.object = ct.a.from(_f7.object).parse();
                return _context169.abrupt("break", 36);

              case 29:
                _f7.object = {
                  entries: Ht.a.from(_f7.object).entries()
                };
                return _context169.abrupt("break", 36);

              case 31:
                c ? _f7.object = _f7.object.toString(c) : _f7.format = "content";
                return _context169.abrupt("break", 36);

              case 33:
                _f7.object = O.a.from(_f7.object).parse();
                return _context169.abrupt("break", 36);

              case 35:
                throw new u.b(u.a.ObjectTypeUnknownFail, {
                  type: _f7.type
                });

              case 36:
                return _context169.abrupt("return", _f7);

              case 39:
                _context169.prev = 39;
                _context169.t1 = _context169["catch"](1);
                throw _context169.t1.caller = "git.readObject", _context169.t1;

              case 42:
              case "end":
                return _context169.stop();
            }
          }
        }, _callee116, null, [[1, 39]]);
      }))).apply(this, arguments);
    }

    function Je(t) {
      return Qe.apply(this, arguments);
    }

    function Qe() {
      return (Qe = Ke(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee117(_ref145) {
        var t, e, r, n, i, o, a, _iteratorNormalCompletion71, _didIteratorError71, _iteratorError71, _iterator71, _step71, _s11, _ref146, _a13, _c7;

        return regeneratorRuntime.wrap(function _callee117$(_context170) {
          while (1) {
            switch (_context170.prev = _context170.next) {
              case 0:
                t = _ref145.fs, e = _ref145.gitdir, r = _ref145.tree, n = _ref145.pathArray, i = _ref145.oid, o = _ref145.filepath;
                a = n.shift();
                _iteratorNormalCompletion71 = true;
                _didIteratorError71 = false;
                _iteratorError71 = undefined;
                _context170.prev = 5;
                _iterator71 = r[Symbol.iterator]();

              case 7:
                if (_iteratorNormalCompletion71 = (_step71 = _iterator71.next()).done) {
                  _context170.next = 25;
                  break;
                }

                _s11 = _step71.value;

                if (!(_s11.path === a)) {
                  _context170.next = 22;
                  break;
                }

                if (!(0 === n.length)) {
                  _context170.next = 12;
                  break;
                }

                return _context170.abrupt("return", _s11.oid);

              case 12:
                _context170.next = 14;
                return Object(j.a)({
                  fs: t,
                  gitdir: e,
                  oid: _s11.oid
                });

              case 14:
                _ref146 = _context170.sent;
                _a13 = _ref146.type;
                _c7 = _ref146.object;

                if (!("blob" === _a13)) {
                  _context170.next = 19;
                  break;
                }

                throw new u.b(u.a.DirectoryIsAFileError, {
                  oid: i,
                  filepath: o
                });

              case 19:
                if (!("tree" !== _a13)) {
                  _context170.next = 21;
                  break;
                }

                throw new u.b(u.a.ObjectTypeAssertionInTreeFail, {
                  oid: _s11.oid,
                  entrypath: o,
                  type: _a13
                });

              case 21:
                return _context170.abrupt("return", Je({
                  fs: t,
                  gitdir: e,
                  tree: r = Ht.a.from(_c7),
                  pathArray: n,
                  oid: i,
                  filepath: o
                }));

              case 22:
                _iteratorNormalCompletion71 = true;
                _context170.next = 7;
                break;

              case 25:
                _context170.next = 31;
                break;

              case 27:
                _context170.prev = 27;
                _context170.t0 = _context170["catch"](5);
                _didIteratorError71 = true;
                _iteratorError71 = _context170.t0;

              case 31:
                _context170.prev = 31;
                _context170.prev = 32;

                if (!_iteratorNormalCompletion71 && _iterator71.return != null) {
                  _iterator71.return();
                }

              case 34:
                _context170.prev = 34;

                if (!_didIteratorError71) {
                  _context170.next = 37;
                  break;
                }

                throw _iteratorError71;

              case 37:
                return _context170.finish(34);

              case 38:
                return _context170.finish(31);

              case 39:
                throw new u.b(u.a.TreeOrBlobNotFoundError, {
                  oid: i,
                  filepath: o
                });

              case 40:
              case "end":
                return _context170.stop();
            }
          }
        }, _callee117, null, [[5, 27, 31, 39], [32,, 34, 38]]);
      }))).apply(this, arguments);
    }

    function tr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function er(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            tr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            tr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function rr(t) {
      return nr.apply(this, arguments);
    }

    function nr() {
      return (nr = er(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee119(_ref147) {
        var _ref147$core, t, e, _ref147$gitdir, r, _ref147$fs, n, i, _t122, _e65, _n37;

        return regeneratorRuntime.wrap(function _callee119$(_context172) {
          while (1) {
            switch (_context172.prev = _context172.next) {
              case 0:
                _ref147$core = _ref147.core, t = _ref147$core === void 0 ? "default" : _ref147$core, e = _ref147.dir, _ref147$gitdir = _ref147.gitdir, r = _ref147$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref147$gitdir, _ref147$fs = _ref147.fs, n = _ref147$fs === void 0 ? l.a.get(t).get("fs") : _ref147$fs, i = _ref147.ref;
                _context172.prev = 1;
                _t122 = new s.a(n);

                if (!i) {
                  _context172.next = 12;
                  break;
                }

                _context172.next = 6;
                return k.a.resolve({
                  gitdir: r,
                  fs: _t122,
                  ref: i
                });

              case 6:
                _n37 = _context172.sent;
                _e65 = [];
                _context172.next = 10;
                return ir({
                  gitdir: r,
                  fs: _t122,
                  oid: _n37,
                  filenames: _e65,
                  prefix: ""
                });

              case 10:
                _context172.next = 14;
                break;

              case 12:
                _context172.next = 14;
                return a.a.acquire({
                  fs: _t122,
                  filepath: "".concat(r, "/index")
                }, function () {
                  var t = er(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee118(t) {
                    return regeneratorRuntime.wrap(function _callee118$(_context171) {
                      while (1) {
                        switch (_context171.prev = _context171.next) {
                          case 0:
                            _e65 = t.entries.map(function (t) {
                              return t.path;
                            });

                          case 1:
                          case "end":
                            return _context171.stop();
                        }
                      }
                    }, _callee118);
                  }));
                  return function (e) {
                    return t.apply(this, arguments);
                  };
                }());

              case 14:
                return _context172.abrupt("return", _e65);

              case 17:
                _context172.prev = 17;
                _context172.t0 = _context172["catch"](1);
                throw _context172.t0.caller = "git.listFiles", _context172.t0;

              case 20:
              case "end":
                return _context172.stop();
            }
          }
        }, _callee119, null, [[1, 17]]);
      }))).apply(this, arguments);
    }

    function ir(t) {
      return or.apply(this, arguments);
    }

    function or() {
      return (or = er(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee120(_ref148) {
        var t, e, r, n, i, _ref149, o, _iteratorNormalCompletion72, _didIteratorError72, _iteratorError72, _iterator72, _step72, _r46;

        return regeneratorRuntime.wrap(function _callee120$(_context173) {
          while (1) {
            switch (_context173.prev = _context173.next) {
              case 0:
                t = _ref148.gitdir, e = _ref148.fs, r = _ref148.oid, n = _ref148.filenames, i = _ref148.prefix;
                _context173.next = 3;
                return Ve({
                  gitdir: t,
                  fs: e,
                  oid: r,
                  filepath: ""
                });

              case 3:
                _ref149 = _context173.sent;
                o = _ref149.object;
                _iteratorNormalCompletion72 = true;
                _didIteratorError72 = false;
                _iteratorError72 = undefined;
                _context173.prev = 8;
                _iterator72 = o.entries[Symbol.iterator]();

              case 10:
                if (_iteratorNormalCompletion72 = (_step72 = _iterator72.next()).done) {
                  _context173.next = 21;
                  break;
                }

                _r46 = _step72.value;

                if (!("tree" === _r46.type)) {
                  _context173.next = 17;
                  break;
                }

                _context173.next = 15;
                return ir({
                  gitdir: t,
                  fs: e,
                  oid: _r46.oid,
                  filenames: n,
                  prefix: Object(f.a)(i, _r46.path)
                });

              case 15:
                _context173.next = 18;
                break;

              case 17:
                n.push(Object(f.a)(i, _r46.path));

              case 18:
                _iteratorNormalCompletion72 = true;
                _context173.next = 10;
                break;

              case 21:
                _context173.next = 27;
                break;

              case 23:
                _context173.prev = 23;
                _context173.t0 = _context173["catch"](8);
                _didIteratorError72 = true;
                _iteratorError72 = _context173.t0;

              case 27:
                _context173.prev = 27;
                _context173.prev = 28;

                if (!_iteratorNormalCompletion72 && _iterator72.return != null) {
                  _iterator72.return();
                }

              case 30:
                _context173.prev = 30;

                if (!_didIteratorError72) {
                  _context173.next = 33;
                  break;
                }

                throw _iteratorError72;

              case 33:
                return _context173.finish(30);

              case 34:
                return _context173.finish(27);

              case 35:
              case "end":
                return _context173.stop();
            }
          }
        }, _callee120, null, [[8, 23, 27, 35], [28,, 30, 34]]);
      }))).apply(this, arguments);
    }

    function ar(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function sr(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            ar(o, n, i, a, s, "next", t);
          }

          function s(t) {
            ar(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function ur(t) {
      return cr.apply(this, arguments);
    }

    function cr() {
      return (cr = sr(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee122(_ref150) {
        var _ref150$core, t, e, _ref150$gitdir, r, _ref150$fs, n, _t123, _e66, _i25;

        return regeneratorRuntime.wrap(function _callee122$(_context175) {
          while (1) {
            switch (_context175.prev = _context175.next) {
              case 0:
                _ref150$core = _ref150.core, t = _ref150$core === void 0 ? "default" : _ref150$core, e = _ref150.dir, _ref150$gitdir = _ref150.gitdir, r = _ref150$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref150$gitdir, _ref150$fs = _ref150.fs, n = _ref150$fs === void 0 ? l.a.get(t).get("fs") : _ref150$fs;
                _context175.prev = 1;
                _t123 = new s.a(n);
                _context175.next = 5;
                return b.a.get({
                  fs: _t123,
                  gitdir: r
                });

              case 5:
                _e66 = _context175.sent;
                _context175.next = 8;
                return _e66.getSubsections("remote");

              case 8:
                _i25 = _context175.sent;
                return _context175.abrupt("return", Promise.all(_i25.map(function () {
                  var t = sr(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee121(t) {
                    return regeneratorRuntime.wrap(function _callee121$(_context174) {
                      while (1) {
                        switch (_context174.prev = _context174.next) {
                          case 0:
                            _context174.t0 = t;
                            _context174.next = 3;
                            return _e66.get("remote.".concat(t, ".url"));

                          case 3:
                            _context174.t1 = _context174.sent;
                            return _context174.abrupt("return", {
                              remote: _context174.t0,
                              url: _context174.t1
                            });

                          case 5:
                          case "end":
                            return _context174.stop();
                        }
                      }
                    }, _callee121);
                  }));
                  return function (e) {
                    return t.apply(this, arguments);
                  };
                }())));

              case 12:
                _context175.prev = 12;
                _context175.t0 = _context175["catch"](1);
                throw _context175.t0.caller = "git.listRemotes", _context175.t0;

              case 15:
              case "end":
                return _context175.stop();
            }
          }
        }, _callee122, null, [[1, 12]]);
      }))).apply(this, arguments);
    }

    function fr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function lr(t) {
      return dr.apply(this, arguments);
    }

    function dr() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref151) {
        var _ref151$core, t, e, _ref151$gitdir, r, _ref151$fs, n, _t124;

        return regeneratorRuntime.wrap(function t$(_context176) {
          while (1) {
            switch (_context176.prev = _context176.next) {
              case 0:
                _ref151$core = _ref151.core, t = _ref151$core === void 0 ? "default" : _ref151$core, e = _ref151.dir, _ref151$gitdir = _ref151.gitdir, r = _ref151$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref151$gitdir, _ref151$fs = _ref151.fs, n = _ref151$fs === void 0 ? l.a.get(t).get("fs") : _ref151$fs;
                _context176.prev = 1;
                _t124 = new s.a(n);
                return _context176.abrupt("return", k.a.listTags({
                  fs: _t124,
                  gitdir: r
                }));

              case 6:
                _context176.prev = 6;
                _context176.t0 = _context176["catch"](1);
                throw _context176.t0.caller = "git.listTags", _context176.t0;

              case 9:
              case "end":
                return _context176.stop();
            }
          }
        }, t, null, [[1, 6]]);
      }), (dr = function dr() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            fr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            fr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function hr(t, e) {
      return t.committer.timestamp - e.committer.timestamp;
    }

    function pr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function gr(t) {
      return mr.apply(this, arguments);
    }

    function mr() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref152) {
        var t, e, r, n, _ref153, _i26, _o24, _a14, _s12;

        return regeneratorRuntime.wrap(function t$(_context177) {
          while (1) {
            switch (_context177.prev = _context177.next) {
              case 0:
                t = _ref152.fs, e = _ref152.gitdir, r = _ref152.oid, n = _ref152.signing;
                _context177.prev = 1;
                _context177.next = 4;
                return Object(j.a)({
                  fs: t,
                  gitdir: e,
                  oid: r
                });

              case 4:
                _ref153 = _context177.sent;
                _i26 = _ref153.type;
                _o24 = _ref153.object;

                if (!("commit" !== _i26)) {
                  _context177.next = 9;
                  break;
                }

                throw new u.b(u.a.ObjectTypeAssertionFail, {
                  oid: r,
                  expected: "commit",
                  type: _i26
                });

              case 9:
                _a14 = ct.a.from(_o24), _s12 = Object.assign({
                  oid: r
                }, _a14.parse());
                return _context177.abrupt("return", (n && (_s12.payload = _a14.withoutSignature()), _s12));

              case 13:
                _context177.prev = 13;
                _context177.t0 = _context177["catch"](1);
                return _context177.abrupt("return", {
                  oid: r,
                  error: _context177.t0
                });

              case 16:
              case "end":
                return _context177.stop();
            }
          }
        }, t, null, [[1, 13]]);
      }), (mr = function mr() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            pr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            pr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function yr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function vr(t) {
      return wr.apply(this, arguments);
    }

    function wr() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref154) {
        var _ref154$core, t, e, _ref154$gitdir, r, _ref154$fs, n, _ref154$ref, i, o, a, _ref154$signing, u, _t125, _e67, _c8, _f8, _l8, _d5, _n38, _iteratorNormalCompletion73, _didIteratorError73, _iteratorError73, _iterator73, _step73, _e68, _n39;

        return regeneratorRuntime.wrap(function t$(_context178) {
          while (1) {
            switch (_context178.prev = _context178.next) {
              case 0:
                _ref154$core = _ref154.core, t = _ref154$core === void 0 ? "default" : _ref154$core, e = _ref154.dir, _ref154$gitdir = _ref154.gitdir, r = _ref154$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref154$gitdir, _ref154$fs = _ref154.fs, n = _ref154$fs === void 0 ? l.a.get(t).get("fs") : _ref154$fs, _ref154$ref = _ref154.ref, i = _ref154$ref === void 0 ? "HEAD" : _ref154$ref, o = _ref154.depth, a = _ref154.since, _ref154$signing = _ref154.signing, u = _ref154$signing === void 0 ? !1 : _ref154$signing;
                _context178.prev = 1;
                _t125 = new s.a(n);
                _e67 = void 0 === a ? void 0 : Math.floor(a.valueOf() / 1e3);
                _c8 = [];
                _context178.next = 7;
                return ut.a.read({
                  fs: _t125,
                  gitdir: r
                });

              case 7:
                _f8 = _context178.sent;
                _context178.next = 10;
                return k.a.resolve({
                  fs: _t125,
                  gitdir: r,
                  ref: i
                });

              case 10:
                _l8 = _context178.sent;
                _context178.next = 13;
                return gr({
                  fs: _t125,
                  gitdir: r,
                  oid: _l8,
                  signing: u
                });

              case 13:
                _context178.t0 = _context178.sent;
                _d5 = [_context178.t0];

              case 15:
                _n38 = _d5.pop();

                if (!_n38.error) {
                  _context178.next = 19;
                  break;
                }

                _c8.push(_n38);

                return _context178.abrupt("break", 57);

              case 19:
                if (!(void 0 !== _e67 && _n38.committer.timestamp <= _e67)) {
                  _context178.next = 21;
                  break;
                }

                return _context178.abrupt("break", 57);

              case 21:
                if (!(_c8.push(_n38), void 0 !== o && _c8.length === o)) {
                  _context178.next = 23;
                  break;
                }

                return _context178.abrupt("break", 57);

              case 23:
                if (_f8.has(_n38.oid)) {
                  _context178.next = 52;
                  break;
                }

                _iteratorNormalCompletion73 = true;
                _didIteratorError73 = false;
                _iteratorError73 = undefined;
                _context178.prev = 27;
                _iterator73 = _n38.parent[Symbol.iterator]();

              case 29:
                if (_iteratorNormalCompletion73 = (_step73 = _iterator73.next()).done) {
                  _context178.next = 38;
                  break;
                }

                _e68 = _step73.value;
                _context178.next = 33;
                return gr({
                  fs: _t125,
                  gitdir: r,
                  oid: _e68,
                  signing: u
                });

              case 33:
                _n39 = _context178.sent;
                _d5.map(function (t) {
                  return t.oid;
                }).includes(_n39.oid) || _d5.push(_n39);

              case 35:
                _iteratorNormalCompletion73 = true;
                _context178.next = 29;
                break;

              case 38:
                _context178.next = 44;
                break;

              case 40:
                _context178.prev = 40;
                _context178.t1 = _context178["catch"](27);
                _didIteratorError73 = true;
                _iteratorError73 = _context178.t1;

              case 44:
                _context178.prev = 44;
                _context178.prev = 45;

                if (!_iteratorNormalCompletion73 && _iterator73.return != null) {
                  _iterator73.return();
                }

              case 47:
                _context178.prev = 47;

                if (!_didIteratorError73) {
                  _context178.next = 50;
                  break;
                }

                throw _iteratorError73;

              case 50:
                return _context178.finish(47);

              case 51:
                return _context178.finish(44);

              case 52:
                if (!(0 === _d5.length)) {
                  _context178.next = 54;
                  break;
                }

                return _context178.abrupt("break", 57);

              case 54:
                _d5.sort(hr);

              case 55:
                _context178.next = 15;
                break;

              case 57:
                return _context178.abrupt("return", _c8);

              case 60:
                _context178.prev = 60;
                _context178.t2 = _context178["catch"](1);
                throw _context178.t2.caller = "git.log", _context178.t2;

              case 63:
              case "end":
                return _context178.stop();
            }
          }
        }, t, null, [[1, 60], [27, 40, 44, 52], [45,, 47, 51]]);
      }), (wr = function wr() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            yr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            yr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var br = r(82);

    function _r(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function xr(t) {
      return Er.apply(this, arguments);
    }

    function Er() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref155) {
        var _ref155$core, t, e, _ref155$gitdir, r, _ref155$fs, n, i, o, _ref155$fastForwardOn, a, _ref155$dryRun, c, _ref155$noUpdateBranc, d, h, p, g, m, _f9, _l9, _y3, _v3, _w2, _e69;

        return regeneratorRuntime.wrap(function t$(_context179) {
          while (1) {
            switch (_context179.prev = _context179.next) {
              case 0:
                _ref155$core = _ref155.core, t = _ref155$core === void 0 ? "default" : _ref155$core, e = _ref155.dir, _ref155$gitdir = _ref155.gitdir, r = _ref155$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref155$gitdir, _ref155$fs = _ref155.fs, n = _ref155$fs === void 0 ? l.a.get(t).get("fs") : _ref155$fs, i = _ref155.ours, o = _ref155.theirs, _ref155$fastForwardOn = _ref155.fastForwardOnly, a = _ref155$fastForwardOn === void 0 ? !1 : _ref155$fastForwardOn, _ref155$dryRun = _ref155.dryRun, c = _ref155$dryRun === void 0 ? !1 : _ref155$dryRun, _ref155$noUpdateBranc = _ref155.noUpdateBranch, d = _ref155$noUpdateBranc === void 0 ? !1 : _ref155$noUpdateBranc, h = _ref155.message, p = _ref155.author, g = _ref155.committer, m = _ref155.signingKey;
                _context179.prev = 1;
                _f9 = new s.a(n);
                _context179.t0 = void 0 === i;

                if (!_context179.t0) {
                  _context179.next = 8;
                  break;
                }

                _context179.next = 7;
                return Xt({
                  fs: _f9,
                  gitdir: r,
                  fullname: !0
                });

              case 7:
                i = _context179.sent;

              case 8:
                _context179.next = 10;
                return k.a.expand({
                  fs: _f9,
                  gitdir: r,
                  ref: i
                });

              case 10:
                i = _context179.sent;
                _context179.next = 13;
                return k.a.expand({
                  fs: _f9,
                  gitdir: r,
                  ref: o
                });

              case 13:
                o = _context179.sent;
                _context179.next = 16;
                return k.a.resolve({
                  fs: _f9,
                  gitdir: r,
                  ref: i
                });

              case 16:
                _l9 = _context179.sent;
                _context179.next = 19;
                return k.a.resolve({
                  fs: _f9,
                  gitdir: r,
                  ref: o
                });

              case 19:
                _y3 = _context179.sent;
                _context179.next = 22;
                return ke({
                  core: t,
                  dir: e,
                  gitdir: r,
                  fs: _f9,
                  oids: [_l9, _y3]
                });

              case 22:
                _v3 = _context179.sent;

                if (!(1 !== _v3.length)) {
                  _context179.next = 25;
                  break;
                }

                throw new u.b(u.a.MergeNotSupportedFail);

              case 25:
                _w2 = _v3[0];

                if (!(_w2 === _y3)) {
                  _context179.next = 28;
                  break;
                }

                return _context179.abrupt("return", {
                  oid: _l9,
                  alreadyMerged: !0
                });

              case 28:
                if (!(_w2 === _l9)) {
                  _context179.next = 34;
                  break;
                }

                _context179.t1 = c || d;

                if (_context179.t1) {
                  _context179.next = 33;
                  break;
                }

                _context179.next = 33;
                return k.a.writeRef({
                  fs: _f9,
                  gitdir: r,
                  ref: i,
                  value: _y3
                });

              case 33:
                return _context179.abrupt("return", {
                  oid: _y3,
                  fastForward: !0
                });

              case 34:
                if (!a) {
                  _context179.next = 36;
                  break;
                }

                throw new u.b(u.a.FastForwardFail);

              case 36:
                _context179.next = 38;
                return Object(br.a)({
                  core: t,
                  fs: _f9,
                  gitdir: r,
                  ourOid: _l9,
                  theirOid: _y3,
                  baseOid: _w2,
                  ourName: i,
                  baseName: "base",
                  theirName: o,
                  dryRun: c
                });

              case 38:
                _e69 = _context179.sent;
                h || (h = "Merge branch '".concat(bt(o), "' into ").concat(bt(i)));
                _context179.next = 42;
                return Wt({
                  fs: _f9,
                  gitdir: r,
                  message: h,
                  ref: i,
                  tree: _e69,
                  parent: [_l9, _y3],
                  author: p,
                  committer: g,
                  signingKey: m,
                  dryRun: c,
                  noUpdateBranch: d
                });

              case 42:
                _context179.t2 = _context179.sent;
                _context179.t3 = _e69;
                _context179.t4 = !0;
                return _context179.abrupt("return", {
                  oid: _context179.t2,
                  tree: _context179.t3,
                  mergeCommit: _context179.t4
                });

              case 48:
                _context179.prev = 48;
                _context179.t5 = _context179["catch"](1);
                throw _context179.t5.caller = "git.merge", _context179.t5;

              case 51:
              case "end":
                return _context179.stop();
            }
          }
        }, t, null, [[1, 48]]);
      }), (Er = function Er() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            _r(o, n, i, a, s, "next", t);
          }

          function s(t) {
            _r(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var kr = r(69);

    function Or(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function jr(t) {
      return Pr.apply(this, arguments);
    }

    function Pr() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref156) {
        var _ref156$core, t, e, _ref156$gitdir, r, _ref156$fs, n, i, _ref156$write, o, _e70, _a15, _u4, _c9;

        return regeneratorRuntime.wrap(function t$(_context180) {
          while (1) {
            switch (_context180.prev = _context180.next) {
              case 0:
                _ref156$core = _ref156.core, t = _ref156$core === void 0 ? "default" : _ref156$core, e = _ref156.dir, _ref156$gitdir = _ref156.gitdir, r = _ref156$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref156$gitdir, _ref156$fs = _ref156.fs, n = _ref156$fs === void 0 ? l.a.get(t).get("fs") : _ref156$fs, i = _ref156.oids, _ref156$write = _ref156.write, o = _ref156$write === void 0 ? !1 : _ref156$write;
                _context180.prev = 1;
                _e70 = new s.a(n);
                _context180.next = 5;
                return Object(kr.a)({
                  core: t,
                  gitdir: r,
                  fs: _e70,
                  oids: i
                });

              case 5:
                _a15 = _context180.sent;
                _context180.next = 8;
                return Object(_t.a)(_a15);

              case 8:
                _u4 = _context180.sent;
                _c9 = "pack-".concat(_u4.slice(-20).toString("hex"), ".pack");

                if (!o) {
                  _context180.next = 16;
                  break;
                }

                _context180.next = 13;
                return _e70.write(Object(f.a)(r, "objects/pack/".concat(_c9)), _u4);

              case 13:
                _context180.t0 = {
                  filename: _c9
                };
                _context180.next = 17;
                break;

              case 16:
                _context180.t0 = {
                  filename: _c9,
                  packfile: _u4
                };

              case 17:
                return _context180.abrupt("return", _context180.t0);

              case 20:
                _context180.prev = 20;
                _context180.t1 = _context180["catch"](1);
                throw _context180.t1.caller = "git.packObjects", _context180.t1;

              case 23:
              case "end":
                return _context180.stop();
            }
          }
        }, t, null, [[1, 20]]);
      }), (Pr = function Pr() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Or(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Or(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function Sr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Rr(t) {
      return Ar.apply(this, arguments);
    }

    function Ar() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref157) {
        var _ref157$core, t, e, _ref157$gitdir, r, _ref157$fs, n, i, _ref157$fastForwardOn, o, _ref157$noGitSuffix, a, u, _ref157$emitter, c, _ref157$emitterPrefix, d, h, p, _ref157$username, g, _ref157$password, m, y, v, w, _ref157$headers, b, _, x, E, _t126, _f10, _ref158, _l10, _h2;

        return regeneratorRuntime.wrap(function t$(_context181) {
          while (1) {
            switch (_context181.prev = _context181.next) {
              case 0:
                _ref157$core = _ref157.core, t = _ref157$core === void 0 ? "default" : _ref157$core, e = _ref157.dir, _ref157$gitdir = _ref157.gitdir, r = _ref157$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref157$gitdir, _ref157$fs = _ref157.fs, n = _ref157$fs === void 0 ? l.a.get(t).get("fs") : _ref157$fs, i = _ref157.ref, _ref157$fastForwardOn = _ref157.fastForwardOnly, o = _ref157$fastForwardOn === void 0 ? !1 : _ref157$fastForwardOn, _ref157$noGitSuffix = _ref157.noGitSuffix, a = _ref157$noGitSuffix === void 0 ? !1 : _ref157$noGitSuffix, u = _ref157.corsProxy, _ref157$emitter = _ref157.emitter, c = _ref157$emitter === void 0 ? l.a.get(t).get("emitter") : _ref157$emitter, _ref157$emitterPrefix = _ref157.emitterPrefix, d = _ref157$emitterPrefix === void 0 ? "" : _ref157$emitterPrefix, h = _ref157.authUsername, p = _ref157.authPassword, _ref157$username = _ref157.username, g = _ref157$username === void 0 ? h : _ref157$username, _ref157$password = _ref157.password, m = _ref157$password === void 0 ? p : _ref157$password, y = _ref157.token, v = _ref157.oauth2format, w = _ref157.singleBranch, _ref157$headers = _ref157.headers, b = _ref157$headers === void 0 ? {} : _ref157$headers, _ = _ref157.author, x = _ref157.committer, E = _ref157.signingKey;
                _context181.prev = 1;
                _t126 = new s.a(n);
                _context181.t0 = i;

                if (_context181.t0) {
                  _context181.next = 8;
                  break;
                }

                _context181.next = 7;
                return Xt({
                  fs: _t126,
                  gitdir: r
                });

              case 7:
                i = _context181.sent;

              case 8:
                _context181.next = 10;
                return S({
                  gitdir: r,
                  fs: _t126,
                  path: "branch.".concat(i, ".remote")
                });

              case 10:
                _f10 = _context181.sent;
                _context181.next = 13;
                return It({
                  dir: e,
                  gitdir: r,
                  fs: _t126,
                  emitter: c,
                  emitterPrefix: d,
                  noGitSuffix: a,
                  corsProxy: u,
                  ref: i,
                  remote: _f10,
                  username: g,
                  password: m,
                  token: y,
                  oauth2format: v,
                  singleBranch: w,
                  headers: b
                });

              case 13:
                _ref158 = _context181.sent;
                _l10 = _ref158.fetchHead;
                _h2 = _ref158.fetchHeadDescription;
                _context181.next = 18;
                return xr({
                  gitdir: r,
                  fs: _t126,
                  ours: i,
                  theirs: _l10,
                  fastForwardOnly: o,
                  message: "Merge ".concat(_h2),
                  author: _,
                  committer: x,
                  signingKey: E
                });

              case 18:
                _context181.next = 20;
                return ot({
                  dir: e,
                  gitdir: r,
                  fs: _t126,
                  ref: i,
                  emitter: c,
                  emitterPrefix: d
                });

              case 20:
                _context181.next = 25;
                break;

              case 22:
                _context181.prev = 22;
                _context181.t1 = _context181["catch"](1);
                throw _context181.t1.caller = "git.pull", _context181.t1;

              case 25:
              case "end":
                return _context181.stop();
            }
          }
        }, t, null, [[1, 22]]);
      }), (Ar = function Ar() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Sr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Sr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var $r = r(51),
        Tr = r(86),
        Ir = r(85),
        Br = r(83),
        Fr = r(84);

    function Ur(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Mr(t) {
      return Cr.apply(this, arguments);
    }

    function Cr() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref159) {
        var _ref159$core, t, e, _ref159$gitdir, r, _ref159$fs, n, _ref159$emitter, i, _ref159$emitterPrefix, o, a, c, _ref159$remote, d, h, _ref159$force, p, _ref159$noGitSuffix, g, m, y, v, _ref159$username, w, _ref159$password, b, _, x, _ref159$headers, E, _e71, _f11, _l11, _y4, _v4, _O, _j, _P, _R, _A2, _iteratorNormalCompletion74, _didIteratorError74, _iteratorError74, _iterator74, _step74, _t128, _$, _T2, _I, _B, _F, _U, _ref160, _M, _C, _t127, _D;

        return regeneratorRuntime.wrap(function t$(_context182) {
          while (1) {
            switch (_context182.prev = _context182.next) {
              case 0:
                _ref159$core = _ref159.core, t = _ref159$core === void 0 ? "default" : _ref159$core, e = _ref159.dir, _ref159$gitdir = _ref159.gitdir, r = _ref159$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref159$gitdir, _ref159$fs = _ref159.fs, n = _ref159$fs === void 0 ? l.a.get(t).get("fs") : _ref159$fs, _ref159$emitter = _ref159.emitter, i = _ref159$emitter === void 0 ? l.a.get(t).get("emitter") : _ref159$emitter, _ref159$emitterPrefix = _ref159.emitterPrefix, o = _ref159$emitterPrefix === void 0 ? "" : _ref159$emitterPrefix, a = _ref159.ref, c = _ref159.remoteRef, _ref159$remote = _ref159.remote, d = _ref159$remote === void 0 ? "origin" : _ref159$remote, h = _ref159.url, _ref159$force = _ref159.force, p = _ref159$force === void 0 ? !1 : _ref159$force, _ref159$noGitSuffix = _ref159.noGitSuffix, g = _ref159$noGitSuffix === void 0 ? !1 : _ref159$noGitSuffix, m = _ref159.corsProxy, y = _ref159.authUsername, v = _ref159.authPassword, _ref159$username = _ref159.username, w = _ref159$username === void 0 ? y : _ref159$username, _ref159$password = _ref159.password, b = _ref159$password === void 0 ? v : _ref159$password, _ = _ref159.token, x = _ref159.oauth2format, _ref159$headers = _ref159.headers, E = _ref159$headers === void 0 ? {} : _ref159$headers;
                _context182.prev = 1;
                _e71 = new s.a(n);
                _context182.t0 = void 0 === h;

                if (!_context182.t0) {
                  _context182.next = 8;
                  break;
                }

                _context182.next = 7;
                return S({
                  fs: _e71,
                  gitdir: r,
                  path: "remote.".concat(d, ".url")
                });

              case 7:
                h = _context182.sent;

              case 8:
                _context182.t1 = void 0 === m;

                if (!_context182.t1) {
                  _context182.next = 13;
                  break;
                }

                _context182.next = 12;
                return S({
                  fs: _e71,
                  gitdir: r,
                  path: "http.corsProxy"
                });

              case 12:
                m = _context182.sent;

              case 13:
                if (!a) {
                  _context182.next = 19;
                  break;
                }

                _context182.next = 16;
                return k.a.expand({
                  fs: _e71,
                  gitdir: r,
                  ref: a
                });

              case 16:
                _context182.t2 = _context182.sent;
                _context182.next = 22;
                break;

              case 19:
                _context182.next = 21;
                return k.a.resolve({
                  fs: _e71,
                  gitdir: r,
                  ref: "HEAD",
                  depth: 2
                });

              case 21:
                _context182.t2 = _context182.sent;

              case 22:
                _f11 = _context182.t2;
                _context182.next = 25;
                return k.a.resolve({
                  fs: _e71,
                  gitdir: r,
                  ref: _f11
                });

              case 25:
                _l11 = _context182.sent;
                _y4 = {
                  username: w,
                  password: b,
                  token: _,
                  oauth2format: x
                };
                _v4 = st.a.getRemoteHelperFor({
                  url: h
                });
                _context182.next = 30;
                return _v4.discover({
                  core: t,
                  corsProxy: m,
                  service: "git-receive-pack",
                  url: h,
                  noGitSuffix: g,
                  auth: _y4,
                  headers: E
                });

              case 30:
                _O = _context182.sent;

                if (!(_y4 = _O.auth, c)) {
                  _context182.next = 45;
                  break;
                }

                _context182.prev = 32;
                _context182.next = 35;
                return k.a.expandAgainstMap({
                  ref: c,
                  map: _O.refs
                });

              case 35:
                _j = _context182.sent;
                _context182.next = 43;
                break;

              case 38:
                _context182.prev = 38;
                _context182.t3 = _context182["catch"](32);

                if (!(_context182.t3.code !== u.a.ExpandRefError)) {
                  _context182.next = 42;
                  break;
                }

                throw _context182.t3;

              case 42:
                _j = c.startsWith("refs/") ? c : "refs/heads/".concat(c);

              case 43:
                _context182.next = 46;
                break;

              case 45:
                _j = _f11;

              case 46:
                _P = _O.refs.get(_j) || "0000000000000000000000000000000000000000";
                _R = _toConsumableArray(_O.refs.values());
                _context182.next = 50;
                return ke({
                  fs: _e71,
                  gitdir: r,
                  oids: [_l11, _P]
                });

              case 50:
                _A2 = _context182.sent;
                _iteratorNormalCompletion74 = true;
                _didIteratorError74 = false;
                _iteratorError74 = undefined;
                _context182.prev = 54;

                for (_iterator74 = _A2[Symbol.iterator](); !(_iteratorNormalCompletion74 = (_step74 = _iterator74.next()).done); _iteratorNormalCompletion74 = true) {
                  _t128 = _step74.value;

                  _R.push(_t128);
                }

                _context182.next = 62;
                break;

              case 58:
                _context182.prev = 58;
                _context182.t4 = _context182["catch"](54);
                _didIteratorError74 = true;
                _iteratorError74 = _context182.t4;

              case 62:
                _context182.prev = 62;
                _context182.prev = 63;

                if (!_iteratorNormalCompletion74 && _iterator74.return != null) {
                  _iterator74.return();
                }

              case 65:
                _context182.prev = 65;

                if (!_didIteratorError74) {
                  _context182.next = 68;
                  break;
                }

                throw _iteratorError74;

              case 68:
                return _context182.finish(65);

              case 69:
                return _context182.finish(62);

              case 70:
                _context182.next = 72;
                return Object(Br.a)({
                  fs: _e71,
                  gitdir: r,
                  start: [_l11],
                  finish: _R
                });

              case 72:
                _$ = _context182.sent;
                _context182.next = 75;
                return Object(Fr.a)({
                  fs: _e71,
                  gitdir: r,
                  oids: _$
                });

              case 75:
                _T2 = _context182.sent;

                if (p) {
                  _context182.next = 86;
                  break;
                }

                if (!(_f11.startsWith("refs/tags") && "0000000000000000000000000000000000000000" !== _P)) {
                  _context182.next = 79;
                  break;
                }

                throw new u.b(u.a.PushRejectedTagExists, {});

              case 79:
                _context182.t5 = "0000000000000000000000000000000000000000" !== _l11 && "0000000000000000000000000000000000000000" !== _P;

                if (!_context182.t5) {
                  _context182.next = 84;
                  break;
                }

                _context182.next = 83;
                return He({
                  fs: _e71,
                  gitdir: r,
                  oid: _l11,
                  ancestor: _P
                });

              case 83:
                _context182.t5 = !_context182.sent;

              case 84:
                if (!_context182.t5) {
                  _context182.next = 86;
                  break;
                }

                throw new u.b(u.a.PushRejectedNonFastForward, {});

              case 86:
                _I = xt(_toConsumableArray(_O.capabilities), ["report-status", "side-band-64k", "agent=".concat(kt.a.agent)]);
                _context182.next = 89;
                return Object(Ir.a)({
                  capabilities: _I,
                  triplets: [{
                    oldoid: _P,
                    oid: _l11,
                    fullRef: _j
                  }]
                });

              case 89:
                _B = _context182.sent;
                _context182.next = 92;
                return Object(kr.a)({
                  fs: _e71,
                  gitdir: r,
                  oids: _toConsumableArray(_T2)
                });

              case 92:
                _F = _context182.sent;
                _context182.next = 95;
                return _v4.connect({
                  core: t,
                  emitter: i,
                  emitterPrefix: o,
                  corsProxy: m,
                  service: "git-receive-pack",
                  url: h,
                  noGitSuffix: g,
                  auth: _y4,
                  headers: E,
                  body: [].concat(_toConsumableArray(_B), _toConsumableArray(_F))
                });

              case 95:
                _U = _context182.sent;
                _context182.next = 98;
                return $r.a.demux(_U.body);

              case 98:
                _ref160 = _context182.sent;
                _M = _ref160.packfile;
                _C = _ref160.progress;

                if (i) {
                  _t127 = St(_C);
                  Object(Et.a)(_t127, function (t) {
                    i.emit("".concat(o, "message"), t);
                  });
                }

                _context182.next = 104;
                return Object(Tr.a)(_M);

              case 104:
                _D = _context182.sent;
                return _context182.abrupt("return", (_U.headers && (_D.headers = _U.headers), _D));

              case 108:
                _context182.prev = 108;
                _context182.t6 = _context182["catch"](1);
                throw _context182.t6.caller = "git.push", _context182.t6;

              case 111:
              case "end":
                return _context182.stop();
            }
          }
        }, t, null, [[1, 108], [32, 38], [54, 58, 62, 70], [63,, 65, 69]]);
      }), (Cr = function Cr() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Ur(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Ur(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function Dr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Nr(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Dr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Dr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function zr(t) {
      return Hr.apply(this, arguments);
    }

    function Hr() {
      return (Hr = Nr(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee124(_ref161) {
        var _ref161$core, t, e, _ref161$gitdir, r, _ref161$fs, n, i, _t129;

        return regeneratorRuntime.wrap(function _callee124$(_context184) {
          while (1) {
            switch (_context184.prev = _context184.next) {
              case 0:
                _ref161$core = _ref161.core, t = _ref161$core === void 0 ? "default" : _ref161$core, e = _ref161.dir, _ref161$gitdir = _ref161.gitdir, r = _ref161$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref161$gitdir, _ref161$fs = _ref161.fs, n = _ref161$fs === void 0 ? l.a.get(t).get("fs") : _ref161$fs, i = _ref161.filepath;
                _context184.prev = 1;
                _t129 = new s.a(n);
                _context184.next = 5;
                return a.a.acquire({
                  fs: _t129,
                  filepath: "".concat(r, "/index")
                }, function () {
                  var t = Nr(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee123(t) {
                    return regeneratorRuntime.wrap(function _callee123$(_context183) {
                      while (1) {
                        switch (_context183.prev = _context183.next) {
                          case 0:
                            t.delete({
                              filepath: i
                            });

                          case 1:
                          case "end":
                            return _context183.stop();
                        }
                      }
                    }, _callee123);
                  }));
                  return function (e) {
                    return t.apply(this, arguments);
                  };
                }());

              case 5:
                _context184.next = 10;
                break;

              case 7:
                _context184.prev = 7;
                _context184.t0 = _context184["catch"](1);
                throw _context184.t0.caller = "git.remove", _context184.t0;

              case 10:
              case "end":
                return _context184.stop();
            }
          }
        }, _callee124, null, [[1, 7]]);
      }))).apply(this, arguments);
    }

    function Lr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Gr(t) {
      return qr.apply(this, arguments);
    }

    function qr() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref162) {
        var t, e, r;
        return regeneratorRuntime.wrap(function t$(_context185) {
          while (1) {
            switch (_context185.prev = _context185.next) {
              case 0:
                t = _ref162.gitdir, e = _ref162.type, r = _ref162.object;
                return _context185.abrupt("return", Object(K.a)(V.a.wrap({
                  type: e,
                  object: r
                })));

              case 2:
              case "end":
                return _context185.stop();
            }
          }
        }, t);
      }), (qr = function qr() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Lr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Lr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function Wr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Yr(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Wr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Wr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function Zr(t) {
      return Kr.apply(this, arguments);
    }

    function Kr() {
      return (Kr = Yr(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee126(_ref163) {
        var _ref163$core, t, e, _ref163$gitdir, r, _ref163$fs, n, i, _ref163$ref, o, _t130, _u5, _c10, _e72, _l12, _d6;

        return regeneratorRuntime.wrap(function _callee126$(_context187) {
          while (1) {
            switch (_context187.prev = _context187.next) {
              case 0:
                _ref163$core = _ref163.core, t = _ref163$core === void 0 ? "default" : _ref163$core, e = _ref163.dir, _ref163$gitdir = _ref163.gitdir, r = _ref163$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref163$gitdir, _ref163$fs = _ref163.fs, n = _ref163$fs === void 0 ? l.a.get(t).get("fs") : _ref163$fs, i = _ref163.filepath, _ref163$ref = _ref163.ref, o = _ref163$ref === void 0 ? "HEAD" : _ref163$ref;
                _context187.prev = 1;
                _t130 = new s.a(n);
                _context187.next = 5;
                return k.a.resolve({
                  fs: _t130,
                  gitdir: r,
                  ref: o
                });

              case 5:
                _c10 = _context187.sent;
                _context187.prev = 6;
                _context187.next = 9;
                return Ve({
                  gitdir: r,
                  fs: _t130,
                  oid: _c10,
                  filepath: i,
                  format: "deflated"
                });

              case 9:
                _e72 = _context187.sent;
                _c10 = _e72 && _e72.oid;
                _context187.next = 16;
                break;

              case 13:
                _context187.prev = 13;
                _context187.t0 = _context187["catch"](6);
                _c10 = null;

              case 16:
                _l12 = {
                  ctime: new Date(0),
                  mtime: new Date(0),
                  dev: 0,
                  ino: 0,
                  mode: 0,
                  uid: 0,
                  gid: 0,
                  size: 0
                };
                _context187.t1 = e;

                if (!_context187.t1) {
                  _context187.next = 22;
                  break;
                }

                _context187.next = 21;
                return _t130.read(Object(f.a)(e, i));

              case 21:
                _context187.t1 = _context187.sent;

              case 22:
                _d6 = _context187.t1;
                _context187.t2 = _d6;

                if (!_context187.t2) {
                  _context187.next = 33;
                  break;
                }

                _context187.next = 27;
                return Gr({
                  gitdir: r,
                  type: "blob",
                  object: _d6
                });

              case 27:
                _u5 = _context187.sent;
                _context187.t3 = _c10 === _u5;

                if (!_context187.t3) {
                  _context187.next = 33;
                  break;
                }

                _context187.next = 32;
                return _t130.lstat(Object(f.a)(e, i));

              case 32:
                _l12 = _context187.sent;

              case 33:
                _context187.next = 35;
                return a.a.acquire({
                  fs: _t130,
                  filepath: "".concat(r, "/index")
                }, function () {
                  var t = Yr(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee125(t) {
                    return regeneratorRuntime.wrap(function _callee125$(_context186) {
                      while (1) {
                        switch (_context186.prev = _context186.next) {
                          case 0:
                            t.delete({
                              filepath: i
                            }), _c10 && t.insert({
                              filepath: i,
                              stats: _l12,
                              oid: _c10
                            });

                          case 1:
                          case "end":
                            return _context186.stop();
                        }
                      }
                    }, _callee125);
                  }));
                  return function (e) {
                    return t.apply(this, arguments);
                  };
                }());

              case 35:
                _context187.next = 40;
                break;

              case 37:
                _context187.prev = 37;
                _context187.t4 = _context187["catch"](1);
                throw _context187.t4.caller = "git.reset", _context187.t4;

              case 40:
              case "end":
                return _context187.stop();
            }
          }
        }, _callee126, null, [[1, 37], [6, 13]]);
      }))).apply(this, arguments);
    }

    function Vr(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function Xr(t) {
      return Jr.apply(this, arguments);
    }

    function Jr() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref164) {
        var _ref164$core, t, e, _ref164$gitdir, r, _ref164$fs, n, i, o, _t131;

        return regeneratorRuntime.wrap(function t$(_context188) {
          while (1) {
            switch (_context188.prev = _context188.next) {
              case 0:
                _ref164$core = _ref164.core, t = _ref164$core === void 0 ? "default" : _ref164$core, e = _ref164.dir, _ref164$gitdir = _ref164.gitdir, r = _ref164$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref164$gitdir, _ref164$fs = _ref164.fs, n = _ref164$fs === void 0 ? l.a.get(t).get("fs") : _ref164$fs, i = _ref164.ref, o = _ref164.depth;
                _context188.prev = 1;
                _t131 = new s.a(n);
                _context188.next = 5;
                return k.a.resolve({
                  fs: _t131,
                  gitdir: r,
                  ref: i,
                  depth: o
                });

              case 5:
                return _context188.abrupt("return", _context188.sent);

              case 8:
                _context188.prev = 8;
                _context188.t0 = _context188["catch"](1);
                throw _context188.t0.caller = "git.resolveRef", _context188.t0;

              case 11:
              case "end":
                return _context188.stop();
            }
          }
        }, t, null, [[1, 8]]);
      }), (Jr = function Jr() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Vr(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Vr(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    var Qr = r(70);

    function tn(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function en(t) {
      return rn.apply(this, arguments);
    }

    function rn() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref165) {
        var _ref165$core, t, e, _ref165$gitdir, r, _ref165$fs, n, i, o, _e73, _a16, _ref166, _d7, _h3, _p, _e74, _g2, _m4;

        return regeneratorRuntime.wrap(function t$(_context189) {
          while (1) {
            switch (_context189.prev = _context189.next) {
              case 0:
                _ref165$core = _ref165.core, t = _ref165$core === void 0 ? "default" : _ref165$core, e = _ref165.dir, _ref165$gitdir = _ref165.gitdir, r = _ref165$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref165$gitdir, _ref165$fs = _ref165.fs, n = _ref165$fs === void 0 ? l.a.get(t).get("fs") : _ref165$fs, i = _ref165.privateKeys, o = _ref165.openpgp;
                _context189.prev = 1;
                _e73 = new s.a(n);
                _context189.next = 5;
                return k.a.resolve({
                  fs: _e73,
                  gitdir: r,
                  ref: "HEAD"
                });

              case 5:
                _a16 = _context189.sent;
                _context189.next = 8;
                return Object(j.a)({
                  fs: _e73,
                  gitdir: r,
                  oid: _a16
                });

              case 8:
                _ref166 = _context189.sent;
                _d7 = _ref166.type;
                _h3 = _ref166.object;

                if (!("commit" !== _d7)) {
                  _context189.next = 13;
                  break;
                }

                throw new u.b(u.a.ObjectTypeAssertionInRefFail, {
                  expected: "commit",
                  ref: "HEAD",
                  type: _d7
                });

              case 13:
                if (!o) {
                  _context189.next = 20;
                  break;
                }

                _p = Qr.a.from(_h3);
                _context189.next = 17;
                return _p.sign(o, i);

              case 17:
                _p = _context189.sent;
                _context189.next = 25;
                break;

              case 20:
                _e74 = l.a.get(t).get("pgp");
                _p = ct.a.from(_h3);
                _context189.next = 24;
                return ct.a.sign(_p, _e74, i);

              case 24:
                _p = _context189.sent;

              case 25:
                _context189.next = 27;
                return Object(c.a)({
                  fs: _e73,
                  gitdir: r,
                  type: "commit",
                  object: _p.toObject()
                });

              case 27:
                _g2 = _context189.sent;
                _context189.next = 30;
                return k.a.resolve({
                  fs: _e73,
                  gitdir: r,
                  ref: "HEAD",
                  depth: 2
                });

              case 30:
                _m4 = _context189.sent;
                _context189.next = 33;
                return _e73.write(Object(f.a)(r, _m4), _g2 + "\n");

              case 33:
                _context189.next = 38;
                break;

              case 35:
                _context189.prev = 35;
                _context189.t0 = _context189["catch"](1);
                throw _context189.t0.caller = "git.sign", _context189.t0;

              case 38:
              case "end":
                return _context189.stop();
            }
          }
        }, t, null, [[1, 35]]);
      }), (rn = function rn() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            tn(o, n, i, a, s, "next", t);
          }

          function s(t) {
            tn(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function nn(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function on(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            nn(o, n, i, a, s, "next", t);
          }

          function s(t) {
            nn(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function an(t) {
      return sn.apply(this, arguments);
    }

    function sn() {
      return (sn = on(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee130(_ref167) {
        var _ref167$core, t, e, _ref167$gitdir, r, _ref167$fs, n, i, _t132, _u6, _c11, _l13, _d8, _h4, _p2, _g3, _m5, _t133;

        return regeneratorRuntime.wrap(function _callee130$(_context193) {
          while (1) {
            switch (_context193.prev = _context193.next) {
              case 0:
                _ref167$core = _ref167.core, t = _ref167$core === void 0 ? "default" : _ref167$core, e = _ref167.dir, _ref167$gitdir = _ref167.gitdir, r = _ref167$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref167$gitdir, _ref167$fs = _ref167.fs, n = _ref167$fs === void 0 ? l.a.get(t).get("fs") : _ref167$fs, i = _ref167.filepath;
                _context193.prev = 1;
                _t132 = new s.a(n);
                _context193.next = 5;
                return o.a.isIgnored({
                  gitdir: r,
                  dir: e,
                  filepath: i,
                  fs: _t132
                });

              case 5:
                if (!_context193.sent) {
                  _context193.next = 7;
                  break;
                }

                return _context193.abrupt("return", "ignored");

              case 7:
                _context193.next = 9;
                return function (t) {
                  return fn.apply(this, arguments);
                }({
                  fs: _t132,
                  gitdir: r
                });

              case 9:
                _u6 = _context193.sent;
                _context193.next = 12;
                return un({
                  fs: _t132,
                  gitdir: r,
                  tree: _u6,
                  path: i
                });

              case 12:
                _c11 = _context193.sent;
                _l13 = null;
                _context193.next = 16;
                return a.a.acquire({
                  fs: _t132,
                  filepath: "".concat(r, "/index")
                }, function () {
                  var t = on(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee127(t) {
                    var _iteratorNormalCompletion75, _didIteratorError75, _iteratorError75, _iterator75, _step75, _e75;

                    return regeneratorRuntime.wrap(function _callee127$(_context190) {
                      while (1) {
                        switch (_context190.prev = _context190.next) {
                          case 0:
                            _iteratorNormalCompletion75 = true;
                            _didIteratorError75 = false;
                            _iteratorError75 = undefined;
                            _context190.prev = 3;
                            _iterator75 = t[Symbol.iterator]();

                          case 5:
                            if (_iteratorNormalCompletion75 = (_step75 = _iterator75.next()).done) {
                              _context190.next = 13;
                              break;
                            }

                            _e75 = _step75.value;

                            if (!(_e75.path === i)) {
                              _context190.next = 10;
                              break;
                            }

                            _l13 = _e75;
                            return _context190.abrupt("break", 13);

                          case 10:
                            _iteratorNormalCompletion75 = true;
                            _context190.next = 5;
                            break;

                          case 13:
                            _context190.next = 19;
                            break;

                          case 15:
                            _context190.prev = 15;
                            _context190.t0 = _context190["catch"](3);
                            _didIteratorError75 = true;
                            _iteratorError75 = _context190.t0;

                          case 19:
                            _context190.prev = 19;
                            _context190.prev = 20;

                            if (!_iteratorNormalCompletion75 && _iterator75.return != null) {
                              _iterator75.return();
                            }

                          case 22:
                            _context190.prev = 22;

                            if (!_didIteratorError75) {
                              _context190.next = 25;
                              break;
                            }

                            throw _iteratorError75;

                          case 25:
                            return _context190.finish(22);

                          case 26:
                            return _context190.finish(19);

                          case 27:
                          case "end":
                            return _context190.stop();
                        }
                      }
                    }, _callee127, null, [[3, 15, 19, 27], [20,, 22, 26]]);
                  }));
                  return function (e) {
                    return t.apply(this, arguments);
                  };
                }());

              case 16:
                _context193.next = 18;
                return _t132.lstat(Object(f.a)(e, i));

              case 18:
                _d8 = _context193.sent;
                _h4 = null !== _c11;
                _p2 = null !== _l13;
                _g3 = null !== _d8;

                _m5 = function () {
                  var n = on(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee129() {
                    var _n40, _o25;

                    return regeneratorRuntime.wrap(function _callee129$(_context192) {
                      while (1) {
                        switch (_context192.prev = _context192.next) {
                          case 0:
                            if (!(_p2 && !Object(W.a)(_l13, _d8))) {
                              _context192.next = 2;
                              break;
                            }

                            return _context192.abrupt("return", _l13.oid);

                          case 2:
                            _context192.next = 4;
                            return _t132.read(Object(f.a)(e, i));

                          case 4:
                            _n40 = _context192.sent;
                            _context192.next = 7;
                            return Gr({
                              gitdir: r,
                              type: "blob",
                              object: _n40
                            });

                          case 7:
                            _o25 = _context192.sent;
                            return _context192.abrupt("return", (_p2 && _l13.oid === _o25 && -1 !== _d8.size && a.a.acquire({
                              fs: _t132,
                              filepath: "".concat(r, "/index")
                            }, function () {
                              var t = on(
                              /*#__PURE__*/
                              regeneratorRuntime.mark(function _callee128(t) {
                                return regeneratorRuntime.wrap(function _callee128$(_context191) {
                                  while (1) {
                                    switch (_context191.prev = _context191.next) {
                                      case 0:
                                        t.insert({
                                          filepath: i,
                                          stats: _d8,
                                          oid: _o25
                                        });

                                      case 1:
                                      case "end":
                                        return _context191.stop();
                                    }
                                  }
                                }, _callee128);
                              }));
                              return function (e) {
                                return t.apply(this, arguments);
                              };
                            }()), _o25));

                          case 9:
                          case "end":
                            return _context192.stop();
                        }
                      }
                    }, _callee129);
                  }));
                  return function () {
                    return n.apply(this, arguments);
                  };
                }();

                if (!(!_h4 && !_g3 && !_p2)) {
                  _context193.next = 25;
                  break;
                }

                return _context193.abrupt("return", "absent");

              case 25:
                if (!(!_h4 && !_g3 && _p2)) {
                  _context193.next = 27;
                  break;
                }

                return _context193.abrupt("return", "*absent");

              case 27:
                if (!(!_h4 && _g3 && !_p2)) {
                  _context193.next = 29;
                  break;
                }

                return _context193.abrupt("return", "*added");

              case 29:
                if (!(!_h4 && _g3 && _p2)) {
                  _context193.next = 40;
                  break;
                }

                _context193.next = 32;
                return _m5();

              case 32:
                _context193.t0 = _context193.sent;
                _context193.t1 = _l13.oid;

                if (!(_context193.t0 === _context193.t1)) {
                  _context193.next = 38;
                  break;
                }

                _context193.t2 = "added";
                _context193.next = 39;
                break;

              case 38:
                _context193.t2 = "*added";

              case 39:
                return _context193.abrupt("return", _context193.t2);

              case 40:
                if (!(_h4 && !_g3 && !_p2)) {
                  _context193.next = 42;
                  break;
                }

                return _context193.abrupt("return", "deleted");

              case 42:
                if (!(_h4 && !_g3 && _p2)) {
                  _context193.next = 44;
                  break;
                }

                return _context193.abrupt("return", (_l13.oid, "*deleted"));

              case 44:
                if (!(_h4 && _g3 && !_p2)) {
                  _context193.next = 55;
                  break;
                }

                _context193.next = 47;
                return _m5();

              case 47:
                _context193.t3 = _context193.sent;
                _context193.t4 = _c11;

                if (!(_context193.t3 === _context193.t4)) {
                  _context193.next = 53;
                  break;
                }

                _context193.t5 = "*undeleted";
                _context193.next = 54;
                break;

              case 53:
                _context193.t5 = "*undeletemodified";

              case 54:
                return _context193.abrupt("return", _context193.t5);

              case 55:
                if (!(_h4 && _g3 && _p2)) {
                  _context193.next = 60;
                  break;
                }

                _context193.next = 58;
                return _m5();

              case 58:
                _t133 = _context193.sent;
                return _context193.abrupt("return", _t133 === _c11 ? _t133 === _l13.oid ? "unmodified" : "*unmodified" : _t133 === _l13.oid ? "modified" : "*modified");

              case 60:
                _context193.next = 65;
                break;

              case 62:
                _context193.prev = 62;
                _context193.t6 = _context193["catch"](1);
                throw _context193.t6.caller = "git.status", _context193.t6;

              case 65:
              case "end":
                return _context193.stop();
            }
          }
        }, _callee130, null, [[1, 62]]);
      }))).apply(this, arguments);
    }

    function un(t) {
      return cn.apply(this, arguments);
    }

    function cn() {
      return (cn = on(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee131(_ref168) {
        var t, e, r, n, i, _iteratorNormalCompletion76, _didIteratorError76, _iteratorError76, _iterator76, _step76, _o26, _ref169, _r47, _i27;

        return regeneratorRuntime.wrap(function _callee131$(_context194) {
          while (1) {
            switch (_context194.prev = _context194.next) {
              case 0:
                t = _ref168.fs, e = _ref168.gitdir, r = _ref168.tree, n = _ref168.path;
                "string" == typeof n && (n = n.split("/"));
                i = n.shift();
                _iteratorNormalCompletion76 = true;
                _didIteratorError76 = false;
                _iteratorError76 = undefined;
                _context194.prev = 6;
                _iterator76 = r[Symbol.iterator]();

              case 8:
                if (_iteratorNormalCompletion76 = (_step76 = _iterator76.next()).done) {
                  _context194.next = 25;
                  break;
                }

                _o26 = _step76.value;

                if (!(_o26.path === i)) {
                  _context194.next = 22;
                  break;
                }

                if (!(0 === n.length)) {
                  _context194.next = 13;
                  break;
                }

                return _context194.abrupt("return", _o26.oid);

              case 13:
                _context194.next = 15;
                return Object(j.a)({
                  fs: t,
                  gitdir: e,
                  oid: _o26.oid
                });

              case 15:
                _ref169 = _context194.sent;
                _r47 = _ref169.type;
                _i27 = _ref169.object;

                if (!("tree" === _r47)) {
                  _context194.next = 20;
                  break;
                }

                return _context194.abrupt("return", un({
                  fs: t,
                  gitdir: e,
                  tree: Ht.a.from(_i27),
                  path: n
                }));

              case 20:
                if (!("blob" === _r47)) {
                  _context194.next = 22;
                  break;
                }

                throw new u.b(u.a.ObjectTypeAssertionInPathFail, {
                  oid: _o26.oid,
                  path: n.join("/")
                });

              case 22:
                _iteratorNormalCompletion76 = true;
                _context194.next = 8;
                break;

              case 25:
                _context194.next = 31;
                break;

              case 27:
                _context194.prev = 27;
                _context194.t0 = _context194["catch"](6);
                _didIteratorError76 = true;
                _iteratorError76 = _context194.t0;

              case 31:
                _context194.prev = 31;
                _context194.prev = 32;

                if (!_iteratorNormalCompletion76 && _iterator76.return != null) {
                  _iterator76.return();
                }

              case 34:
                _context194.prev = 34;

                if (!_didIteratorError76) {
                  _context194.next = 37;
                  break;
                }

                throw _iteratorError76;

              case 37:
                return _context194.finish(34);

              case 38:
                return _context194.finish(31);

              case 39:
                return _context194.abrupt("return", null);

              case 40:
              case "end":
                return _context194.stop();
            }
          }
        }, _callee131, null, [[6, 27, 31, 39], [32,, 34, 38]]);
      }))).apply(this, arguments);
    }

    function fn() {
      return (fn = on(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee132(_ref170) {
        var t, e, r, _ref171, n, i;

        return regeneratorRuntime.wrap(function _callee132$(_context195) {
          while (1) {
            switch (_context195.prev = _context195.next) {
              case 0:
                t = _ref170.fs, e = _ref170.gitdir;
                _context195.prev = 1;
                _context195.next = 4;
                return k.a.resolve({
                  fs: t,
                  gitdir: e,
                  ref: "HEAD"
                });

              case 4:
                r = _context195.sent;
                _context195.next = 11;
                break;

              case 7:
                _context195.prev = 7;
                _context195.t0 = _context195["catch"](1);

                if (!(_context195.t0.code === u.a.ResolveRefError)) {
                  _context195.next = 11;
                  break;
                }

                return _context195.abrupt("return", []);

              case 11:
                _context195.next = 13;
                return Object(j.a)({
                  fs: t,
                  gitdir: e,
                  oid: r
                });

              case 13:
                _ref171 = _context195.sent;
                n = _ref171.type;
                i = _ref171.object;

                if (!("commit" !== n)) {
                  _context195.next = 18;
                  break;
                }

                throw new u.b(u.a.ResolveCommitError, {
                  oid: r
                });

              case 18:
                return _context195.abrupt("return", function (t) {
                  return ln.apply(this, arguments);
                }({
                  fs: t,
                  gitdir: e,
                  oid: r = ct.a.from(i).parseHeaders().tree
                }));

              case 19:
              case "end":
                return _context195.stop();
            }
          }
        }, _callee132, null, [[1, 7]]);
      }))).apply(this, arguments);
    }

    function ln() {
      return (ln = on(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee133(_ref172) {
        var t, e, r, _ref173, n, i;

        return regeneratorRuntime.wrap(function _callee133$(_context196) {
          while (1) {
            switch (_context196.prev = _context196.next) {
              case 0:
                t = _ref172.fs, e = _ref172.gitdir, r = _ref172.oid;
                _context196.next = 3;
                return Object(j.a)({
                  fs: t,
                  gitdir: e,
                  oid: r
                });

              case 3:
                _ref173 = _context196.sent;
                n = _ref173.type;
                i = _ref173.object;

                if (!("tree" !== n)) {
                  _context196.next = 8;
                  break;
                }

                throw new u.b(u.a.ResolveTreeError, {
                  oid: r
                });

              case 8:
                return _context196.abrupt("return", Ht.a.from(i).entries());

              case 9:
              case "end":
                return _context196.stop();
            }
          }
        }, _callee133);
      }))).apply(this, arguments);
    }

    var dn = r(40);

    function hn(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function pn(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            hn(o, n, i, a, s, "next", t);
          }

          function s(t) {
            hn(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    var gn =
    /*#__PURE__*/
    function () {
      function gn(_ref174) {
        var t = _ref174.fs,
            e = _ref174.gitdir;

        _classCallCheck(this, gn);

        var r = new s.a(t);
        this.treePromise = pn(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee135() {
          var t;
          return regeneratorRuntime.wrap(function _callee135$(_context198) {
            while (1) {
              switch (_context198.prev = _context198.next) {
                case 0:
                  _context198.next = 2;
                  return a.a.acquire({
                    fs: r,
                    filepath: "".concat(e, "/index")
                  }, function () {
                    var e = pn(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee134(e) {
                      return regeneratorRuntime.wrap(function _callee134$(_context197) {
                        while (1) {
                          switch (_context197.prev = _context197.next) {
                            case 0:
                              t = Object(Lt.a)(e.entries);

                            case 1:
                            case "end":
                              return _context197.stop();
                          }
                        }
                      }, _callee134);
                    }));
                    return function (t) {
                      return e.apply(this, arguments);
                    };
                  }());

                case 2:
                  return _context198.abrupt("return", t);

                case 3:
                case "end":
                  return _context198.stop();
              }
            }
          }, _callee135);
        }))();
        var n = this;

        this.ConstructEntry =
        /*#__PURE__*/
        function () {
          function _class4(t) {
            _classCallCheck(this, _class4);

            Object.assign(this, t);
          }

          _createClass(_class4, [{
            key: "populateStat",
            value: function populateStat() {
              var t = this;
              return pn(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee136() {
                return regeneratorRuntime.wrap(function _callee136$(_context199) {
                  while (1) {
                    switch (_context199.prev = _context199.next) {
                      case 0:
                        _context199.t0 = t.exists;

                        if (!_context199.t0) {
                          _context199.next = 4;
                          break;
                        }

                        _context199.next = 4;
                        return n.populateStat(t);

                      case 4:
                      case "end":
                        return _context199.stop();
                    }
                  }
                }, _callee136);
              }))();
            }
          }, {
            key: "populateContent",
            value: function populateContent() {
              var t = this;
              return pn(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee137() {
                return regeneratorRuntime.wrap(function _callee137$(_context200) {
                  while (1) {
                    switch (_context200.prev = _context200.next) {
                      case 0:
                        _context200.t0 = t.exists;

                        if (!_context200.t0) {
                          _context200.next = 4;
                          break;
                        }

                        _context200.next = 4;
                        return n.populateContent(t);

                      case 4:
                      case "end":
                        return _context200.stop();
                    }
                  }
                }, _callee137);
              }))();
            }
          }, {
            key: "populateHash",
            value: function populateHash() {
              var t = this;
              return pn(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee138() {
                return regeneratorRuntime.wrap(function _callee138$(_context201) {
                  while (1) {
                    switch (_context201.prev = _context201.next) {
                      case 0:
                        _context201.t0 = t.exists;

                        if (!_context201.t0) {
                          _context201.next = 4;
                          break;
                        }

                        _context201.next = 4;
                        return n.populateHash(t);

                      case 4:
                      case "end":
                        return _context201.stop();
                    }
                  }
                }, _callee138);
              }))();
            }
          }]);

          return _class4;
        }();
      }

      _createClass(gn, [{
        key: "readdir",
        value: function readdir(t) {
          var e = this;
          return pn(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee139() {
            var r, n;
            return regeneratorRuntime.wrap(function _callee139$(_context202) {
              while (1) {
                switch (_context202.prev = _context202.next) {
                  case 0:
                    if (t.exists) {
                      _context202.next = 2;
                      break;
                    }

                    return _context202.abrupt("return", []);

                  case 2:
                    r = t.fullpath;
                    _context202.next = 5;
                    return e.treePromise;

                  case 5:
                    _context202.t0 = r;
                    n = _context202.sent.get(_context202.t0);

                    if (n) {
                      _context202.next = 9;
                      break;
                    }

                    return _context202.abrupt("return", null);

                  case 9:
                    if (!("blob" === n.type)) {
                      _context202.next = 11;
                      break;
                    }

                    return _context202.abrupt("return", null);

                  case 11:
                    if (!("tree" !== n.type)) {
                      _context202.next = 13;
                      break;
                    }

                    throw new Error("ENOTDIR: not a directory, scandir '".concat(r, "'"));

                  case 13:
                    return _context202.abrupt("return", n.children.map(function (t) {
                      return {
                        fullpath: t.fullpath,
                        basename: t.basename,
                        exists: !0
                      };
                    }).sort(function (t, e) {
                      return Object(dn.a)(t.fullpath, e.fullpath);
                    }));

                  case 14:
                  case "end":
                    return _context202.stop();
                }
              }
            }, _callee139);
          }))();
        }
      }, {
        key: "populateStat",
        value: function populateStat(t) {
          var e = this;
          return pn(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee140() {
            var r, n;
            return regeneratorRuntime.wrap(function _callee140$(_context203) {
              while (1) {
                switch (_context203.prev = _context203.next) {
                  case 0:
                    _context203.next = 2;
                    return e.treePromise;

                  case 2:
                    _context203.t0 = t.fullpath;
                    r = _context203.sent.get(_context203.t0);

                    if (r) {
                      _context203.next = 6;
                      break;
                    }

                    throw new Error("ENOENT: no such file or directory, lstat '".concat(t.fullpath, "'"));

                  case 6:
                    n = "tree" === r.type ? {} : Object(Z.a)(r.metadata);
                    Object.assign(t, {
                      type: r.type
                    }, n);

                  case 8:
                  case "end":
                    return _context203.stop();
                }
              }
            }, _callee140);
          }))();
        }
      }, {
        key: "populateContent",
        value: function populateContent(t) {
          return pn(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee141() {
            return regeneratorRuntime.wrap(function _callee141$(_context204) {
              while (1) {
                switch (_context204.prev = _context204.next) {
                  case 0:
                  case "end":
                    return _context204.stop();
                }
              }
            }, _callee141);
          }))();
        }
      }, {
        key: "populateHash",
        value: function populateHash(t) {
          var e = this;
          return pn(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee142() {
            var r;
            return regeneratorRuntime.wrap(function _callee142$(_context205) {
              while (1) {
                switch (_context205.prev = _context205.next) {
                  case 0:
                    _context205.next = 2;
                    return e.treePromise;

                  case 2:
                    _context205.t0 = t.fullpath;
                    r = _context205.sent.get(_context205.t0);

                    if (r) {
                      _context205.next = 6;
                      break;
                    }

                    return _context205.abrupt("return", null);

                  case 6:
                    if (!("tree" === r.type)) {
                      _context205.next = 8;
                      break;
                    }

                    throw new Error("EISDIR: illegal operation on a directory, read");

                  case 8:
                    Object.assign(t, {
                      oid: r.metadata.oid
                    });

                  case 9:
                  case "end":
                    return _context205.stop();
                }
              }
            }, _callee142);
          }))();
        }
      }]);

      return gn;
    }();

    function mn(_ref175) {
      var _ref175$core = _ref175.core,
          t = _ref175$core === void 0 ? "default" : _ref175$core,
          e = _ref175.dir,
          _ref175$gitdir = _ref175.gitdir,
          r = _ref175$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref175$gitdir,
          _ref175$fs = _ref175.fs,
          n = _ref175$fs === void 0 ? l.a.get(t).get("fs") : _ref175$fs;
      var i = new s.a(n),
          o = Object.create(null);
      return Object.defineProperty(o, tt.a, {
        value: function value() {
          return new gn({
            fs: i,
            gitdir: r
          });
        }
      }), Object.freeze(o), o;
    }

    function yn(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function vn(t) {
      return function () {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            yn(o, n, i, a, s, "next", t);
          }

          function s(t) {
            yn(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      };
    }

    function wn(t) {
      return bn.apply(this, arguments);
    }

    function bn() {
      return (bn = vn(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee145(_ref176) {
        var _ref176$core, t, e, _ref176$gitdir, r, _ref176$fs, n, _ref176$ref, i, _ref176$filepaths, a, _ref176$pattern, u, _t134, _l14, _h5, _p3, c, d;

        return regeneratorRuntime.wrap(function _callee145$(_context208) {
          while (1) {
            switch (_context208.prev = _context208.next) {
              case 0:
                _ref176$core = _ref176.core, t = _ref176$core === void 0 ? "default" : _ref176$core, e = _ref176.dir, _ref176$gitdir = _ref176.gitdir, r = _ref176$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref176$gitdir, _ref176$fs = _ref176.fs, n = _ref176$fs === void 0 ? l.a.get(t).get("fs") : _ref176$fs, _ref176$ref = _ref176.ref, i = _ref176$ref === void 0 ? "HEAD" : _ref176$ref, _ref176$filepaths = _ref176.filepaths, a = _ref176$filepaths === void 0 ? ["."] : _ref176$filepaths, _ref176$pattern = _ref176.pattern, u = _ref176$pattern === void 0 ? null : _ref176$pattern;
                _context208.prev = 1;
                _t134 = new s.a(n);
                _h5 = "";
                u && ((_h5 = L(u)) && (u = u.replace(_h5 + "/", "")), _l14 = N()(u, {
                  globstar: !0,
                  extended: !0
                }));
                _p3 = a.map(function (t) {
                  return Object(f.a)(t, _h5);
                });
                _context208.next = 8;
                return Object(rt.a)({
                  trees: [Object(q.a)({
                    fs: _t134,
                    gitdir: r,
                    ref: i
                  }), et({
                    fs: _t134,
                    dir: e,
                    gitdir: r
                  }), mn({
                    fs: _t134,
                    gitdir: r
                  })],
                  filter: (d = vn(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee143(_ref177) {
                    var _ref178, r, n, i;

                    return regeneratorRuntime.wrap(function _callee143$(_context206) {
                      while (1) {
                        switch (_context206.prev = _context206.next) {
                          case 0:
                            _ref178 = _slicedToArray(_ref177, 3), r = _ref178[0], n = _ref178[1], i = _ref178[2];
                            _context206.t1 = !r.exists && !i.exists && n.exists;

                            if (!_context206.t1) {
                              _context206.next = 6;
                              break;
                            }

                            _context206.next = 5;
                            return o.a.isIgnored({
                              fs: _t134,
                              dir: e,
                              filepath: n.fullpath
                            });

                          case 5:
                            _context206.t1 = _context206.sent;

                          case 6:
                            _context206.t0 = !_context206.t1;

                            if (!_context206.t0) {
                              _context206.next = 9;
                              break;
                            }

                            _context206.t0 = _p3.some(function (t) {
                              return G(r.fullpath, t);
                            });

                          case 9:
                            return _context206.abrupt("return", _context206.t0);

                          case 10:
                          case "end":
                            return _context206.stop();
                        }
                      }
                    }, _callee143);
                  })), function (t) {
                    return d.apply(this, arguments);
                  }),
                  map: (c = vn(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee144(_ref179) {
                    var _ref180, t, e, r, _e76, _iteratorNormalCompletion77, _didIteratorError77, _iteratorError77, _iterator77, _step77, _r48, _n41, n, i;

                    return regeneratorRuntime.wrap(function _callee144$(_context207) {
                      while (1) {
                        switch (_context207.prev = _context207.next) {
                          case 0:
                            _ref180 = _slicedToArray(_ref179, 3), t = _ref180[0], e = _ref180[1], r = _ref180[2];

                            if (!_l14) {
                              _context207.next = 33;
                              break;
                            }

                            _e76 = !1;
                            _iteratorNormalCompletion77 = true;
                            _didIteratorError77 = false;
                            _iteratorError77 = undefined;
                            _context207.prev = 6;
                            _iterator77 = _p3[Symbol.iterator]();

                          case 8:
                            if (_iteratorNormalCompletion77 = (_step77 = _iterator77.next()).done) {
                              _context207.next = 17;
                              break;
                            }

                            _r48 = _step77.value;
                            _n41 = t.fullpath.replace(_r48 + "/", "");

                            if (!_l14.regex.test(_n41)) {
                              _context207.next = 14;
                              break;
                            }

                            _e76 = !0;
                            return _context207.abrupt("break", 17);

                          case 14:
                            _iteratorNormalCompletion77 = true;
                            _context207.next = 8;
                            break;

                          case 17:
                            _context207.next = 23;
                            break;

                          case 19:
                            _context207.prev = 19;
                            _context207.t0 = _context207["catch"](6);
                            _didIteratorError77 = true;
                            _iteratorError77 = _context207.t0;

                          case 23:
                            _context207.prev = 23;
                            _context207.prev = 24;

                            if (!_iteratorNormalCompletion77 && _iterator77.return != null) {
                              _iterator77.return();
                            }

                          case 26:
                            _context207.prev = 26;

                            if (!_didIteratorError77) {
                              _context207.next = 29;
                              break;
                            }

                            throw _iteratorError77;

                          case 29:
                            return _context207.finish(26);

                          case 30:
                            return _context207.finish(23);

                          case 31:
                            if (_e76) {
                              _context207.next = 33;
                              break;
                            }

                            return _context207.abrupt("return");

                          case 33:
                            _context207.next = 35;
                            return t.populateStat();

                          case 35:
                            if (!("tree" === t.type || "special" === t.type)) {
                              _context207.next = 37;
                              break;
                            }

                            return _context207.abrupt("return");

                          case 37:
                            _context207.next = 39;
                            return e.populateStat();

                          case 39:
                            if (!("tree" === e.type || "special" === e.type)) {
                              _context207.next = 41;
                              break;
                            }

                            return _context207.abrupt("return");

                          case 41:
                            _context207.next = 43;
                            return r.populateStat();

                          case 43:
                            if (!("tree" === r.type || "special" === r.type)) {
                              _context207.next = 45;
                              break;
                            }

                            return _context207.abrupt("return");

                          case 45:
                            _context207.next = 47;
                            return t.populateHash();

                          case 47:
                            _context207.next = 49;
                            return r.populateHash();

                          case 49:
                            if (!(t.exists || !e.exists || r.exists)) {
                              _context207.next = 56;
                              break;
                            }

                            _context207.t1 = e.exists;

                            if (!_context207.t1) {
                              _context207.next = 54;
                              break;
                            }

                            _context207.next = 54;
                            return e.populateHash();

                          case 54:
                            _context207.next = 57;
                            break;

                          case 56:
                            e.oid = "42";

                          case 57:
                            n = [void 0, t.oid, e.oid, r.oid], i = n.map(function (t) {
                              return n.indexOf(t);
                            });
                            return _context207.abrupt("return", (i.shift(), [t.fullpath || e.fullpath || r.fullpath].concat(_toConsumableArray(i))));

                          case 59:
                          case "end":
                            return _context207.stop();
                        }
                      }
                    }, _callee144, null, [[6, 19, 23, 31], [24,, 26, 30]]);
                  })), function (t) {
                    return c.apply(this, arguments);
                  })
                });

              case 8:
                return _context208.abrupt("return", _context208.sent);

              case 11:
                _context208.prev = 11;
                _context208.t0 = _context208["catch"](1);
                throw _context208.t0.caller = "git.statusMatrix", _context208.t0;

              case 14:
              case "end":
                return _context208.stop();
            }
          }
        }, _callee145, null, [[1, 11]]);
      }))).apply(this, arguments);
    }

    function _n(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function xn(t) {
      return En.apply(this, arguments);
    }

    function En() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref181) {
        var _ref181$core, t, e, _ref181$gitdir, r, _ref181$fs, n, i, o, _ref181$force, a, _t135, _e77;

        return regeneratorRuntime.wrap(function t$(_context209) {
          while (1) {
            switch (_context209.prev = _context209.next) {
              case 0:
                _ref181$core = _ref181.core, t = _ref181$core === void 0 ? "default" : _ref181$core, e = _ref181.dir, _ref181$gitdir = _ref181.gitdir, r = _ref181$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref181$gitdir, _ref181$fs = _ref181.fs, n = _ref181$fs === void 0 ? l.a.get(t).get("fs") : _ref181$fs, i = _ref181.ref, o = _ref181.object, _ref181$force = _ref181.force, a = _ref181$force === void 0 ? !1 : _ref181$force;
                _context209.prev = 1;
                _t135 = new s.a(n);

                if (!(void 0 === i)) {
                  _context209.next = 5;
                  break;
                }

                throw new u.b(u.a.MissingRequiredParameterError, {
                  function: "tag",
                  parameter: "ref"
                });

              case 5:
                i = i.startsWith("refs/tags/") ? i : "refs/tags/".concat(i);
                _context209.next = 8;
                return k.a.resolve({
                  fs: _t135,
                  gitdir: r,
                  ref: o || "HEAD"
                });

              case 8:
                _e77 = _context209.sent;
                _context209.t0 = !a;

                if (!_context209.t0) {
                  _context209.next = 14;
                  break;
                }

                _context209.next = 13;
                return k.a.exists({
                  fs: _t135,
                  gitdir: r,
                  ref: i
                });

              case 13:
                _context209.t0 = _context209.sent;

              case 14:
                if (!_context209.t0) {
                  _context209.next = 16;
                  break;
                }

                throw new u.b(u.a.RefExistsError, {
                  noun: "tag",
                  ref: i
                });

              case 16:
                _context209.next = 18;
                return k.a.writeRef({
                  fs: _t135,
                  gitdir: r,
                  ref: i,
                  value: _e77
                });

              case 18:
                _context209.next = 23;
                break;

              case 20:
                _context209.prev = 20;
                _context209.t1 = _context209["catch"](1);
                throw _context209.t1.caller = "git.tag", _context209.t1;

              case 23:
              case "end":
                return _context209.stop();
            }
          }
        }, t, null, [[1, 20]]);
      }), (En = function En() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            _n(o, n, i, a, s, "next", t);
          }

          function s(t) {
            _n(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function kn(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function On(t) {
      return jn.apply(this, arguments);
    }

    function jn() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref182) {
        var _ref182$core, t, e, _ref182$gitdir, r, _ref182$fs, n, i, o, a, _e78, _c12, _ref183, _f12, d, _t136, _e79, _e80, _t137, _ref184, _r49, _n42, _t138, _ref185, _r50, _n43;

        return regeneratorRuntime.wrap(function t$(_context210) {
          while (1) {
            switch (_context210.prev = _context210.next) {
              case 0:
                _ref182$core = _ref182.core, t = _ref182$core === void 0 ? "default" : _ref182$core, e = _ref182.dir, _ref182$gitdir = _ref182.gitdir, r = _ref182$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref182$gitdir, _ref182$fs = _ref182.fs, n = _ref182$fs === void 0 ? l.a.get(t).get("fs") : _ref182$fs, i = _ref182.ref, o = _ref182.publicKeys, a = _ref182.openpgp;
                _context210.prev = 1;
                _e78 = new s.a(n);
                _context210.next = 5;
                return k.a.resolve({
                  fs: _e78,
                  gitdir: r,
                  ref: i
                });

              case 5:
                _c12 = _context210.sent;
                _context210.next = 8;
                return Object(j.a)({
                  fs: _e78,
                  gitdir: r,
                  oid: _c12
                });

              case 8:
                _ref183 = _context210.sent;
                _f12 = _ref183.type;
                d = _ref183.object;

                if (!("commit" !== _f12 && "tag" !== _f12)) {
                  _context210.next = 13;
                  break;
                }

                throw new u.b(u.a.ObjectTypeAssertionInRefFail, {
                  expected: "commit/tag",
                  ref: i,
                  type: _f12
                });

              case 13:
                if (!a) {
                  _context210.next = 24;
                  break;
                }

                _t136 = Qr.a.from(d);
                _context210.next = 17;
                return _t136.listSigningKeys(a);

              case 17:
                _e79 = _context210.sent;
                _context210.next = 20;
                return _t136.verify(a, o);

              case 20:
                _context210.t0 = !!_context210.sent;

                if (!_context210.t0) {
                  _context210.next = 23;
                  break;
                }

                _context210.t0 = _e79;

              case 23:
                return _context210.abrupt("return", _context210.t0);

              case 24:
                _e80 = l.a.get(t).get("pgp");

                if (!("commit" === _f12)) {
                  _context210.next = 33;
                  break;
                }

                _t137 = ct.a.from(d);
                _context210.next = 29;
                return ct.a.verify(_t137, _e80, o);

              case 29:
                _ref184 = _context210.sent;
                _r49 = _ref184.valid;
                _n42 = _ref184.invalid;
                return _context210.abrupt("return", !(_n42.length > 0) && _r49);

              case 33:
                if (!("tag" === _f12)) {
                  _context210.next = 41;
                  break;
                }

                _t138 = O.a.from(d);
                _context210.next = 37;
                return O.a.verify(_t138, _e80, o);

              case 37:
                _ref185 = _context210.sent;
                _r50 = _ref185.valid;
                _n43 = _ref185.invalid;
                return _context210.abrupt("return", !(_n43.length > 0) && _r50);

              case 41:
                _context210.next = 46;
                break;

              case 43:
                _context210.prev = 43;
                _context210.t1 = _context210["catch"](1);
                throw _context210.t1.caller = "git.verify", _context210.t1;

              case 46:
              case "end":
                return _context210.stop();
            }
          }
        }, t, null, [[1, 43]]);
      }), (jn = function jn() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            kn(o, n, i, a, s, "next", t);
          }

          function s(t) {
            kn(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    function Pn() {
      try {
        return kt.a.version;
      } catch (t) {
        throw t.caller = "git.version", t;
      }
    }

    var Sn = r(126);

    function Rn(t, e, r, n, i, o, a) {
      try {
        var s = t[o](a),
            u = s.value;
      } catch (t) {
        return void r(t);
      }

      s.done ? e(u) : Promise.resolve(u).then(n, i);
    }

    function An(t) {
      return $n.apply(this, arguments);
    }

    function $n() {
      var t;
      return t =
      /*#__PURE__*/
      regeneratorRuntime.mark(function t(_ref186) {
        var _ref186$core, t, e, _ref186$gitdir, r, _ref186$fs, n, i, o, _ref186$force, a, _ref186$symbolic, c, _t139;

        return regeneratorRuntime.wrap(function t$(_context211) {
          while (1) {
            switch (_context211.prev = _context211.next) {
              case 0:
                _ref186$core = _ref186.core, t = _ref186$core === void 0 ? "default" : _ref186$core, e = _ref186.dir, _ref186$gitdir = _ref186.gitdir, r = _ref186$gitdir === void 0 ? Object(f.a)(e, ".git") : _ref186$gitdir, _ref186$fs = _ref186.fs, n = _ref186$fs === void 0 ? l.a.get(t).get("fs") : _ref186$fs, i = _ref186.ref, o = _ref186.value, _ref186$force = _ref186.force, a = _ref186$force === void 0 ? !1 : _ref186$force, _ref186$symbolic = _ref186.symbolic, c = _ref186$symbolic === void 0 ? !1 : _ref186$symbolic;
                _context211.prev = 1;
                _t139 = new s.a(n);

                if (!(i !== w.a.clean(i))) {
                  _context211.next = 5;
                  break;
                }

                throw new u.b(u.a.InvalidRefNameError, {
                  verb: "write",
                  noun: "ref",
                  ref: i,
                  suggestion: w.a.clean(i)
                });

              case 5:
                _context211.t0 = !a;

                if (!_context211.t0) {
                  _context211.next = 10;
                  break;
                }

                _context211.next = 9;
                return k.a.exists({
                  fs: _t139,
                  gitdir: r,
                  ref: i
                });

              case 9:
                _context211.t0 = _context211.sent;

              case 10:
                if (!_context211.t0) {
                  _context211.next = 12;
                  break;
                }

                throw new u.b(u.a.RefExistsError, {
                  noun: "ref",
                  ref: i
                });

              case 12:
                if (!c) {
                  _context211.next = 17;
                  break;
                }

                _context211.next = 15;
                return k.a.writeSymbolicRef({
                  fs: _t139,
                  gitdir: r,
                  ref: i,
                  value: o
                });

              case 15:
                _context211.next = 22;
                break;

              case 17:
                _context211.next = 19;
                return k.a.resolve({
                  fs: _t139,
                  gitdir: r,
                  ref: o
                });

              case 19:
                o = _context211.sent;
                _context211.next = 22;
                return k.a.writeRef({
                  fs: _t139,
                  gitdir: r,
                  ref: i,
                  value: o
                });

              case 22:
                _context211.next = 27;
                break;

              case 24:
                _context211.prev = 24;
                _context211.t1 = _context211["catch"](1);
                throw _context211.t1.caller = "git.writeRef", _context211.t1;

              case 27:
              case "end":
                return _context211.stop();
            }
          }
        }, t, null, [[1, 24]]);
      }), ($n = function $n() {
        var e = this,
            r = arguments;
        return new Promise(function (n, i) {
          var o = t.apply(e, r);

          function a(t) {
            Rn(o, n, i, a, s, "next", t);
          }

          function s(t) {
            Rn(o, n, i, a, s, "throw", t);
          }

          a(void 0);
        });
      }).apply(this, arguments);
    }

    r.d(e, "utils", function () {
      return Tn;
    }), r.d(e, "add", function () {
      return p;
    }), r.d(e, "addRemote", function () {
      return x;
    }), r.d(e, "annotatedTag", function () {
      return B;
    }), r.d(e, "branch", function () {
      return M;
    }), r.d(e, "checkout", function () {
      return ot;
    }), r.d(e, "clone", function () {
      return Nt;
    }), r.d(e, "commit", function () {
      return Wt;
    }), r.d(e, "config", function () {
      return S;
    }), r.d(e, "currentBranch", function () {
      return Xt;
    }), r.d(e, "deleteBranch", function () {
      return te;
    }), r.d(e, "deleteRef", function () {
      return ne;
    }), r.d(e, "deleteRemote", function () {
      return ae;
    }), r.d(e, "deleteTag", function () {
      return ce;
    }), r.d(e, "expandOid", function () {
      return ve;
    }), r.d(e, "expandRef", function () {
      return _e;
    }), r.d(e, "fetch", function () {
      return It;
    }), r.d(e, "findMergeBase", function () {
      return ke;
    }), r.d(e, "findRoot", function () {
      return Re;
    }), r.d(e, "getRemoteInfo", function () {
      return Fe;
    }), r.d(e, "hashBlob", function () {
      return Me.a;
    }), r.d(e, "indexPack", function () {
      return De;
    }), r.d(e, "init", function () {
      return Mt;
    }), r.d(e, "isDescendent", function () {
      return He;
    }), r.d(e, "listBranches", function () {
      return qe;
    }), r.d(e, "listFiles", function () {
      return rr;
    }), r.d(e, "listRemotes", function () {
      return ur;
    }), r.d(e, "listTags", function () {
      return lr;
    }), r.d(e, "log", function () {
      return vr;
    }), r.d(e, "merge", function () {
      return xr;
    }), r.d(e, "packObjects", function () {
      return jr;
    }), r.d(e, "pull", function () {
      return Rr;
    }), r.d(e, "push", function () {
      return Mr;
    }), r.d(e, "readObject", function () {
      return Ve;
    }), r.d(e, "remove", function () {
      return zr;
    }), r.d(e, "resetIndex", function () {
      return Zr;
    }), r.d(e, "resolveRef", function () {
      return Xr;
    }), r.d(e, "sign", function () {
      return en;
    }), r.d(e, "status", function () {
      return an;
    }), r.d(e, "statusMatrix", function () {
      return wn;
    }), r.d(e, "tag", function () {
      return xn;
    }), r.d(e, "verify", function () {
      return On;
    }), r.d(e, "version", function () {
      return Pn;
    }), r.d(e, "walkBeta1", function () {
      return rt.a;
    }), r.d(e, "writeObject", function () {
      return Sn.a;
    }), r.d(e, "writeRef", function () {
      return An;
    }), r.d(e, "WORKDIR", function () {
      return et;
    }), r.d(e, "STAGE", function () {
      return mn;
    }), r.d(e, "TREE", function () {
      return q.a;
    }), r.d(e, "E", function () {
      return u.a;
    }), r.d(e, "plugins", function () {
      return l.b;
    }), r.d(e, "cores", function () {
      return l.a;
    });
    var Tn = {
      auth: n.a,
      oauth2: i.a
    };
  }]);
});
},{}],"node_modules/secure-compare/index.js":[function(require,module,exports) {
/**
 * Expose secure-compare
 */

module.exports = compare;


/**
 * Secure compare
 */

function compare (a, b) {
  if (typeof a !== 'string' || typeof b !== 'string') return false;
  
  var mismatch = a.length === b.length ? 0 : 1;
  if (mismatch) {
    b = a;
  }
  
  for (var i = 0, il = a.length; i < il; ++i) {
    mismatch |= (a.charCodeAt(i) ^ b.charCodeAt(i));
  }
  
  return mismatch === 0;
};

},{}],"node_modules/fastify-bearer-auth/plugin.js":[function(require,module,exports) {
'use strict'

const fp = require('fastify-plugin')
const compare = require('secure-compare')

function factory (options) {
  const defaultOptions = {
    keys: [],
    auth: undefined,
    errorResponse (err) {
      return { error: err.message }
    },
    contentType: undefined,
    bearerType: 'Bearer'
  }
  const _options = Object.assign({}, defaultOptions, options || {})
  if (_options.keys instanceof Set) _options.keys = Array.from(_options.keys)
  const { keys, errorResponse, contentType, bearerType, auth } = _options

  function bearerAuthHook (fastifyReq, fastifyRes, next) {
    const header = fastifyReq.req.headers['authorization']
    if (!header) {
      const noHeaderError = Error('missing authorization header')
      fastifyReq.log.error('unauthorized: %s', noHeaderError.message)
      if (contentType) fastifyRes.header('content-type', contentType)
      fastifyRes.code(401).send(errorResponse(noHeaderError))
      return
    }

    const key = header.substring(bearerType.length).trim()
    let retVal
    // check if auth function is defined
    if (auth && auth instanceof Function) {
      try {
        retVal = auth(key, fastifyReq)
      // catch any error from the user provided function
      } catch (err) {
        retVal = Promise.reject(err)
      }
    } else {
    // if auth is not defined use keys
      retVal = authenticate(keys, key)
    }

    const invalidKeyError = Error('invalid authorization header')

    // retVal contains the result of the auth function if defined or the
    // result of the key comparison.
    // retVal is enclosed in a Promise.resolve to allow auth to be a normal
    // function or an async funtion. If it returns a non-promise value it
    // will be converted to a resolving promise. If it returns a promise it
    // will be resolved.
    Promise.resolve(retVal).then((val) => {
      // if val is not truthy return 401
      if (val === false) {
        fastifyReq.log.error('invalid authorization header: `%s`', header)
        if (contentType) fastifyRes.header('content-type', contentType)
        fastifyRes.code(401).send(errorResponse(invalidKeyError))
        return
      }
      if (val === true) {
        // if it fails down stream return the proper error
        try {
          next()
        } catch (err) {
          next(err)
        }
        return
      }
      fastifyRes.code(500).send(errorResponse(new Error('internal server error')))
    }).catch((err) => {
      fastifyRes.code(500).send(errorResponse(err instanceof Error ? err : Error(String(err))))
    })
  }

  return bearerAuthHook
}

function authenticate (keys, key) {
  return keys.findIndex((a) => compare(a, key)) !== -1
}

function plugin (fastify, options, next) {
  fastify.addHook('onRequest', factory(options))
  next()
}

module.exports = fp(plugin, {
  fastify: '^2.0.0',
  name: 'fastify-bearer-auth'
})
module.exports.internals = { factory }

},{"fastify-plugin":"node_modules/fastify-plugin/index.js","secure-compare":"node_modules/secure-compare/index.js"}],"server.ts":[function(require,module,exports) {
var process = require("process");
"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var fastify = __importStar(require("fastify"));

var sensible = __importStar(require("fastify-sensible"));

var cors = __importStar(require("fastify-cors"));

var nedb = __importStar(require("nedb-promises"));

from;
'minimist';

var prelude_ts_1 = require("prelude-ts");

var git = __importStar(require("isomorphic-git"));

var fs = __importStar(require("fs"));

var path = __importStar(require("path"));

var argv = minimist(process.argv.slice(2));

if (argv._.length == 0) {
  throw new Error('usage: nanocrud <config.json>');
}

var isDirectory = function isDirectory(path) {
  return fs.existsSync(path) && fs.statSync(path).isDirectory();
};

var config = JSON.parse(fs.readFileSync(argv._[0]).toString());
var dataDir = config.data;
var gitAuthor = config.git.author;
var gitSignPass = config.git.signingPassphrase;

if (!dataDir || !isDirectory(dataDir)) {
  fs.mkdirSync(dataDir);
}

var server = fastify({
  logger: {
    level: config.logLevel || 'info'
  }
});
server.register(sensible);
server.register(cors, {
  origin: config.origin || '*'
});
git.plugins.set('fs', fs);
var gitDir = path.join(dataDir, '.git');

if (!fs.existsSync(gitDir)) {
  git.init({
    dir: dataDir
  }).then(function () {
    return server.log.info("initialized git repo at " + dataDir + "/.git");
  });
}

var dbCache = new Map();

var openDb = function openDb(name) {
  if (dbCache.has(name)) {
    return dbCache.get(name);
  }

  var basename = path.basename(name);
  var fullPath = path.join(dataDir, basename);
  var db = nedb.create({
    filename: fullPath,
    autoload: true,
    timestampData: true
  });
  fs.watchFile(fullPath, {
    persistent: false
  }, function (curr, prev) {
    if (curr.mtime > prev.mtime) {
      git.add({
        dir: dataDir,
        filepath: basename
      });
    }
  });
  dbCache.set(name, db);
  return db;
};

process.on('SIGUSR2', function (e) {
  return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
      return [2
      /*return*/
      , Promise.all(Array.from(dbCache.keys()).map(function (name) {
        return __awaiter(void 0, void 0, void 0, function () {
          var db;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                db = dbCache.get(name);

                if (db) {
                  // okay, sometimes the type checker really isn't doing us any favors...like when
                  // the typings have a big hole named 'persistence'
                  prelude_ts_1.Option.of(db.persistence).map(function (p) {
                    return __awaiter(void 0, void 0, void 0, function () {
                      return __generator(this, function (_a) {
                        switch (_a.label) {
                          case 0:
                            return [4
                            /*yield*/
                            , p.compactDatafile()];

                          case 1:
                            return [2
                            /*return*/
                            , _a.sent()];
                        }
                      });
                    });
                  });
                }

                return [4
                /*yield*/
                , git.add({
                  dir: dataDir,
                  filepath: path.basename(name)
                })];

              case 1:
                return [2
                /*return*/
                , _a.sent()];
            }
          });
        });
      })).then(function () {
        return __awaiter(void 0, void 0, void 0, function () {
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4
                /*yield*/
                , git.commit({
                  dir: dataDir,
                  message: 'automatic commit based on signal',
                  author: gitAuthor
                })];

              case 1:
                return [2
                /*return*/
                , _a.sent()];
            }
          });
        });
      })];
    });
  });
});

if (config.keys) {
  server.register(require('fastify-bearer-auth'), {
    keys: new Set(config.keys)
  });
}

var paginationQuerySchema = {
  skip: {
    type: 'number'
  },
  limit: {
    type: 'number'
  }
};

var tryOpenDb = function tryOpenDb(name) {
  return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          return [4
          /*yield*/
          , openDb(prelude_ts_1.Option.of(name).getOrThrow())];

        case 1:
          return [2
          /*return*/
          , _a.sent()];
      }
    });
  });
};

server.route({
  url: '/db/:name',
  method: 'GET',
  schema: {
    querystring: paginationQuerySchema
  },
  handler: function handler(req, reply) {
    return __awaiter(void 0, void 0, void 0, function () {
      var _a, _b;

      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            _b = (_a = reply).send;
            return [4
            /*yield*/
            , tryOpenDb(req.params.name)];

          case 1:
            return [2
            /*return*/
            , _b.apply(_a, [_c.sent().find(req.body)])];
        }
      });
    });
  }
});
server.route({
  url: '/db/:name',
  method: 'POST',
  handler: function handler(req, reply) {
    return __awaiter(void 0, void 0, void 0, function () {
      var _a, _b;

      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            _b = (_a = reply).send;
            return [4
            /*yield*/
            , tryOpenDb(req.params.name)];

          case 1:
            return [2
            /*return*/
            , _b.apply(_a, [_c.sent().insert(req.body)])];
        }
      });
    });
  }
});
server.route({
  url: '/db/:name/update',
  method: 'POST',
  schema: {
    querystring: paginationQuerySchema,
    body: {
      type: 'object',
      required: ['query', 'update'],
      properties: {
        where: {
          type: 'object'
        },
        with: {
          type: 'object'
        }
      }
    }
  },
  handler: function handler(req, reply) {
    return __awaiter(void 0, void 0, void 0, function () {
      var _a, _b;

      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            _b = (_a = reply).send;
            return [4
            /*yield*/
            , tryOpenDb(req.params.name)];

          case 1:
            return [2
            /*return*/
            , _b.apply(_a, [_c.sent().update(req.body.where, req.body.with)])];
        }
      });
    });
  }
});
server.route({
  url: '/db/:name',
  method: 'DELETE',
  handler: function handler(req, reply) {
    return __awaiter(void 0, void 0, void 0, function () {
      var _a, _b;

      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            _b = (_a = reply).send;
            return [4
            /*yield*/
            , tryOpenDb(req.params.name)];

          case 1:
            return [2
            /*return*/
            , _b.apply(_a, [_c.sent().remove(req.body, {
              multi: true
            })])];
        }
      });
    });
  }
});
server.listen(config.port || 9080);
},{"fastify":"node_modules/fastify/fastify.js","fastify-sensible":"node_modules/fastify-sensible/index.js","fastify-cors":"node_modules/fastify-cors/index.js","nedb-promises":"node_modules/nedb-promises/index.js","prelude-ts":"node_modules/prelude-ts/dist/src/index.js","isomorphic-git":"node_modules/isomorphic-git/dist/bundle.umd.min.js","fs":"node_modules/parcel-bundler/src/builtins/_empty.js","path":"node_modules/path-browserify/index.js","fastify-bearer-auth":"node_modules/fastify-bearer-auth/plugin.js","process":"node_modules/process/browser.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "56870" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","server.ts"], null)